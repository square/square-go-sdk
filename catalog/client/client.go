// Code generated by Fern. DO NOT EDIT.

package client

import (
	context "context"
	square "github.com/square/square-go-sdk/v2"
	images "github.com/square/square-go-sdk/v2/catalog/images"
	object "github.com/square/square-go-sdk/v2/catalog/object"
	core "github.com/square/square-go-sdk/v2/core"
	internal "github.com/square/square-go-sdk/v2/internal"
	option "github.com/square/square-go-sdk/v2/option"
	http "net/http"
	os "os"
)

type Client struct {
	WithRawResponse *RawClient
	Images          *images.Client
	Object          *object.Client

	options *core.RequestOptions
	baseURL string
	caller  *internal.Caller
}

func NewClient(options *core.RequestOptions) *Client {
	if options.Token == "" {
		options.Token = os.Getenv("SQUARE_TOKEN")
	}
	if options.Version == "" {
		options.Version = os.Getenv("VERSION")
	}
	return &Client{
		Images:          images.NewClient(options),
		Object:          object.NewClient(options),
		WithRawResponse: NewRawClient(options),
		options:         options,
		baseURL:         options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
	}
}

// Deletes a set of [CatalogItem](entity:CatalogItem)s based on the
// provided list of target IDs and returns a set of successfully deleted IDs in
// the response. Deletion is a cascading event such that all children of the
// targeted object are also deleted. For example, deleting a CatalogItem will
// also delete all of its [CatalogItemVariation](entity:CatalogItemVariation)
// children.
//
// `BatchDeleteCatalogObjects` succeeds even if only a portion of the targeted
// IDs can be deleted. The response will only include IDs that were
// actually deleted.
//
// To ensure consistency, only one delete request is processed at a time per seller account.
// While one (batch or non-batch) delete request is being processed, other (batched and non-batched)
// delete requests are rejected with the `429` error code.
func (c *Client) BatchDelete(
	ctx context.Context,
	request *square.BatchDeleteCatalogObjectsRequest,
	opts ...option.RequestOption,
) (*square.BatchDeleteCatalogObjectsResponse, error) {
	response, err := c.WithRawResponse.BatchDelete(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Returns a set of objects based on the provided ID.
// Each [CatalogItem](entity:CatalogItem) returned in the set includes all of its
// child information including: all of its
// [CatalogItemVariation](entity:CatalogItemVariation) objects, references to
// its [CatalogModifierList](entity:CatalogModifierList) objects, and the ids of
// any [CatalogTax](entity:CatalogTax) objects that apply to it.
func (c *Client) BatchGet(
	ctx context.Context,
	request *square.BatchGetCatalogObjectsRequest,
	opts ...option.RequestOption,
) (*square.BatchGetCatalogObjectsResponse, error) {
	response, err := c.WithRawResponse.BatchGet(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Creates or updates up to 10,000 target objects based on the provided
// list of objects. The target objects are grouped into batches and each batch is
// inserted/updated in an all-or-nothing manner. If an object within a batch is
// malformed in some way, or violates a database constraint, the entire batch
// containing that item will be disregarded. However, other batches in the same
// request may still succeed. Each batch may contain up to 1,000 objects, and
// batches will be processed in order as long as the total object count for the
// request (items, variations, modifier lists, discounts, and taxes) is no more
// than 10,000.
//
// To ensure consistency, only one update request is processed at a time per seller account.
// While one (batch or non-batch) update request is being processed, other (batched and non-batched)
// update requests are rejected with the `429` error code.
func (c *Client) BatchUpsert(
	ctx context.Context,
	request *square.BatchUpsertCatalogObjectsRequest,
	opts ...option.RequestOption,
) (*square.BatchUpsertCatalogObjectsResponse, error) {
	response, err := c.WithRawResponse.BatchUpsert(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Retrieves information about the Square Catalog API, such as batch size
// limits that can be used by the `BatchUpsertCatalogObjects` endpoint.
func (c *Client) Info(
	ctx context.Context,
	opts ...option.RequestOption,
) (*square.CatalogInfoResponse, error) {
	response, err := c.WithRawResponse.Info(
		ctx,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Returns a list of all [CatalogObject](entity:CatalogObject)s of the specified types in the catalog.
//
// The `types` parameter is specified as a comma-separated list of the [CatalogObjectType](entity:CatalogObjectType) values,
// for example, "`ITEM`, `ITEM_VARIATION`, `MODIFIER`, `MODIFIER_LIST`, `CATEGORY`, `DISCOUNT`, `TAX`, `IMAGE`".
//
// __Important:__ ListCatalog does not return deleted catalog items. To retrieve
// deleted catalog items, use [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects)
// and set the `include_deleted_objects` attribute value to `true`.
func (c *Client) List(
	ctx context.Context,
	request *square.ListCatalogRequest,
	opts ...option.RequestOption,
) (*core.Page[*string, *square.CatalogObject, *square.ListCatalogResponse], error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://connect.squareup.com",
	)
	endpointURL := baseURL + "/v2/catalog/list"
	queryParams, err := internal.QueryValues(request)
	if err != nil {
		return nil, err
	}
	headers := internal.MergeHeaders(
		c.options.ToHeader(),
		options.ToHeader(),
	)
	prepareCall := func(pageRequest *core.PageRequest[*string]) *internal.CallParams {
		if pageRequest.Cursor != nil {
			queryParams.Set("cursor", *pageRequest.Cursor)
		}
		nextURL := endpointURL
		if len(queryParams) > 0 {
			nextURL += "?" + queryParams.Encode()
		}
		return &internal.CallParams{
			URL:             nextURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        pageRequest.Response,
		}
	}
	readPageResponse := func(response *square.ListCatalogResponse) *core.PageResponse[*string, *square.CatalogObject, *square.ListCatalogResponse] {
		var zeroValue *string
		next := response.GetCursor()
		results := response.GetObjects()
		return &core.PageResponse[*string, *square.CatalogObject, *square.ListCatalogResponse]{
			Results:  results,
			Response: response,
			Next:     next,
			Done:     next == zeroValue,
		}
	}
	pager := internal.NewCursorPager(
		c.caller,
		prepareCall,
		readPageResponse,
	)
	return pager.GetPage(ctx, request.Cursor)
}

// Searches for [CatalogObject](entity:CatalogObject) of any type by matching supported search attribute values,
// excluding custom attribute values on items or item variations, against one or more of the specified query filters.
//
// This (`SearchCatalogObjects`) endpoint differs from the [SearchCatalogItems](api-endpoint:Catalog-SearchCatalogItems)
// endpoint in the following aspects:
//
// - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects.
// - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not.
// - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does.
// - The both endpoints have different call conventions, including the query filter formats.
func (c *Client) Search(
	ctx context.Context,
	request *square.SearchCatalogObjectsRequest,
	opts ...option.RequestOption,
) (*square.SearchCatalogObjectsResponse, error) {
	response, err := c.WithRawResponse.Search(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Searches for catalog items or item variations by matching supported search attribute values, including
// custom attribute values, against one or more of the specified query filters.
//
// This (`SearchCatalogItems`) endpoint differs from the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects)
// endpoint in the following aspects:
//
// - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects.
// - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not.
// - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does.
// - The both endpoints use different call conventions, including the query filter formats.
func (c *Client) SearchItems(
	ctx context.Context,
	request *square.SearchCatalogItemsRequest,
	opts ...option.RequestOption,
) (*square.SearchCatalogItemsResponse, error) {
	response, err := c.WithRawResponse.SearchItems(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Updates the [CatalogModifierList](entity:CatalogModifierList) objects
// that apply to the targeted [CatalogItem](entity:CatalogItem) without having
// to perform an upsert on the entire item.
func (c *Client) UpdateItemModifierLists(
	ctx context.Context,
	request *square.UpdateItemModifierListsRequest,
	opts ...option.RequestOption,
) (*square.UpdateItemModifierListsResponse, error) {
	response, err := c.WithRawResponse.UpdateItemModifierLists(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Updates the [CatalogTax](entity:CatalogTax) objects that apply to the
// targeted [CatalogItem](entity:CatalogItem) without having to perform an
// upsert on the entire item.
func (c *Client) UpdateItemTaxes(
	ctx context.Context,
	request *square.UpdateItemTaxesRequest,
	opts ...option.RequestOption,
) (*square.UpdateItemTaxesResponse, error) {
	response, err := c.WithRawResponse.UpdateItemTaxes(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}
