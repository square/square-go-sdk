// Code generated by Fern. DO NOT EDIT.

package transferorders

import (
	context "context"
	v2 "github.com/square/square-go-sdk/v2"
	core "github.com/square/square-go-sdk/v2/core"
	internal "github.com/square/square-go-sdk/v2/internal"
	option "github.com/square/square-go-sdk/v2/option"
	http "net/http"
	os "os"
)

type Client struct {
	WithRawResponse *RawClient

	baseURL string
	caller  *internal.Caller
	header  http.Header
}

func NewClient(opts ...option.RequestOption) *Client {
	options := core.NewRequestOptions(opts...)
	if options.Token == "" {
		options.Token = os.Getenv("SQUARE_TOKEN")
	}
	if options.Version == "" {
		options.Version = os.Getenv("VERSION")
	}
	return &Client{
		WithRawResponse: NewRawClient(options),
		baseURL:         options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
		header: options.ToHeader(),
	}
}

// Creates a new transfer order in [DRAFT](entity:TransferOrderStatus) status. A transfer order represents the intent
// to move [CatalogItemVariation](entity:CatalogItemVariation)s from one [Location](entity:Location) to another.
// The source and destination locations must be different and must belong to your Square account.
//
// In [DRAFT](entity:TransferOrderStatus) status, you can:
// - Add or remove items
// - Modify quantities
// - Update shipping information
// - Delete the entire order via [DeleteTransferOrder](api-endpoint:TransferOrders-DeleteTransferOrder)
//
// The request requires source_location_id and destination_location_id.
// Inventory levels are not affected until the order is started via
// [StartTransferOrder](api-endpoint:TransferOrders-StartTransferOrder).
//
// Common integration points:
// - Sync with warehouse management systems
// - Automate regular stock transfers
// - Initialize transfers from inventory optimization systems
//
// Creates a [transfer_order.created](webhook:transfer_order.created) webhook event.
func (c *Client) Create(
	ctx context.Context,
	request *v2.CreateTransferOrderRequest,
	opts ...option.RequestOption,
) (*v2.CreateTransferOrderResponse, error) {
	response, err := c.WithRawResponse.Create(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Searches for transfer orders using filters. Returns a paginated list of matching
// [TransferOrder](entity:TransferOrder)s sorted by creation date.
//
// Common search scenarios:
// - Find orders for a source [Location](entity:Location)
// - Find orders for a destination [Location](entity:Location)
// - Find orders in a particular [TransferOrderStatus](entity:TransferOrderStatus)
func (c *Client) Search(
	ctx context.Context,
	request *v2.SearchTransferOrdersRequest,
	opts ...option.RequestOption,
) (*v2.SearchTransferOrdersResponse, error) {
	response, err := c.WithRawResponse.Search(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Retrieves a specific [TransferOrder](entity:TransferOrder) by ID. Returns the complete
// order details including:
//
// - Basic information (status, dates, notes)
// - Line items with ordered and received quantities
// - Source and destination [Location](entity:Location)s
// - Tracking information (if available)
func (c *Client) Get(
	ctx context.Context,
	request *v2.GetTransferOrdersRequest,
	opts ...option.RequestOption,
) (*v2.RetrieveTransferOrderResponse, error) {
	response, err := c.WithRawResponse.Get(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Updates an existing transfer order. This endpoint supports sparse updates,
// allowing you to modify specific fields without affecting others.
//
// Creates a [transfer_order.updated](webhook:transfer_order.updated) webhook event.
func (c *Client) Update(
	ctx context.Context,
	request *v2.UpdateTransferOrderRequest,
	opts ...option.RequestOption,
) (*v2.UpdateTransferOrderResponse, error) {
	response, err := c.WithRawResponse.Update(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Deletes a transfer order in [DRAFT](entity:TransferOrderStatus) status.
// Only draft orders can be deleted. Once an order is started via
// [StartTransferOrder](api-endpoint:TransferOrders-StartTransferOrder), it can no longer be deleted.
//
// Creates a [transfer_order.deleted](webhook:transfer_order.deleted) webhook event.
func (c *Client) Delete(
	ctx context.Context,
	request *v2.DeleteTransferOrdersRequest,
	opts ...option.RequestOption,
) (*v2.DeleteTransferOrderResponse, error) {
	response, err := c.WithRawResponse.Delete(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Cancels a transfer order in [STARTED](entity:TransferOrderStatus) or
// [PARTIALLY_RECEIVED](entity:TransferOrderStatus) status. Any unreceived quantities will no
// longer be receivable and will be immediately returned to the source [Location](entity:Location)'s inventory.
//
// Common reasons for cancellation:
// - Items no longer needed at destination
// - Source location needs the inventory
// - Order created in error
//
// Creates a [transfer_order.updated](webhook:transfer_order.updated) webhook event.
func (c *Client) Cancel(
	ctx context.Context,
	request *v2.CancelTransferOrderRequest,
	opts ...option.RequestOption,
) (*v2.CancelTransferOrderResponse, error) {
	response, err := c.WithRawResponse.Cancel(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Records receipt of [CatalogItemVariation](entity:CatalogItemVariation)s for a transfer order.
// This endpoint supports partial receiving - you can receive items in multiple batches.
//
// For each line item, you can specify:
// - Quantity received in good condition (added to destination inventory with [InventoryState](entity:InventoryState) of IN_STOCK)
// - Quantity damaged during transit/handling (added to destination inventory with [InventoryState](entity:InventoryState) of WASTE)
// - Quantity canceled (returned to source location's inventory)
//
// The order must be in [STARTED](entity:TransferOrderStatus) or [PARTIALLY_RECEIVED](entity:TransferOrderStatus) status.
// Received quantities are added to the destination [Location](entity:Location)'s inventory according to their condition.
// Canceled quantities are immediately returned to the source [Location](entity:Location)'s inventory.
//
// When all items are either received, damaged, or canceled, the order moves to
// [COMPLETED](entity:TransferOrderStatus) status.
//
// Creates a [transfer_order.updated](webhook:transfer_order.updated) webhook event.
func (c *Client) Receive(
	ctx context.Context,
	request *v2.ReceiveTransferOrderRequest,
	opts ...option.RequestOption,
) (*v2.ReceiveTransferOrderResponse, error) {
	response, err := c.WithRawResponse.Receive(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Changes a [DRAFT](entity:TransferOrderStatus) transfer order to [STARTED](entity:TransferOrderStatus) status.
// This decrements inventory at the source [Location](entity:Location) and marks it as in-transit.
//
// The order must be in [DRAFT](entity:TransferOrderStatus) status and have all required fields populated.
// Once started, the order can no longer be deleted, but it can be canceled via
// [CancelTransferOrder](api-endpoint:TransferOrders-CancelTransferOrder).
//
// Creates a [transfer_order.updated](webhook:transfer_order.updated) webhook event.
func (c *Client) Start(
	ctx context.Context,
	request *v2.StartTransferOrderRequest,
	opts ...option.RequestOption,
) (*v2.StartTransferOrderResponse, error) {
	response, err := c.WithRawResponse.Start(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}
