// Code generated by Fern. DO NOT EDIT.

package square

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/square/square-go-sdk/v2/internal"
	big "math/big"
)

var (
	bulkSwapPlanRequestFieldNewPlanVariationID = big.NewInt(1 << 0)
	bulkSwapPlanRequestFieldOldPlanVariationID = big.NewInt(1 << 1)
	bulkSwapPlanRequestFieldLocationID         = big.NewInt(1 << 2)
)

type BulkSwapPlanRequest struct {
	// The ID of the new subscription plan variation.
	//
	// This field is required.
	NewPlanVariationID string `json:"new_plan_variation_id" url:"-"`
	// The ID of the plan variation whose subscriptions should be swapped. Active subscriptions
	// using this plan variation will be subscribed to the new plan variation on their next billing
	// day.
	OldPlanVariationID string `json:"old_plan_variation_id" url:"-"`
	// The ID of the location to associate with the swapped subscriptions.
	LocationID string `json:"location_id" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (b *BulkSwapPlanRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetNewPlanVariationID sets the NewPlanVariationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BulkSwapPlanRequest) SetNewPlanVariationID(newPlanVariationID string) {
	b.NewPlanVariationID = newPlanVariationID
	b.require(bulkSwapPlanRequestFieldNewPlanVariationID)
}

// SetOldPlanVariationID sets the OldPlanVariationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BulkSwapPlanRequest) SetOldPlanVariationID(oldPlanVariationID string) {
	b.OldPlanVariationID = oldPlanVariationID
	b.require(bulkSwapPlanRequestFieldOldPlanVariationID)
}

// SetLocationID sets the LocationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BulkSwapPlanRequest) SetLocationID(locationID string) {
	b.LocationID = locationID
	b.require(bulkSwapPlanRequestFieldLocationID)
}

var (
	changeBillingAnchorDateRequestFieldSubscriptionID           = big.NewInt(1 << 0)
	changeBillingAnchorDateRequestFieldMonthlyBillingAnchorDate = big.NewInt(1 << 1)
	changeBillingAnchorDateRequestFieldEffectiveDate            = big.NewInt(1 << 2)
)

type ChangeBillingAnchorDateRequest struct {
	// The ID of the subscription to update the billing anchor date.
	SubscriptionID string `json:"-" url:"-"`
	// The anchor day for the billing cycle.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the scheduled `BILLING_ANCHOR_CHANGE` action takes
	// place on the subscription.
	//
	// When this date is unspecified or falls within the current billing cycle, the billing anchor date
	// is changed immediately.
	EffectiveDate *string `json:"effective_date,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *ChangeBillingAnchorDateRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChangeBillingAnchorDateRequest) SetSubscriptionID(subscriptionID string) {
	c.SubscriptionID = subscriptionID
	c.require(changeBillingAnchorDateRequestFieldSubscriptionID)
}

// SetMonthlyBillingAnchorDate sets the MonthlyBillingAnchorDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChangeBillingAnchorDateRequest) SetMonthlyBillingAnchorDate(monthlyBillingAnchorDate *int) {
	c.MonthlyBillingAnchorDate = monthlyBillingAnchorDate
	c.require(changeBillingAnchorDateRequestFieldMonthlyBillingAnchorDate)
}

// SetEffectiveDate sets the EffectiveDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChangeBillingAnchorDateRequest) SetEffectiveDate(effectiveDate *string) {
	c.EffectiveDate = effectiveDate
	c.require(changeBillingAnchorDateRequestFieldEffectiveDate)
}

var (
	deleteActionSubscriptionsRequestFieldSubscriptionID = big.NewInt(1 << 0)
	deleteActionSubscriptionsRequestFieldActionID       = big.NewInt(1 << 1)
)

type DeleteActionSubscriptionsRequest struct {
	// The ID of the subscription the targeted action is to act upon.
	SubscriptionID string `json:"-" url:"-"`
	// The ID of the targeted action to be deleted.
	ActionID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (d *DeleteActionSubscriptionsRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteActionSubscriptionsRequest) SetSubscriptionID(subscriptionID string) {
	d.SubscriptionID = subscriptionID
	d.require(deleteActionSubscriptionsRequestFieldSubscriptionID)
}

// SetActionID sets the ActionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteActionSubscriptionsRequest) SetActionID(actionID string) {
	d.ActionID = actionID
	d.require(deleteActionSubscriptionsRequestFieldActionID)
}

var (
	swapPlanRequestFieldSubscriptionID     = big.NewInt(1 << 0)
	swapPlanRequestFieldNewPlanVariationID = big.NewInt(1 << 1)
	swapPlanRequestFieldPhases             = big.NewInt(1 << 2)
)

type SwapPlanRequest struct {
	// The ID of the subscription to swap the subscription plan for.
	SubscriptionID string `json:"-" url:"-"`
	// The ID of the new subscription plan variation.
	//
	// This field is required.
	NewPlanVariationID *string `json:"new_plan_variation_id,omitempty" url:"-"`
	// A list of PhaseInputs, to pass phase-specific information used in the swap.
	Phases []*PhaseInput `json:"phases,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SwapPlanRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwapPlanRequest) SetSubscriptionID(subscriptionID string) {
	s.SubscriptionID = subscriptionID
	s.require(swapPlanRequestFieldSubscriptionID)
}

// SetNewPlanVariationID sets the NewPlanVariationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwapPlanRequest) SetNewPlanVariationID(newPlanVariationID *string) {
	s.NewPlanVariationID = newPlanVariationID
	s.require(swapPlanRequestFieldNewPlanVariationID)
}

// SetPhases sets the Phases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwapPlanRequest) SetPhases(phases []*PhaseInput) {
	s.Phases = phases
	s.require(swapPlanRequestFieldPhases)
}

var (
	cancelSubscriptionsRequestFieldSubscriptionID = big.NewInt(1 << 0)
)

type CancelSubscriptionsRequest struct {
	// The ID of the subscription to cancel.
	SubscriptionID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CancelSubscriptionsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CancelSubscriptionsRequest) SetSubscriptionID(subscriptionID string) {
	c.SubscriptionID = subscriptionID
	c.require(cancelSubscriptionsRequestFieldSubscriptionID)
}

var (
	createSubscriptionRequestFieldIdempotencyKey           = big.NewInt(1 << 0)
	createSubscriptionRequestFieldLocationID               = big.NewInt(1 << 1)
	createSubscriptionRequestFieldPlanVariationID          = big.NewInt(1 << 2)
	createSubscriptionRequestFieldCustomerID               = big.NewInt(1 << 3)
	createSubscriptionRequestFieldStartDate                = big.NewInt(1 << 4)
	createSubscriptionRequestFieldCanceledDate             = big.NewInt(1 << 5)
	createSubscriptionRequestFieldTaxPercentage            = big.NewInt(1 << 6)
	createSubscriptionRequestFieldPriceOverrideMoney       = big.NewInt(1 << 7)
	createSubscriptionRequestFieldCardID                   = big.NewInt(1 << 8)
	createSubscriptionRequestFieldTimezone                 = big.NewInt(1 << 9)
	createSubscriptionRequestFieldSource                   = big.NewInt(1 << 10)
	createSubscriptionRequestFieldMonthlyBillingAnchorDate = big.NewInt(1 << 11)
	createSubscriptionRequestFieldPhases                   = big.NewInt(1 << 12)
)

type CreateSubscriptionRequest struct {
	// A unique string that identifies this `CreateSubscription` request.
	// If you do not provide a unique string (or provide an empty string as the value),
	// the endpoint treats each request as independent.
	//
	// For more information, see [Idempotency keys](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"-"`
	// The ID of the location the subscription is associated with.
	LocationID string `json:"location_id" url:"-"`
	// The ID of the [subscription plan variation](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations#plan-variations) created using the Catalog API.
	PlanVariationID *string `json:"plan_variation_id,omitempty" url:"-"`
	// The ID of the [customer](entity:Customer) subscribing to the subscription plan variation.
	CustomerID string `json:"customer_id" url:"-"`
	// The `YYYY-MM-DD`-formatted date to start the subscription.
	// If it is unspecified, the subscription starts immediately.
	StartDate *string `json:"start_date,omitempty" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the newly created subscription is scheduled for cancellation.
	//
	// This date overrides the cancellation date set in the plan variation configuration.
	// If the cancellation date is earlier than the end date of a subscription cycle, the subscription stops
	// at the canceled date and the subscriber is sent a prorated invoice at the beginning of the canceled cycle.
	//
	// When the subscription plan of the newly created subscription has a fixed number of cycles and the `canceled_date`
	// occurs before the subscription plan completes, the specified `canceled_date` sets the date when the subscription
	// stops through the end of the last cycle.
	CanceledDate *string `json:"canceled_date,omitempty" url:"-"`
	// The tax to add when billing the subscription.
	// The percentage is expressed in decimal form, using a `'.'` as the decimal
	// separator and without a `'%'` sign. For example, a value of 7.5
	// corresponds to 7.5%.
	TaxPercentage *string `json:"tax_percentage,omitempty" url:"-"`
	// A custom price which overrides the cost of a subscription plan variation with `STATIC` pricing.
	// This field does not affect itemized subscriptions with `RELATIVE` pricing. Instead,
	// you should edit the Subscription's [order template](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#phases-and-order-templates).
	PriceOverrideMoney *Money `json:"price_override_money,omitempty" url:"-"`
	// The ID of the [subscriber's](entity:Customer) [card](entity:Card) to charge.
	// If it is not specified, the subscriber receives an invoice via email with a link to pay for their subscription.
	CardID *string `json:"card_id,omitempty" url:"-"`
	// The timezone that is used in date calculations for the subscription. If unset, defaults to
	// the location timezone. If a timezone is not configured for the location, defaults to "America/New_York".
	// Format: the IANA Timezone Database identifier for the location timezone. For
	// a list of time zones, see [List of tz database time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *string `json:"timezone,omitempty" url:"-"`
	// The origination details of the subscription.
	Source *SubscriptionSource `json:"source,omitempty" url:"-"`
	// The day-of-the-month to change the billing date to.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"-"`
	// array of phases for this subscription
	Phases []*Phase `json:"phases,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *CreateSubscriptionRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetIdempotencyKey sets the IdempotencyKey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetIdempotencyKey(idempotencyKey *string) {
	c.IdempotencyKey = idempotencyKey
	c.require(createSubscriptionRequestFieldIdempotencyKey)
}

// SetLocationID sets the LocationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetLocationID(locationID string) {
	c.LocationID = locationID
	c.require(createSubscriptionRequestFieldLocationID)
}

// SetPlanVariationID sets the PlanVariationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetPlanVariationID(planVariationID *string) {
	c.PlanVariationID = planVariationID
	c.require(createSubscriptionRequestFieldPlanVariationID)
}

// SetCustomerID sets the CustomerID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetCustomerID(customerID string) {
	c.CustomerID = customerID
	c.require(createSubscriptionRequestFieldCustomerID)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetStartDate(startDate *string) {
	c.StartDate = startDate
	c.require(createSubscriptionRequestFieldStartDate)
}

// SetCanceledDate sets the CanceledDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetCanceledDate(canceledDate *string) {
	c.CanceledDate = canceledDate
	c.require(createSubscriptionRequestFieldCanceledDate)
}

// SetTaxPercentage sets the TaxPercentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetTaxPercentage(taxPercentage *string) {
	c.TaxPercentage = taxPercentage
	c.require(createSubscriptionRequestFieldTaxPercentage)
}

// SetPriceOverrideMoney sets the PriceOverrideMoney field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetPriceOverrideMoney(priceOverrideMoney *Money) {
	c.PriceOverrideMoney = priceOverrideMoney
	c.require(createSubscriptionRequestFieldPriceOverrideMoney)
}

// SetCardID sets the CardID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetCardID(cardID *string) {
	c.CardID = cardID
	c.require(createSubscriptionRequestFieldCardID)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetTimezone(timezone *string) {
	c.Timezone = timezone
	c.require(createSubscriptionRequestFieldTimezone)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetSource(source *SubscriptionSource) {
	c.Source = source
	c.require(createSubscriptionRequestFieldSource)
}

// SetMonthlyBillingAnchorDate sets the MonthlyBillingAnchorDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetMonthlyBillingAnchorDate(monthlyBillingAnchorDate *int) {
	c.MonthlyBillingAnchorDate = monthlyBillingAnchorDate
	c.require(createSubscriptionRequestFieldMonthlyBillingAnchorDate)
}

// SetPhases sets the Phases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionRequest) SetPhases(phases []*Phase) {
	c.Phases = phases
	c.require(createSubscriptionRequestFieldPhases)
}

var (
	getSubscriptionsRequestFieldSubscriptionID = big.NewInt(1 << 0)
	getSubscriptionsRequestFieldInclude        = big.NewInt(1 << 1)
)

type GetSubscriptionsRequest struct {
	// The ID of the subscription to retrieve.
	SubscriptionID string `json:"-" url:"-"`
	// A query parameter to specify related information to be included in the response.
	//
	// The supported query parameter values are:
	//
	// - `actions`: to include scheduled actions on the targeted subscription.
	Include *string `json:"-" url:"include,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetSubscriptionsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetSubscriptionsRequest) SetSubscriptionID(subscriptionID string) {
	g.SubscriptionID = subscriptionID
	g.require(getSubscriptionsRequestFieldSubscriptionID)
}

// SetInclude sets the Include field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetSubscriptionsRequest) SetInclude(include *string) {
	g.Include = include
	g.require(getSubscriptionsRequestFieldInclude)
}

var (
	listEventsSubscriptionsRequestFieldSubscriptionID = big.NewInt(1 << 0)
	listEventsSubscriptionsRequestFieldCursor         = big.NewInt(1 << 1)
	listEventsSubscriptionsRequestFieldLimit          = big.NewInt(1 << 2)
)

type ListEventsSubscriptionsRequest struct {
	// The ID of the subscription to retrieve the events for.
	SubscriptionID string `json:"-" url:"-"`
	// When the total number of resulting subscription events exceeds the limit of a paged response,
	// specify the cursor returned from a preceding response here to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The upper limit on the number of subscription events to return
	// in a paged response.
	Limit *int `json:"-" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListEventsSubscriptionsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListEventsSubscriptionsRequest) SetSubscriptionID(subscriptionID string) {
	l.SubscriptionID = subscriptionID
	l.require(listEventsSubscriptionsRequestFieldSubscriptionID)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListEventsSubscriptionsRequest) SetCursor(cursor *string) {
	l.Cursor = cursor
	l.require(listEventsSubscriptionsRequestFieldCursor)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListEventsSubscriptionsRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listEventsSubscriptionsRequestFieldLimit)
}

var (
	pauseSubscriptionRequestFieldSubscriptionID      = big.NewInt(1 << 0)
	pauseSubscriptionRequestFieldPauseEffectiveDate  = big.NewInt(1 << 1)
	pauseSubscriptionRequestFieldPauseCycleDuration  = big.NewInt(1 << 2)
	pauseSubscriptionRequestFieldResumeEffectiveDate = big.NewInt(1 << 3)
	pauseSubscriptionRequestFieldResumeChangeTiming  = big.NewInt(1 << 4)
	pauseSubscriptionRequestFieldPauseReason         = big.NewInt(1 << 5)
)

type PauseSubscriptionRequest struct {
	// The ID of the subscription to pause.
	SubscriptionID string `json:"-" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the scheduled `PAUSE` action takes place on the subscription.
	//
	// When this date is unspecified or falls within the current billing cycle, the subscription is paused
	// on the starting date of the next billing cycle.
	PauseEffectiveDate *string `json:"pause_effective_date,omitempty" url:"-"`
	// The number of billing cycles the subscription will be paused before it is reactivated.
	//
	// When this is set, a `RESUME` action is also scheduled to take place on the subscription at
	// the end of the specified pause cycle duration. In this case, neither `resume_effective_date`
	// nor `resume_change_timing` may be specified.
	PauseCycleDuration *int64 `json:"pause_cycle_duration,omitempty" url:"-"`
	// The date when the subscription is reactivated by a scheduled `RESUME` action.
	// This date must be at least one billing cycle ahead of `pause_effective_date`.
	ResumeEffectiveDate *string `json:"resume_effective_date,omitempty" url:"-"`
	// The timing whether the subscription is reactivated immediately or at the end of the billing cycle, relative to
	// `resume_effective_date`.
	// See [ChangeTiming](#type-changetiming) for possible values
	ResumeChangeTiming *ChangeTiming `json:"resume_change_timing,omitempty" url:"-"`
	// The user-provided reason to pause the subscription.
	PauseReason *string `json:"pause_reason,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (p *PauseSubscriptionRequest) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionRequest) SetSubscriptionID(subscriptionID string) {
	p.SubscriptionID = subscriptionID
	p.require(pauseSubscriptionRequestFieldSubscriptionID)
}

// SetPauseEffectiveDate sets the PauseEffectiveDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionRequest) SetPauseEffectiveDate(pauseEffectiveDate *string) {
	p.PauseEffectiveDate = pauseEffectiveDate
	p.require(pauseSubscriptionRequestFieldPauseEffectiveDate)
}

// SetPauseCycleDuration sets the PauseCycleDuration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionRequest) SetPauseCycleDuration(pauseCycleDuration *int64) {
	p.PauseCycleDuration = pauseCycleDuration
	p.require(pauseSubscriptionRequestFieldPauseCycleDuration)
}

// SetResumeEffectiveDate sets the ResumeEffectiveDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionRequest) SetResumeEffectiveDate(resumeEffectiveDate *string) {
	p.ResumeEffectiveDate = resumeEffectiveDate
	p.require(pauseSubscriptionRequestFieldResumeEffectiveDate)
}

// SetResumeChangeTiming sets the ResumeChangeTiming field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionRequest) SetResumeChangeTiming(resumeChangeTiming *ChangeTiming) {
	p.ResumeChangeTiming = resumeChangeTiming
	p.require(pauseSubscriptionRequestFieldResumeChangeTiming)
}

// SetPauseReason sets the PauseReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionRequest) SetPauseReason(pauseReason *string) {
	p.PauseReason = pauseReason
	p.require(pauseSubscriptionRequestFieldPauseReason)
}

var (
	resumeSubscriptionRequestFieldSubscriptionID      = big.NewInt(1 << 0)
	resumeSubscriptionRequestFieldResumeEffectiveDate = big.NewInt(1 << 1)
	resumeSubscriptionRequestFieldResumeChangeTiming  = big.NewInt(1 << 2)
)

type ResumeSubscriptionRequest struct {
	// The ID of the subscription to resume.
	SubscriptionID string `json:"-" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the subscription reactivated.
	ResumeEffectiveDate *string `json:"resume_effective_date,omitempty" url:"-"`
	// The timing to resume a subscription, relative to the specified
	// `resume_effective_date` attribute value.
	// See [ChangeTiming](#type-changetiming) for possible values
	ResumeChangeTiming *ChangeTiming `json:"resume_change_timing,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (r *ResumeSubscriptionRequest) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResumeSubscriptionRequest) SetSubscriptionID(subscriptionID string) {
	r.SubscriptionID = subscriptionID
	r.require(resumeSubscriptionRequestFieldSubscriptionID)
}

// SetResumeEffectiveDate sets the ResumeEffectiveDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResumeSubscriptionRequest) SetResumeEffectiveDate(resumeEffectiveDate *string) {
	r.ResumeEffectiveDate = resumeEffectiveDate
	r.require(resumeSubscriptionRequestFieldResumeEffectiveDate)
}

// SetResumeChangeTiming sets the ResumeChangeTiming field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResumeSubscriptionRequest) SetResumeChangeTiming(resumeChangeTiming *ChangeTiming) {
	r.ResumeChangeTiming = resumeChangeTiming
	r.require(resumeSubscriptionRequestFieldResumeChangeTiming)
}

var (
	searchSubscriptionsRequestFieldCursor  = big.NewInt(1 << 0)
	searchSubscriptionsRequestFieldLimit   = big.NewInt(1 << 1)
	searchSubscriptionsRequestFieldQuery   = big.NewInt(1 << 2)
	searchSubscriptionsRequestFieldInclude = big.NewInt(1 << 3)
)

type SearchSubscriptionsRequest struct {
	// When the total number of resulting subscriptions exceeds the limit of a paged response,
	// specify the cursor returned from a preceding response here to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"-"`
	// The upper limit on the number of subscriptions to return
	// in a paged response.
	Limit *int `json:"limit,omitempty" url:"-"`
	// A subscription query consisting of specified filtering conditions.
	//
	// If this `query` field is unspecified, the `SearchSubscriptions` call will return all subscriptions.
	Query *SearchSubscriptionsQuery `json:"query,omitempty" url:"-"`
	// An option to include related information in the response.
	//
	// The supported values are:
	//
	// - `actions`: to include scheduled actions on the targeted subscriptions.
	Include []string `json:"include,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SearchSubscriptionsRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsRequest) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(searchSubscriptionsRequestFieldCursor)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsRequest) SetLimit(limit *int) {
	s.Limit = limit
	s.require(searchSubscriptionsRequestFieldLimit)
}

// SetQuery sets the Query field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsRequest) SetQuery(query *SearchSubscriptionsQuery) {
	s.Query = query
	s.require(searchSubscriptionsRequestFieldQuery)
}

// SetInclude sets the Include field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsRequest) SetInclude(include []string) {
	s.Include = include
	s.require(searchSubscriptionsRequestFieldInclude)
}

// Defines output parameters in a response of the
// [BulkSwapPlan](api-endpoint:Subscriptions-BulkSwapPlan) endpoint.
var (
	bulkSwapPlanResponseFieldErrors                = big.NewInt(1 << 0)
	bulkSwapPlanResponseFieldAffectedSubscriptions = big.NewInt(1 << 1)
)

type BulkSwapPlanResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The number of affected subscriptions.
	AffectedSubscriptions *int `json:"affected_subscriptions,omitempty" url:"affected_subscriptions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkSwapPlanResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkSwapPlanResponse) GetAffectedSubscriptions() *int {
	if b == nil {
		return nil
	}
	return b.AffectedSubscriptions
}

func (b *BulkSwapPlanResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkSwapPlanResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BulkSwapPlanResponse) SetErrors(errors []*Error) {
	b.Errors = errors
	b.require(bulkSwapPlanResponseFieldErrors)
}

// SetAffectedSubscriptions sets the AffectedSubscriptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BulkSwapPlanResponse) SetAffectedSubscriptions(affectedSubscriptions *int) {
	b.AffectedSubscriptions = affectedSubscriptions
	b.require(bulkSwapPlanResponseFieldAffectedSubscriptions)
}

func (b *BulkSwapPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkSwapPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkSwapPlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSwapPlanResponse) MarshalJSON() ([]byte, error) {
	type embed BulkSwapPlanResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BulkSwapPlanResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines output parameters in a response from the
// [CancelSubscription](api-endpoint:Subscriptions-CancelSubscription) endpoint.
var (
	cancelSubscriptionResponseFieldErrors       = big.NewInt(1 << 0)
	cancelSubscriptionResponseFieldSubscription = big.NewInt(1 << 1)
	cancelSubscriptionResponseFieldActions      = big.NewInt(1 << 2)
)

type CancelSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The specified subscription scheduled for cancellation according to the action created by the request.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a single `CANCEL` action scheduled for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelSubscriptionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CancelSubscriptionResponse) GetSubscription() *Subscription {
	if c == nil {
		return nil
	}
	return c.Subscription
}

func (c *CancelSubscriptionResponse) GetActions() []*SubscriptionAction {
	if c == nil {
		return nil
	}
	return c.Actions
}

func (c *CancelSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelSubscriptionResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CancelSubscriptionResponse) SetErrors(errors []*Error) {
	c.Errors = errors
	c.require(cancelSubscriptionResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CancelSubscriptionResponse) SetSubscription(subscription *Subscription) {
	c.Subscription = subscription
	c.require(cancelSubscriptionResponseFieldSubscription)
}

// SetActions sets the Actions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CancelSubscriptionResponse) SetActions(actions []*SubscriptionAction) {
	c.Actions = actions
	c.require(cancelSubscriptionResponseFieldActions)
}

func (c *CancelSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelSubscriptionResponse) MarshalJSON() ([]byte, error) {
	type embed CancelSubscriptionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CancelSubscriptionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines output parameters in a request to the
// [ChangeBillingAnchorDate](api-endpoint:Subscriptions-ChangeBillingAnchorDate) endpoint.
var (
	changeBillingAnchorDateResponseFieldErrors       = big.NewInt(1 << 0)
	changeBillingAnchorDateResponseFieldSubscription = big.NewInt(1 << 1)
	changeBillingAnchorDateResponseFieldActions      = big.NewInt(1 << 2)
)

type ChangeBillingAnchorDateResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The specified subscription for updating billing anchor date.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a single billing anchor date change for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChangeBillingAnchorDateResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *ChangeBillingAnchorDateResponse) GetSubscription() *Subscription {
	if c == nil {
		return nil
	}
	return c.Subscription
}

func (c *ChangeBillingAnchorDateResponse) GetActions() []*SubscriptionAction {
	if c == nil {
		return nil
	}
	return c.Actions
}

func (c *ChangeBillingAnchorDateResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChangeBillingAnchorDateResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChangeBillingAnchorDateResponse) SetErrors(errors []*Error) {
	c.Errors = errors
	c.require(changeBillingAnchorDateResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChangeBillingAnchorDateResponse) SetSubscription(subscription *Subscription) {
	c.Subscription = subscription
	c.require(changeBillingAnchorDateResponseFieldSubscription)
}

// SetActions sets the Actions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ChangeBillingAnchorDateResponse) SetActions(actions []*SubscriptionAction) {
	c.Actions = actions
	c.require(changeBillingAnchorDateResponseFieldActions)
}

func (c *ChangeBillingAnchorDateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChangeBillingAnchorDateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChangeBillingAnchorDateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChangeBillingAnchorDateResponse) MarshalJSON() ([]byte, error) {
	type embed ChangeBillingAnchorDateResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ChangeBillingAnchorDateResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Supported timings when a pending change, as an action, takes place to a subscription.
type ChangeTiming string

const (
	ChangeTimingImmediate         ChangeTiming = "IMMEDIATE"
	ChangeTimingEndOfBillingCycle ChangeTiming = "END_OF_BILLING_CYCLE"
)

func NewChangeTimingFromString(s string) (ChangeTiming, error) {
	switch s {
	case "IMMEDIATE":
		return ChangeTimingImmediate, nil
	case "END_OF_BILLING_CYCLE":
		return ChangeTimingEndOfBillingCycle, nil
	}
	var t ChangeTiming
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChangeTiming) Ptr() *ChangeTiming {
	return &c
}

// Defines output parameters in a response from the
// [CreateSubscription](api-endpoint:Subscriptions-CreateSubscription) endpoint.
var (
	createSubscriptionResponseFieldErrors       = big.NewInt(1 << 0)
	createSubscriptionResponseFieldSubscription = big.NewInt(1 << 1)
)

type CreateSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created subscription.
	//
	// For more information, see
	// [Subscription object](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#subscription-object).
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSubscriptionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateSubscriptionResponse) GetSubscription() *Subscription {
	if c == nil {
		return nil
	}
	return c.Subscription
}

func (c *CreateSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSubscriptionResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionResponse) SetErrors(errors []*Error) {
	c.Errors = errors
	c.require(createSubscriptionResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CreateSubscriptionResponse) SetSubscription(subscription *Subscription) {
	c.Subscription = subscription
	c.require(createSubscriptionResponseFieldSubscription)
}

func (c *CreateSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSubscriptionResponse) MarshalJSON() ([]byte, error) {
	type embed CreateSubscriptionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CreateSubscriptionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines output parameters in a response of the [DeleteSubscriptionAction](api-endpoint:Subscriptions-DeleteSubscriptionAction)
// endpoint.
var (
	deleteSubscriptionActionResponseFieldErrors       = big.NewInt(1 << 0)
	deleteSubscriptionActionResponseFieldSubscription = big.NewInt(1 << 1)
)

type DeleteSubscriptionActionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription that has the specified action deleted.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteSubscriptionActionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteSubscriptionActionResponse) GetSubscription() *Subscription {
	if d == nil {
		return nil
	}
	return d.Subscription
}

func (d *DeleteSubscriptionActionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSubscriptionActionResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteSubscriptionActionResponse) SetErrors(errors []*Error) {
	d.Errors = errors
	d.require(deleteSubscriptionActionResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeleteSubscriptionActionResponse) SetSubscription(subscription *Subscription) {
	d.Subscription = subscription
	d.require(deleteSubscriptionActionResponseFieldSubscription)
}

func (d *DeleteSubscriptionActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSubscriptionActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSubscriptionActionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSubscriptionActionResponse) MarshalJSON() ([]byte, error) {
	type embed DeleteSubscriptionActionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeleteSubscriptionActionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines output parameters in a response from the
// [RetrieveSubscription](api-endpoint:Subscriptions-RetrieveSubscription) endpoint.
var (
	getSubscriptionResponseFieldErrors       = big.NewInt(1 << 0)
	getSubscriptionResponseFieldSubscription = big.NewInt(1 << 1)
)

type GetSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription retrieved.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetSubscriptionResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetSubscriptionResponse) GetSubscription() *Subscription {
	if g == nil {
		return nil
	}
	return g.Subscription
}

func (g *GetSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetSubscriptionResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetSubscriptionResponse) SetErrors(errors []*Error) {
	g.Errors = errors
	g.require(getSubscriptionResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetSubscriptionResponse) SetSubscription(subscription *Subscription) {
	g.Subscription = subscription
	g.require(getSubscriptionResponseFieldSubscription)
}

func (g *GetSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSubscriptionResponse) MarshalJSON() ([]byte, error) {
	type embed GetSubscriptionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GetSubscriptionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines output parameters in a response from the
// [ListSubscriptionEvents](api-endpoint:Subscriptions-ListSubscriptionEvents).
var (
	listSubscriptionEventsResponseFieldErrors             = big.NewInt(1 << 0)
	listSubscriptionEventsResponseFieldSubscriptionEvents = big.NewInt(1 << 1)
	listSubscriptionEventsResponseFieldCursor             = big.NewInt(1 << 2)
)

type ListSubscriptionEventsResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved subscription events.
	SubscriptionEvents []*SubscriptionEvent `json:"subscription_events,omitempty" url:"subscription_events,omitempty"`
	// When the total number of resulting subscription events exceeds the limit of a paged response,
	// the response includes a cursor for you to use in a subsequent request to fetch the next set of events.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListSubscriptionEventsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListSubscriptionEventsResponse) GetSubscriptionEvents() []*SubscriptionEvent {
	if l == nil {
		return nil
	}
	return l.SubscriptionEvents
}

func (l *ListSubscriptionEventsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListSubscriptionEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSubscriptionEventsResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListSubscriptionEventsResponse) SetErrors(errors []*Error) {
	l.Errors = errors
	l.require(listSubscriptionEventsResponseFieldErrors)
}

// SetSubscriptionEvents sets the SubscriptionEvents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListSubscriptionEventsResponse) SetSubscriptionEvents(subscriptionEvents []*SubscriptionEvent) {
	l.SubscriptionEvents = subscriptionEvents
	l.require(listSubscriptionEventsResponseFieldSubscriptionEvents)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListSubscriptionEventsResponse) SetCursor(cursor *string) {
	l.Cursor = cursor
	l.require(listSubscriptionEventsResponseFieldCursor)
}

func (l *ListSubscriptionEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSubscriptionEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSubscriptionEventsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSubscriptionEventsResponse) MarshalJSON() ([]byte, error) {
	type embed ListSubscriptionEventsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListSubscriptionEventsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines output parameters in a response from the
// [PauseSubscription](api-endpoint:Subscriptions-PauseSubscription) endpoint.
var (
	pauseSubscriptionResponseFieldErrors       = big.NewInt(1 << 0)
	pauseSubscriptionResponseFieldSubscription = big.NewInt(1 << 1)
	pauseSubscriptionResponseFieldActions      = big.NewInt(1 << 2)
)

type PauseSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription to be paused by the scheduled `PAUSE` action.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// The list of a `PAUSE` action and a possible `RESUME` action created by the request.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PauseSubscriptionResponse) GetErrors() []*Error {
	if p == nil {
		return nil
	}
	return p.Errors
}

func (p *PauseSubscriptionResponse) GetSubscription() *Subscription {
	if p == nil {
		return nil
	}
	return p.Subscription
}

func (p *PauseSubscriptionResponse) GetActions() []*SubscriptionAction {
	if p == nil {
		return nil
	}
	return p.Actions
}

func (p *PauseSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PauseSubscriptionResponse) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionResponse) SetErrors(errors []*Error) {
	p.Errors = errors
	p.require(pauseSubscriptionResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionResponse) SetSubscription(subscription *Subscription) {
	p.Subscription = subscription
	p.require(pauseSubscriptionResponseFieldSubscription)
}

// SetActions sets the Actions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PauseSubscriptionResponse) SetActions(actions []*SubscriptionAction) {
	p.Actions = actions
	p.require(pauseSubscriptionResponseFieldActions)
}

func (p *PauseSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PauseSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PauseSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PauseSubscriptionResponse) MarshalJSON() ([]byte, error) {
	type embed PauseSubscriptionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PauseSubscriptionResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a phase, which can override subscription phases as defined by plan_id
var (
	phaseFieldUID             = big.NewInt(1 << 0)
	phaseFieldOrdinal         = big.NewInt(1 << 1)
	phaseFieldOrderTemplateID = big.NewInt(1 << 2)
	phaseFieldPlanPhaseUID    = big.NewInt(1 << 3)
)

type Phase struct {
	// id of subscription phase
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// index of phase in total subscription plan
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// id of order to be used in billing
	OrderTemplateID *string `json:"order_template_id,omitempty" url:"order_template_id,omitempty"`
	// the uid from the plan's phase in catalog
	PlanPhaseUID *string `json:"plan_phase_uid,omitempty" url:"plan_phase_uid,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Phase) GetUID() *string {
	if p == nil {
		return nil
	}
	return p.UID
}

func (p *Phase) GetOrdinal() *int64 {
	if p == nil {
		return nil
	}
	return p.Ordinal
}

func (p *Phase) GetOrderTemplateID() *string {
	if p == nil {
		return nil
	}
	return p.OrderTemplateID
}

func (p *Phase) GetPlanPhaseUID() *string {
	if p == nil {
		return nil
	}
	return p.PlanPhaseUID
}

func (p *Phase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Phase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetUID sets the UID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Phase) SetUID(uid *string) {
	p.UID = uid
	p.require(phaseFieldUID)
}

// SetOrdinal sets the Ordinal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Phase) SetOrdinal(ordinal *int64) {
	p.Ordinal = ordinal
	p.require(phaseFieldOrdinal)
}

// SetOrderTemplateID sets the OrderTemplateID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Phase) SetOrderTemplateID(orderTemplateID *string) {
	p.OrderTemplateID = orderTemplateID
	p.require(phaseFieldOrderTemplateID)
}

// SetPlanPhaseUID sets the PlanPhaseUID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Phase) SetPlanPhaseUID(planPhaseUID *string) {
	p.PlanPhaseUID = planPhaseUID
	p.require(phaseFieldPlanPhaseUID)
}

func (p *Phase) UnmarshalJSON(data []byte) error {
	type unmarshaler Phase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Phase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Phase) MarshalJSON() ([]byte, error) {
	type embed Phase
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Phase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the arguments used to construct a new phase.
var (
	phaseInputFieldOrdinal         = big.NewInt(1 << 0)
	phaseInputFieldOrderTemplateID = big.NewInt(1 << 1)
)

type PhaseInput struct {
	// index of phase in total subscription plan
	Ordinal int64 `json:"ordinal" url:"ordinal"`
	// id of order to be used in billing
	OrderTemplateID *string `json:"order_template_id,omitempty" url:"order_template_id,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhaseInput) GetOrdinal() int64 {
	if p == nil {
		return 0
	}
	return p.Ordinal
}

func (p *PhaseInput) GetOrderTemplateID() *string {
	if p == nil {
		return nil
	}
	return p.OrderTemplateID
}

func (p *PhaseInput) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhaseInput) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOrdinal sets the Ordinal field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PhaseInput) SetOrdinal(ordinal int64) {
	p.Ordinal = ordinal
	p.require(phaseInputFieldOrdinal)
}

// SetOrderTemplateID sets the OrderTemplateID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PhaseInput) SetOrderTemplateID(orderTemplateID *string) {
	p.OrderTemplateID = orderTemplateID
	p.require(phaseInputFieldOrderTemplateID)
}

func (p *PhaseInput) UnmarshalJSON(data []byte) error {
	type unmarshaler PhaseInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhaseInput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhaseInput) MarshalJSON() ([]byte, error) {
	type embed PhaseInput
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PhaseInput) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Defines output parameters in a response from the
// [ResumeSubscription](api-endpoint:Subscriptions-ResumeSubscription) endpoint.
var (
	resumeSubscriptionResponseFieldErrors       = big.NewInt(1 << 0)
	resumeSubscriptionResponseFieldSubscription = big.NewInt(1 << 1)
	resumeSubscriptionResponseFieldActions      = big.NewInt(1 << 2)
)

type ResumeSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resumed subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of `RESUME` actions created by the request and scheduled for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResumeSubscriptionResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *ResumeSubscriptionResponse) GetSubscription() *Subscription {
	if r == nil {
		return nil
	}
	return r.Subscription
}

func (r *ResumeSubscriptionResponse) GetActions() []*SubscriptionAction {
	if r == nil {
		return nil
	}
	return r.Actions
}

func (r *ResumeSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResumeSubscriptionResponse) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResumeSubscriptionResponse) SetErrors(errors []*Error) {
	r.Errors = errors
	r.require(resumeSubscriptionResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResumeSubscriptionResponse) SetSubscription(subscription *Subscription) {
	r.Subscription = subscription
	r.require(resumeSubscriptionResponseFieldSubscription)
}

// SetActions sets the Actions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResumeSubscriptionResponse) SetActions(actions []*SubscriptionAction) {
	r.Actions = actions
	r.require(resumeSubscriptionResponseFieldActions)
}

func (r *ResumeSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResumeSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResumeSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResumeSubscriptionResponse) MarshalJSON() ([]byte, error) {
	type embed ResumeSubscriptionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResumeSubscriptionResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a set of query expressions (filters) to narrow the scope of targeted subscriptions returned by
// the [SearchSubscriptions](api-endpoint:Subscriptions-SearchSubscriptions) endpoint.
var (
	searchSubscriptionsFilterFieldCustomerIDs = big.NewInt(1 << 0)
	searchSubscriptionsFilterFieldLocationIDs = big.NewInt(1 << 1)
	searchSubscriptionsFilterFieldSourceNames = big.NewInt(1 << 2)
)

type SearchSubscriptionsFilter struct {
	// A filter to select subscriptions based on the subscribing customer IDs.
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`
	// A filter to select subscriptions based on the location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// A filter to select subscriptions based on the source application.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSubscriptionsFilter) GetCustomerIDs() []string {
	if s == nil {
		return nil
	}
	return s.CustomerIDs
}

func (s *SearchSubscriptionsFilter) GetLocationIDs() []string {
	if s == nil {
		return nil
	}
	return s.LocationIDs
}

func (s *SearchSubscriptionsFilter) GetSourceNames() []string {
	if s == nil {
		return nil
	}
	return s.SourceNames
}

func (s *SearchSubscriptionsFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsFilter) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetCustomerIDs sets the CustomerIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsFilter) SetCustomerIDs(customerIDs []string) {
	s.CustomerIDs = customerIDs
	s.require(searchSubscriptionsFilterFieldCustomerIDs)
}

// SetLocationIDs sets the LocationIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsFilter) SetLocationIDs(locationIDs []string) {
	s.LocationIDs = locationIDs
	s.require(searchSubscriptionsFilterFieldLocationIDs)
}

// SetSourceNames sets the SourceNames field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsFilter) SetSourceNames(sourceNames []string) {
	s.SourceNames = sourceNames
	s.require(searchSubscriptionsFilterFieldSourceNames)
}

func (s *SearchSubscriptionsFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsFilter) MarshalJSON() ([]byte, error) {
	type embed SearchSubscriptionsFilter
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SearchSubscriptionsFilter) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a query, consisting of specified query expressions, used to search for subscriptions.
var (
	searchSubscriptionsQueryFieldFilter = big.NewInt(1 << 0)
)

type SearchSubscriptionsQuery struct {
	// A list of query expressions.
	Filter *SearchSubscriptionsFilter `json:"filter,omitempty" url:"filter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSubscriptionsQuery) GetFilter() *SearchSubscriptionsFilter {
	if s == nil {
		return nil
	}
	return s.Filter
}

func (s *SearchSubscriptionsQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsQuery) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsQuery) SetFilter(filter *SearchSubscriptionsFilter) {
	s.Filter = filter
	s.require(searchSubscriptionsQueryFieldFilter)
}

func (s *SearchSubscriptionsQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsQuery) MarshalJSON() ([]byte, error) {
	type embed SearchSubscriptionsQuery
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SearchSubscriptionsQuery) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines output parameters in a response from the
// [SearchSubscriptions](api-endpoint:Subscriptions-SearchSubscriptions) endpoint.
var (
	searchSubscriptionsResponseFieldErrors        = big.NewInt(1 << 0)
	searchSubscriptionsResponseFieldSubscriptions = big.NewInt(1 << 1)
	searchSubscriptionsResponseFieldCursor        = big.NewInt(1 << 2)
)

type SearchSubscriptionsResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscriptions matching the specified query expressions.
	Subscriptions []*Subscription `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	// When the total number of resulting subscription exceeds the limit of a paged response,
	// the response includes a cursor for you to use in a subsequent request to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSubscriptionsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchSubscriptionsResponse) GetSubscriptions() []*Subscription {
	if s == nil {
		return nil
	}
	return s.Subscriptions
}

func (s *SearchSubscriptionsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchSubscriptionsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsResponse) SetErrors(errors []*Error) {
	s.Errors = errors
	s.require(searchSubscriptionsResponseFieldErrors)
}

// SetSubscriptions sets the Subscriptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsResponse) SetSubscriptions(subscriptions []*Subscription) {
	s.Subscriptions = subscriptions
	s.require(searchSubscriptionsResponseFieldSubscriptions)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SearchSubscriptionsResponse) SetCursor(cursor *string) {
	s.Cursor = cursor
	s.require(searchSubscriptionsResponseFieldCursor)
}

func (s *SearchSubscriptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsResponse) MarshalJSON() ([]byte, error) {
	type embed SearchSubscriptionsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SearchSubscriptionsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a subscription purchased by a customer.
//
// For more information, see
// [Manage Subscriptions](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions).
var (
	subscriptionFieldID                       = big.NewInt(1 << 0)
	subscriptionFieldLocationID               = big.NewInt(1 << 1)
	subscriptionFieldPlanVariationID          = big.NewInt(1 << 2)
	subscriptionFieldCustomerID               = big.NewInt(1 << 3)
	subscriptionFieldStartDate                = big.NewInt(1 << 4)
	subscriptionFieldCanceledDate             = big.NewInt(1 << 5)
	subscriptionFieldChargedThroughDate       = big.NewInt(1 << 6)
	subscriptionFieldStatus                   = big.NewInt(1 << 7)
	subscriptionFieldTaxPercentage            = big.NewInt(1 << 8)
	subscriptionFieldInvoiceIDs               = big.NewInt(1 << 9)
	subscriptionFieldPriceOverrideMoney       = big.NewInt(1 << 10)
	subscriptionFieldVersion                  = big.NewInt(1 << 11)
	subscriptionFieldCreatedAt                = big.NewInt(1 << 12)
	subscriptionFieldCardID                   = big.NewInt(1 << 13)
	subscriptionFieldTimezone                 = big.NewInt(1 << 14)
	subscriptionFieldSource                   = big.NewInt(1 << 15)
	subscriptionFieldActions                  = big.NewInt(1 << 16)
	subscriptionFieldMonthlyBillingAnchorDate = big.NewInt(1 << 17)
	subscriptionFieldPhases                   = big.NewInt(1 << 18)
	subscriptionFieldCompletedDate            = big.NewInt(1 << 19)
)

type Subscription struct {
	// The Square-assigned ID of the subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the location associated with the subscription.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the subscribed-to [subscription plan variation](entity:CatalogSubscriptionPlanVariation).
	PlanVariationID *string `json:"plan_variation_id,omitempty" url:"plan_variation_id,omitempty"`
	// The ID of the subscribing [customer](entity:Customer) profile.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) to start the subscription.
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) to cancel the subscription,
	// when the subscription status changes to `CANCELED` and the subscription billing stops.
	//
	// If this field is not set, the subscription ends according its subscription plan.
	//
	// This field cannot be updated, other than being cleared.
	CanceledDate *string `json:"canceled_date,omitempty" url:"canceled_date,omitempty"`
	// The `YYYY-MM-DD`-formatted date up to when the subscriber is invoiced for the
	// subscription.
	//
	// After the invoice is sent for a given billing period,
	// this date will be the last day of the billing period.
	// For example,
	// suppose for the month of May a subscriber gets an invoice
	// (or charged the card) on May 1. For the monthly billing scenario,
	// this date is then set to May 31.
	ChargedThroughDate *string `json:"charged_through_date,omitempty" url:"charged_through_date,omitempty"`
	// The current status of the subscription.
	// See [SubscriptionStatus](#type-subscriptionstatus) for possible values
	Status *SubscriptionStatus `json:"status,omitempty" url:"status,omitempty"`
	// The tax amount applied when billing the subscription. The
	// percentage is expressed in decimal form, using a `'.'` as the decimal
	// separator and without a `'%'` sign. For example, a value of `7.5`
	// corresponds to 7.5%.
	TaxPercentage *string `json:"tax_percentage,omitempty" url:"tax_percentage,omitempty"`
	// The IDs of the [invoices](entity:Invoice) created for the
	// subscription, listed in order when the invoices were created
	// (newest invoices appear first).
	InvoiceIDs []string `json:"invoice_ids,omitempty" url:"invoice_ids,omitempty"`
	// A custom price which overrides the cost of a subscription plan variation with `STATIC` pricing.
	// This field does not affect itemized subscriptions with `RELATIVE` pricing. Instead,
	// you should edit the Subscription's [order template](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#phases-and-order-templates).
	PriceOverrideMoney *Money `json:"price_override_money,omitempty" url:"price_override_money,omitempty"`
	// The version of the object. When updating an object, the version
	// supplied must match the version in the database, otherwise the write will
	// be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp when the subscription was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The ID of the [subscriber's](entity:Customer) [card](entity:Card)
	// used to charge for the subscription.
	CardID *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// Timezone that will be used in date calculations for the subscription.
	// Defaults to the timezone of the location based on `location_id`.
	// Format: the IANA Timezone Database identifier for the location timezone (for example, `America/Los_Angeles`).
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// The origination details of the subscription.
	Source *SubscriptionSource `json:"source,omitempty" url:"source,omitempty"`
	// The list of scheduled actions on this subscription. It is set only in the response from
	// [RetrieveSubscription](api-endpoint:Subscriptions-RetrieveSubscription) with the query parameter
	// of `include=actions` or from
	// [SearchSubscriptions](api-endpoint:Subscriptions-SearchSubscriptions) with the input parameter
	// of `include:["actions"]`.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`
	// The day of the month on which the subscription will issue invoices and publish orders.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// array of phases for this subscription
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`
	// The `YYYY-MM-DD`-formatted date when the subscription enters a terminal state.
	CompletedDate *string `json:"completed_date,omitempty" url:"completed_date,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Subscription) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Subscription) GetLocationID() *string {
	if s == nil {
		return nil
	}
	return s.LocationID
}

func (s *Subscription) GetPlanVariationID() *string {
	if s == nil {
		return nil
	}
	return s.PlanVariationID
}

func (s *Subscription) GetCustomerID() *string {
	if s == nil {
		return nil
	}
	return s.CustomerID
}

func (s *Subscription) GetStartDate() *string {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *Subscription) GetCanceledDate() *string {
	if s == nil {
		return nil
	}
	return s.CanceledDate
}

func (s *Subscription) GetChargedThroughDate() *string {
	if s == nil {
		return nil
	}
	return s.ChargedThroughDate
}

func (s *Subscription) GetStatus() *SubscriptionStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *Subscription) GetTaxPercentage() *string {
	if s == nil {
		return nil
	}
	return s.TaxPercentage
}

func (s *Subscription) GetInvoiceIDs() []string {
	if s == nil {
		return nil
	}
	return s.InvoiceIDs
}

func (s *Subscription) GetPriceOverrideMoney() *Money {
	if s == nil {
		return nil
	}
	return s.PriceOverrideMoney
}

func (s *Subscription) GetVersion() *int64 {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *Subscription) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *Subscription) GetCardID() *string {
	if s == nil {
		return nil
	}
	return s.CardID
}

func (s *Subscription) GetTimezone() *string {
	if s == nil {
		return nil
	}
	return s.Timezone
}

func (s *Subscription) GetSource() *SubscriptionSource {
	if s == nil {
		return nil
	}
	return s.Source
}

func (s *Subscription) GetActions() []*SubscriptionAction {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *Subscription) GetMonthlyBillingAnchorDate() *int {
	if s == nil {
		return nil
	}
	return s.MonthlyBillingAnchorDate
}

func (s *Subscription) GetPhases() []*Phase {
	if s == nil {
		return nil
	}
	return s.Phases
}

func (s *Subscription) GetCompletedDate() *string {
	if s == nil {
		return nil
	}
	return s.CompletedDate
}

func (s *Subscription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subscription) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetID(id *string) {
	s.ID = id
	s.require(subscriptionFieldID)
}

// SetLocationID sets the LocationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetLocationID(locationID *string) {
	s.LocationID = locationID
	s.require(subscriptionFieldLocationID)
}

// SetPlanVariationID sets the PlanVariationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetPlanVariationID(planVariationID *string) {
	s.PlanVariationID = planVariationID
	s.require(subscriptionFieldPlanVariationID)
}

// SetCustomerID sets the CustomerID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCustomerID(customerID *string) {
	s.CustomerID = customerID
	s.require(subscriptionFieldCustomerID)
}

// SetStartDate sets the StartDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetStartDate(startDate *string) {
	s.StartDate = startDate
	s.require(subscriptionFieldStartDate)
}

// SetCanceledDate sets the CanceledDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCanceledDate(canceledDate *string) {
	s.CanceledDate = canceledDate
	s.require(subscriptionFieldCanceledDate)
}

// SetChargedThroughDate sets the ChargedThroughDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetChargedThroughDate(chargedThroughDate *string) {
	s.ChargedThroughDate = chargedThroughDate
	s.require(subscriptionFieldChargedThroughDate)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetStatus(status *SubscriptionStatus) {
	s.Status = status
	s.require(subscriptionFieldStatus)
}

// SetTaxPercentage sets the TaxPercentage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetTaxPercentage(taxPercentage *string) {
	s.TaxPercentage = taxPercentage
	s.require(subscriptionFieldTaxPercentage)
}

// SetInvoiceIDs sets the InvoiceIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetInvoiceIDs(invoiceIDs []string) {
	s.InvoiceIDs = invoiceIDs
	s.require(subscriptionFieldInvoiceIDs)
}

// SetPriceOverrideMoney sets the PriceOverrideMoney field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetPriceOverrideMoney(priceOverrideMoney *Money) {
	s.PriceOverrideMoney = priceOverrideMoney
	s.require(subscriptionFieldPriceOverrideMoney)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetVersion(version *int64) {
	s.Version = version
	s.require(subscriptionFieldVersion)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCreatedAt(createdAt *string) {
	s.CreatedAt = createdAt
	s.require(subscriptionFieldCreatedAt)
}

// SetCardID sets the CardID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCardID(cardID *string) {
	s.CardID = cardID
	s.require(subscriptionFieldCardID)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetTimezone(timezone *string) {
	s.Timezone = timezone
	s.require(subscriptionFieldTimezone)
}

// SetSource sets the Source field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetSource(source *SubscriptionSource) {
	s.Source = source
	s.require(subscriptionFieldSource)
}

// SetActions sets the Actions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetActions(actions []*SubscriptionAction) {
	s.Actions = actions
	s.require(subscriptionFieldActions)
}

// SetMonthlyBillingAnchorDate sets the MonthlyBillingAnchorDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetMonthlyBillingAnchorDate(monthlyBillingAnchorDate *int) {
	s.MonthlyBillingAnchorDate = monthlyBillingAnchorDate
	s.require(subscriptionFieldMonthlyBillingAnchorDate)
}

// SetPhases sets the Phases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetPhases(phases []*Phase) {
	s.Phases = phases
	s.require(subscriptionFieldPhases)
}

// SetCompletedDate sets the CompletedDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Subscription) SetCompletedDate(completedDate *string) {
	s.CompletedDate = completedDate
	s.require(subscriptionFieldCompletedDate)
}

func (s *Subscription) UnmarshalJSON(data []byte) error {
	type unmarshaler Subscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Subscription(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Subscription) MarshalJSON() ([]byte, error) {
	type embed Subscription
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Subscription) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents an action as a pending change to a subscription.
var (
	subscriptionActionFieldID                       = big.NewInt(1 << 0)
	subscriptionActionFieldType                     = big.NewInt(1 << 1)
	subscriptionActionFieldEffectiveDate            = big.NewInt(1 << 2)
	subscriptionActionFieldMonthlyBillingAnchorDate = big.NewInt(1 << 3)
	subscriptionActionFieldPhases                   = big.NewInt(1 << 4)
	subscriptionActionFieldNewPlanVariationID       = big.NewInt(1 << 5)
)

type SubscriptionAction struct {
	// The ID of an action scoped to a subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the action.
	// See [SubscriptionActionType](#type-subscriptionactiontype) for possible values
	Type *SubscriptionActionType `json:"type,omitempty" url:"type,omitempty"`
	// The `YYYY-MM-DD`-formatted date when the action occurs on the subscription.
	EffectiveDate *string `json:"effective_date,omitempty" url:"effective_date,omitempty"`
	// The new billing anchor day value, for a `CHANGE_BILLING_ANCHOR_DATE` action.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// A list of Phases, to pass phase-specific information used in the swap.
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`
	// The target subscription plan variation that a subscription switches to, for a `SWAP_PLAN` action.
	NewPlanVariationID *string `json:"new_plan_variation_id,omitempty" url:"new_plan_variation_id,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionAction) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *SubscriptionAction) GetType() *SubscriptionActionType {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SubscriptionAction) GetEffectiveDate() *string {
	if s == nil {
		return nil
	}
	return s.EffectiveDate
}

func (s *SubscriptionAction) GetMonthlyBillingAnchorDate() *int {
	if s == nil {
		return nil
	}
	return s.MonthlyBillingAnchorDate
}

func (s *SubscriptionAction) GetPhases() []*Phase {
	if s == nil {
		return nil
	}
	return s.Phases
}

func (s *SubscriptionAction) GetNewPlanVariationID() *string {
	if s == nil {
		return nil
	}
	return s.NewPlanVariationID
}

func (s *SubscriptionAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionAction) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionAction) SetID(id *string) {
	s.ID = id
	s.require(subscriptionActionFieldID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionAction) SetType(type_ *SubscriptionActionType) {
	s.Type = type_
	s.require(subscriptionActionFieldType)
}

// SetEffectiveDate sets the EffectiveDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionAction) SetEffectiveDate(effectiveDate *string) {
	s.EffectiveDate = effectiveDate
	s.require(subscriptionActionFieldEffectiveDate)
}

// SetMonthlyBillingAnchorDate sets the MonthlyBillingAnchorDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionAction) SetMonthlyBillingAnchorDate(monthlyBillingAnchorDate *int) {
	s.MonthlyBillingAnchorDate = monthlyBillingAnchorDate
	s.require(subscriptionActionFieldMonthlyBillingAnchorDate)
}

// SetPhases sets the Phases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionAction) SetPhases(phases []*Phase) {
	s.Phases = phases
	s.require(subscriptionActionFieldPhases)
}

// SetNewPlanVariationID sets the NewPlanVariationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionAction) SetNewPlanVariationID(newPlanVariationID *string) {
	s.NewPlanVariationID = newPlanVariationID
	s.require(subscriptionActionFieldNewPlanVariationID)
}

func (s *SubscriptionAction) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionAction) MarshalJSON() ([]byte, error) {
	type embed SubscriptionAction
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionAction) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported types of an action as a pending change to a subscription.
type SubscriptionActionType string

const (
	SubscriptionActionTypeCancel                  SubscriptionActionType = "CANCEL"
	SubscriptionActionTypePause                   SubscriptionActionType = "PAUSE"
	SubscriptionActionTypeResume                  SubscriptionActionType = "RESUME"
	SubscriptionActionTypeSwapPlan                SubscriptionActionType = "SWAP_PLAN"
	SubscriptionActionTypeChangeBillingAnchorDate SubscriptionActionType = "CHANGE_BILLING_ANCHOR_DATE"
	SubscriptionActionTypeComplete                SubscriptionActionType = "COMPLETE"
)

func NewSubscriptionActionTypeFromString(s string) (SubscriptionActionType, error) {
	switch s {
	case "CANCEL":
		return SubscriptionActionTypeCancel, nil
	case "PAUSE":
		return SubscriptionActionTypePause, nil
	case "RESUME":
		return SubscriptionActionTypeResume, nil
	case "SWAP_PLAN":
		return SubscriptionActionTypeSwapPlan, nil
	case "CHANGE_BILLING_ANCHOR_DATE":
		return SubscriptionActionTypeChangeBillingAnchorDate, nil
	case "COMPLETE":
		return SubscriptionActionTypeComplete, nil
	}
	var t SubscriptionActionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionActionType) Ptr() *SubscriptionActionType {
	return &s
}

// Describes changes to a subscription and the subscription status.
var (
	subscriptionEventFieldID                       = big.NewInt(1 << 0)
	subscriptionEventFieldSubscriptionEventType    = big.NewInt(1 << 1)
	subscriptionEventFieldEffectiveDate            = big.NewInt(1 << 2)
	subscriptionEventFieldMonthlyBillingAnchorDate = big.NewInt(1 << 3)
	subscriptionEventFieldInfo                     = big.NewInt(1 << 4)
	subscriptionEventFieldPhases                   = big.NewInt(1 << 5)
	subscriptionEventFieldPlanVariationID          = big.NewInt(1 << 6)
)

type SubscriptionEvent struct {
	// The ID of the subscription event.
	ID string `json:"id" url:"id"`
	// Type of the subscription event.
	// See [SubscriptionEventSubscriptionEventType](#type-subscriptioneventsubscriptioneventtype) for possible values
	SubscriptionEventType SubscriptionEventSubscriptionEventType `json:"subscription_event_type" url:"subscription_event_type"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) when the subscription event occurred.
	EffectiveDate string `json:"effective_date" url:"effective_date"`
	// The day-of-the-month the billing anchor date was changed to, if applicable.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// Additional information about the subscription event.
	Info *SubscriptionEventInfo `json:"info,omitempty" url:"info,omitempty"`
	// A list of Phases, to pass phase-specific information used in the swap.
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`
	// The ID of the subscription plan variation associated with the subscription.
	PlanVariationID string `json:"plan_variation_id" url:"plan_variation_id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionEvent) GetID() string {
	if s == nil {
		return ""
	}
	return s.ID
}

func (s *SubscriptionEvent) GetSubscriptionEventType() SubscriptionEventSubscriptionEventType {
	if s == nil {
		return ""
	}
	return s.SubscriptionEventType
}

func (s *SubscriptionEvent) GetEffectiveDate() string {
	if s == nil {
		return ""
	}
	return s.EffectiveDate
}

func (s *SubscriptionEvent) GetMonthlyBillingAnchorDate() *int {
	if s == nil {
		return nil
	}
	return s.MonthlyBillingAnchorDate
}

func (s *SubscriptionEvent) GetInfo() *SubscriptionEventInfo {
	if s == nil {
		return nil
	}
	return s.Info
}

func (s *SubscriptionEvent) GetPhases() []*Phase {
	if s == nil {
		return nil
	}
	return s.Phases
}

func (s *SubscriptionEvent) GetPlanVariationID() string {
	if s == nil {
		return ""
	}
	return s.PlanVariationID
}

func (s *SubscriptionEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEvent) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEvent) SetID(id string) {
	s.ID = id
	s.require(subscriptionEventFieldID)
}

// SetSubscriptionEventType sets the SubscriptionEventType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEvent) SetSubscriptionEventType(subscriptionEventType SubscriptionEventSubscriptionEventType) {
	s.SubscriptionEventType = subscriptionEventType
	s.require(subscriptionEventFieldSubscriptionEventType)
}

// SetEffectiveDate sets the EffectiveDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEvent) SetEffectiveDate(effectiveDate string) {
	s.EffectiveDate = effectiveDate
	s.require(subscriptionEventFieldEffectiveDate)
}

// SetMonthlyBillingAnchorDate sets the MonthlyBillingAnchorDate field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEvent) SetMonthlyBillingAnchorDate(monthlyBillingAnchorDate *int) {
	s.MonthlyBillingAnchorDate = monthlyBillingAnchorDate
	s.require(subscriptionEventFieldMonthlyBillingAnchorDate)
}

// SetInfo sets the Info field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEvent) SetInfo(info *SubscriptionEventInfo) {
	s.Info = info
	s.require(subscriptionEventFieldInfo)
}

// SetPhases sets the Phases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEvent) SetPhases(phases []*Phase) {
	s.Phases = phases
	s.require(subscriptionEventFieldPhases)
}

// SetPlanVariationID sets the PlanVariationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEvent) SetPlanVariationID(planVariationID string) {
	s.PlanVariationID = planVariationID
	s.require(subscriptionEventFieldPlanVariationID)
}

func (s *SubscriptionEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEvent) MarshalJSON() ([]byte, error) {
	type embed SubscriptionEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionEvent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Provides information about the subscription event.
var (
	subscriptionEventInfoFieldDetail = big.NewInt(1 << 0)
	subscriptionEventInfoFieldCode   = big.NewInt(1 << 1)
)

type SubscriptionEventInfo struct {
	// A human-readable explanation for the event.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// An info code indicating the subscription event that occurred.
	// See [InfoCode](#type-infocode) for possible values
	Code *SubscriptionEventInfoCode `json:"code,omitempty" url:"code,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionEventInfo) GetDetail() *string {
	if s == nil {
		return nil
	}
	return s.Detail
}

func (s *SubscriptionEventInfo) GetCode() *SubscriptionEventInfoCode {
	if s == nil {
		return nil
	}
	return s.Code
}

func (s *SubscriptionEventInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEventInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetDetail sets the Detail field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEventInfo) SetDetail(detail *string) {
	s.Detail = detail
	s.require(subscriptionEventInfoFieldDetail)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionEventInfo) SetCode(code *SubscriptionEventInfoCode) {
	s.Code = code
	s.require(subscriptionEventInfoFieldCode)
}

func (s *SubscriptionEventInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEventInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEventInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEventInfo) MarshalJSON() ([]byte, error) {
	type embed SubscriptionEventInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionEventInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported info codes of a subscription event.
type SubscriptionEventInfoCode string

const (
	SubscriptionEventInfoCodeLocationNotActive           SubscriptionEventInfoCode = "LOCATION_NOT_ACTIVE"
	SubscriptionEventInfoCodeLocationCannotAcceptPayment SubscriptionEventInfoCode = "LOCATION_CANNOT_ACCEPT_PAYMENT"
	SubscriptionEventInfoCodeCustomerDeleted             SubscriptionEventInfoCode = "CUSTOMER_DELETED"
	SubscriptionEventInfoCodeCustomerNoEmail             SubscriptionEventInfoCode = "CUSTOMER_NO_EMAIL"
	SubscriptionEventInfoCodeCustomerNoName              SubscriptionEventInfoCode = "CUSTOMER_NO_NAME"
	SubscriptionEventInfoCodeUserProvided                SubscriptionEventInfoCode = "USER_PROVIDED"
)

func NewSubscriptionEventInfoCodeFromString(s string) (SubscriptionEventInfoCode, error) {
	switch s {
	case "LOCATION_NOT_ACTIVE":
		return SubscriptionEventInfoCodeLocationNotActive, nil
	case "LOCATION_CANNOT_ACCEPT_PAYMENT":
		return SubscriptionEventInfoCodeLocationCannotAcceptPayment, nil
	case "CUSTOMER_DELETED":
		return SubscriptionEventInfoCodeCustomerDeleted, nil
	case "CUSTOMER_NO_EMAIL":
		return SubscriptionEventInfoCodeCustomerNoEmail, nil
	case "CUSTOMER_NO_NAME":
		return SubscriptionEventInfoCodeCustomerNoName, nil
	case "USER_PROVIDED":
		return SubscriptionEventInfoCodeUserProvided, nil
	}
	var t SubscriptionEventInfoCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventInfoCode) Ptr() *SubscriptionEventInfoCode {
	return &s
}

// Supported types of an event occurred to a subscription.
type SubscriptionEventSubscriptionEventType string

const (
	SubscriptionEventSubscriptionEventTypeStartSubscription        SubscriptionEventSubscriptionEventType = "START_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePlanChange               SubscriptionEventSubscriptionEventType = "PLAN_CHANGE"
	SubscriptionEventSubscriptionEventTypeStopSubscription         SubscriptionEventSubscriptionEventType = "STOP_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeDeactivateSubscription   SubscriptionEventSubscriptionEventType = "DEACTIVATE_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeResumeSubscription       SubscriptionEventSubscriptionEventType = "RESUME_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePauseSubscription        SubscriptionEventSubscriptionEventType = "PAUSE_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeBillingAnchorDateChanged SubscriptionEventSubscriptionEventType = "BILLING_ANCHOR_DATE_CHANGED"
)

func NewSubscriptionEventSubscriptionEventTypeFromString(s string) (SubscriptionEventSubscriptionEventType, error) {
	switch s {
	case "START_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStartSubscription, nil
	case "PLAN_CHANGE":
		return SubscriptionEventSubscriptionEventTypePlanChange, nil
	case "STOP_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStopSubscription, nil
	case "DEACTIVATE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeDeactivateSubscription, nil
	case "RESUME_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeResumeSubscription, nil
	case "PAUSE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypePauseSubscription, nil
	case "BILLING_ANCHOR_DATE_CHANGED":
		return SubscriptionEventSubscriptionEventTypeBillingAnchorDateChanged, nil
	}
	var t SubscriptionEventSubscriptionEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventSubscriptionEventType) Ptr() *SubscriptionEventSubscriptionEventType {
	return &s
}

// The origination details of the subscription.
var (
	subscriptionSourceFieldName = big.NewInt(1 << 0)
)

type SubscriptionSource struct {
	// The name used to identify the place (physical or digital) that
	// a subscription originates. If unset, the name defaults to the name
	// of the application that created the subscription.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionSource) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SubscriptionSource) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionSource) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubscriptionSource) SetName(name *string) {
	s.Name = name
	s.require(subscriptionSourceFieldName)
}

func (s *SubscriptionSource) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionSource) MarshalJSON() ([]byte, error) {
	type embed SubscriptionSource
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubscriptionSource) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported subscription statuses.
type SubscriptionStatus string

const (
	SubscriptionStatusPending     SubscriptionStatus = "PENDING"
	SubscriptionStatusActive      SubscriptionStatus = "ACTIVE"
	SubscriptionStatusCanceled    SubscriptionStatus = "CANCELED"
	SubscriptionStatusDeactivated SubscriptionStatus = "DEACTIVATED"
	SubscriptionStatusPaused      SubscriptionStatus = "PAUSED"
	SubscriptionStatusCompleted   SubscriptionStatus = "COMPLETED"
)

func NewSubscriptionStatusFromString(s string) (SubscriptionStatus, error) {
	switch s {
	case "PENDING":
		return SubscriptionStatusPending, nil
	case "ACTIVE":
		return SubscriptionStatusActive, nil
	case "CANCELED":
		return SubscriptionStatusCanceled, nil
	case "DEACTIVATED":
		return SubscriptionStatusDeactivated, nil
	case "PAUSED":
		return SubscriptionStatusPaused, nil
	case "COMPLETED":
		return SubscriptionStatusCompleted, nil
	}
	var t SubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStatus) Ptr() *SubscriptionStatus {
	return &s
}

// Defines output parameters in a response of the
// [SwapPlan](api-endpoint:Subscriptions-SwapPlan) endpoint.
var (
	swapPlanResponseFieldErrors       = big.NewInt(1 << 0)
	swapPlanResponseFieldSubscription = big.NewInt(1 << 1)
	swapPlanResponseFieldActions      = big.NewInt(1 << 2)
)

type SwapPlanResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription with the updated subscription plan.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a `SWAP_PLAN` action created by the request.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SwapPlanResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SwapPlanResponse) GetSubscription() *Subscription {
	if s == nil {
		return nil
	}
	return s.Subscription
}

func (s *SwapPlanResponse) GetActions() []*SubscriptionAction {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *SwapPlanResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SwapPlanResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwapPlanResponse) SetErrors(errors []*Error) {
	s.Errors = errors
	s.require(swapPlanResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwapPlanResponse) SetSubscription(subscription *Subscription) {
	s.Subscription = subscription
	s.require(swapPlanResponseFieldSubscription)
}

// SetActions sets the Actions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SwapPlanResponse) SetActions(actions []*SubscriptionAction) {
	s.Actions = actions
	s.require(swapPlanResponseFieldActions)
}

func (s *SwapPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SwapPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SwapPlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SwapPlanResponse) MarshalJSON() ([]byte, error) {
	type embed SwapPlanResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SwapPlanResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines output parameters in a response from the
// [UpdateSubscription](api-endpoint:Subscriptions-UpdateSubscription) endpoint.
var (
	updateSubscriptionResponseFieldErrors       = big.NewInt(1 << 0)
	updateSubscriptionResponseFieldSubscription = big.NewInt(1 << 1)
)

type UpdateSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSubscriptionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateSubscriptionResponse) GetSubscription() *Subscription {
	if u == nil {
		return nil
	}
	return u.Subscription
}

func (u *UpdateSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSubscriptionResponse) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSubscriptionResponse) SetErrors(errors []*Error) {
	u.Errors = errors
	u.require(updateSubscriptionResponseFieldErrors)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSubscriptionResponse) SetSubscription(subscription *Subscription) {
	u.Subscription = subscription
	u.require(updateSubscriptionResponseFieldSubscription)
}

func (u *UpdateSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSubscriptionResponse) MarshalJSON() ([]byte, error) {
	type embed UpdateSubscriptionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateSubscriptionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	updateSubscriptionRequestFieldSubscriptionID = big.NewInt(1 << 0)
	updateSubscriptionRequestFieldSubscription   = big.NewInt(1 << 1)
)

type UpdateSubscriptionRequest struct {
	// The ID of the subscription to update.
	SubscriptionID string `json:"-" url:"-"`
	// The subscription object containing the current version, and fields to update.
	// Unset fields will be left at their current server values, and JSON `null` values will
	// be treated as a request to clear the relevant data.
	Subscription *Subscription `json:"subscription,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (u *UpdateSubscriptionRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetSubscriptionID sets the SubscriptionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSubscriptionRequest) SetSubscriptionID(subscriptionID string) {
	u.SubscriptionID = subscriptionID
	u.require(updateSubscriptionRequestFieldSubscriptionID)
}

// SetSubscription sets the Subscription field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateSubscriptionRequest) SetSubscription(subscription *Subscription) {
	u.Subscription = subscription
	u.require(updateSubscriptionRequestFieldSubscription)
}
