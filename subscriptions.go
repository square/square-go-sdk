// This file was auto-generated by Fern from our API Definition.

package square

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/square/square-go-sdk/internal"
)

type BulkSwapPlanRequest struct {
	// The ID of the new subscription plan variation.
	//
	// This field is required.
	NewPlanVariationID string `json:"new_plan_variation_id" url:"-"`
	// The ID of the plan variation whose subscriptions should be swapped. Active subscriptions
	// using this plan variation will be subscribed to the new plan variation on their next billing
	// day.
	OldPlanVariationID string `json:"old_plan_variation_id" url:"-"`
	// The ID of the location to associate with the swapped subscriptions.
	LocationID string `json:"location_id" url:"-"`
}

type ChangeBillingAnchorDateRequest struct {
	// The ID of the subscription to update the billing anchor date.
	SubscriptionID string `json:"-" url:"-"`
	// The anchor day for the billing cycle.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the scheduled `BILLING_ANCHOR_CHANGE` action takes
	// place on the subscription.
	//
	// When this date is unspecified or falls within the current billing cycle, the billing anchor date
	// is changed immediately.
	EffectiveDate *string `json:"effective_date,omitempty" url:"-"`
}

type SubscriptionsDeleteActionRequest struct {
	// The ID of the subscription the targeted action is to act upon.
	SubscriptionID string `json:"-" url:"-"`
	// The ID of the targeted action to be deleted.
	ActionID string `json:"-" url:"-"`
}

type SwapPlanRequest struct {
	// The ID of the subscription to swap the subscription plan for.
	SubscriptionID string `json:"-" url:"-"`
	// The ID of the new subscription plan.
	//
	// Retired in favour of `new_plan_variation_id`.
	NewPlanID *string `json:"new_plan_id,omitempty" url:"-"`
	// The ID of the new subscription plan variation.
	//
	// This field is required.
	NewPlanVariationID *string `json:"new_plan_variation_id,omitempty" url:"-"`
	// A list of PhaseInputs, to pass phase-specific information used in the swap.
	Phases []*PhaseInput `json:"phases,omitempty" url:"-"`
}

type SubscriptionsCancelRequest struct {
	// The ID of the subscription to cancel.
	SubscriptionID string `json:"-" url:"-"`
}

type CreateSubscriptionRequest struct {
	// A unique string that identifies this `CreateSubscription` request.
	// If you do not provide a unique string (or provide an empty string as the value),
	// the endpoint treats each request as independent.
	//
	// For more information, see [Idempotency keys](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"-"`
	// The ID of the location the subscription is associated with.
	LocationID string `json:"location_id" url:"-"`
	// The ID of the [subscription plan](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations) created using the Catalog API.
	//
	// Retired in favour of `plan_variation_id`.
	//
	// For more information, see
	// [Set Up and Manage a Subscription Plan](https://developer.squareup.com/docs/subscriptions-api/setup-plan) and
	// [Subscriptions Walkthrough](https://developer.squareup.com/docs/subscriptions-api/walkthrough).
	PlanID *string `json:"plan_id,omitempty" url:"-"`
	// The ID of the [subscription plan variation](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations#plan-variations) created using the Catalog API.
	PlanVariationID *string `json:"plan_variation_id,omitempty" url:"-"`
	// The ID of the [customer](entity:Customer) subscribing to the subscription plan variation.
	CustomerID string `json:"customer_id" url:"-"`
	// The `YYYY-MM-DD`-formatted date to start the subscription.
	// If it is unspecified, the subscription starts immediately.
	StartDate *string `json:"start_date,omitempty" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the newly created subscription is scheduled for cancellation.
	//
	// This date overrides the cancellation date set in the plan variation configuration.
	// If the cancellation date is earlier than the end date of a subscription cycle, the subscription stops
	// at the canceled date and the subscriber is sent a prorated invoice at the beginning of the canceled cycle.
	//
	// When the subscription plan of the newly created subscription has a fixed number of cycles and the `canceled_date`
	// occurs before the subscription plan expires, the specified `canceled_date` sets the date when the subscription
	// stops through the end of the last cycle.
	CanceledDate *string `json:"canceled_date,omitempty" url:"-"`
	// The tax to add when billing the subscription.
	// The percentage is expressed in decimal form, using a `'.'` as the decimal
	// separator and without a `'%'` sign. For example, a value of 7.5
	// corresponds to 7.5%.
	TaxPercentage *string `json:"tax_percentage,omitempty" url:"-"`
	// A custom price which overrides the cost of a subscription plan variation with `STATIC` pricing.
	// This field does not affect itemized subscriptions with `RELATIVE` pricing. Instead,
	// you should edit the Subscription's [order template](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#phases-and-order-templates).
	PriceOverrideMoney *Money `json:"price_override_money,omitempty" url:"-"`
	// The ID of the [subscriber's](entity:Customer) [card](entity:Card) to charge.
	// If it is not specified, the subscriber receives an invoice via email with a link to pay for their subscription.
	CardID *string `json:"card_id,omitempty" url:"-"`
	// The timezone that is used in date calculations for the subscription. If unset, defaults to
	// the location timezone. If a timezone is not configured for the location, defaults to "America/New_York".
	// Format: the IANA Timezone Database identifier for the location timezone. For
	// a list of time zones, see [List of tz database time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
	Timezone *string `json:"timezone,omitempty" url:"-"`
	// The origination details of the subscription.
	Source *SubscriptionSource `json:"source,omitempty" url:"-"`
	// The day-of-the-month to change the billing date to.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"-"`
	// array of phases for this subscription
	Phases []*Phase `json:"phases,omitempty" url:"-"`
}

type SubscriptionsGetRequest struct {
	// The ID of the subscription to retrieve.
	SubscriptionID string `json:"-" url:"-"`
	// A query parameter to specify related information to be included in the response.
	//
	// The supported query parameter values are:
	//
	// - `actions`: to include scheduled actions on the targeted subscription.
	Include *string `json:"-" url:"include,omitempty"`
}

type SubscriptionsListEventsRequest struct {
	// The ID of the subscription to retrieve the events for.
	SubscriptionID string `json:"-" url:"-"`
	// When the total number of resulting subscription events exceeds the limit of a paged response,
	// specify the cursor returned from a preceding response here to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// The upper limit on the number of subscription events to return
	// in a paged response.
	Limit *int `json:"-" url:"limit,omitempty"`
}

type PauseSubscriptionRequest struct {
	// The ID of the subscription to pause.
	SubscriptionID string `json:"-" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the scheduled `PAUSE` action takes place on the subscription.
	//
	// When this date is unspecified or falls within the current billing cycle, the subscription is paused
	// on the starting date of the next billing cycle.
	PauseEffectiveDate *string `json:"pause_effective_date,omitempty" url:"-"`
	// The number of billing cycles the subscription will be paused before it is reactivated.
	//
	// When this is set, a `RESUME` action is also scheduled to take place on the subscription at
	// the end of the specified pause cycle duration. In this case, neither `resume_effective_date`
	// nor `resume_change_timing` may be specified.
	PauseCycleDuration *int64 `json:"pause_cycle_duration,omitempty" url:"-"`
	// The date when the subscription is reactivated by a scheduled `RESUME` action.
	// This date must be at least one billing cycle ahead of `pause_effective_date`.
	ResumeEffectiveDate *string `json:"resume_effective_date,omitempty" url:"-"`
	// The timing whether the subscription is reactivated immediately or at the end of the billing cycle, relative to
	// `resume_effective_date`.
	// See [ChangeTiming](#type-changetiming) for possible values
	ResumeChangeTiming *ChangeTiming `json:"resume_change_timing,omitempty" url:"-"`
	// The user-provided reason to pause the subscription.
	PauseReason *string `json:"pause_reason,omitempty" url:"-"`
}

type ResumeSubscriptionRequest struct {
	// The ID of the subscription to resume.
	SubscriptionID string `json:"-" url:"-"`
	// The `YYYY-MM-DD`-formatted date when the subscription reactivated.
	ResumeEffectiveDate *string `json:"resume_effective_date,omitempty" url:"-"`
	// The timing to resume a subscription, relative to the specified
	// `resume_effective_date` attribute value.
	// See [ChangeTiming](#type-changetiming) for possible values
	ResumeChangeTiming *ChangeTiming `json:"resume_change_timing,omitempty" url:"-"`
}

type SearchSubscriptionsRequest struct {
	// When the total number of resulting subscriptions exceeds the limit of a paged response,
	// specify the cursor returned from a preceding response here to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"-"`
	// The upper limit on the number of subscriptions to return
	// in a paged response.
	Limit *int `json:"limit,omitempty" url:"-"`
	// A subscription query consisting of specified filtering conditions.
	//
	// If this `query` field is unspecified, the `SearchSubscriptions` call will return all subscriptions.
	Query *SearchSubscriptionsQuery `json:"query,omitempty" url:"-"`
	// An option to include related information in the response.
	//
	// The supported values are:
	//
	// - `actions`: to include scheduled actions on the targeted subscriptions.
	Include []string `json:"include,omitempty" url:"-"`
}

// Defines output parameters in a response of the
// [BulkSwapPlan](api-endpoint:Subscriptions-BulkSwapPlan) endpoint.
type BulkSwapPlanResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The number of affected subscriptions.
	AffectedSubscriptions *int `json:"affected_subscriptions,omitempty" url:"affected_subscriptions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkSwapPlanResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkSwapPlanResponse) GetAffectedSubscriptions() *int {
	if b == nil {
		return nil
	}
	return b.AffectedSubscriptions
}

func (b *BulkSwapPlanResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkSwapPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkSwapPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkSwapPlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSwapPlanResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines output parameters in a response from the
// [CancelSubscription](api-endpoint:Subscriptions-CancelSubscription) endpoint.
type CancelSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The specified subscription scheduled for cancellation according to the action created by the request.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a single `CANCEL` action scheduled for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelSubscriptionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CancelSubscriptionResponse) GetSubscription() *Subscription {
	if c == nil {
		return nil
	}
	return c.Subscription
}

func (c *CancelSubscriptionResponse) GetActions() []*SubscriptionAction {
	if c == nil {
		return nil
	}
	return c.Actions
}

func (c *CancelSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelSubscriptionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines output parameters in a request to the
// [ChangeBillingAnchorDate](api-endpoint:Subscriptions-ChangeBillingAnchorDate) endpoint.
type ChangeBillingAnchorDateResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The specified subscription for updating billing anchor date.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a single billing anchor date change for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChangeBillingAnchorDateResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *ChangeBillingAnchorDateResponse) GetSubscription() *Subscription {
	if c == nil {
		return nil
	}
	return c.Subscription
}

func (c *ChangeBillingAnchorDateResponse) GetActions() []*SubscriptionAction {
	if c == nil {
		return nil
	}
	return c.Actions
}

func (c *ChangeBillingAnchorDateResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChangeBillingAnchorDateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChangeBillingAnchorDateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChangeBillingAnchorDateResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChangeBillingAnchorDateResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Supported timings when a pending change, as an action, takes place to a subscription.
type ChangeTiming string

const (
	ChangeTimingDefaultChangeTimingTypeDoNotUse ChangeTiming = "DEFAULT_CHANGE_TIMING_TYPE_DO_NOT_USE"
	ChangeTimingImmediate                       ChangeTiming = "IMMEDIATE"
	ChangeTimingEndOfBillingCycle               ChangeTiming = "END_OF_BILLING_CYCLE"
)

func NewChangeTimingFromString(s string) (ChangeTiming, error) {
	switch s {
	case "DEFAULT_CHANGE_TIMING_TYPE_DO_NOT_USE":
		return ChangeTimingDefaultChangeTimingTypeDoNotUse, nil
	case "IMMEDIATE":
		return ChangeTimingImmediate, nil
	case "END_OF_BILLING_CYCLE":
		return ChangeTimingEndOfBillingCycle, nil
	}
	var t ChangeTiming
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChangeTiming) Ptr() *ChangeTiming {
	return &c
}

// Defines output parameters in a response from the
// [CreateSubscription](api-endpoint:Subscriptions-CreateSubscription) endpoint.
type CreateSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created subscription.
	//
	// For more information, see
	// [Subscription object](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#subscription-object).
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateSubscriptionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateSubscriptionResponse) GetSubscription() *Subscription {
	if c == nil {
		return nil
	}
	return c.Subscription
}

func (c *CreateSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSubscriptionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines output parameters in a response of the [DeleteSubscriptionAction](api-endpoint:Subscriptions-DeleteSubscriptionAction)
// endpoint.
type DeleteSubscriptionActionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription that has the specified action deleted.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteSubscriptionActionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteSubscriptionActionResponse) GetSubscription() *Subscription {
	if d == nil {
		return nil
	}
	return d.Subscription
}

func (d *DeleteSubscriptionActionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSubscriptionActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSubscriptionActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSubscriptionActionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSubscriptionActionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines output parameters in a response from the
// [RetrieveSubscription](api-endpoint:Subscriptions-RetrieveSubscription) endpoint.
type GetSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription retrieved.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetSubscriptionResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetSubscriptionResponse) GetSubscription() *Subscription {
	if g == nil {
		return nil
	}
	return g.Subscription
}

func (g *GetSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSubscriptionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines output parameters in a response from the
// [ListSubscriptionEvents](api-endpoint:Subscriptions-ListSubscriptionEvents).
type ListSubscriptionEventsResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved subscription events.
	SubscriptionEvents []*SubscriptionEvent `json:"subscription_events,omitempty" url:"subscription_events,omitempty"`
	// When the total number of resulting subscription events exceeds the limit of a paged response,
	// the response includes a cursor for you to use in a subsequent request to fetch the next set of events.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListSubscriptionEventsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListSubscriptionEventsResponse) GetSubscriptionEvents() []*SubscriptionEvent {
	if l == nil {
		return nil
	}
	return l.SubscriptionEvents
}

func (l *ListSubscriptionEventsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListSubscriptionEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSubscriptionEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSubscriptionEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSubscriptionEventsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSubscriptionEventsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines output parameters in a response from the
// [PauseSubscription](api-endpoint:Subscriptions-PauseSubscription) endpoint.
type PauseSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription to be paused by the scheduled `PAUSE` action.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// The list of a `PAUSE` action and a possible `RESUME` action created by the request.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PauseSubscriptionResponse) GetErrors() []*Error {
	if p == nil {
		return nil
	}
	return p.Errors
}

func (p *PauseSubscriptionResponse) GetSubscription() *Subscription {
	if p == nil {
		return nil
	}
	return p.Subscription
}

func (p *PauseSubscriptionResponse) GetActions() []*SubscriptionAction {
	if p == nil {
		return nil
	}
	return p.Actions
}

func (p *PauseSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PauseSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PauseSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PauseSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PauseSubscriptionResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a phase, which can override subscription phases as defined by plan_id
type Phase struct {
	// id of subscription phase
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// index of phase in total subscription plan
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// id of order to be used in billing
	OrderTemplateID *string `json:"order_template_id,omitempty" url:"order_template_id,omitempty"`
	// the uid from the plan's phase in catalog
	PlanPhaseUID *string `json:"plan_phase_uid,omitempty" url:"plan_phase_uid,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Phase) GetUID() *string {
	if p == nil {
		return nil
	}
	return p.UID
}

func (p *Phase) GetOrdinal() *int64 {
	if p == nil {
		return nil
	}
	return p.Ordinal
}

func (p *Phase) GetOrderTemplateID() *string {
	if p == nil {
		return nil
	}
	return p.OrderTemplateID
}

func (p *Phase) GetPlanPhaseUID() *string {
	if p == nil {
		return nil
	}
	return p.PlanPhaseUID
}

func (p *Phase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Phase) UnmarshalJSON(data []byte) error {
	type unmarshaler Phase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Phase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Phase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the arguments used to construct a new phase.
type PhaseInput struct {
	// index of phase in total subscription plan
	Ordinal int64 `json:"ordinal" url:"ordinal"`
	// id of order to be used in billing
	OrderTemplateID *string `json:"order_template_id,omitempty" url:"order_template_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PhaseInput) GetOrdinal() int64 {
	if p == nil {
		return 0
	}
	return p.Ordinal
}

func (p *PhaseInput) GetOrderTemplateID() *string {
	if p == nil {
		return nil
	}
	return p.OrderTemplateID
}

func (p *PhaseInput) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhaseInput) UnmarshalJSON(data []byte) error {
	type unmarshaler PhaseInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhaseInput(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhaseInput) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Defines output parameters in a response from the
// [ResumeSubscription](api-endpoint:Subscriptions-ResumeSubscription) endpoint.
type ResumeSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resumed subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of `RESUME` actions created by the request and scheduled for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResumeSubscriptionResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *ResumeSubscriptionResponse) GetSubscription() *Subscription {
	if r == nil {
		return nil
	}
	return r.Subscription
}

func (r *ResumeSubscriptionResponse) GetActions() []*SubscriptionAction {
	if r == nil {
		return nil
	}
	return r.Actions
}

func (r *ResumeSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResumeSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResumeSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResumeSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResumeSubscriptionResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a set of query expressions (filters) to narrow the scope of targeted subscriptions returned by
// the [SearchSubscriptions](api-endpoint:Subscriptions-SearchSubscriptions) endpoint.
type SearchSubscriptionsFilter struct {
	// A filter to select subscriptions based on the subscribing customer IDs.
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`
	// A filter to select subscriptions based on the location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// A filter to select subscriptions based on the source application.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSubscriptionsFilter) GetCustomerIDs() []string {
	if s == nil {
		return nil
	}
	return s.CustomerIDs
}

func (s *SearchSubscriptionsFilter) GetLocationIDs() []string {
	if s == nil {
		return nil
	}
	return s.LocationIDs
}

func (s *SearchSubscriptionsFilter) GetSourceNames() []string {
	if s == nil {
		return nil
	}
	return s.SourceNames
}

func (s *SearchSubscriptionsFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsFilter) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a query, consisting of specified query expressions, used to search for subscriptions.
type SearchSubscriptionsQuery struct {
	// A list of query expressions.
	Filter *SearchSubscriptionsFilter `json:"filter,omitempty" url:"filter,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSubscriptionsQuery) GetFilter() *SearchSubscriptionsFilter {
	if s == nil {
		return nil
	}
	return s.Filter
}

func (s *SearchSubscriptionsQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsQuery) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines output parameters in a response from the
// [SearchSubscriptions](api-endpoint:Subscriptions-SearchSubscriptions) endpoint.
type SearchSubscriptionsResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscriptions matching the specified query expressions.
	Subscriptions []*Subscription `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	// When the total number of resulting subscription exceeds the limit of a paged response,
	// the response includes a cursor for you to use in a subsequent request to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchSubscriptionsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchSubscriptionsResponse) GetSubscriptions() []*Subscription {
	if s == nil {
		return nil
	}
	return s.Subscriptions
}

func (s *SearchSubscriptionsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchSubscriptionsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a subscription purchased by a customer.
//
// For more information, see
// [Manage Subscriptions](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions).
type Subscription struct {
	// The Square-assigned ID of the subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the location associated with the subscription.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the subscribed-to [subscription plan](entity:CatalogSubscriptionPlan).
	PlanID *string `json:"plan_id,omitempty" url:"plan_id,omitempty"`
	// The ID of the subscribed-to [subscription plan variation](entity:CatalogSubscriptionPlanVariation).
	PlanVariationID *string `json:"plan_variation_id,omitempty" url:"plan_variation_id,omitempty"`
	// The ID of the subscribing [customer](entity:Customer) profile.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) to start the subscription.
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) to cancel the subscription,
	// when the subscription status changes to `CANCELED` and the subscription billing stops.
	//
	// If this field is not set, the subscription ends according its subscription plan.
	//
	// This field cannot be updated, other than being cleared.
	CanceledDate *string `json:"canceled_date,omitempty" url:"canceled_date,omitempty"`
	// The `YYYY-MM-DD`-formatted date up to when the subscriber is invoiced for the
	// subscription.
	//
	// After the invoice is sent for a given billing period,
	// this date will be the last day of the billing period.
	// For example,
	// suppose for the month of May a subscriber gets an invoice
	// (or charged the card) on May 1. For the monthly billing scenario,
	// this date is then set to May 31.
	ChargedThroughDate *string `json:"charged_through_date,omitempty" url:"charged_through_date,omitempty"`
	// The current status of the subscription.
	// See [SubscriptionStatus](#type-subscriptionstatus) for possible values
	Status *SubscriptionStatus `json:"status,omitempty" url:"status,omitempty"`
	// The tax amount applied when billing the subscription. The
	// percentage is expressed in decimal form, using a `'.'` as the decimal
	// separator and without a `'%'` sign. For example, a value of `7.5`
	// corresponds to 7.5%.
	TaxPercentage *string `json:"tax_percentage,omitempty" url:"tax_percentage,omitempty"`
	// The IDs of the [invoices](entity:Invoice) created for the
	// subscription, listed in order when the invoices were created
	// (newest invoices appear first).
	InvoiceIDs []string `json:"invoice_ids,omitempty" url:"invoice_ids,omitempty"`
	// A custom price which overrides the cost of a subscription plan variation with `STATIC` pricing.
	// This field does not affect itemized subscriptions with `RELATIVE` pricing. Instead,
	// you should edit the Subscription's [order template](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#phases-and-order-templates).
	PriceOverrideMoney *Money `json:"price_override_money,omitempty" url:"price_override_money,omitempty"`
	// The version of the object. When updating an object, the version
	// supplied must match the version in the database, otherwise the write will
	// be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp when the subscription was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The ID of the [subscriber's](entity:Customer) [card](entity:Card)
	// used to charge for the subscription.
	CardID *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) up to when the subscriber is invoiced for the
	// subscription.
	//
	// After the invoice is sent for a given billing period,
	// this date will be the last day of the billing period.
	// For example,
	// suppose for the month of May a subscriber gets an invoice
	// (or charged the card) on May 1. For the monthly billing scenario,
	// this date is then set to May 31.
	PaidUntilDate *string `json:"paid_until_date,omitempty" url:"paid_until_date,omitempty"`
	// Timezone that will be used in date calculations for the subscription.
	// Defaults to the timezone of the location based on `location_id`.
	// Format: the IANA Timezone Database identifier for the location timezone (for example, `America/Los_Angeles`).
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// The origination details of the subscription.
	Source *SubscriptionSource `json:"source,omitempty" url:"source,omitempty"`
	// The list of scheduled actions on this subscription. It is set only in the response from
	// [RetrieveSubscription](api-endpoint:Subscriptions-RetrieveSubscription) with the query parameter
	// of `include=actions` or from
	// [SearchSubscriptions](api-endpoint:Subscriptions-SearchSubscriptions) with the input parameter
	// of `include:["actions"]`.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`
	// The day of the month on which the subscription will issue invoices and publish orders.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// array of phases for this subscription
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Subscription) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Subscription) GetLocationID() *string {
	if s == nil {
		return nil
	}
	return s.LocationID
}

func (s *Subscription) GetPlanID() *string {
	if s == nil {
		return nil
	}
	return s.PlanID
}

func (s *Subscription) GetPlanVariationID() *string {
	if s == nil {
		return nil
	}
	return s.PlanVariationID
}

func (s *Subscription) GetCustomerID() *string {
	if s == nil {
		return nil
	}
	return s.CustomerID
}

func (s *Subscription) GetStartDate() *string {
	if s == nil {
		return nil
	}
	return s.StartDate
}

func (s *Subscription) GetCanceledDate() *string {
	if s == nil {
		return nil
	}
	return s.CanceledDate
}

func (s *Subscription) GetChargedThroughDate() *string {
	if s == nil {
		return nil
	}
	return s.ChargedThroughDate
}

func (s *Subscription) GetStatus() *SubscriptionStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *Subscription) GetTaxPercentage() *string {
	if s == nil {
		return nil
	}
	return s.TaxPercentage
}

func (s *Subscription) GetInvoiceIDs() []string {
	if s == nil {
		return nil
	}
	return s.InvoiceIDs
}

func (s *Subscription) GetPriceOverrideMoney() *Money {
	if s == nil {
		return nil
	}
	return s.PriceOverrideMoney
}

func (s *Subscription) GetVersion() *int64 {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *Subscription) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *Subscription) GetCardID() *string {
	if s == nil {
		return nil
	}
	return s.CardID
}

func (s *Subscription) GetPaidUntilDate() *string {
	if s == nil {
		return nil
	}
	return s.PaidUntilDate
}

func (s *Subscription) GetTimezone() *string {
	if s == nil {
		return nil
	}
	return s.Timezone
}

func (s *Subscription) GetSource() *SubscriptionSource {
	if s == nil {
		return nil
	}
	return s.Source
}

func (s *Subscription) GetActions() []*SubscriptionAction {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *Subscription) GetMonthlyBillingAnchorDate() *int {
	if s == nil {
		return nil
	}
	return s.MonthlyBillingAnchorDate
}

func (s *Subscription) GetPhases() []*Phase {
	if s == nil {
		return nil
	}
	return s.Phases
}

func (s *Subscription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subscription) UnmarshalJSON(data []byte) error {
	type unmarshaler Subscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Subscription(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Subscription) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents an action as a pending change to a subscription.
type SubscriptionAction struct {
	// The ID of an action scoped to a subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the action.
	// See [SubscriptionActionType](#type-subscriptionactiontype) for possible values
	Type *SubscriptionActionType `json:"type,omitempty" url:"type,omitempty"`
	// The `YYYY-MM-DD`-formatted date when the action occurs on the subscription.
	EffectiveDate *string `json:"effective_date,omitempty" url:"effective_date,omitempty"`
	// The target subscription plan a subscription switches to, for a `SWAP_PLAN` action.
	NewPlanID *string `json:"new_plan_id,omitempty" url:"new_plan_id,omitempty"`
	// The new billing anchor day value, for a `CHANGE_BILLING_ANCHOR_DATE` action.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// A list of Phases, to pass phase-specific information used in the swap.
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`
	// The target subscription plan variation that a subscription switches to, for a `SWAP_PLAN` action.
	NewPlanVariationID *string `json:"new_plan_variation_id,omitempty" url:"new_plan_variation_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionAction) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *SubscriptionAction) GetType() *SubscriptionActionType {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SubscriptionAction) GetEffectiveDate() *string {
	if s == nil {
		return nil
	}
	return s.EffectiveDate
}

func (s *SubscriptionAction) GetNewPlanID() *string {
	if s == nil {
		return nil
	}
	return s.NewPlanID
}

func (s *SubscriptionAction) GetMonthlyBillingAnchorDate() *int {
	if s == nil {
		return nil
	}
	return s.MonthlyBillingAnchorDate
}

func (s *SubscriptionAction) GetPhases() []*Phase {
	if s == nil {
		return nil
	}
	return s.Phases
}

func (s *SubscriptionAction) GetNewPlanVariationID() *string {
	if s == nil {
		return nil
	}
	return s.NewPlanVariationID
}

func (s *SubscriptionAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionAction) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionAction) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported types of an action as a pending change to a subscription.
type SubscriptionActionType string

const (
	SubscriptionActionTypeDefaultSubscriptionActionTypeDoNotUse SubscriptionActionType = "DEFAULT_SUBSCRIPTION_ACTION_TYPE_DO_NOT_USE"
	SubscriptionActionTypeCancel                                SubscriptionActionType = "CANCEL"
	SubscriptionActionTypePause                                 SubscriptionActionType = "PAUSE"
	SubscriptionActionTypeResume                                SubscriptionActionType = "RESUME"
	SubscriptionActionTypeSwapPlan                              SubscriptionActionType = "SWAP_PLAN"
	SubscriptionActionTypeChangeBillingAnchorDate               SubscriptionActionType = "CHANGE_BILLING_ANCHOR_DATE"
)

func NewSubscriptionActionTypeFromString(s string) (SubscriptionActionType, error) {
	switch s {
	case "DEFAULT_SUBSCRIPTION_ACTION_TYPE_DO_NOT_USE":
		return SubscriptionActionTypeDefaultSubscriptionActionTypeDoNotUse, nil
	case "CANCEL":
		return SubscriptionActionTypeCancel, nil
	case "PAUSE":
		return SubscriptionActionTypePause, nil
	case "RESUME":
		return SubscriptionActionTypeResume, nil
	case "SWAP_PLAN":
		return SubscriptionActionTypeSwapPlan, nil
	case "CHANGE_BILLING_ANCHOR_DATE":
		return SubscriptionActionTypeChangeBillingAnchorDate, nil
	}
	var t SubscriptionActionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionActionType) Ptr() *SubscriptionActionType {
	return &s
}

// Describes changes to a subscription and the subscription status.
type SubscriptionEvent struct {
	// The ID of the subscription event.
	ID string `json:"id" url:"id"`
	// Type of the subscription event.
	// See [SubscriptionEventSubscriptionEventType](#type-subscriptioneventsubscriptioneventtype) for possible values
	SubscriptionEventType SubscriptionEventSubscriptionEventType `json:"subscription_event_type" url:"subscription_event_type"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) when the subscription event occurred.
	EffectiveDate string `json:"effective_date" url:"effective_date"`
	// The ID of the subscription plan associated with the subscription.
	PlanID *string `json:"plan_id,omitempty" url:"plan_id,omitempty"`
	// The day-of-the-month the billing anchor date was changed to, if applicable.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// Additional information about the subscription event.
	Info *SubscriptionEventInfo `json:"info,omitempty" url:"info,omitempty"`
	// A list of Phases, to pass phase-specific information used in the swap.
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`
	// The ID of the subscription plan variation associated with the subscription.
	PlanVariationID string `json:"plan_variation_id" url:"plan_variation_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionEvent) GetID() string {
	if s == nil {
		return ""
	}
	return s.ID
}

func (s *SubscriptionEvent) GetSubscriptionEventType() SubscriptionEventSubscriptionEventType {
	if s == nil {
		return ""
	}
	return s.SubscriptionEventType
}

func (s *SubscriptionEvent) GetEffectiveDate() string {
	if s == nil {
		return ""
	}
	return s.EffectiveDate
}

func (s *SubscriptionEvent) GetPlanID() *string {
	if s == nil {
		return nil
	}
	return s.PlanID
}

func (s *SubscriptionEvent) GetMonthlyBillingAnchorDate() *int {
	if s == nil {
		return nil
	}
	return s.MonthlyBillingAnchorDate
}

func (s *SubscriptionEvent) GetInfo() *SubscriptionEventInfo {
	if s == nil {
		return nil
	}
	return s.Info
}

func (s *SubscriptionEvent) GetPhases() []*Phase {
	if s == nil {
		return nil
	}
	return s.Phases
}

func (s *SubscriptionEvent) GetPlanVariationID() string {
	if s == nil {
		return ""
	}
	return s.PlanVariationID
}

func (s *SubscriptionEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEvent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Provides information about the subscription event.
type SubscriptionEventInfo struct {
	// A human-readable explanation for the event.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// An info code indicating the subscription event that occurred.
	// See [InfoCode](#type-infocode) for possible values
	Code *SubscriptionEventInfoCode `json:"code,omitempty" url:"code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionEventInfo) GetDetail() *string {
	if s == nil {
		return nil
	}
	return s.Detail
}

func (s *SubscriptionEventInfo) GetCode() *SubscriptionEventInfoCode {
	if s == nil {
		return nil
	}
	return s.Code
}

func (s *SubscriptionEventInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEventInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEventInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEventInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEventInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported info codes of a subscription event.
type SubscriptionEventInfoCode string

const (
	SubscriptionEventInfoCodeLocationNotActive           SubscriptionEventInfoCode = "LOCATION_NOT_ACTIVE"
	SubscriptionEventInfoCodeLocationCannotAcceptPayment SubscriptionEventInfoCode = "LOCATION_CANNOT_ACCEPT_PAYMENT"
	SubscriptionEventInfoCodeCustomerDeleted             SubscriptionEventInfoCode = "CUSTOMER_DELETED"
	SubscriptionEventInfoCodeCustomerNoEmail             SubscriptionEventInfoCode = "CUSTOMER_NO_EMAIL"
	SubscriptionEventInfoCodeCustomerNoName              SubscriptionEventInfoCode = "CUSTOMER_NO_NAME"
	SubscriptionEventInfoCodeUserProvided                SubscriptionEventInfoCode = "USER_PROVIDED"
	SubscriptionEventInfoCodeInvoiceInvalid              SubscriptionEventInfoCode = "INVOICE_INVALID"
)

func NewSubscriptionEventInfoCodeFromString(s string) (SubscriptionEventInfoCode, error) {
	switch s {
	case "LOCATION_NOT_ACTIVE":
		return SubscriptionEventInfoCodeLocationNotActive, nil
	case "LOCATION_CANNOT_ACCEPT_PAYMENT":
		return SubscriptionEventInfoCodeLocationCannotAcceptPayment, nil
	case "CUSTOMER_DELETED":
		return SubscriptionEventInfoCodeCustomerDeleted, nil
	case "CUSTOMER_NO_EMAIL":
		return SubscriptionEventInfoCodeCustomerNoEmail, nil
	case "CUSTOMER_NO_NAME":
		return SubscriptionEventInfoCodeCustomerNoName, nil
	case "USER_PROVIDED":
		return SubscriptionEventInfoCodeUserProvided, nil
	case "INVOICE_INVALID":
		return SubscriptionEventInfoCodeInvoiceInvalid, nil
	}
	var t SubscriptionEventInfoCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventInfoCode) Ptr() *SubscriptionEventInfoCode {
	return &s
}

// Supported types of an event occurred to a subscription.
type SubscriptionEventSubscriptionEventType string

const (
	SubscriptionEventSubscriptionEventTypeDefaultSubscriptionEventTypeDoNotUse SubscriptionEventSubscriptionEventType = "DEFAULT_SUBSCRIPTION_EVENT_TYPE_DO_NOT_USE"
	SubscriptionEventSubscriptionEventTypeStartSubscription                    SubscriptionEventSubscriptionEventType = "START_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePlanChange                           SubscriptionEventSubscriptionEventType = "PLAN_CHANGE"
	SubscriptionEventSubscriptionEventTypeStopSubscription                     SubscriptionEventSubscriptionEventType = "STOP_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeDeactivateSubscription               SubscriptionEventSubscriptionEventType = "DEACTIVATE_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeResumeSubscription                   SubscriptionEventSubscriptionEventType = "RESUME_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePauseSubscription                    SubscriptionEventSubscriptionEventType = "PAUSE_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeBillingAnchorDateChanged             SubscriptionEventSubscriptionEventType = "BILLING_ANCHOR_DATE_CHANGED"
)

func NewSubscriptionEventSubscriptionEventTypeFromString(s string) (SubscriptionEventSubscriptionEventType, error) {
	switch s {
	case "DEFAULT_SUBSCRIPTION_EVENT_TYPE_DO_NOT_USE":
		return SubscriptionEventSubscriptionEventTypeDefaultSubscriptionEventTypeDoNotUse, nil
	case "START_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStartSubscription, nil
	case "PLAN_CHANGE":
		return SubscriptionEventSubscriptionEventTypePlanChange, nil
	case "STOP_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStopSubscription, nil
	case "DEACTIVATE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeDeactivateSubscription, nil
	case "RESUME_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeResumeSubscription, nil
	case "PAUSE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypePauseSubscription, nil
	case "BILLING_ANCHOR_DATE_CHANGED":
		return SubscriptionEventSubscriptionEventTypeBillingAnchorDateChanged, nil
	}
	var t SubscriptionEventSubscriptionEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventSubscriptionEventType) Ptr() *SubscriptionEventSubscriptionEventType {
	return &s
}

// The origination details of the subscription.
type SubscriptionSource struct {
	// The name used to identify the place (physical or digital) that
	// a subscription originates. If unset, the name defaults to the name
	// of the application that created the subscription.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionSource) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SubscriptionSource) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionSource) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionSource) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported subscription statuses.
type SubscriptionStatus string

const (
	SubscriptionStatusDefaultSubscriptionStatusDoNotUse SubscriptionStatus = "DEFAULT_SUBSCRIPTION_STATUS_DO_NOT_USE"
	SubscriptionStatusPending                           SubscriptionStatus = "PENDING"
	SubscriptionStatusActive                            SubscriptionStatus = "ACTIVE"
	SubscriptionStatusCanceled                          SubscriptionStatus = "CANCELED"
	SubscriptionStatusDeactivated                       SubscriptionStatus = "DEACTIVATED"
	SubscriptionStatusPaused                            SubscriptionStatus = "PAUSED"
)

func NewSubscriptionStatusFromString(s string) (SubscriptionStatus, error) {
	switch s {
	case "DEFAULT_SUBSCRIPTION_STATUS_DO_NOT_USE":
		return SubscriptionStatusDefaultSubscriptionStatusDoNotUse, nil
	case "PENDING":
		return SubscriptionStatusPending, nil
	case "ACTIVE":
		return SubscriptionStatusActive, nil
	case "CANCELED":
		return SubscriptionStatusCanceled, nil
	case "DEACTIVATED":
		return SubscriptionStatusDeactivated, nil
	case "PAUSED":
		return SubscriptionStatusPaused, nil
	}
	var t SubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStatus) Ptr() *SubscriptionStatus {
	return &s
}

// Defines output parameters in a response of the
// [SwapPlan](api-endpoint:Subscriptions-SwapPlan) endpoint.
type SwapPlanResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription with the updated subscription plan.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a `SWAP_PLAN` action created by the request.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SwapPlanResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SwapPlanResponse) GetSubscription() *Subscription {
	if s == nil {
		return nil
	}
	return s.Subscription
}

func (s *SwapPlanResponse) GetActions() []*SubscriptionAction {
	if s == nil {
		return nil
	}
	return s.Actions
}

func (s *SwapPlanResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SwapPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SwapPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SwapPlanResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SwapPlanResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines output parameters in a response from the
// [UpdateSubscription](api-endpoint:Subscriptions-UpdateSubscription) endpoint.
type UpdateSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateSubscriptionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateSubscriptionResponse) GetSubscription() *Subscription {
	if u == nil {
		return nil
	}
	return u.Subscription
}

func (u *UpdateSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSubscriptionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateSubscriptionRequest struct {
	// The ID of the subscription to update.
	SubscriptionID string `json:"-" url:"-"`
	// The subscription object containing the current version, and fields to update.
	// Unset fields will be left at their current server values, and JSON `null` values will
	// be treated as a request to clear the relevant data.
	Subscription *Subscription `json:"subscription,omitempty" url:"-"`
}
