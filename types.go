// This file was auto-generated by Fern from our API Definition.

package square

import (
	json "encoding/json"
	fmt "fmt"

	core "github.com/fern-demo/square-go-sdk/core"
)

// Defines the request parameters for the `AcceptDispute` endpoint.
type AcceptDisputeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AcceptDisputeRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AcceptDisputeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AcceptDisputeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcceptDisputeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcceptDisputeRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Defines the fields in an `AcceptDispute` response.
type AcceptDisputeResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Details about the accepted dispute.
	Dispute *Dispute `json:"dispute,omitempty" url:"dispute,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AcceptDisputeResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AcceptDisputeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AcceptDisputeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcceptDisputeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcceptDisputeResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AcceptedPaymentMethods struct {
	// Whether Apple Pay is accepted at checkout.
	ApplePay *bool `json:"apple_pay,omitempty" url:"apple_pay,omitempty"`
	// Whether Google Pay is accepted at checkout.
	GooglePay *bool `json:"google_pay,omitempty" url:"google_pay,omitempty"`
	// Whether Cash App Pay is accepted at checkout.
	CashAppPay *bool `json:"cash_app_pay,omitempty" url:"cash_app_pay,omitempty"`
	// Whether Afterpay/Clearpay is accepted at checkout.
	AfterpayClearpay *bool `json:"afterpay_clearpay,omitempty" url:"afterpay_clearpay,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AcceptedPaymentMethods) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AcceptedPaymentMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler AcceptedPaymentMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcceptedPaymentMethods(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcceptedPaymentMethods) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an [AccumulateLoyaltyPoints]($e/Loyalty/AccumulateLoyaltyPoints) response.
type AccumulateLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resulting loyalty event. Starting in Square version 2022-08-17, this field is no longer returned.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`
	// The resulting loyalty events. If the purchase qualifies for points, the `ACCUMULATE_POINTS` event
	// is always included. When using the Orders API, the `ACCUMULATE_PROMOTION_POINTS` event is included
	// if the purchase also qualifies for a loyalty promotion.
	Events []*LoyaltyEvent `json:"events,omitempty" url:"events,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AccumulateLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccumulateLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AccumulateLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccumulateLoyaltyPointsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccumulateLoyaltyPointsResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// ACH-specific details about `BANK_ACCOUNT` type payments with the `transfer_type` of `ACH`.
type AchDetails struct {
	// The routing number for the bank account.
	RoutingNumber *string `json:"routing_number,omitempty" url:"routing_number,omitempty"`
	// The last few digits of the bank account number.
	AccountNumberSuffix *string `json:"account_number_suffix,omitempty" url:"account_number_suffix,omitempty"`
	// The type of the bank account performing the transfer. The account type can be `CHECKING`,
	// `SAVINGS`, or `UNKNOWN`.
	AccountType *string `json:"account_type,omitempty" url:"account_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AchDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AchDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionCancelReason string

const (
	ActionCancelReasonBuyerCanceled  ActionCancelReason = "BUYER_CANCELED"
	ActionCancelReasonSellerCanceled ActionCancelReason = "SELLER_CANCELED"
	ActionCancelReasonTimedOut       ActionCancelReason = "TIMED_OUT"
)

func NewActionCancelReasonFromString(s string) (ActionCancelReason, error) {
	switch s {
	case "BUYER_CANCELED":
		return ActionCancelReasonBuyerCanceled, nil
	case "SELLER_CANCELED":
		return ActionCancelReasonSellerCanceled, nil
	case "TIMED_OUT":
		return ActionCancelReasonTimedOut, nil
	}
	var t ActionCancelReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionCancelReason) Ptr() *ActionCancelReason {
	return &a
}

type ActivityType string

const (
	ActivityTypeAdjustment                            ActivityType = "ADJUSTMENT"
	ActivityTypeAppFeeRefund                          ActivityType = "APP_FEE_REFUND"
	ActivityTypeAppFeeRevenue                         ActivityType = "APP_FEE_REVENUE"
	ActivityTypeAutomaticSavings                      ActivityType = "AUTOMATIC_SAVINGS"
	ActivityTypeAutomaticSavingsReversed              ActivityType = "AUTOMATIC_SAVINGS_REVERSED"
	ActivityTypeCharge                                ActivityType = "CHARGE"
	ActivityTypeDepositFee                            ActivityType = "DEPOSIT_FEE"
	ActivityTypeDispute                               ActivityType = "DISPUTE"
	ActivityTypeEscheatment                           ActivityType = "ESCHEATMENT"
	ActivityTypeFee                                   ActivityType = "FEE"
	ActivityTypeFreeProcessing                        ActivityType = "FREE_PROCESSING"
	ActivityTypeHoldAdjustment                        ActivityType = "HOLD_ADJUSTMENT"
	ActivityTypeInitialBalanceChange                  ActivityType = "INITIAL_BALANCE_CHANGE"
	ActivityTypeMoneyTransfer                         ActivityType = "MONEY_TRANSFER"
	ActivityTypeMoneyTransferReversal                 ActivityType = "MONEY_TRANSFER_REVERSAL"
	ActivityTypeOpenDispute                           ActivityType = "OPEN_DISPUTE"
	ActivityTypeOther                                 ActivityType = "OTHER"
	ActivityTypeOtherAdjustment                       ActivityType = "OTHER_ADJUSTMENT"
	ActivityTypePaidServiceFee                        ActivityType = "PAID_SERVICE_FEE"
	ActivityTypePaidServiceFeeRefund                  ActivityType = "PAID_SERVICE_FEE_REFUND"
	ActivityTypeRedemptionCode                        ActivityType = "REDEMPTION_CODE"
	ActivityTypeRefund                                ActivityType = "REFUND"
	ActivityTypeReleaseAdjustment                     ActivityType = "RELEASE_ADJUSTMENT"
	ActivityTypeReserveHold                           ActivityType = "RESERVE_HOLD"
	ActivityTypeReserveRelease                        ActivityType = "RESERVE_RELEASE"
	ActivityTypeReturnedPayout                        ActivityType = "RETURNED_PAYOUT"
	ActivityTypeSquareCapitalPayment                  ActivityType = "SQUARE_CAPITAL_PAYMENT"
	ActivityTypeSquareCapitalReversedPayment          ActivityType = "SQUARE_CAPITAL_REVERSED_PAYMENT"
	ActivityTypeSubscriptionFee                       ActivityType = "SUBSCRIPTION_FEE"
	ActivityTypeSubscriptionFeePaidRefund             ActivityType = "SUBSCRIPTION_FEE_PAID_REFUND"
	ActivityTypeSubscriptionFeeRefund                 ActivityType = "SUBSCRIPTION_FEE_REFUND"
	ActivityTypeTaxOnFee                              ActivityType = "TAX_ON_FEE"
	ActivityTypeThirdPartyFee                         ActivityType = "THIRD_PARTY_FEE"
	ActivityTypeThirdPartyFeeRefund                   ActivityType = "THIRD_PARTY_FEE_REFUND"
	ActivityTypePayout                                ActivityType = "PAYOUT"
	ActivityTypeAutomaticBitcoinConversions           ActivityType = "AUTOMATIC_BITCOIN_CONVERSIONS"
	ActivityTypeAutomaticBitcoinConversionsReversed   ActivityType = "AUTOMATIC_BITCOIN_CONVERSIONS_REVERSED"
	ActivityTypeCreditCardRepayment                   ActivityType = "CREDIT_CARD_REPAYMENT"
	ActivityTypeCreditCardRepaymentReversed           ActivityType = "CREDIT_CARD_REPAYMENT_REVERSED"
	ActivityTypeLocalOffersCashback                   ActivityType = "LOCAL_OFFERS_CASHBACK"
	ActivityTypeLocalOffersFee                        ActivityType = "LOCAL_OFFERS_FEE"
	ActivityTypePercentageProcessingEnrollment        ActivityType = "PERCENTAGE_PROCESSING_ENROLLMENT"
	ActivityTypePercentageProcessingDeactivation      ActivityType = "PERCENTAGE_PROCESSING_DEACTIVATION"
	ActivityTypePercentageProcessingRepayment         ActivityType = "PERCENTAGE_PROCESSING_REPAYMENT"
	ActivityTypePercentageProcessingRepaymentReversed ActivityType = "PERCENTAGE_PROCESSING_REPAYMENT_REVERSED"
	ActivityTypeProcessingFee                         ActivityType = "PROCESSING_FEE"
	ActivityTypeProcessingFeeRefund                   ActivityType = "PROCESSING_FEE_REFUND"
	ActivityTypeUndoProcessingFeeRefund               ActivityType = "UNDO_PROCESSING_FEE_REFUND"
	ActivityTypeGiftCardLoadFee                       ActivityType = "GIFT_CARD_LOAD_FEE"
	ActivityTypeGiftCardLoadFeeRefund                 ActivityType = "GIFT_CARD_LOAD_FEE_REFUND"
	ActivityTypeUndoGiftCardLoadFeeRefund             ActivityType = "UNDO_GIFT_CARD_LOAD_FEE_REFUND"
	ActivityTypeBalanceFoldersTransfer                ActivityType = "BALANCE_FOLDERS_TRANSFER"
	ActivityTypeBalanceFoldersTransferReversed        ActivityType = "BALANCE_FOLDERS_TRANSFER_REVERSED"
	ActivityTypeGiftCardPoolTransfer                  ActivityType = "GIFT_CARD_POOL_TRANSFER"
	ActivityTypeGiftCardPoolTransferReversed          ActivityType = "GIFT_CARD_POOL_TRANSFER_REVERSED"
)

func NewActivityTypeFromString(s string) (ActivityType, error) {
	switch s {
	case "ADJUSTMENT":
		return ActivityTypeAdjustment, nil
	case "APP_FEE_REFUND":
		return ActivityTypeAppFeeRefund, nil
	case "APP_FEE_REVENUE":
		return ActivityTypeAppFeeRevenue, nil
	case "AUTOMATIC_SAVINGS":
		return ActivityTypeAutomaticSavings, nil
	case "AUTOMATIC_SAVINGS_REVERSED":
		return ActivityTypeAutomaticSavingsReversed, nil
	case "CHARGE":
		return ActivityTypeCharge, nil
	case "DEPOSIT_FEE":
		return ActivityTypeDepositFee, nil
	case "DISPUTE":
		return ActivityTypeDispute, nil
	case "ESCHEATMENT":
		return ActivityTypeEscheatment, nil
	case "FEE":
		return ActivityTypeFee, nil
	case "FREE_PROCESSING":
		return ActivityTypeFreeProcessing, nil
	case "HOLD_ADJUSTMENT":
		return ActivityTypeHoldAdjustment, nil
	case "INITIAL_BALANCE_CHANGE":
		return ActivityTypeInitialBalanceChange, nil
	case "MONEY_TRANSFER":
		return ActivityTypeMoneyTransfer, nil
	case "MONEY_TRANSFER_REVERSAL":
		return ActivityTypeMoneyTransferReversal, nil
	case "OPEN_DISPUTE":
		return ActivityTypeOpenDispute, nil
	case "OTHER":
		return ActivityTypeOther, nil
	case "OTHER_ADJUSTMENT":
		return ActivityTypeOtherAdjustment, nil
	case "PAID_SERVICE_FEE":
		return ActivityTypePaidServiceFee, nil
	case "PAID_SERVICE_FEE_REFUND":
		return ActivityTypePaidServiceFeeRefund, nil
	case "REDEMPTION_CODE":
		return ActivityTypeRedemptionCode, nil
	case "REFUND":
		return ActivityTypeRefund, nil
	case "RELEASE_ADJUSTMENT":
		return ActivityTypeReleaseAdjustment, nil
	case "RESERVE_HOLD":
		return ActivityTypeReserveHold, nil
	case "RESERVE_RELEASE":
		return ActivityTypeReserveRelease, nil
	case "RETURNED_PAYOUT":
		return ActivityTypeReturnedPayout, nil
	case "SQUARE_CAPITAL_PAYMENT":
		return ActivityTypeSquareCapitalPayment, nil
	case "SQUARE_CAPITAL_REVERSED_PAYMENT":
		return ActivityTypeSquareCapitalReversedPayment, nil
	case "SUBSCRIPTION_FEE":
		return ActivityTypeSubscriptionFee, nil
	case "SUBSCRIPTION_FEE_PAID_REFUND":
		return ActivityTypeSubscriptionFeePaidRefund, nil
	case "SUBSCRIPTION_FEE_REFUND":
		return ActivityTypeSubscriptionFeeRefund, nil
	case "TAX_ON_FEE":
		return ActivityTypeTaxOnFee, nil
	case "THIRD_PARTY_FEE":
		return ActivityTypeThirdPartyFee, nil
	case "THIRD_PARTY_FEE_REFUND":
		return ActivityTypeThirdPartyFeeRefund, nil
	case "PAYOUT":
		return ActivityTypePayout, nil
	case "AUTOMATIC_BITCOIN_CONVERSIONS":
		return ActivityTypeAutomaticBitcoinConversions, nil
	case "AUTOMATIC_BITCOIN_CONVERSIONS_REVERSED":
		return ActivityTypeAutomaticBitcoinConversionsReversed, nil
	case "CREDIT_CARD_REPAYMENT":
		return ActivityTypeCreditCardRepayment, nil
	case "CREDIT_CARD_REPAYMENT_REVERSED":
		return ActivityTypeCreditCardRepaymentReversed, nil
	case "LOCAL_OFFERS_CASHBACK":
		return ActivityTypeLocalOffersCashback, nil
	case "LOCAL_OFFERS_FEE":
		return ActivityTypeLocalOffersFee, nil
	case "PERCENTAGE_PROCESSING_ENROLLMENT":
		return ActivityTypePercentageProcessingEnrollment, nil
	case "PERCENTAGE_PROCESSING_DEACTIVATION":
		return ActivityTypePercentageProcessingDeactivation, nil
	case "PERCENTAGE_PROCESSING_REPAYMENT":
		return ActivityTypePercentageProcessingRepayment, nil
	case "PERCENTAGE_PROCESSING_REPAYMENT_REVERSED":
		return ActivityTypePercentageProcessingRepaymentReversed, nil
	case "PROCESSING_FEE":
		return ActivityTypeProcessingFee, nil
	case "PROCESSING_FEE_REFUND":
		return ActivityTypeProcessingFeeRefund, nil
	case "UNDO_PROCESSING_FEE_REFUND":
		return ActivityTypeUndoProcessingFeeRefund, nil
	case "GIFT_CARD_LOAD_FEE":
		return ActivityTypeGiftCardLoadFee, nil
	case "GIFT_CARD_LOAD_FEE_REFUND":
		return ActivityTypeGiftCardLoadFeeRefund, nil
	case "UNDO_GIFT_CARD_LOAD_FEE_REFUND":
		return ActivityTypeUndoGiftCardLoadFeeRefund, nil
	case "BALANCE_FOLDERS_TRANSFER":
		return ActivityTypeBalanceFoldersTransfer, nil
	case "BALANCE_FOLDERS_TRANSFER_REVERSED":
		return ActivityTypeBalanceFoldersTransferReversed, nil
	case "GIFT_CARD_POOL_TRANSFER":
		return ActivityTypeGiftCardPoolTransfer, nil
	case "GIFT_CARD_POOL_TRANSFER_REVERSED":
		return ActivityTypeGiftCardPoolTransferReversed, nil
	}
	var t ActivityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActivityType) Ptr() *ActivityType {
	return &a
}

// Defines the fields that are included in the request body of
// a request to the [AddGroupToCustomer]($e/Customers/AddGroupToCustomer) endpoint.
type AddGroupToCustomerRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddGroupToCustomerRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddGroupToCustomerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AddGroupToCustomerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddGroupToCustomerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddGroupToCustomerRequest) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Defines the fields that are included in the response body of
// a request to the [AddGroupToCustomer]($e/Customers/AddGroupToCustomer) endpoint.
type AddGroupToCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AddGroupToCustomerResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddGroupToCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AddGroupToCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddGroupToCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddGroupToCustomerResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an additional recipient (other than the merchant) receiving a portion of this tender.
type AdditionalRecipient struct {
	// The location ID for a recipient (other than the merchant) receiving a portion of this tender.
	LocationID string `json:"location_id" url:"location_id"`
	// The description of the additional recipient.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money distributed to the recipient.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The unique ID for the RETIRED `AdditionalRecipientReceivable` object. This field should be empty for any `AdditionalRecipient` objects created after the retirement.
	ReceivableID *string `json:"receivable_id,omitempty" url:"receivable_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdditionalRecipient) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdditionalRecipient) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents a postal address in a country.
// For more information, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
type Address struct {
	// The first line of the address.
	//
	// Fields that start with `address_line` provide the address's most specific
	// details, like street number, street name, and building name. They do _not_
	// provide less specific details like city, state/province, or country (these
	// details are provided in other fields).
	AddressLine1 *string `json:"address_line_1,omitempty" url:"address_line_1,omitempty"`
	// The second line of the address, if any.
	AddressLine2 *string `json:"address_line_2,omitempty" url:"address_line_2,omitempty"`
	// The third line of the address, if any.
	AddressLine3 *string `json:"address_line_3,omitempty" url:"address_line_3,omitempty"`
	// The city or town of the address. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	Locality *string `json:"locality,omitempty" url:"locality,omitempty"`
	// A civil region within the address's `locality`, if any.
	Sublocality *string `json:"sublocality,omitempty" url:"sublocality,omitempty"`
	// A civil region within the address's `sublocality`, if any.
	Sublocality2 *string `json:"sublocality_2,omitempty" url:"sublocality_2,omitempty"`
	// A civil region within the address's `sublocality_2`, if any.
	Sublocality3 *string `json:"sublocality_3,omitempty" url:"sublocality_3,omitempty"`
	// A civil entity within the address's country. In the US, this
	// is the state. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	AdministrativeDistrictLevel1 *string `json:"administrative_district_level_1,omitempty" url:"administrative_district_level_1,omitempty"`
	// A civil entity within the address's `administrative_district_level_1`.
	// In the US, this is the county.
	AdministrativeDistrictLevel2 *string `json:"administrative_district_level_2,omitempty" url:"administrative_district_level_2,omitempty"`
	// A civil entity within the address's `administrative_district_level_2`,
	// if any.
	AdministrativeDistrictLevel3 *string `json:"administrative_district_level_3,omitempty" url:"administrative_district_level_3,omitempty"`
	// The address's postal code. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// The address's country, in the two-letter format of ISO 3166. For example, `US` or `FR`.
	// See [Country](#type-country) for possible values
	Country *Country `json:"country,omitempty" url:"country,omitempty"`
	// Optional first name when it's representing recipient.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// Optional last name when it's representing recipient.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an [AdjustLoyaltyPoints]($e/Loyalty/AdjustLoyaltyPoints) request.
type AdjustLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resulting event data for the adjustment.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdjustLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdjustLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AdjustLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdjustLoyaltyPointsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdjustLoyaltyPointsResponse) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Additional details about Afterpay payments.
type AfterpayDetails struct {
	// Email address on the buyer's Afterpay account.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AfterpayDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AfterpayDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AfterpayDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AfterpayDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AfterpayDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Details about the application that took the payment.
type ApplicationDetails struct {
	// The Square product, such as Square Point of Sale (POS),
	// Square Invoices, or Square Virtual Terminal.
	// See [ExternalSquareProduct](#type-externalsquareproduct) for possible values
	SquareProduct *ApplicationDetailsExternalSquareProduct `json:"square_product,omitempty" url:"square_product,omitempty"`
	// The Square ID assigned to the application used to take the payment.
	// Application developers can use this information to identify payments that
	// their application processed.
	// For example, if a developer uses a custom application to process payments,
	// this field contains the application ID from the Developer Dashboard.
	// If a seller uses a [Square App Marketplace](https://developer.squareup.com/docs/app-marketplace)
	// application to process payments, the field contains the corresponding application ID.
	ApplicationID *string `json:"application_id,omitempty" url:"application_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApplicationDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApplicationDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ApplicationDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApplicationDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApplicationDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A list of products to return to external callers.
type ApplicationDetailsExternalSquareProduct string

const (
	ApplicationDetailsExternalSquareProductAppointments    ApplicationDetailsExternalSquareProduct = "APPOINTMENTS"
	ApplicationDetailsExternalSquareProductEcommerceAPI    ApplicationDetailsExternalSquareProduct = "ECOMMERCE_API"
	ApplicationDetailsExternalSquareProductInvoices        ApplicationDetailsExternalSquareProduct = "INVOICES"
	ApplicationDetailsExternalSquareProductOnlineStore     ApplicationDetailsExternalSquareProduct = "ONLINE_STORE"
	ApplicationDetailsExternalSquareProductOther           ApplicationDetailsExternalSquareProduct = "OTHER"
	ApplicationDetailsExternalSquareProductRestaurants     ApplicationDetailsExternalSquareProduct = "RESTAURANTS"
	ApplicationDetailsExternalSquareProductRetail          ApplicationDetailsExternalSquareProduct = "RETAIL"
	ApplicationDetailsExternalSquareProductSquarePos       ApplicationDetailsExternalSquareProduct = "SQUARE_POS"
	ApplicationDetailsExternalSquareProductTerminalAPI     ApplicationDetailsExternalSquareProduct = "TERMINAL_API"
	ApplicationDetailsExternalSquareProductVirtualTerminal ApplicationDetailsExternalSquareProduct = "VIRTUAL_TERMINAL"
)

func NewApplicationDetailsExternalSquareProductFromString(s string) (ApplicationDetailsExternalSquareProduct, error) {
	switch s {
	case "APPOINTMENTS":
		return ApplicationDetailsExternalSquareProductAppointments, nil
	case "ECOMMERCE_API":
		return ApplicationDetailsExternalSquareProductEcommerceAPI, nil
	case "INVOICES":
		return ApplicationDetailsExternalSquareProductInvoices, nil
	case "ONLINE_STORE":
		return ApplicationDetailsExternalSquareProductOnlineStore, nil
	case "OTHER":
		return ApplicationDetailsExternalSquareProductOther, nil
	case "RESTAURANTS":
		return ApplicationDetailsExternalSquareProductRestaurants, nil
	case "RETAIL":
		return ApplicationDetailsExternalSquareProductRetail, nil
	case "SQUARE_POS":
		return ApplicationDetailsExternalSquareProductSquarePos, nil
	case "TERMINAL_API":
		return ApplicationDetailsExternalSquareProductTerminalAPI, nil
	case "VIRTUAL_TERMINAL":
		return ApplicationDetailsExternalSquareProductVirtualTerminal, nil
	}
	var t ApplicationDetailsExternalSquareProduct
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApplicationDetailsExternalSquareProduct) Ptr() *ApplicationDetailsExternalSquareProduct {
	return &a
}

type ApplicationType = string

// Defines an appointment segment of a booking.
type AppointmentSegment struct {
	// The time span in minutes of an appointment segment.
	DurationMinutes *int `json:"duration_minutes,omitempty" url:"duration_minutes,omitempty"`
	// The ID of the [CatalogItemVariation](entity:CatalogItemVariation) object representing the service booked in this segment.
	ServiceVariationID *string `json:"service_variation_id,omitempty" url:"service_variation_id,omitempty"`
	// The ID of the [TeamMember](entity:TeamMember) object representing the team member booked in this segment.
	TeamMemberID string `json:"team_member_id" url:"team_member_id"`
	// The current version of the item variation representing the service booked in this segment.
	ServiceVariationVersion *int64 `json:"service_variation_version,omitempty" url:"service_variation_version,omitempty"`
	// Time between the end of this segment and the beginning of the subsequent segment.
	IntermissionMinutes *int `json:"intermission_minutes,omitempty" url:"intermission_minutes,omitempty"`
	// Whether the customer accepts any team member, instead of a specific one, to serve this segment.
	AnyTeamMember *bool `json:"any_team_member,omitempty" url:"any_team_member,omitempty"`
	// The IDs of the seller-accessible resources used for this appointment segment.
	ResourceIDs []string `json:"resource_ids,omitempty" url:"resource_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AppointmentSegment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppointmentSegment) UnmarshalJSON(data []byte) error {
	type unmarshaler AppointmentSegment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppointmentSegment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppointmentSegment) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Defines the values for the `archived_state` query expression
// used in [SearchCatalogItems]($e/Catalog/SearchCatalogItems)
// to return the archived, not archived or either type of catalog items.
type ArchivedState string

const (
	ArchivedStateArchivedStateNotArchived ArchivedState = "ARCHIVED_STATE_NOT_ARCHIVED"
	ArchivedStateArchivedStateArchived    ArchivedState = "ARCHIVED_STATE_ARCHIVED"
	ArchivedStateArchivedStateAll         ArchivedState = "ARCHIVED_STATE_ALL"
)

func NewArchivedStateFromString(s string) (ArchivedState, error) {
	switch s {
	case "ARCHIVED_STATE_NOT_ARCHIVED":
		return ArchivedStateArchivedStateNotArchived, nil
	case "ARCHIVED_STATE_ARCHIVED":
		return ArchivedStateArchivedStateArchived, nil
	case "ARCHIVED_STATE_ALL":
		return ArchivedStateArchivedStateAll, nil
	}
	var t ArchivedState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ArchivedState) Ptr() *ArchivedState {
	return &a
}

// Defines an appointment slot that encapsulates the appointment segments, location and starting time available for booking.
type Availability struct {
	// The RFC 3339 timestamp specifying the beginning time of the slot available for booking.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// The ID of the location available for booking.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The list of appointment segments available for booking
	AppointmentSegments []*AppointmentSegment `json:"appointment_segments,omitempty" url:"appointment_segments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Availability) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Availability) UnmarshalJSON(data []byte) error {
	type unmarshaler Availability
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Availability(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Availability) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents a bank account. For more information about
// linking a bank account to a Square account, see
// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
type BankAccount struct {
	// The unique, Square-issued identifier for the bank account.
	ID string `json:"id" url:"id"`
	// The last few digits of the account number.
	AccountNumberSuffix string `json:"account_number_suffix" url:"account_number_suffix"`
	// The ISO 3166 Alpha-2 country code where the bank account is based.
	// See [Country](#type-country) for possible values
	Country Country `json:"country" url:"country"`
	// The 3-character ISO 4217 currency code indicating the operating
	// currency of the bank account. For example, the currency code for US dollars
	// is `USD`.
	// See [Currency](#type-currency) for possible values
	Currency Currency `json:"currency" url:"currency"`
	// The financial purpose of the associated bank account.
	// See [BankAccountType](#type-bankaccounttype) for possible values
	AccountType BankAccountType `json:"account_type" url:"account_type"`
	// Name of the account holder. This name must match the name
	// on the targeted bank account record.
	HolderName string `json:"holder_name" url:"holder_name"`
	// Primary identifier for the bank. For more information, see
	// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
	PrimaryBankIdentificationNumber string `json:"primary_bank_identification_number" url:"primary_bank_identification_number"`
	// Secondary identifier for the bank. For more information, see
	// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
	SecondaryBankIdentificationNumber *string `json:"secondary_bank_identification_number,omitempty" url:"secondary_bank_identification_number,omitempty"`
	// Reference identifier that will be displayed to UK bank account owners
	// when collecting direct debit authorization. Only required for UK bank accounts.
	DebitMandateReferenceID *string `json:"debit_mandate_reference_id,omitempty" url:"debit_mandate_reference_id,omitempty"`
	// Client-provided identifier for linking the banking account to an entity
	// in a third-party system (for example, a bank account number or a user identifier).
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The location to which the bank account belongs.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Read-only. The current verification status of this BankAccount object.
	// See [BankAccountStatus](#type-bankaccountstatus) for possible values
	Status BankAccountStatus `json:"status" url:"status"`
	// Indicates whether it is possible for Square to send money to this bank account.
	Creditable bool `json:"creditable" url:"creditable"`
	// Indicates whether it is possible for Square to take money from this
	// bank account.
	Debitable bool `json:"debitable" url:"debitable"`
	// A Square-assigned, unique identifier for the bank account based on the
	// account information. The account fingerprint can be used to compare account
	// entries and determine if the they represent the same real-world bank account.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// The current version of the `BankAccount`.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// Read only. Name of actual financial institution.
	// For example "Bank of America".
	BankName *string `json:"bank_name,omitempty" url:"bank_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccount) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccount) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Additional details about BANK_ACCOUNT type payments.
type BankAccountPaymentDetails struct {
	// The name of the bank associated with the bank account.
	BankName *string `json:"bank_name,omitempty" url:"bank_name,omitempty"`
	// The type of the bank transfer. The type can be `ACH` or `UNKNOWN`.
	TransferType *string `json:"transfer_type,omitempty" url:"transfer_type,omitempty"`
	// The ownership type of the bank account performing the transfer.
	// The type can be `INDIVIDUAL`, `COMPANY`, or `ACCOUNT_TYPE_UNKNOWN`.
	AccountOwnershipType *string `json:"account_ownership_type,omitempty" url:"account_ownership_type,omitempty"`
	// Uniquely identifies the bank account for this seller and can be used
	// to determine if payments are from the same bank account.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// The two-letter ISO code representing the country the bank account is located in.
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The statement description as sent to the bank.
	StatementDescription *string `json:"statement_description,omitempty" url:"statement_description,omitempty"`
	// ACH-specific information about the transfer. The information is only populated
	// if the `transfer_type` is `ACH`.
	AchDetails *AchDetails `json:"ach_details,omitempty" url:"ach_details,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountPaymentDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountPaymentDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Indicates the current verification status of a `BankAccount` object.
type BankAccountStatus string

const (
	BankAccountStatusVerificationInProgress BankAccountStatus = "VERIFICATION_IN_PROGRESS"
	BankAccountStatusVerified               BankAccountStatus = "VERIFIED"
	BankAccountStatusDisabled               BankAccountStatus = "DISABLED"
)

func NewBankAccountStatusFromString(s string) (BankAccountStatus, error) {
	switch s {
	case "VERIFICATION_IN_PROGRESS":
		return BankAccountStatusVerificationInProgress, nil
	case "VERIFIED":
		return BankAccountStatusVerified, nil
	case "DISABLED":
		return BankAccountStatusDisabled, nil
	}
	var t BankAccountStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankAccountStatus) Ptr() *BankAccountStatus {
	return &b
}

// Indicates the financial purpose of the bank account.
type BankAccountType string

const (
	BankAccountTypeChecking         BankAccountType = "CHECKING"
	BankAccountTypeSavings          BankAccountType = "SAVINGS"
	BankAccountTypeInvestment       BankAccountType = "INVESTMENT"
	BankAccountTypeOther            BankAccountType = "OTHER"
	BankAccountTypeBusinessChecking BankAccountType = "BUSINESS_CHECKING"
)

func NewBankAccountTypeFromString(s string) (BankAccountType, error) {
	switch s {
	case "CHECKING":
		return BankAccountTypeChecking, nil
	case "SAVINGS":
		return BankAccountTypeSavings, nil
	case "INVESTMENT":
		return BankAccountTypeInvestment, nil
	case "OTHER":
		return BankAccountTypeOther, nil
	case "BUSINESS_CHECKING":
		return BankAccountTypeBusinessChecking, nil
	}
	var t BankAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankAccountType) Ptr() *BankAccountType {
	return &b
}

type BatchChangeInventoryRequest struct {
	// A client-supplied, universally unique identifier (UUID) for the
	// request.
	//
	// See [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) in the
	// [API Development 101](https://developer.squareup.com/docs/buildbasics) section for more
	// information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The set of physical counts and inventory adjustments to be made.
	// Changes are applied based on the client-supplied timestamp and may be sent
	// out of order.
	Changes []*InventoryChange `json:"changes,omitempty" url:"changes,omitempty"`
	// Indicates whether the current physical count should be ignored if
	// the quantity is unchanged since the last physical count. Default: `true`.
	IgnoreUnchangedCounts *bool `json:"ignore_unchanged_counts,omitempty" url:"ignore_unchanged_counts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchChangeInventoryRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchChangeInventoryRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchChangeInventoryRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchChangeInventoryRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchChangeInventoryRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchChangeInventoryResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The current counts for all objects referenced in the request.
	Counts []*InventoryCount `json:"counts,omitempty" url:"counts,omitempty"`
	// Changes created for the request.
	Changes []*InventoryChange `json:"changes,omitempty" url:"changes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchChangeInventoryResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchChangeInventoryResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchChangeInventoryResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchChangeInventoryResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchChangeInventoryResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response from a bulk create request containing the created `TeamMember` objects or error messages.
type BatchCreateTeamMembersResponse struct {
	// The successfully created `TeamMember` objects. Each key is the `idempotency_key` that maps to the `CreateTeamMemberRequest`.
	TeamMembers map[string]*CreateTeamMemberResponse `json:"team_members,omitempty" url:"team_members,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchCreateTeamMembersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchCreateTeamMembersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchCreateTeamMembersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchCreateTeamMembersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchCreateTeamMembersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an output from a call to [BulkCreateVendors]($e/Vendors/BulkCreateVendors).
type BatchCreateVendorsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A set of [CreateVendorResponse](entity:CreateVendorResponse) objects encapsulating successfully created [Vendor](entity:Vendor)
	// objects or error responses for failed attempts. The set is represented by
	// a collection of idempotency-key/`Vendor`-object or idempotency-key/error-object pairs. The idempotency keys correspond to those specified
	// in the input.
	Responses map[string]*CreateVendorResponse `json:"responses,omitempty" url:"responses,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchCreateVendorsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchCreateVendorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchCreateVendorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchCreateVendorsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchCreateVendorsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchDeleteCatalogObjectsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The IDs of all CatalogObjects deleted by this request.
	DeletedObjectIDs []string `json:"deleted_object_ids,omitempty" url:"deleted_object_ids,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) of this deletion in RFC 3339 format, e.g., "2016-09-04T23:59:33.123Z".
	DeletedAt *string `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchDeleteCatalogObjectsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchDeleteCatalogObjectsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchDeleteCatalogObjectsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchDeleteCatalogObjectsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchDeleteCatalogObjectsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchGetCatalogObjectsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A list of [CatalogObject](entity:CatalogObject)s returned.
	Objects []*CatalogObject `json:"objects,omitempty" url:"objects,omitempty"`
	// A list of [CatalogObject](entity:CatalogObject)s referenced by the object in the `objects` field.
	RelatedObjects []*CatalogObject `json:"related_objects,omitempty" url:"related_objects,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchGetCatalogObjectsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchGetCatalogObjectsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchGetCatalogObjectsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchGetCatalogObjectsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchGetCatalogObjectsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchGetInventoryChangesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The current calculated inventory changes for the requested objects
	// and locations.
	Changes []*InventoryChange `json:"changes,omitempty" url:"changes,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchGetInventoryChangesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchGetInventoryChangesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchGetInventoryChangesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchGetInventoryChangesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchGetInventoryChangesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchGetInventoryCountsRequest struct {
	// The filter to return results by `CatalogObject` ID.
	// The filter is applicable only when set. The default is null.
	CatalogObjectIDs []string `json:"catalog_object_ids,omitempty" url:"catalog_object_ids,omitempty"`
	// The filter to return results by `Location` ID.
	// This filter is applicable only when set. The default is null.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// The filter to return results with their `calculated_at` value
	// after the given time as specified in an RFC 3339 timestamp.
	// The default value is the UNIX epoch of (`1970-01-01T00:00:00Z`).
	UpdatedAfter *string `json:"updated_after,omitempty" url:"updated_after,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for the original query.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The filter to return results by `InventoryState`. The filter is only applicable when set.
	// Ignored are untracked states of `NONE`, `SOLD`, and `UNLINKED_RETURN`.
	// The default is null.
	States []InventoryState `json:"states,omitempty" url:"states,omitempty"`
	// The number of [records](entity:InventoryCount) to return.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchGetInventoryCountsRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchGetInventoryCountsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchGetInventoryCountsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchGetInventoryCountsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchGetInventoryCountsRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchGetInventoryCountsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The current calculated inventory counts for the requested objects
	// and locations.
	Counts []*InventoryCount `json:"counts,omitempty" url:"counts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchGetInventoryCountsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchGetInventoryCountsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchGetInventoryCountsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchGetInventoryCountsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchGetInventoryCountsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the fields that are included in the response body of
// a request to the `BatchRetrieveOrders` endpoint.
type BatchGetOrdersResponse struct {
	// The requested orders. This will omit any requested orders that do not exist.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchGetOrdersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchGetOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchGetOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchGetOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchGetOrdersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an output from a call to [BulkRetrieveVendors]($e/Vendors/BulkRetrieveVendors).
type BatchGetVendorsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The set of [RetrieveVendorResponse](entity:RetrieveVendorResponse) objects encapsulating successfully retrieved [Vendor](entity:Vendor)
	// objects or error responses for failed attempts. The set is represented by
	// a collection of `Vendor`-ID/`Vendor`-object or `Vendor`-ID/error-object pairs.
	Responses map[string]*GetVendorResponse `json:"responses,omitempty" url:"responses,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchGetVendorsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchGetVendorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchGetVendorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchGetVendorsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchGetVendorsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchRetrieveInventoryChangesRequest struct {
	// The filter to return results by `CatalogObject` ID.
	// The filter is only applicable when set. The default value is null.
	CatalogObjectIDs []string `json:"catalog_object_ids,omitempty" url:"catalog_object_ids,omitempty"`
	// The filter to return results by `Location` ID.
	// The filter is only applicable when set. The default value is null.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// The filter to return results by `InventoryChangeType` values other than `TRANSFER`.
	// The default value is `[PHYSICAL_COUNT, ADJUSTMENT]`.
	Types []InventoryChangeType `json:"types,omitempty" url:"types,omitempty"`
	// The filter to return `ADJUSTMENT` query results by
	// `InventoryState`. This filter is only applied when set.
	// The default value is null.
	States []InventoryState `json:"states,omitempty" url:"states,omitempty"`
	// The filter to return results with their `calculated_at` value
	// after the given time as specified in an RFC 3339 timestamp.
	// The default value is the UNIX epoch of (`1970-01-01T00:00:00Z`).
	UpdatedAfter *string `json:"updated_after,omitempty" url:"updated_after,omitempty"`
	// The filter to return results with their `created_at` or `calculated_at` value
	// strictly before the given time as specified in an RFC 3339 timestamp.
	// The default value is the UNIX epoch of (`1970-01-01T00:00:00Z`).
	UpdatedBefore *string `json:"updated_before,omitempty" url:"updated_before,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for the original query.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The number of [records](entity:InventoryChange) to return.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchRetrieveInventoryChangesRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchRetrieveInventoryChangesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchRetrieveInventoryChangesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchRetrieveInventoryChangesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchRetrieveInventoryChangesRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response from a bulk update request containing the updated `TeamMember` objects or error messages.
type BatchUpdateTeamMembersResponse struct {
	// The successfully updated `TeamMember` objects. Each key is the `team_member_id` that maps to the `UpdateTeamMemberRequest`.
	TeamMembers map[string]*UpdateTeamMemberResponse `json:"team_members,omitempty" url:"team_members,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchUpdateTeamMembersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpdateTeamMembersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpdateTeamMembersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpdateTeamMembersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpdateTeamMembersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an output from a call to [BulkUpdateVendors]($e/Vendors/BulkUpdateVendors).
type BatchUpdateVendorsResponse struct {
	// Errors encountered when the request fails.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A set of [UpdateVendorResponse](entity:UpdateVendorResponse) objects encapsulating successfully created [Vendor](entity:Vendor)
	// objects or error responses for failed attempts. The set is represented by a collection of `Vendor`-ID/`UpdateVendorResponse`-object or
	// `Vendor`-ID/error-object pairs.
	Responses map[string]*UpdateVendorResponse `json:"responses,omitempty" url:"responses,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchUpdateVendorsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpdateVendorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpdateVendorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpdateVendorsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpdateVendorsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BatchUpsertCatalogObjectsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created successfully created CatalogObjects.
	Objects []*CatalogObject `json:"objects,omitempty" url:"objects,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) of this update in RFC 3339 format, e.g., "2016-09-04T23:59:33.123Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The mapping between client and server IDs for this upsert.
	IDMappings []*CatalogIDMapping `json:"id_mappings,omitempty" url:"id_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchUpsertCatalogObjectsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCatalogObjectsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCatalogObjectsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCatalogObjectsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCatalogObjectsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertCustomerCustomAttributes]($e/CustomerCustomAttributes/BulkUpsertCustomerCustomAttributes)
// request. An individual request contains a customer ID, the custom attribute to create or update,
// and an optional idempotency key.
type BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest struct {
	// The ID of the target [customer profile](entity:Customer).
	CustomerID string `json:"customer_id" url:"customer_id"`
	// The custom attribute to create or update, with following fields:
	//
	//   - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	//     account. If the requesting application is not the definition owner, you must provide the qualified key.
	//
	//   - `value`. This value must conform to the `schema` specified by the definition.
	//     For more information, see [Value data types](https://developer.squareup.com/docs/customer-custom-attributes-api/custom-attributes#value-data-types).
	//
	//   - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	//     control for update operations, include this optional field in the request and set the
	//     value to the current version of the custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertCustomerCustomAttributes]($e/CustomerCustomAttributes/BulkUpsertCustomerCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BatchUpsertCustomerCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `customer_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchUpsertCustomerCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCustomerCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCustomerCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCustomerCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCustomerCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertCustomerCustomAttributes]($e/CustomerCustomAttributes/BulkUpsertCustomerCustomAttributes) operation.
type BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse struct {
	// The ID of the customer profile associated with the custom attribute.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a booking as a time-bound service contract for a seller's staff member to provide a specified service
// at a given location to a requesting customer in one or more appointment segments.
type Booking struct {
	// A unique ID of this object representing a booking.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The revision number for the booking used for optimistic concurrency.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The status of the booking, describing where the booking stands with respect to the booking state machine.
	// See [BookingStatus](#type-bookingstatus) for possible values
	Status *BookingStatus `json:"status,omitempty" url:"status,omitempty"`
	// The RFC 3339 timestamp specifying the creation time of this booking.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The RFC 3339 timestamp specifying the most recent update time of this booking.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The RFC 3339 timestamp specifying the starting time of this booking.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// The ID of the [Location](entity:Location) object representing the location where the booked service is provided. Once set when the booking is created, its value cannot be changed.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the [Customer](entity:Customer) object representing the customer receiving the booked service.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The free-text field for the customer to supply notes about the booking. For example, the note can be preferences that cannot be expressed by supported attributes of a relevant [CatalogObject](entity:CatalogObject) instance.
	CustomerNote *string `json:"customer_note,omitempty" url:"customer_note,omitempty"`
	// The free-text field for the seller to supply notes about the booking. For example, the note can be preferences that cannot be expressed by supported attributes of a specific [CatalogObject](entity:CatalogObject) instance.
	// This field should not be visible to customers.
	SellerNote *string `json:"seller_note,omitempty" url:"seller_note,omitempty"`
	// A list of appointment segments for this booking.
	AppointmentSegments []*AppointmentSegment `json:"appointment_segments,omitempty" url:"appointment_segments,omitempty"`
	// Additional time at the end of a booking.
	// Applications should not make this field visible to customers of a seller.
	TransitionTimeMinutes *int `json:"transition_time_minutes,omitempty" url:"transition_time_minutes,omitempty"`
	// Whether the booking is of a full business day.
	AllDay *bool `json:"all_day,omitempty" url:"all_day,omitempty"`
	// The type of location where the booking is held.
	// See [BusinessAppointmentSettingsBookingLocationType](#type-businessappointmentsettingsbookinglocationtype) for possible values
	LocationType *BusinessAppointmentSettingsBookingLocationType `json:"location_type,omitempty" url:"location_type,omitempty"`
	// Information about the booking creator.
	CreatorDetails *BookingCreatorDetails `json:"creator_details,omitempty" url:"creator_details,omitempty"`
	// The source of the booking.
	// Access to this field requires seller-level permissions.
	// See [BookingBookingSource](#type-bookingbookingsource) for possible values
	Source *BookingBookingSource `json:"source,omitempty" url:"source,omitempty"`
	// Stores a customer address if the location type is `CUSTOMER_LOCATION`.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Booking) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Booking) UnmarshalJSON(data []byte) error {
	type unmarshaler Booking
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Booking(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Booking) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Supported sources a booking was created from.
type BookingBookingSource string

const (
	BookingBookingSourceFirstPartyMerchant BookingBookingSource = "FIRST_PARTY_MERCHANT"
	BookingBookingSourceFirstPartyBuyer    BookingBookingSource = "FIRST_PARTY_BUYER"
	BookingBookingSourceThirdPartyBuyer    BookingBookingSource = "THIRD_PARTY_BUYER"
	BookingBookingSourceAPI                BookingBookingSource = "API"
)

func NewBookingBookingSourceFromString(s string) (BookingBookingSource, error) {
	switch s {
	case "FIRST_PARTY_MERCHANT":
		return BookingBookingSourceFirstPartyMerchant, nil
	case "FIRST_PARTY_BUYER":
		return BookingBookingSourceFirstPartyBuyer, nil
	case "THIRD_PARTY_BUYER":
		return BookingBookingSourceThirdPartyBuyer, nil
	case "API":
		return BookingBookingSourceAPI, nil
	}
	var t BookingBookingSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookingBookingSource) Ptr() *BookingBookingSource {
	return &b
}

// Information about a booking creator.
type BookingCreatorDetails struct {
	// The seller-accessible type of the creator of the booking.
	// See [BookingCreatorDetailsCreatorType](#type-bookingcreatordetailscreatortype) for possible values
	CreatorType *BookingCreatorDetailsCreatorType `json:"creator_type,omitempty" url:"creator_type,omitempty"`
	// The ID of the team member who created the booking, when the booking creator is of the `TEAM_MEMBER` type.
	// Access to this field requires seller-level permissions.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The ID of the customer who created the booking, when the booking creator is of the `CUSTOMER` type.
	// Access to this field requires seller-level permissions.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCreatorDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatorDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatorDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatorDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatorDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Supported types of a booking creator.
type BookingCreatorDetailsCreatorType string

const (
	BookingCreatorDetailsCreatorTypeTeamMember BookingCreatorDetailsCreatorType = "TEAM_MEMBER"
	BookingCreatorDetailsCreatorTypeCustomer   BookingCreatorDetailsCreatorType = "CUSTOMER"
)

func NewBookingCreatorDetailsCreatorTypeFromString(s string) (BookingCreatorDetailsCreatorType, error) {
	switch s {
	case "TEAM_MEMBER":
		return BookingCreatorDetailsCreatorTypeTeamMember, nil
	case "CUSTOMER":
		return BookingCreatorDetailsCreatorTypeCustomer, nil
	}
	var t BookingCreatorDetailsCreatorType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookingCreatorDetailsCreatorType) Ptr() *BookingCreatorDetailsCreatorType {
	return &b
}

// Represents an individual delete request in a [BulkDeleteBookingCustomAttributes]($e/BookingCustomAttributes/BulkDeleteBookingCustomAttributes)
// request. An individual request contains a booking ID, the custom attribute to delete, and an optional idempotency key.
type BookingCustomAttributeDeleteRequest struct {
	// The ID of the target [booking](entity:Booking).
	BookingID string `json:"booking_id" url:"booking_id"`
	// The key of the custom attribute to delete. This key must match the `key` of a
	// custom attribute definition in the Square seller account. If the requesting application is not
	// the definition owner, you must use the qualified key.
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCustomAttributeDeleteRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDeleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDeleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDeleteRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDeleteRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkDeleteBookingCustomAttributes]($e/BookingCustomAttributes/BulkDeleteBookingCustomAttributes) operation.
type BookingCustomAttributeDeleteResponse struct {
	// The ID of the [booking](entity:Booking) associated with the custom attribute.
	BookingID *string `json:"booking_id,omitempty" url:"booking_id,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCustomAttributeDeleteResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDeleteResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDeleteResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertBookingCustomAttributes]($e/BookingCustomAttributes/BulkUpsertBookingCustomAttributes)
// request. An individual request contains a booking ID, the custom attribute to create or update,
// and an optional idempotency key.
type BookingCustomAttributeUpsertRequest struct {
	// The ID of the target [booking](entity:Booking).
	BookingID string `json:"booking_id" url:"booking_id"`
	// The custom attribute to create or update, with following fields:
	//
	//   - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	//     account. If the requesting application is not the definition owner, you must provide the qualified key.
	//
	//   - `value`. This value must conform to the `schema` specified by the definition.
	//     For more information, see [Value data types](https://developer.squareup.com/docs/booking-custom-attributes-api/custom-attributes#value-data-types).
	//
	//   - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	//     control for update operations, include this optional field in the request and set the
	//     value to the current version of the custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeUpsertRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeUpsertRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertBookingCustomAttributes]($e/BookingCustomAttributes/BulkUpsertBookingCustomAttributes) operation.
type BookingCustomAttributeUpsertResponse struct {
	// The ID of the [booking](entity:Booking) associated with the custom attribute.
	BookingID *string `json:"booking_id,omitempty" url:"booking_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BookingCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeUpsertResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeUpsertResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Supported booking statuses.
type BookingStatus string

const (
	BookingStatusPending             BookingStatus = "PENDING"
	BookingStatusCancelledByCustomer BookingStatus = "CANCELLED_BY_CUSTOMER"
	BookingStatusCancelledBySeller   BookingStatus = "CANCELLED_BY_SELLER"
	BookingStatusDeclined            BookingStatus = "DECLINED"
	BookingStatusAccepted            BookingStatus = "ACCEPTED"
	BookingStatusNoShow              BookingStatus = "NO_SHOW"
)

func NewBookingStatusFromString(s string) (BookingStatus, error) {
	switch s {
	case "PENDING":
		return BookingStatusPending, nil
	case "CANCELLED_BY_CUSTOMER":
		return BookingStatusCancelledByCustomer, nil
	case "CANCELLED_BY_SELLER":
		return BookingStatusCancelledBySeller, nil
	case "DECLINED":
		return BookingStatusDeclined, nil
	case "ACCEPTED":
		return BookingStatusAccepted, nil
	case "NO_SHOW":
		return BookingStatusNoShow, nil
	}
	var t BookingStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookingStatus) Ptr() *BookingStatus {
	return &b
}

// A record of an employee's break during a shift.
type Break struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// RFC 3339; follows the same timezone information as `Shift`. Precision up to
	// the minute is respected; seconds are truncated.
	StartAt string `json:"start_at" url:"start_at"`
	// RFC 3339; follows the same timezone information as `Shift`. Precision up to
	// the minute is respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// The `BreakType` that this `Break` was templated on.
	BreakTypeID string `json:"break_type_id" url:"break_type_id"`
	// A human-readable name.
	Name string `json:"name" url:"name"`
	// Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of
	// the break.
	ExpectedDuration string `json:"expected_duration" url:"expected_duration"`
	// Whether this break counts towards time worked for compensation
	// purposes.
	IsPaid bool `json:"is_paid" url:"is_paid"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Break) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Break) UnmarshalJSON(data []byte) error {
	type unmarshaler Break
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Break(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Break) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A defined break template that sets an expectation for possible `Break`
// instances on a `Shift`.
type BreakType struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the business location this type of break applies to.
	LocationID string `json:"location_id" url:"location_id"`
	// A human-readable name for this type of break. The name is displayed to
	// employees in Square products.
	BreakName string `json:"break_name" url:"break_name"`
	// Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of
	// this break. Precision less than minutes is truncated.
	//
	// Example for break expected duration of 15 minutes: T15M
	ExpectedDuration string `json:"expected_duration" url:"expected_duration"`
	// Whether this break counts towards time worked for compensation
	// purposes.
	IsPaid bool `json:"is_paid" url:"is_paid"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If a value is not
	// provided, Square's servers execute a "blind" write; potentially
	// overwriting another writer's data.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BreakType) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BreakType) UnmarshalJSON(data []byte) error {
	type unmarshaler BreakType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BreakType(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BreakType) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the customer data provided in individual create requests for a
// [BulkCreateCustomers]($e/Customers/BulkCreateCustomers) operation.
type BulkCreateCustomerData struct {
	// The given name (that is, the first name) associated with the customer profile.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The family name (that is, the last name) associated with the customer profile.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// A business name associated with the customer profile.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// A nickname for the customer profile.
	Nickname *string `json:"nickname,omitempty" url:"nickname,omitempty"`
	// The email address associated with the customer profile.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The physical address associated with the customer profile. For maximum length constraints,
	// see [Customer addresses](https://developer.squareup.com/docs/customers-api/use-the-api/keep-records#address).
	// The `first_name` and `last_name` fields are ignored if they are present in the request.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The phone number associated with the customer profile. The phone number must be valid
	// and can contain 9–16 digits, with an optional `+` prefix and country code. For more information,
	// see [Customer phone numbers](https://developer.squareup.com/docs/customers-api/use-the-api/keep-records#phone-number).
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// An optional second ID used to associate the customer profile with an
	// entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// A custom note associated with the customer profile.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The birthday associated with the customer profile, in `YYYY-MM-DD` or `MM-DD` format.
	// For example, specify `1998-09-21` for September 21, 1998, or `09-21` for September 21.
	// Birthdays are returned in `YYYY-MM-DD` format, where `YYYY` is the specified birth year or
	// `0000` if a birth year is not specified.
	Birthday *string `json:"birthday,omitempty" url:"birthday,omitempty"`
	// The tax ID associated with the customer profile. This field is available only for
	// customers of sellers in EU countries or the United Kingdom. For more information, see
	// [Customer tax IDs](https://developer.squareup.com/docs/customers-api/what-it-does#customer-tax-ids).
	TaxIDs *CustomerTaxIDs `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkCreateCustomerData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkCreateCustomerData) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkCreateCustomerData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkCreateCustomerData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkCreateCustomerData) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the fields included in the response body from the
// [BulkCreateCustomers]($e/Customers/BulkCreateCustomers) endpoint.
type BulkCreateCustomersResponse struct {
	// A map of responses that correspond to individual create requests, represented by
	// key-value pairs.
	//
	// Each key is the idempotency key that was provided for a create request and each value
	// is the corresponding response.
	// If the request succeeds, the value is the new customer profile.
	// If the request fails, the value contains any errors that occurred during the request.
	Responses map[string]*CreateCustomerResponse `json:"responses,omitempty" url:"responses,omitempty"`
	// Any top-level errors that prevented the bulk operation from running.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkCreateCustomersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkCreateCustomersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkCreateCustomersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkCreateCustomersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkCreateCustomersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkDeleteBookingCustomAttributes]($e/BookingCustomAttributes/BulkDeleteBookingCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual delete request.
type BulkDeleteBookingCustomAttributesResponse struct {
	// A map of responses that correspond to individual delete requests. Each response has the
	// same ID as the corresponding request and contains `booking_id` and `errors` field.
	Values map[string]*BookingCustomAttributeDeleteResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteBookingCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteBookingCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteBookingCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteBookingCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteBookingCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the fields included in the response body from the
// [BulkDeleteCustomers]($e/Customers/BulkDeleteCustomers) endpoint.
type BulkDeleteCustomersResponse struct {
	// A map of responses that correspond to individual delete requests, represented by
	// key-value pairs.
	//
	// Each key is the customer ID that was specified for a delete request and each value
	// is the corresponding response.
	// If the request succeeds, the value is an empty object (`{ }`).
	// If the request fails, the value contains any errors that occurred during the request.
	Responses map[string]*DeleteCustomerResponse `json:"responses,omitempty" url:"responses,omitempty"`
	// Any top-level errors that prevented the bulk operation from running.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteCustomersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteCustomersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteCustomersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteCustomersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteCustomersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete request in a [BulkDeleteLocationCustomAttributes]($e/LocationCustomAttributes/BulkDeleteLocationCustomAttributes)
// request. An individual request contains an optional ID of the associated custom attribute definition
// and optional key of the associated custom attribute definition.
type BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest struct {
	// The key of the associated custom attribute definition.
	// Represented as a qualified key if the requesting app is not the definition owner.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkDeleteLocationCustomAttributes]($e/LocationCustomAttributes/BulkDeleteLocationCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual delete request.
type BulkDeleteLocationCustomAttributesResponse struct {
	// A map of responses that correspond to individual delete requests. Each response has the
	// same key as the corresponding request.
	Values map[string]*BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteLocationCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteLocationCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteLocationCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteLocationCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteLocationCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete response in a [BulkDeleteLocationCustomAttributes]($e/LocationCustomAttributes/BulkDeleteLocationCustomAttributes)
// request.
type BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse struct {
	// The ID of the location associated with the custom attribute.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Errors that occurred while processing the individual LocationCustomAttributeDeleteRequest request
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete request in a [BulkDeleteMerchantCustomAttributes]($e/MerchantCustomAttributes/BulkDeleteMerchantCustomAttributes)
// request. An individual request contains an optional ID of the associated custom attribute definition
// and optional key of the associated custom attribute definition.
type BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest struct {
	// The key of the associated custom attribute definition.
	// Represented as a qualified key if the requesting app is not the definition owner.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkDeleteMerchantCustomAttributes]($e/MerchantCustomAttributes/BulkDeleteMerchantCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual delete request.
type BulkDeleteMerchantCustomAttributesResponse struct {
	// A map of responses that correspond to individual delete requests. Each response has the
	// same key as the corresponding request.
	Values map[string]*BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteMerchantCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteMerchantCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteMerchantCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteMerchantCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteMerchantCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete response in a [BulkDeleteMerchantCustomAttributes]($e/MerchantCustomAttributes/BulkDeleteMerchantCustomAttributes)
// request.
type BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse struct {
	// Errors that occurred while processing the individual MerchantCustomAttributeDeleteRequest request
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents one delete within the bulk operation.
type BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute struct {
	// The key of the custom attribute to delete. This key must match the key
	// of an existing custom attribute definition.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// The ID of the target [order](entity:Order).
	OrderID string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response from deleting one or more order custom attributes.
type BulkDeleteOrderCustomAttributesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A map of responses that correspond to individual delete requests. Each response has the same ID
	// as the corresponding request and contains either a `custom_attribute` or an `errors` field.
	Values map[string]*DeleteOrderCustomAttributeResponse `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkDeleteOrderCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteOrderCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteOrderCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteOrderCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteOrderCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Response payload for bulk retrieval of bookings.
type BulkRetrieveBookingsResponse struct {
	// Requested bookings returned as a map containing `booking_id` as the key and `RetrieveBookingResponse` as the value.
	Bookings map[string]*GetBookingResponse `json:"bookings,omitempty" url:"bookings,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkRetrieveBookingsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkRetrieveBookingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkRetrieveBookingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkRetrieveBookingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkRetrieveBookingsResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the fields included in the response body from the
// [BulkRetrieveCustomers]($e/Customers/BulkRetrieveCustomers) endpoint.
type BulkRetrieveCustomersResponse struct {
	// A map of responses that correspond to individual retrieve requests, represented by
	// key-value pairs.
	//
	// Each key is the customer ID that was specified for a retrieve request and each value
	// is the corresponding response.
	// If the request succeeds, the value is the requested customer profile.
	// If the request fails, the value contains any errors that occurred during the request.
	Responses map[string]*GetCustomerResponse `json:"responses,omitempty" url:"responses,omitempty"`
	// Any top-level errors that prevented the bulk operation from running.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkRetrieveCustomersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkRetrieveCustomersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkRetrieveCustomersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkRetrieveCustomersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkRetrieveCustomersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Response payload for the [BulkRetrieveTeamMemberBookingProfiles]($e/Bookings/BulkRetrieveTeamMemberBookingProfiles) endpoint.
type BulkRetrieveTeamMemberBookingProfilesResponse struct {
	// The returned team members' booking profiles, as a map with `team_member_id` as the key and [TeamMemberBookingProfile](entity:TeamMemberBookingProfile) the value.
	TeamMemberBookingProfiles map[string]*GetTeamMemberBookingProfileResponse `json:"team_member_booking_profiles,omitempty" url:"team_member_booking_profiles,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkRetrieveTeamMemberBookingProfilesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkRetrieveTeamMemberBookingProfilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkRetrieveTeamMemberBookingProfilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkRetrieveTeamMemberBookingProfilesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkRetrieveTeamMemberBookingProfilesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines output parameters in a response of the
// [BulkSwapPlan]($e/Subscriptions/BulkSwapPlan) endpoint.
type BulkSwapPlanResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The number of affected subscriptions.
	AffectedSubscriptions *int `json:"affected_subscriptions,omitempty" url:"affected_subscriptions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkSwapPlanResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkSwapPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkSwapPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkSwapPlanResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSwapPlanResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the customer data provided in individual update requests for a
// [BulkUpdateCustomers]($e/Customers/BulkUpdateCustomers) operation.
type BulkUpdateCustomerData struct {
	// The given name (that is, the first name) associated with the customer profile.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The family name (that is, the last name) associated with the customer profile.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// A business name associated with the customer profile.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// A nickname for the customer profile.
	Nickname *string `json:"nickname,omitempty" url:"nickname,omitempty"`
	// The email address associated with the customer profile.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The physical address associated with the customer profile. For maximum length constraints,
	// see [Customer addresses](https://developer.squareup.com/docs/customers-api/use-the-api/keep-records#address).
	// The `first_name` and `last_name` fields are ignored if they are present in the request.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The phone number associated with the customer profile. The phone number must be valid
	// and can contain 9–16 digits, with an optional `+` prefix and country code. For more information,
	// see [Customer phone numbers](https://developer.squareup.com/docs/customers-api/use-the-api/keep-records#phone-number).
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// An optional second ID used to associate the customer profile with an
	// entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// An custom note associates with the customer profile.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The birthday associated with the customer profile, in `YYYY-MM-DD` or `MM-DD` format.
	// For example, specify `1998-09-21` for September 21, 1998, or `09-21` for September 21.
	// Birthdays are returned in `YYYY-MM-DD` format, where `YYYY` is the specified birth year or
	// `0000` if a birth year is not specified.
	Birthday *string `json:"birthday,omitempty" url:"birthday,omitempty"`
	// The tax ID associated with the customer profile. This field is available only for
	// customers of sellers in EU countries or the United Kingdom. For more information, see
	// [Customer tax IDs](https://developer.squareup.com/docs/customers-api/what-it-does#customer-tax-ids).
	TaxIDs *CustomerTaxIDs `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`
	// The current version of the customer profile.
	//
	// As a best practice, you should include this field to enable
	// [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpdateCustomerData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpdateCustomerData) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpdateCustomerData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpdateCustomerData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpdateCustomerData) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the fields included in the response body from the
// [BulkUpdateCustomers]($e/Customers/BulkUpdateCustomers) endpoint.
type BulkUpdateCustomersResponse struct {
	// A map of responses that correspond to individual update requests, represented by
	// key-value pairs.
	//
	// Each key is the customer ID that was specified for an update request and each value
	// is the corresponding response.
	// If the request succeeds, the value is the updated customer profile.
	// If the request fails, the value contains any errors that occurred during the request.
	Responses map[string]*UpdateCustomerResponse `json:"responses,omitempty" url:"responses,omitempty"`
	// Any top-level errors that prevented the bulk operation from running.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpdateCustomersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpdateCustomersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpdateCustomersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpdateCustomersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpdateCustomersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertBookingCustomAttributes]($e/BookingCustomAttributes/BulkUpsertBookingCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BulkUpsertBookingCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `booking_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BookingCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertBookingCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertBookingCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertBookingCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertBookingCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertBookingCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertLocationCustomAttributes]($e/LocationCustomAttributes/BulkUpsertLocationCustomAttributes)
// request. An individual request contains a location ID, the custom attribute to create or update,
// and an optional idempotency key.
type BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest struct {
	// The ID of the target [location](entity:Location).
	LocationID string `json:"location_id" url:"location_id"`
	// The custom attribute to create or update, with following fields:
	//
	//   - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	//     account. If the requesting application is not the definition owner, you must provide the qualified key.
	//   - `value`. This value must conform to the `schema` specified by the definition.
	//     For more information, see [Supported data types](https://developer.squareup.com/docs/devtools/customattributes/overview#supported-data-types)..
	//   - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	//     control, specify the current version of the custom attribute.
	//     If this is not important for your application, `version` can be set to -1.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertLocationCustomAttributes]($e/LocationCustomAttributes/BulkUpsertLocationCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BulkUpsertLocationCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `location_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertLocationCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertLocationCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertLocationCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertLocationCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertLocationCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertLocationCustomAttributes]($e/LocationCustomAttributes/BulkUpsertLocationCustomAttributes) operation.
type BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse struct {
	// The ID of the location associated with the custom attribute.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertMerchantCustomAttributes]($e/MerchantCustomAttributes/BulkUpsertMerchantCustomAttributes)
// request. An individual request contains a merchant ID, the custom attribute to create or update,
// and an optional idempotency key.
type BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest struct {
	// The ID of the target [merchant](entity:Merchant).
	MerchantID string `json:"merchant_id" url:"merchant_id"`
	// The custom attribute to create or update, with following fields:
	//
	//   - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	//     account. If the requesting application is not the definition owner, you must provide the qualified key.
	//   - `value`. This value must conform to the `schema` specified by the definition.
	//     For more information, see [Supported data types](https://developer.squareup.com/docs/devtools/customattributes/overview#supported-data-types).
	//   - The version field must match the current version of the custom attribute definition to enable
	//     [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	//     If this is not important for your application, version can be set to -1. For any other values, the request fails with a BAD_REQUEST error.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertMerchantCustomAttributes]($e/MerchantCustomAttributes/BulkUpsertMerchantCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BulkUpsertMerchantCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `merchant_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertMerchantCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertMerchantCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertMerchantCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertMerchantCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertMerchantCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertMerchantCustomAttributes]($e/MerchantCustomAttributes/BulkUpsertMerchantCustomAttributes) operation.
type BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse struct {
	// The ID of the merchant associated with the custom attribute.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents one upsert within the bulk operation.
type BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute struct {
	// The custom attribute to create or update, with the following fields:
	//
	//   - `value`. This value must conform to the `schema` specified by the definition.
	//     For more information, see [Value data types](https://developer.squareup.com/docs/customer-custom-attributes-api/custom-attributes#value-data-types).
	//
	//   - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	//     control, include this optional field and specify the current version of the custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// A unique identifier for this request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`
	// The ID of the target [order](entity:Order).
	OrderID string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response from a bulk upsert of order custom attributes.
type BulkUpsertOrderCustomAttributesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A map of responses that correspond to individual upsert operations for custom attributes.
	Values map[string]*UpsertOrderCustomAttributeResponse `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BulkUpsertOrderCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertOrderCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertOrderCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertOrderCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertOrderCustomAttributesResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The service appointment settings, including where and how the service is provided.
type BusinessAppointmentSettings struct {
	// Types of the location allowed for bookings.
	// See [BusinessAppointmentSettingsBookingLocationType](#type-businessappointmentsettingsbookinglocationtype) for possible values
	LocationTypes []BusinessAppointmentSettingsBookingLocationType `json:"location_types,omitempty" url:"location_types,omitempty"`
	// The time unit of the service duration for bookings.
	// See [BusinessAppointmentSettingsAlignmentTime](#type-businessappointmentsettingsalignmenttime) for possible values
	AlignmentTime *BusinessAppointmentSettingsAlignmentTime `json:"alignment_time,omitempty" url:"alignment_time,omitempty"`
	// The minimum lead time in seconds before a service can be booked. A booking must be created at least this amount of time before its starting time.
	MinBookingLeadTimeSeconds *int `json:"min_booking_lead_time_seconds,omitempty" url:"min_booking_lead_time_seconds,omitempty"`
	// The maximum lead time in seconds before a service can be booked. A booking must be created at most this amount of time before its starting time.
	MaxBookingLeadTimeSeconds *int `json:"max_booking_lead_time_seconds,omitempty" url:"max_booking_lead_time_seconds,omitempty"`
	// Indicates whether a customer can choose from all available time slots and have a staff member assigned
	// automatically (`true`) or not (`false`).
	AnyTeamMemberBookingEnabled *bool `json:"any_team_member_booking_enabled,omitempty" url:"any_team_member_booking_enabled,omitempty"`
	// Indicates whether a customer can book multiple services in a single online booking.
	MultipleServiceBookingEnabled *bool `json:"multiple_service_booking_enabled,omitempty" url:"multiple_service_booking_enabled,omitempty"`
	// Indicates whether the daily appointment limit applies to team members or to
	// business locations.
	// See [BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType](#type-businessappointmentsettingsmaxappointmentsperdaylimittype) for possible values
	MaxAppointmentsPerDayLimitType *BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType `json:"max_appointments_per_day_limit_type,omitempty" url:"max_appointments_per_day_limit_type,omitempty"`
	// The maximum number of daily appointments per team member or per location.
	MaxAppointmentsPerDayLimit *int `json:"max_appointments_per_day_limit,omitempty" url:"max_appointments_per_day_limit,omitempty"`
	// The cut-off time in seconds for allowing clients to cancel or reschedule an appointment.
	CancellationWindowSeconds *int `json:"cancellation_window_seconds,omitempty" url:"cancellation_window_seconds,omitempty"`
	// The flat-fee amount charged for a no-show booking.
	CancellationFeeMoney *Money `json:"cancellation_fee_money,omitempty" url:"cancellation_fee_money,omitempty"`
	// The cancellation policy adopted by the seller.
	// See [BusinessAppointmentSettingsCancellationPolicy](#type-businessappointmentsettingscancellationpolicy) for possible values
	CancellationPolicy *BusinessAppointmentSettingsCancellationPolicy `json:"cancellation_policy,omitempty" url:"cancellation_policy,omitempty"`
	// The free-form text of the seller's cancellation policy.
	CancellationPolicyText *string `json:"cancellation_policy_text,omitempty" url:"cancellation_policy_text,omitempty"`
	// Indicates whether customers has an assigned staff member (`true`) or can select s staff member of their choice (`false`).
	SkipBookingFlowStaffSelection *bool `json:"skip_booking_flow_staff_selection,omitempty" url:"skip_booking_flow_staff_selection,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessAppointmentSettings) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessAppointmentSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessAppointmentSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessAppointmentSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessAppointmentSettings) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Time units of a service duration for bookings.
type BusinessAppointmentSettingsAlignmentTime string

const (
	BusinessAppointmentSettingsAlignmentTimeServiceDuration BusinessAppointmentSettingsAlignmentTime = "SERVICE_DURATION"
	BusinessAppointmentSettingsAlignmentTimeQuarterHourly   BusinessAppointmentSettingsAlignmentTime = "QUARTER_HOURLY"
	BusinessAppointmentSettingsAlignmentTimeHalfHourly      BusinessAppointmentSettingsAlignmentTime = "HALF_HOURLY"
	BusinessAppointmentSettingsAlignmentTimeHourly          BusinessAppointmentSettingsAlignmentTime = "HOURLY"
)

func NewBusinessAppointmentSettingsAlignmentTimeFromString(s string) (BusinessAppointmentSettingsAlignmentTime, error) {
	switch s {
	case "SERVICE_DURATION":
		return BusinessAppointmentSettingsAlignmentTimeServiceDuration, nil
	case "QUARTER_HOURLY":
		return BusinessAppointmentSettingsAlignmentTimeQuarterHourly, nil
	case "HALF_HOURLY":
		return BusinessAppointmentSettingsAlignmentTimeHalfHourly, nil
	case "HOURLY":
		return BusinessAppointmentSettingsAlignmentTimeHourly, nil
	}
	var t BusinessAppointmentSettingsAlignmentTime
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsAlignmentTime) Ptr() *BusinessAppointmentSettingsAlignmentTime {
	return &b
}

// Supported types of location where service is provided.
type BusinessAppointmentSettingsBookingLocationType string

const (
	BusinessAppointmentSettingsBookingLocationTypeBusinessLocation BusinessAppointmentSettingsBookingLocationType = "BUSINESS_LOCATION"
	BusinessAppointmentSettingsBookingLocationTypeCustomerLocation BusinessAppointmentSettingsBookingLocationType = "CUSTOMER_LOCATION"
	BusinessAppointmentSettingsBookingLocationTypePhone            BusinessAppointmentSettingsBookingLocationType = "PHONE"
)

func NewBusinessAppointmentSettingsBookingLocationTypeFromString(s string) (BusinessAppointmentSettingsBookingLocationType, error) {
	switch s {
	case "BUSINESS_LOCATION":
		return BusinessAppointmentSettingsBookingLocationTypeBusinessLocation, nil
	case "CUSTOMER_LOCATION":
		return BusinessAppointmentSettingsBookingLocationTypeCustomerLocation, nil
	case "PHONE":
		return BusinessAppointmentSettingsBookingLocationTypePhone, nil
	}
	var t BusinessAppointmentSettingsBookingLocationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsBookingLocationType) Ptr() *BusinessAppointmentSettingsBookingLocationType {
	return &b
}

// The category of the seller’s cancellation policy.
type BusinessAppointmentSettingsCancellationPolicy string

const (
	BusinessAppointmentSettingsCancellationPolicyCancellationTreatedAsNoShow BusinessAppointmentSettingsCancellationPolicy = "CANCELLATION_TREATED_AS_NO_SHOW"
	BusinessAppointmentSettingsCancellationPolicyCustomPolicy                BusinessAppointmentSettingsCancellationPolicy = "CUSTOM_POLICY"
)

func NewBusinessAppointmentSettingsCancellationPolicyFromString(s string) (BusinessAppointmentSettingsCancellationPolicy, error) {
	switch s {
	case "CANCELLATION_TREATED_AS_NO_SHOW":
		return BusinessAppointmentSettingsCancellationPolicyCancellationTreatedAsNoShow, nil
	case "CUSTOM_POLICY":
		return BusinessAppointmentSettingsCancellationPolicyCustomPolicy, nil
	}
	var t BusinessAppointmentSettingsCancellationPolicy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsCancellationPolicy) Ptr() *BusinessAppointmentSettingsCancellationPolicy {
	return &b
}

// Types of daily appointment limits.
type BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType string

const (
	BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerTeamMember BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType = "PER_TEAM_MEMBER"
	BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerLocation   BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType = "PER_LOCATION"
)

func NewBusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypeFromString(s string) (BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType, error) {
	switch s {
	case "PER_TEAM_MEMBER":
		return BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerTeamMember, nil
	case "PER_LOCATION":
		return BusinessAppointmentSettingsMaxAppointmentsPerDayLimitTypePerLocation, nil
	}
	var t BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType) Ptr() *BusinessAppointmentSettingsMaxAppointmentsPerDayLimitType {
	return &b
}

// A seller's business booking profile, including booking policy, appointment settings, etc.
type BusinessBookingProfile struct {
	// The ID of the seller, obtainable using the Merchants API.
	SellerID *string `json:"seller_id,omitempty" url:"seller_id,omitempty"`
	// The RFC 3339 timestamp specifying the booking's creation time.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Indicates whether the seller is open for booking.
	BookingEnabled *bool `json:"booking_enabled,omitempty" url:"booking_enabled,omitempty"`
	// The choice of customer's time zone information of a booking.
	// The Square online booking site and all notifications to customers uses either the seller location’s time zone
	// or the time zone the customer chooses at booking.
	// See [BusinessBookingProfileCustomerTimezoneChoice](#type-businessbookingprofilecustomertimezonechoice) for possible values
	CustomerTimezoneChoice *BusinessBookingProfileCustomerTimezoneChoice `json:"customer_timezone_choice,omitempty" url:"customer_timezone_choice,omitempty"`
	// The policy for the seller to automatically accept booking requests (`ACCEPT_ALL`) or not (`REQUIRES_ACCEPTANCE`).
	// See [BusinessBookingProfileBookingPolicy](#type-businessbookingprofilebookingpolicy) for possible values
	BookingPolicy *BusinessBookingProfileBookingPolicy `json:"booking_policy,omitempty" url:"booking_policy,omitempty"`
	// Indicates whether customers can cancel or reschedule their own bookings (`true`) or not (`false`).
	AllowUserCancel *bool `json:"allow_user_cancel,omitempty" url:"allow_user_cancel,omitempty"`
	// Settings for appointment-type bookings.
	BusinessAppointmentSettings *BusinessAppointmentSettings `json:"business_appointment_settings,omitempty" url:"business_appointment_settings,omitempty"`
	// Indicates whether the seller's subscription to Square Appointments supports creating, updating or canceling an appointment through the API (`true`) or not (`false`) using seller permission.
	SupportSellerLevelWrites *bool `json:"support_seller_level_writes,omitempty" url:"support_seller_level_writes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessBookingProfile) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessBookingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessBookingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessBookingProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessBookingProfile) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Policies for accepting bookings.
type BusinessBookingProfileBookingPolicy string

const (
	BusinessBookingProfileBookingPolicyAcceptAll          BusinessBookingProfileBookingPolicy = "ACCEPT_ALL"
	BusinessBookingProfileBookingPolicyRequiresAcceptance BusinessBookingProfileBookingPolicy = "REQUIRES_ACCEPTANCE"
)

func NewBusinessBookingProfileBookingPolicyFromString(s string) (BusinessBookingProfileBookingPolicy, error) {
	switch s {
	case "ACCEPT_ALL":
		return BusinessBookingProfileBookingPolicyAcceptAll, nil
	case "REQUIRES_ACCEPTANCE":
		return BusinessBookingProfileBookingPolicyRequiresAcceptance, nil
	}
	var t BusinessBookingProfileBookingPolicy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessBookingProfileBookingPolicy) Ptr() *BusinessBookingProfileBookingPolicy {
	return &b
}

// Choices of customer-facing time zone used for bookings.
type BusinessBookingProfileCustomerTimezoneChoice string

const (
	BusinessBookingProfileCustomerTimezoneChoiceBusinessLocationTimezone BusinessBookingProfileCustomerTimezoneChoice = "BUSINESS_LOCATION_TIMEZONE"
	BusinessBookingProfileCustomerTimezoneChoiceCustomerChoice           BusinessBookingProfileCustomerTimezoneChoice = "CUSTOMER_CHOICE"
)

func NewBusinessBookingProfileCustomerTimezoneChoiceFromString(s string) (BusinessBookingProfileCustomerTimezoneChoice, error) {
	switch s {
	case "BUSINESS_LOCATION_TIMEZONE":
		return BusinessBookingProfileCustomerTimezoneChoiceBusinessLocationTimezone, nil
	case "CUSTOMER_CHOICE":
		return BusinessBookingProfileCustomerTimezoneChoiceCustomerChoice, nil
	}
	var t BusinessBookingProfileCustomerTimezoneChoice
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BusinessBookingProfileCustomerTimezoneChoice) Ptr() *BusinessBookingProfileCustomerTimezoneChoice {
	return &b
}

// The hours of operation for a location.
type BusinessHours struct {
	// The list of time periods during which the business is open. There can be at most 10 periods per day.
	Periods []*BusinessHoursPeriod `json:"periods,omitempty" url:"periods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessHours) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessHours) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessHours
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessHours(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessHours) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a period of time during which a business location is open.
type BusinessHoursPeriod struct {
	// The day of the week for this time period.
	// See [DayOfWeek](#type-dayofweek) for possible values
	DayOfWeek *DayOfWeek `json:"day_of_week,omitempty" url:"day_of_week,omitempty"`
	// The start time of a business hours period, specified in local time using partial-time
	// RFC 3339 format. For example, `8:30:00` for a period starting at 8:30 in the morning.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	StartLocalTime *string `json:"start_local_time,omitempty" url:"start_local_time,omitempty"`
	// The end time of a business hours period, specified in local time using partial-time
	// RFC 3339 format. For example, `21:00:00` for a period ending at 9:00 in the evening.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	EndLocalTime *string `json:"end_local_time,omitempty" url:"end_local_time,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessHoursPeriod) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessHoursPeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessHoursPeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessHoursPeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessHoursPeriod) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Additional details about a Buy Now Pay Later payment type.
type BuyNowPayLaterDetails struct {
	// The brand used for the Buy Now Pay Later payment.
	// The brand can be `AFTERPAY`, `CLEARPAY` or `UNKNOWN`.
	Brand *string `json:"brand,omitempty" url:"brand,omitempty"`
	// Details about an Afterpay payment. These details are only populated if the `brand` is
	// `AFTERPAY`.
	AfterpayDetails *AfterpayDetails `json:"afterpay_details,omitempty" url:"afterpay_details,omitempty"`
	// Details about a Clearpay payment. These details are only populated if the `brand` is
	// `CLEARPAY`.
	ClearpayDetails *ClearpayDetails `json:"clearpay_details,omitempty" url:"clearpay_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BuyNowPayLaterDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BuyNowPayLaterDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BuyNowPayLaterDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BuyNowPayLaterDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BuyNowPayLaterDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [CalculateLoyaltyPoints]($e/Loyalty/CalculateLoyaltyPoints) response.
type CalculateLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The number of points that the buyer can earn from the base loyalty program.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The number of points that the buyer can earn from a loyalty promotion. To be eligible
	// to earn promotion points, the purchase must first qualify for program points. When `order_id`
	// is not provided in the request, this value is always 0.
	PromotionPoints *int `json:"promotion_points,omitempty" url:"promotion_points,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CalculateLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CalculateLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CalculateLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CalculateLoyaltyPointsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CalculateLoyaltyPointsResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CalculateOrderResponse struct {
	// The calculated version of the order provided in the request.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CalculateOrderResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CalculateOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CalculateOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CalculateOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CalculateOrderResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelBookingResponse struct {
	// The booking that was cancelled.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelBookingResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelBookingResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response returned by the `CancelInvoice` request.
type CancelInvoiceResponse struct {
	// The canceled invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelInvoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelInvoiceResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CancelLoyaltyPromotion]($e/Loyalty/CancelLoyaltyPromotion) request.
type CancelLoyaltyPromotionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelLoyaltyPromotionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelLoyaltyPromotionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelLoyaltyPromotionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelLoyaltyPromotionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelLoyaltyPromotionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CancelLoyaltyPromotion]($e/Loyalty/CancelLoyaltyPromotion) response.
// Either `loyalty_promotion` or `errors` is present in the response.
type CancelLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelLoyaltyPromotionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelLoyaltyPromotionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the response returned by
// [CancelPaymentByIdempotencyKey]($e/Payments/CancelPaymentByIdempotencyKey).
// On success, `errors` is empty.
type CancelPaymentByIdempotencyKeyResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelPaymentByIdempotencyKeyResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelPaymentByIdempotencyKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelPaymentByIdempotencyKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelPaymentByIdempotencyKeyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelPaymentByIdempotencyKeyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes the request to cancel (void) a payment using
// [CancelPayment]($e/Payments/CancelPayment).
// You can only cancel a payment that is approved (not completed).
// For more information, see
// [Delayed capture of a payment](https://developer.squareup.com/docs/payments-api/take-payments/card-payments#delayed-capture-of-a-card-payment).
type CancelPaymentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelPaymentRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelPaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelPaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelPaymentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelPaymentRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the response returned by [CancelPayment]($e/Payments/CancelPayment).
type CancelPaymentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully canceled `Payment` object.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelPaymentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelPaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelPaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelPaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelPaymentResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines input parameters in a request to the
// [CancelSubscription]($e/Subscriptions/CancelSubscription) endpoint.
type CancelSubscriptionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelSubscriptionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelSubscriptionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelSubscriptionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelSubscriptionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelSubscriptionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines output parameters in a response from the
// [CancelSubscription]($e/Subscriptions/CancelSubscription) endpoint.
type CancelSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The specified subscription scheduled for cancellation according to the action created by the request.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a single `CANCEL` action scheduled for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelSubscriptionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalActionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalActionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalActionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalActionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalActionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalCheckoutRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalCheckoutRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalCheckoutRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalCheckoutRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalCheckoutRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalCheckoutRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalCheckoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalRefundRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalRefundRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalRefundRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated `TerminalRefund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CancelTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalRefundResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CaptureTransactionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CaptureTransactionRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaptureTransactionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CaptureTransactionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaptureTransactionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaptureTransactionRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CaptureTransaction](api-endpoint:Transactions-CaptureTransaction) endpoint.
type CaptureTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CaptureTransactionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaptureTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CaptureTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaptureTransactionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaptureTransactionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the payment details of a card to be used for payments. These
// details are determined by the payment token generated by Web Payments SDK.
type Card struct {
	// Unique ID for this card. Generated by Square.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The card's brand.
	// See [CardBrand](#type-cardbrand) for possible values
	CardBrand *CardBrand `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The last 4 digits of the card number.
	Last4 *string `json:"last_4,omitempty" url:"last_4,omitempty"`
	// The expiration month of the associated card as an integer between 1 and 12.
	ExpMonth *int64 `json:"exp_month,omitempty" url:"exp_month,omitempty"`
	// The four-digit year of the card's expiration date.
	ExpYear *int64 `json:"exp_year,omitempty" url:"exp_year,omitempty"`
	// The name of the cardholder.
	CardholderName *string `json:"cardholder_name,omitempty" url:"cardholder_name,omitempty"`
	// The billing address for this card.
	BillingAddress *Address `json:"billing_address,omitempty" url:"billing_address,omitempty"`
	// Intended as a Square-assigned identifier, based
	// on the card number, to identify the card across multiple locations within a
	// single application.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// **Required** The ID of a customer created using the Customers API to be associated with the card.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The ID of the merchant associated with the card.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// An optional user-defined reference ID that associates this card with
	// another entity in an external system. For example, a customer ID from an
	// external customer management system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Indicates whether or not a card can be used for payments.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The type of the card.
	// The Card object includes this field only in response to Payments API calls.
	// See [CardType](#type-cardtype) for possible values
	CardType *CardType `json:"card_type,omitempty" url:"card_type,omitempty"`
	// Indicates whether the Card is prepaid or not.
	// The Card object includes this field only in response to Payments API calls.
	// See [CardPrepaidType](#type-cardprepaidtype) for possible values
	PrepaidType *CardPrepaidType `json:"prepaid_type,omitempty" url:"prepaid_type,omitempty"`
	// The first six digits of the card number, known as the Bank Identification Number (BIN). Only the Payments API
	// returns this field.
	Bin *string `json:"bin,omitempty" url:"bin,omitempty"`
	// Current version number of the card. Increments with each card update. Requests to update an
	// existing Card object will be rejected unless the version in the request matches the current
	// version for the Card.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The card's co-brand if available. For example, an Afterpay virtual card would have a
	// co-brand of AFTERPAY.
	// See [CardCoBrand](#type-cardcobrand) for possible values
	CardCoBrand *CardCoBrand `json:"card_co_brand,omitempty" url:"card_co_brand,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Card) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Card) UnmarshalJSON(data []byte) error {
	type unmarshaler Card
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Card(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Card) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates a card's brand, such as `VISA` or `MASTERCARD`.
type CardBrand string

const (
	CardBrandOtherBrand        CardBrand = "OTHER_BRAND"
	CardBrandVisa              CardBrand = "VISA"
	CardBrandMastercard        CardBrand = "MASTERCARD"
	CardBrandAmericanExpress   CardBrand = "AMERICAN_EXPRESS"
	CardBrandDiscover          CardBrand = "DISCOVER"
	CardBrandDiscoverDiners    CardBrand = "DISCOVER_DINERS"
	CardBrandJcb               CardBrand = "JCB"
	CardBrandChinaUnionpay     CardBrand = "CHINA_UNIONPAY"
	CardBrandSquareGiftCard    CardBrand = "SQUARE_GIFT_CARD"
	CardBrandSquareCapitalCard CardBrand = "SQUARE_CAPITAL_CARD"
	CardBrandInterac           CardBrand = "INTERAC"
	CardBrandEftpos            CardBrand = "EFTPOS"
	CardBrandFelica            CardBrand = "FELICA"
	CardBrandEbt               CardBrand = "EBT"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return CardBrandOtherBrand, nil
	case "VISA":
		return CardBrandVisa, nil
	case "MASTERCARD":
		return CardBrandMastercard, nil
	case "AMERICAN_EXPRESS":
		return CardBrandAmericanExpress, nil
	case "DISCOVER":
		return CardBrandDiscover, nil
	case "DISCOVER_DINERS":
		return CardBrandDiscoverDiners, nil
	case "JCB":
		return CardBrandJcb, nil
	case "CHINA_UNIONPAY":
		return CardBrandChinaUnionpay, nil
	case "SQUARE_GIFT_CARD":
		return CardBrandSquareGiftCard, nil
	case "SQUARE_CAPITAL_CARD":
		return CardBrandSquareCapitalCard, nil
	case "INTERAC":
		return CardBrandInterac, nil
	case "EFTPOS":
		return CardBrandEftpos, nil
	case "FELICA":
		return CardBrandFelica, nil
	case "EBT":
		return CardBrandEbt, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

// Indicates the brand for a co-branded card.
type CardCoBrand string

const (
	CardCoBrandUnknown  CardCoBrand = "UNKNOWN"
	CardCoBrandAfterpay CardCoBrand = "AFTERPAY"
	CardCoBrandClearpay CardCoBrand = "CLEARPAY"
)

func NewCardCoBrandFromString(s string) (CardCoBrand, error) {
	switch s {
	case "UNKNOWN":
		return CardCoBrandUnknown, nil
	case "AFTERPAY":
		return CardCoBrandAfterpay, nil
	case "CLEARPAY":
		return CardCoBrandClearpay, nil
	}
	var t CardCoBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardCoBrand) Ptr() *CardCoBrand {
	return &c
}

// Reflects the current status of a card payment. Contains only non-confidential information.
type CardPaymentDetails struct {
	// The card payment's current state. The state can be AUTHORIZED, CAPTURED, VOIDED, or
	// FAILED.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The credit card's non-confidential details.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`
	// The method used to enter the card's details for the payment. The method can be
	// `KEYED`, `SWIPED`, `EMV`, `ON_FILE`, or `CONTACTLESS`.
	EntryMethod *string `json:"entry_method,omitempty" url:"entry_method,omitempty"`
	// The status code returned from the Card Verification Value (CVV) check. The code can be
	// `CVV_ACCEPTED`, `CVV_REJECTED`, or `CVV_NOT_CHECKED`.
	CvvStatus *string `json:"cvv_status,omitempty" url:"cvv_status,omitempty"`
	// The status code returned from the Address Verification System (AVS) check. The code can be
	// `AVS_ACCEPTED`, `AVS_REJECTED`, or `AVS_NOT_CHECKED`.
	AvsStatus *string `json:"avs_status,omitempty" url:"avs_status,omitempty"`
	// The status code returned by the card issuer that describes the payment's
	// authorization status.
	AuthResultCode *string `json:"auth_result_code,omitempty" url:"auth_result_code,omitempty"`
	// For EMV payments, the application ID identifies the EMV application used for the payment.
	ApplicationIdentifier *string `json:"application_identifier,omitempty" url:"application_identifier,omitempty"`
	// For EMV payments, the human-readable name of the EMV application used for the payment.
	ApplicationName *string `json:"application_name,omitempty" url:"application_name,omitempty"`
	// For EMV payments, the cryptogram generated for the payment.
	ApplicationCryptogram *string `json:"application_cryptogram,omitempty" url:"application_cryptogram,omitempty"`
	// For EMV payments, the method used to verify the cardholder's identity. The method can be
	// `PIN`, `SIGNATURE`, `PIN_AND_SIGNATURE`, `ON_DEVICE`, or `NONE`.
	VerificationMethod *string `json:"verification_method,omitempty" url:"verification_method,omitempty"`
	// For EMV payments, the results of the cardholder verification. The result can be
	// `SUCCESS`, `FAILURE`, or `UNKNOWN`.
	VerificationResults *string `json:"verification_results,omitempty" url:"verification_results,omitempty"`
	// The statement description sent to the card networks.
	//
	// Note: The actual statement description varies and is likely to be truncated and appended with
	// additional information on a per issuer basis.
	StatementDescription *string `json:"statement_description,omitempty" url:"statement_description,omitempty"`
	// **Deprecated**: Use `Payment.device_details` instead.
	//
	// Details about the device that took the payment.
	DeviceDetails *DeviceDetails `json:"device_details,omitempty" url:"device_details,omitempty"`
	// The timeline for card payments.
	CardPaymentTimeline *CardPaymentTimeline `json:"card_payment_timeline,omitempty" url:"card_payment_timeline,omitempty"`
	// Whether the card must be physically present for the payment to
	// be refunded. If set to `true`, the card must be present.
	RefundRequiresCardPresence *bool `json:"refund_requires_card_presence,omitempty" url:"refund_requires_card_presence,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardPaymentDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CardPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardPaymentDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The timeline for card payments.
type CardPaymentTimeline struct {
	// The timestamp when the payment was authorized, in RFC 3339 format.
	AuthorizedAt *string `json:"authorized_at,omitempty" url:"authorized_at,omitempty"`
	// The timestamp when the payment was captured, in RFC 3339 format.
	CapturedAt *string `json:"captured_at,omitempty" url:"captured_at,omitempty"`
	// The timestamp when the payment was voided, in RFC 3339 format.
	VoidedAt *string `json:"voided_at,omitempty" url:"voided_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardPaymentTimeline) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardPaymentTimeline) UnmarshalJSON(data []byte) error {
	type unmarshaler CardPaymentTimeline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardPaymentTimeline(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardPaymentTimeline) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates a card's prepaid type, such as `NOT_PREPAID` or `PREPAID`.
type CardPrepaidType string

const (
	CardPrepaidTypeUnknownPrepaidType CardPrepaidType = "UNKNOWN_PREPAID_TYPE"
	CardPrepaidTypeNotPrepaid         CardPrepaidType = "NOT_PREPAID"
	CardPrepaidTypePrepaid            CardPrepaidType = "PREPAID"
)

func NewCardPrepaidTypeFromString(s string) (CardPrepaidType, error) {
	switch s {
	case "UNKNOWN_PREPAID_TYPE":
		return CardPrepaidTypeUnknownPrepaidType, nil
	case "NOT_PREPAID":
		return CardPrepaidTypeNotPrepaid, nil
	case "PREPAID":
		return CardPrepaidTypePrepaid, nil
	}
	var t CardPrepaidType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardPrepaidType) Ptr() *CardPrepaidType {
	return &c
}

// Indicates a card's type, such as `CREDIT` or `DEBIT`.
type CardType string

const (
	CardTypeUnknownCardType CardType = "UNKNOWN_CARD_TYPE"
	CardTypeCredit          CardType = "CREDIT"
	CardTypeDebit           CardType = "DEBIT"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "UNKNOWN_CARD_TYPE":
		return CardTypeUnknownCardType, nil
	case "CREDIT":
		return CardTypeCredit, nil
	case "DEBIT":
		return CardTypeDebit, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

// Additional details about `WALLET` type payments with the `brand` of `CASH_APP`.
type CashAppDetails struct {
	// The name of the Cash App account holder.
	BuyerFullName *string `json:"buyer_full_name,omitempty" url:"buyer_full_name,omitempty"`
	// The country of the Cash App account holder, in ISO 3166-1-alpha-2 format.
	//
	// For possible values, see [Country](entity:Country).
	BuyerCountryCode *string `json:"buyer_country_code,omitempty" url:"buyer_country_code,omitempty"`
	// $Cashtag of the Cash App account holder.
	BuyerCashtag *string `json:"buyer_cashtag,omitempty" url:"buyer_cashtag,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashAppDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashAppDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CashAppDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashAppDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashAppDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CashDrawerDevice struct {
	// The device Square-issued ID
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The device merchant-specified name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerDevice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerDevice) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerDevice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerDevice(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerDevice) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The types of events on a CashDrawerShift.
// Each event type represents an employee action on the actual cash drawer
// represented by a CashDrawerShift.
type CashDrawerEventType string

const (
	CashDrawerEventTypeNoSale                      CashDrawerEventType = "NO_SALE"
	CashDrawerEventTypeCashTenderPayment           CashDrawerEventType = "CASH_TENDER_PAYMENT"
	CashDrawerEventTypeOtherTenderPayment          CashDrawerEventType = "OTHER_TENDER_PAYMENT"
	CashDrawerEventTypeCashTenderCancelledPayment  CashDrawerEventType = "CASH_TENDER_CANCELLED_PAYMENT"
	CashDrawerEventTypeOtherTenderCancelledPayment CashDrawerEventType = "OTHER_TENDER_CANCELLED_PAYMENT"
	CashDrawerEventTypeCashTenderRefund            CashDrawerEventType = "CASH_TENDER_REFUND"
	CashDrawerEventTypeOtherTenderRefund           CashDrawerEventType = "OTHER_TENDER_REFUND"
	CashDrawerEventTypePaidIn                      CashDrawerEventType = "PAID_IN"
	CashDrawerEventTypePaidOut                     CashDrawerEventType = "PAID_OUT"
)

func NewCashDrawerEventTypeFromString(s string) (CashDrawerEventType, error) {
	switch s {
	case "NO_SALE":
		return CashDrawerEventTypeNoSale, nil
	case "CASH_TENDER_PAYMENT":
		return CashDrawerEventTypeCashTenderPayment, nil
	case "OTHER_TENDER_PAYMENT":
		return CashDrawerEventTypeOtherTenderPayment, nil
	case "CASH_TENDER_CANCELLED_PAYMENT":
		return CashDrawerEventTypeCashTenderCancelledPayment, nil
	case "OTHER_TENDER_CANCELLED_PAYMENT":
		return CashDrawerEventTypeOtherTenderCancelledPayment, nil
	case "CASH_TENDER_REFUND":
		return CashDrawerEventTypeCashTenderRefund, nil
	case "OTHER_TENDER_REFUND":
		return CashDrawerEventTypeOtherTenderRefund, nil
	case "PAID_IN":
		return CashDrawerEventTypePaidIn, nil
	case "PAID_OUT":
		return CashDrawerEventTypePaidOut, nil
	}
	var t CashDrawerEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CashDrawerEventType) Ptr() *CashDrawerEventType {
	return &c
}

// This model gives the details of a cash drawer shift.
// The cash_payment_money, cash_refund_money, cash_paid_in_money,
// and cash_paid_out_money fields are all computed by summing their respective
// event types.
type CashDrawerShift struct {
	// The shift unique ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The shift current state.
	// See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
	State *CashDrawerShiftState `json:"state,omitempty" url:"state,omitempty"`
	// The time when the shift began, in ISO 8601 format.
	OpenedAt *string `json:"opened_at,omitempty" url:"opened_at,omitempty"`
	// The time when the shift ended, in ISO 8601 format.
	EndedAt *string `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	// The time when the shift was closed, in ISO 8601 format.
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// The free-form text description of a cash drawer by an employee.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money in the cash drawer at the start of the shift.
	// The amount must be greater than or equal to zero.
	OpenedCashMoney *Money `json:"opened_cash_money,omitempty" url:"opened_cash_money,omitempty"`
	// The amount of money added to the cash drawer from cash payments.
	// This is computed by summing all events with the types CASH_TENDER_PAYMENT and
	// CASH_TENDER_CANCELED_PAYMENT. The amount is always greater than or equal to
	// zero.
	CashPaymentMoney *Money `json:"cash_payment_money,omitempty" url:"cash_payment_money,omitempty"`
	// The amount of money removed from the cash drawer from cash refunds.
	// It is computed by summing the events of type CASH_TENDER_REFUND. The amount
	// is always greater than or equal to zero.
	CashRefundsMoney *Money `json:"cash_refunds_money,omitempty" url:"cash_refunds_money,omitempty"`
	// The amount of money added to the cash drawer for reasons other than cash
	// payments. It is computed by summing the events of type PAID_IN. The amount is
	// always greater than or equal to zero.
	CashPaidInMoney *Money `json:"cash_paid_in_money,omitempty" url:"cash_paid_in_money,omitempty"`
	// The amount of money removed from the cash drawer for reasons other than
	// cash refunds. It is computed by summing the events of type PAID_OUT. The amount
	// is always greater than or equal to zero.
	CashPaidOutMoney *Money `json:"cash_paid_out_money,omitempty" url:"cash_paid_out_money,omitempty"`
	// The amount of money that should be in the cash drawer at the end of the
	// shift, based on the shift's other money amounts.
	// This can be negative if employees have not correctly recorded all the events
	// on the cash drawer.
	// cash_paid_out_money is a summation of amounts from cash_payment_money (zero
	// or positive), cash_refunds_money (zero or negative), cash_paid_in_money (zero
	// or positive), and cash_paid_out_money (zero or negative) event types.
	ExpectedCashMoney *Money `json:"expected_cash_money,omitempty" url:"expected_cash_money,omitempty"`
	// The amount of money found in the cash drawer at the end of the shift
	// by an auditing employee. The amount should be positive.
	ClosedCashMoney *Money `json:"closed_cash_money,omitempty" url:"closed_cash_money,omitempty"`
	// The device running Square Point of Sale that was connected to the cash drawer.
	Device *CashDrawerDevice `json:"device,omitempty" url:"device,omitempty"`
	// The shift start time in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The shift updated at time in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the location the cash drawer shift belongs to.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The IDs of all team members that were logged into Square Point of Sale at any
	// point while the cash drawer shift was open.
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`
	// The ID of the team member that started the cash drawer shift.
	OpeningTeamMemberID *string `json:"opening_team_member_id,omitempty" url:"opening_team_member_id,omitempty"`
	// The ID of the team member that ended the cash drawer shift.
	EndingTeamMemberID *string `json:"ending_team_member_id,omitempty" url:"ending_team_member_id,omitempty"`
	// The ID of the team member that closed the cash drawer shift by auditing
	// the cash drawer contents.
	ClosingTeamMemberID *string `json:"closing_team_member_id,omitempty" url:"closing_team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerShift) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShift) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShift
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShift(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShift) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CashDrawerShiftEvent struct {
	// The unique ID of the event.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of cash drawer shift event.
	// See [CashDrawerEventType](#type-cashdrawereventtype) for possible values
	EventType *CashDrawerEventType `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The amount of money that was added to or removed from the cash drawer
	// in the event. The amount can be positive (for added money)
	// or zero (for other tender type payments). The addition or removal of money can be determined by
	// by the event type.
	EventMoney *Money `json:"event_money,omitempty" url:"event_money,omitempty"`
	// The event time in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// An optional description of the event, entered by the employee that
	// created the event.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The ID of the team member that created the event.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerShiftEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShiftEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShiftEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShiftEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShiftEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The current state of a cash drawer shift.
type CashDrawerShiftState string

const (
	CashDrawerShiftStateOpen   CashDrawerShiftState = "OPEN"
	CashDrawerShiftStateEnded  CashDrawerShiftState = "ENDED"
	CashDrawerShiftStateClosed CashDrawerShiftState = "CLOSED"
)

func NewCashDrawerShiftStateFromString(s string) (CashDrawerShiftState, error) {
	switch s {
	case "OPEN":
		return CashDrawerShiftStateOpen, nil
	case "ENDED":
		return CashDrawerShiftStateEnded, nil
	case "CLOSED":
		return CashDrawerShiftStateClosed, nil
	}
	var t CashDrawerShiftState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CashDrawerShiftState) Ptr() *CashDrawerShiftState {
	return &c
}

// The summary of a closed cash drawer shift.
// This model contains only the money counted to start a cash drawer shift, counted
// at the end of the shift, and the amount that should be in the drawer at shift
// end based on summing all cash drawer shift events.
type CashDrawerShiftSummary struct {
	// The shift unique ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The shift current state.
	// See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
	State *CashDrawerShiftState `json:"state,omitempty" url:"state,omitempty"`
	// The shift start time in ISO 8601 format.
	OpenedAt *string `json:"opened_at,omitempty" url:"opened_at,omitempty"`
	// The shift end time in ISO 8601 format.
	EndedAt *string `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	// The shift close time in ISO 8601 format.
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// An employee free-text description of a cash drawer shift.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money in the cash drawer at the start of the shift. This
	// must be a positive amount.
	OpenedCashMoney *Money `json:"opened_cash_money,omitempty" url:"opened_cash_money,omitempty"`
	// The amount of money that should be in the cash drawer at the end of the
	// shift, based on the cash drawer events on the shift.
	// The amount is correct if all shift employees accurately recorded their
	// cash drawer shift events. Unrecorded events and events with the wrong amount
	// result in an incorrect expected_cash_money amount that can be negative.
	ExpectedCashMoney *Money `json:"expected_cash_money,omitempty" url:"expected_cash_money,omitempty"`
	// The amount of money found in the cash drawer at the end of the shift by
	// an auditing employee. The amount must be greater than or equal to zero.
	ClosedCashMoney *Money `json:"closed_cash_money,omitempty" url:"closed_cash_money,omitempty"`
	// The shift start time in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The shift updated at time in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the location the cash drawer shift belongs to.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashDrawerShiftSummary) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShiftSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShiftSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShiftSummary(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShiftSummary) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Stores details about a cash payment. Contains only non-confidential information. For more information, see
// [Take Cash Payments](https://developer.squareup.com/docs/payments-api/take-payments/cash-payments).
type CashPaymentDetails struct {
	// The amount and currency of the money supplied by the buyer.
	BuyerSuppliedMoney *Money `json:"buyer_supplied_money,omitempty" url:"buyer_supplied_money,omitempty"`
	// The amount of change due back to the buyer.
	// This read-only field is calculated
	// from the `amount_money` and `buyer_supplied_money` fields.
	ChangeBackMoney *Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashPaymentDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CashPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashPaymentDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a time period of availability.
type CatalogAvailabilityPeriod struct {
	// The start time of an availability period, specified in local time using partial-time
	// RFC 3339 format. For example, `8:30:00` for a period starting at 8:30 in the morning.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	StartLocalTime *string `json:"start_local_time,omitempty" url:"start_local_time,omitempty"`
	// The end time of an availability period, specified in local time using partial-time
	// RFC 3339 format. For example, `21:00:00` for a period ending at 9:00 in the evening.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	EndLocalTime *string `json:"end_local_time,omitempty" url:"end_local_time,omitempty"`
	// The day of the week for this availability period.
	// See [DayOfWeek](#type-dayofweek) for possible values
	DayOfWeek *DayOfWeek `json:"day_of_week,omitempty" url:"day_of_week,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogAvailabilityPeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogAvailabilityPeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogAvailabilityPeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogAvailabilityPeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogAvailabilityPeriod) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A category to which a `CatalogItem` instance belongs.
type CatalogCategory struct {
	// The category name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The IDs of images associated with this `CatalogCategory` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// The type of the category.
	// See [CatalogCategoryType](#type-catalogcategorytype) for possible values
	CategoryType *CatalogCategoryType `json:"category_type,omitempty" url:"category_type,omitempty"`
	// The ID of the parent category of this category instance.
	ParentCategory *CatalogObjectCategory `json:"parent_category,omitempty" url:"parent_category,omitempty"`
	// Indicates whether a category is a top level category, which does not have any parent_category.
	IsTopLevel *bool `json:"is_top_level,omitempty" url:"is_top_level,omitempty"`
	// A list of IDs representing channels, such as a Square Online site, where the category can be made visible.
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	// The IDs of the `CatalogAvailabilityPeriod` objects associated with the category.
	AvailabilityPeriodIDs []string `json:"availability_period_ids,omitempty" url:"availability_period_ids,omitempty"`
	// Indicates whether the category is visible (`true`) or hidden (`false`) on all of the seller's Square Online sites.
	OnlineVisibility *bool `json:"online_visibility,omitempty" url:"online_visibility,omitempty"`
	// The top-level category in a category hierarchy.
	RootCategory *string `json:"root_category,omitempty" url:"root_category,omitempty"`
	// The SEO data for a seller's Square Online store.
	EcomSeoData *CatalogEcomSeoData `json:"ecom_seo_data,omitempty" url:"ecom_seo_data,omitempty"`
	// The path from the category to its root category. The first node of the path is the parent of the category
	// and the last is the root category. The path is empty if the category is a root category.
	PathToRoot []*CategoryPathToRootNode `json:"path_to_root,omitempty" url:"path_to_root,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCategory) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCategory(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCategory) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the type of a category.
type CatalogCategoryType string

const (
	CatalogCategoryTypeRegularCategory CatalogCategoryType = "REGULAR_CATEGORY"
	CatalogCategoryTypeMenuCategory    CatalogCategoryType = "MENU_CATEGORY"
	CatalogCategoryTypeKitchenCategory CatalogCategoryType = "KITCHEN_CATEGORY"
)

func NewCatalogCategoryTypeFromString(s string) (CatalogCategoryType, error) {
	switch s {
	case "REGULAR_CATEGORY":
		return CatalogCategoryTypeRegularCategory, nil
	case "MENU_CATEGORY":
		return CatalogCategoryTypeMenuCategory, nil
	case "KITCHEN_CATEGORY":
		return CatalogCategoryTypeKitchenCategory, nil
	}
	var t CatalogCategoryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCategoryType) Ptr() *CatalogCategoryType {
	return &c
}

// Contains information defining a custom attribute. Custom attributes are
// intended to store additional information about a catalog object or to associate a
// catalog object with an entity in another system. Do not use custom attributes
// to store any sensitive information (personally identifiable information, card details, etc.).
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes)
type CatalogCustomAttributeDefinition struct {
	// The type of this custom attribute. Cannot be modified after creation.
	// Required.
	// See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
	Type CatalogCustomAttributeDefinitionType `json:"type" url:"type"`
	// The name of this definition for API and seller-facing UI purposes.
	// The name must be unique within the (merchant, application) pair. Required.
	// May not be empty and may not exceed 255 characters. Can be modified after creation.
	Name string `json:"name" url:"name"`
	// Seller-oriented description of the meaning of this Custom Attribute,
	// any constraints that the seller should observe, etc. May be displayed as a tooltip in Square UIs.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// **Read only.** Contains information about the application that
	// created this custom attribute definition.
	SourceApplication *SourceApplication `json:"source_application,omitempty" url:"source_application,omitempty"`
	// The set of `CatalogObject` types that this custom atttribute may be applied to.
	// Currently, only `ITEM`, `ITEM_VARIATION`, `MODIFIER`, `MODIFIER_LIST`, and `CATEGORY` are allowed. At least one type must be included.
	// See [CatalogObjectType](#type-catalogobjecttype) for possible values
	AllowedObjectTypes []CatalogObjectType `json:"allowed_object_types,omitempty" url:"allowed_object_types,omitempty"`
	// The visibility of a custom attribute in seller-facing UIs (including Square Point
	// of Sale applications and Square Dashboard). May be modified.
	// See [CatalogCustomAttributeDefinitionSellerVisibility](#type-catalogcustomattributedefinitionsellervisibility) for possible values
	SellerVisibility *CatalogCustomAttributeDefinitionSellerVisibility `json:"seller_visibility,omitempty" url:"seller_visibility,omitempty"`
	// The visibility of a custom attribute to applications other than the application
	// that created the attribute.
	// See [CatalogCustomAttributeDefinitionAppVisibility](#type-catalogcustomattributedefinitionappvisibility) for possible values
	AppVisibility *CatalogCustomAttributeDefinitionAppVisibility `json:"app_visibility,omitempty" url:"app_visibility,omitempty"`
	// Optionally, populated when `type` = `STRING`, unset otherwise.
	StringConfig *CatalogCustomAttributeDefinitionStringConfig `json:"string_config,omitempty" url:"string_config,omitempty"`
	// Optionally, populated when `type` = `NUMBER`, unset otherwise.
	NumberConfig *CatalogCustomAttributeDefinitionNumberConfig `json:"number_config,omitempty" url:"number_config,omitempty"`
	// Populated when `type` is set to `SELECTION`, unset otherwise.
	SelectionConfig *CatalogCustomAttributeDefinitionSelectionConfig `json:"selection_config,omitempty" url:"selection_config,omitempty"`
	// The number of custom attributes that reference this
	// custom attribute definition. Set by the server in response to a ListCatalog
	// request with `include_counts` set to `true`. If the actual count is greater
	// than 100, `custom_attribute_usage_count` will be set to `100`.
	CustomAttributeUsageCount *int `json:"custom_attribute_usage_count,omitempty" url:"custom_attribute_usage_count,omitempty"`
	// The name of the desired custom attribute key that can be used to access
	// the custom attribute value on catalog objects. Cannot be modified after the
	// custom attribute definition has been created.
	// Must be between 1 and 60 characters, and may only contain the characters `[a-zA-Z0-9_-]`.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinition) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to applications other than their
// creating application.
type CatalogCustomAttributeDefinitionAppVisibility string

const (
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden          CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly        CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_ONLY"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionAppVisibilityFromString(s string) (CatalogCustomAttributeDefinitionAppVisibility, error) {
	switch s {
	case "APP_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden, nil
	case "APP_VISIBILITY_READ_ONLY":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly, nil
	case "APP_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionAppVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionAppVisibility) Ptr() *CatalogCustomAttributeDefinitionAppVisibility {
	return &c
}

type CatalogCustomAttributeDefinitionNumberConfig struct {
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in number custom attribute values
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 5
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionNumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionNumberConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration associated with `SELECTION`-type custom attribute definitions.
type CatalogCustomAttributeDefinitionSelectionConfig struct {
	// The maximum number of selections that can be set. The maximum value for this
	// attribute is 100. The default value is 1. The value can be modified, but changing the value will not
	// affect existing custom attribute values on objects. Clients need to
	// handle custom attributes with more selected values than allowed by this limit.
	MaxAllowedSelections *int `json:"max_allowed_selections,omitempty" url:"max_allowed_selections,omitempty"`
	// The set of valid `CatalogCustomAttributeSelections`. Up to a maximum of 100
	// selections can be defined. Can be modified.
	AllowedSelections []*CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection `json:"allowed_selections,omitempty" url:"allowed_selections,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A named selection for this `SELECTION`-type custom attribute definition.
type CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection struct {
	// Unique ID set by Square.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Selection name, unique within `allowed_selections`.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to sellers in Square
// client applications, Square APIs or in Square UIs (including Square Point
// of Sale applications and Square Dashboard).
type CatalogCustomAttributeDefinitionSellerVisibility string

const (
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden          CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionSellerVisibilityFromString(s string) (CatalogCustomAttributeDefinitionSellerVisibility, error) {
	switch s {
	case "SELLER_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden, nil
	case "SELLER_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionSellerVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionSellerVisibility) Ptr() *CatalogCustomAttributeDefinitionSellerVisibility {
	return &c
}

// Configuration associated with Custom Attribute Definitions of type `STRING`.
type CatalogCustomAttributeDefinitionStringConfig struct {
	// If true, each Custom Attribute instance associated with this Custom Attribute
	// Definition must have a unique value within the seller's catalog. For
	// example, this may be used for a value like a SKU that should not be
	// duplicated within a seller's catalog. May not be modified after the
	// definition has been created.
	EnforceUniqueness *bool `json:"enforce_uniqueness,omitempty" url:"enforce_uniqueness,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionStringConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionStringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionStringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionStringConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionStringConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the possible types for a custom attribute.
type CatalogCustomAttributeDefinitionType string

const (
	CatalogCustomAttributeDefinitionTypeString    CatalogCustomAttributeDefinitionType = "STRING"
	CatalogCustomAttributeDefinitionTypeBoolean   CatalogCustomAttributeDefinitionType = "BOOLEAN"
	CatalogCustomAttributeDefinitionTypeNumber    CatalogCustomAttributeDefinitionType = "NUMBER"
	CatalogCustomAttributeDefinitionTypeSelection CatalogCustomAttributeDefinitionType = "SELECTION"
)

func NewCatalogCustomAttributeDefinitionTypeFromString(s string) (CatalogCustomAttributeDefinitionType, error) {
	switch s {
	case "STRING":
		return CatalogCustomAttributeDefinitionTypeString, nil
	case "BOOLEAN":
		return CatalogCustomAttributeDefinitionTypeBoolean, nil
	case "NUMBER":
		return CatalogCustomAttributeDefinitionTypeNumber, nil
	case "SELECTION":
		return CatalogCustomAttributeDefinitionTypeSelection, nil
	}
	var t CatalogCustomAttributeDefinitionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionType) Ptr() *CatalogCustomAttributeDefinitionType {
	return &c
}

// An instance of a custom attribute. Custom attributes can be defined and
// added to `ITEM` and `ITEM_VARIATION` type catalog objects.
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes).
type CatalogCustomAttributeValue struct {
	// The name of the custom attribute.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The string value of the custom attribute. Populated if `type` = `STRING`.
	StringValue *string `json:"string_value,omitempty" url:"string_value,omitempty"`
	// The id of the [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition) this value belongs to.
	CustomAttributeDefinitionID *string `json:"custom_attribute_definition_id,omitempty" url:"custom_attribute_definition_id,omitempty"`
	// A copy of type from the associated `CatalogCustomAttributeDefinition`.
	// See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
	Type *CatalogCustomAttributeDefinitionType `json:"type,omitempty" url:"type,omitempty"`
	// Populated if `type` = `NUMBER`. Contains a string
	// representation of a decimal number, using a `.` as the decimal separator.
	NumberValue *string `json:"number_value,omitempty" url:"number_value,omitempty"`
	// A `true` or `false` value. Populated if `type` = `BOOLEAN`.
	BooleanValue *bool `json:"boolean_value,omitempty" url:"boolean_value,omitempty"`
	// One or more choices from `allowed_selections`. Populated if `type` = `SELECTION`.
	SelectionUIDValues []string `json:"selection_uid_values,omitempty" url:"selection_uid_values,omitempty"`
	// If the associated `CatalogCustomAttributeDefinition` object is defined by another application, this key is prefixed by the defining application ID.
	// For example, if the CatalogCustomAttributeDefinition has a key attribute of "cocoa_brand" and the defining application ID is "abcd1234", this key is "abcd1234:cocoa_brand"
	// when the application making the request is different from the application defining the custom attribute definition. Otherwise, the key is simply "cocoa_brand".
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A discount applicable to items.
type CatalogDiscount struct {
	// The discount name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale.
	// See [CatalogDiscountType](#type-catalogdiscounttype) for possible values
	DiscountType *CatalogDiscountType `json:"discount_type,omitempty" url:"discount_type,omitempty"`
	// The percentage of the discount as a string representation of a decimal number, using a `.` as the decimal
	// separator and without a `%` sign. A value of `7.5` corresponds to `7.5%`. Specify a percentage of `0` if `discount_type`
	// is `VARIABLE_PERCENTAGE`.
	//
	// Do not use this field for amount-based or variable discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of the discount. Specify an amount of `0` if `discount_type` is `VARIABLE_AMOUNT`.
	//
	// Do not use this field for percentage-based or variable discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// Indicates whether a mobile staff member needs to enter their PIN to apply the
	// discount to a payment in the Square Point of Sale app.
	PinRequired *bool `json:"pin_required,omitempty" url:"pin_required,omitempty"`
	// The color of the discount display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor *string `json:"label_color,omitempty" url:"label_color,omitempty"`
	// Indicates whether this discount should reduce the price used to calculate tax.
	//
	// Most discounts should use `MODIFY_TAX_BASIS`. However, in some circumstances taxes must
	// be calculated based on an item's price, ignoring a particular discount. For example,
	// in many US jurisdictions, a manufacturer coupon or instant rebate reduces the price a
	// customer pays but does not reduce the sale price used to calculate how much sales tax is
	// due. In this case, the discount representing that manufacturer coupon should have
	// `DO_NOT_MODIFY_TAX_BASIS` for this field.
	//
	// If you are unsure whether you need to use this field, consult your tax professional.
	// See [CatalogDiscountModifyTaxBasis](#type-catalogdiscountmodifytaxbasis) for possible values
	ModifyTaxBasis *CatalogDiscountModifyTaxBasis `json:"modify_tax_basis,omitempty" url:"modify_tax_basis,omitempty"`
	// For a percentage discount, the maximum absolute value of the discount. For example, if a
	// 50% discount has a `maximum_amount_money` of $20, a $100 purchase will yield a $20 discount,
	// not a $50 discount.
	MaximumAmountMoney *Money `json:"maximum_amount_money,omitempty" url:"maximum_amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogDiscount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogDiscount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogDiscountModifyTaxBasis string

const (
	CatalogDiscountModifyTaxBasisModifyTaxBasis      CatalogDiscountModifyTaxBasis = "MODIFY_TAX_BASIS"
	CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis CatalogDiscountModifyTaxBasis = "DO_NOT_MODIFY_TAX_BASIS"
)

func NewCatalogDiscountModifyTaxBasisFromString(s string) (CatalogDiscountModifyTaxBasis, error) {
	switch s {
	case "MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisModifyTaxBasis, nil
	case "DO_NOT_MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis, nil
	}
	var t CatalogDiscountModifyTaxBasis
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountModifyTaxBasis) Ptr() *CatalogDiscountModifyTaxBasis {
	return &c
}

// How to apply a CatalogDiscount to a CatalogItem.
type CatalogDiscountType string

const (
	CatalogDiscountTypeFixedPercentage    CatalogDiscountType = "FIXED_PERCENTAGE"
	CatalogDiscountTypeFixedAmount        CatalogDiscountType = "FIXED_AMOUNT"
	CatalogDiscountTypeVariablePercentage CatalogDiscountType = "VARIABLE_PERCENTAGE"
	CatalogDiscountTypeVariableAmount     CatalogDiscountType = "VARIABLE_AMOUNT"
)

func NewCatalogDiscountTypeFromString(s string) (CatalogDiscountType, error) {
	switch s {
	case "FIXED_PERCENTAGE":
		return CatalogDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return CatalogDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return CatalogDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return CatalogDiscountTypeVariableAmount, nil
	}
	var t CatalogDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountType) Ptr() *CatalogDiscountType {
	return &c
}

// SEO data for for a seller's Square Online store.
type CatalogEcomSeoData struct {
	// The SEO title used for the Square Online store.
	PageTitle *string `json:"page_title,omitempty" url:"page_title,omitempty"`
	// The SEO description used for the Square Online store.
	PageDescription *string `json:"page_description,omitempty" url:"page_description,omitempty"`
	// The SEO permalink used for the Square Online store.
	Permalink *string `json:"permalink,omitempty" url:"permalink,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogEcomSeoData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogEcomSeoData) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogEcomSeoData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogEcomSeoData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogEcomSeoData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A mapping between a temporary client-supplied ID and a permanent server-generated ID.
//
// When calling [UpsertCatalogObject]($e/Catalog/UpsertCatalogObject) or
// [BatchUpsertCatalogObjects]($e/Catalog/BatchUpsertCatalogObjects) to
// create a [CatalogObject]($m/CatalogObject) instance, you can supply
// a temporary ID for the to-be-created object, especially when the object is to be referenced
// elsewhere in the same request body. This temporary ID can be any string unique within
// the call, but must be prefixed by "#".
//
// After the request is submitted and the object created, a permanent server-generated ID is assigned
// to the new object. The permanent ID is unique across the Square catalog.
type CatalogIDMapping struct {
	// The client-supplied temporary `#`-prefixed ID for a new `CatalogObject`.
	ClientObjectID *string `json:"client_object_id,omitempty" url:"client_object_id,omitempty"`
	// The permanent ID for the CatalogObject created by the server.
	ObjectID *string `json:"object_id,omitempty" url:"object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogIDMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogIDMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogIDMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogIDMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogIDMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An image file to use in Square catalogs. It can be associated with
// `CatalogItem`, `CatalogItemVariation`, `CatalogCategory`, and `CatalogModifierList` objects.
// Only the images on items and item variations are exposed in Dashboard.
// Only the first image on an item is displayed in Square Point of Sale (SPOS).
// Images on items and variations are displayed through Square Online Store.
// Images on other object types are for use by 3rd party application developers.
type CatalogImage struct {
	// The internal name to identify this image in calls to the Square API.
	// This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	// It is not unique and should not be shown in a buyer facing context.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL of this image, generated by Square after an image is uploaded
	// using the [CreateCatalogImage](api-endpoint:Catalog-CreateCatalogImage) endpoint.
	// To modify the image, use the UpdateCatalogImage endpoint. Do not change the URL field.
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// A caption that describes what is shown in the image. Displayed in the
	// Square Online Store. This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	Caption *string `json:"caption,omitempty" url:"caption,omitempty"`
	// The immutable order ID for this image object created by the Photo Studio service in Square Online Store.
	PhotoStudioOrderID *string `json:"photo_studio_order_id,omitempty" url:"photo_studio_order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogImage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogImage) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogImage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogImage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogInfoRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogInfoRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogInfoRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogInfoRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogInfoRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogInfoRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogInfoResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Limits that apply to this API.
	Limits *CatalogInfoResponseLimits `json:"limits,omitempty" url:"limits,omitempty"`
	// Names and abbreviations for standard units.
	StandardUnitDescriptionGroup *StandardUnitDescriptionGroup `json:"standard_unit_description_group,omitempty" url:"standard_unit_description_group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogInfoResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogInfoResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogInfoResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogInfoResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogInfoResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogInfoResponseLimits struct {
	// The maximum number of objects that may appear within a single batch in a
	// `/v2/catalog/batch-upsert` request.
	BatchUpsertMaxObjectsPerBatch *int `json:"batch_upsert_max_objects_per_batch,omitempty" url:"batch_upsert_max_objects_per_batch,omitempty"`
	// The maximum number of objects that may appear across all batches in a
	// `/v2/catalog/batch-upsert` request.
	BatchUpsertMaxTotalObjects *int `json:"batch_upsert_max_total_objects,omitempty" url:"batch_upsert_max_total_objects,omitempty"`
	// The maximum number of object IDs that may appear in a `/v2/catalog/batch-retrieve`
	// request.
	BatchRetrieveMaxObjectIDs *int `json:"batch_retrieve_max_object_ids,omitempty" url:"batch_retrieve_max_object_ids,omitempty"`
	// The maximum number of results that may be returned in a page of a
	// `/v2/catalog/search` response.
	SearchMaxPageLimit *int `json:"search_max_page_limit,omitempty" url:"search_max_page_limit,omitempty"`
	// The maximum number of object IDs that may be included in a single
	// `/v2/catalog/batch-delete` request.
	BatchDeleteMaxObjectIDs *int `json:"batch_delete_max_object_ids,omitempty" url:"batch_delete_max_object_ids,omitempty"`
	// The maximum number of item IDs that may be included in a single
	// `/v2/catalog/update-item-taxes` request.
	UpdateItemTaxesMaxItemIDs *int `json:"update_item_taxes_max_item_ids,omitempty" url:"update_item_taxes_max_item_ids,omitempty"`
	// The maximum number of tax IDs to be enabled that may be included in a single
	// `/v2/catalog/update-item-taxes` request.
	UpdateItemTaxesMaxTaxesToEnable *int `json:"update_item_taxes_max_taxes_to_enable,omitempty" url:"update_item_taxes_max_taxes_to_enable,omitempty"`
	// The maximum number of tax IDs to be disabled that may be included in a single
	// `/v2/catalog/update-item-taxes` request.
	UpdateItemTaxesMaxTaxesToDisable *int `json:"update_item_taxes_max_taxes_to_disable,omitempty" url:"update_item_taxes_max_taxes_to_disable,omitempty"`
	// The maximum number of item IDs that may be included in a single
	// `/v2/catalog/update-item-modifier-lists` request.
	UpdateItemModifierListsMaxItemIDs *int `json:"update_item_modifier_lists_max_item_ids,omitempty" url:"update_item_modifier_lists_max_item_ids,omitempty"`
	// The maximum number of modifier list IDs to be enabled that may be included in
	// a single `/v2/catalog/update-item-modifier-lists` request.
	UpdateItemModifierListsMaxModifierListsToEnable *int `json:"update_item_modifier_lists_max_modifier_lists_to_enable,omitempty" url:"update_item_modifier_lists_max_modifier_lists_to_enable,omitempty"`
	// The maximum number of modifier list IDs to be disabled that may be included in
	// a single `/v2/catalog/update-item-modifier-lists` request.
	UpdateItemModifierListsMaxModifierListsToDisable *int `json:"update_item_modifier_lists_max_modifier_lists_to_disable,omitempty" url:"update_item_modifier_lists_max_modifier_lists_to_disable,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogInfoResponseLimits) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogInfoResponseLimits) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogInfoResponseLimits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogInfoResponseLimits(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogInfoResponseLimits) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A [CatalogObject]($m/CatalogObject) instance of the `ITEM` type, also referred to as an item, in the catalog.
type CatalogItem struct {
	// The item's name. This is a searchable attribute for use in applicable query filters, its value must not be empty, and the length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item's description. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	//
	// Deprecated at 2022-07-20, this field is planned to retire in 6 months. You should migrate to use `description_html` to set the description
	// of the [CatalogItem](entity:CatalogItem) instance. The `description` and `description_html` field values are kept in sync. If you try to
	// set the both fields, the `description_html` text value overwrites the `description` value. Updates in one field are also reflected in the other,
	// except for when you use an early version before Square API 2022-07-20 and `description_html` is set to blank, setting the `description` value to null
	// does not nullify `description_html`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The text of the item's display label in the Square Point of Sale app. Only up to the first five characters of the string are used.
	// This attribute is searchable, and its value length is of Unicode code points.
	Abbreviation *string `json:"abbreviation,omitempty" url:"abbreviation,omitempty"`
	// The color of the item's display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor *string `json:"label_color,omitempty" url:"label_color,omitempty"`
	// Indicates whether the item is taxable (`true`) or non-taxable (`false`). Default is `true`.
	IsTaxable *bool `json:"is_taxable,omitempty" url:"is_taxable,omitempty"`
	// If `true`, the item can be added to shipping orders from the merchant's online store.
	AvailableOnline *bool `json:"available_online,omitempty" url:"available_online,omitempty"`
	// If `true`, the item can be added to pickup orders from the merchant's online store.
	AvailableForPickup *bool `json:"available_for_pickup,omitempty" url:"available_for_pickup,omitempty"`
	// If `true`, the item can be added to electronically fulfilled orders from the merchant's online store.
	AvailableElectronically *bool `json:"available_electronically,omitempty" url:"available_electronically,omitempty"`
	// The ID of the item's category, if any. Deprecated since 2023-12-13. Use `CatalogItem.categories`, instead.
	CategoryID *string `json:"category_id,omitempty" url:"category_id,omitempty"`
	// A set of IDs indicating the taxes enabled for
	// this item. When updating an item, any taxes listed here will be added to the item.
	// Taxes may also be added to or deleted from an item using `UpdateItemTaxes`.
	TaxIDs []string `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`
	// A set of `CatalogItemModifierListInfo` objects
	// representing the modifier lists that apply to this item, along with the overrides and min
	// and max limits that are specific to this item. Modifier lists
	// may also be added to or deleted from an item using `UpdateItemModifierLists`.
	ModifierListInfo []*CatalogItemModifierListInfo `json:"modifier_list_info,omitempty" url:"modifier_list_info,omitempty"`
	// A list of [CatalogItemVariation](entity:CatalogItemVariation) objects for this item. An item must have
	// at least one variation.
	Variations []*CatalogObject `json:"variations,omitempty" url:"variations,omitempty"`
	// The product type of the item. Once set, the `product_type` value cannot be modified.
	//
	// Items of the `LEGACY_SQUARE_ONLINE_SERVICE` and `LEGACY_SQUARE_ONLINE_MEMBERSHIP` product types can be updated
	// but cannot be created using the API.
	// See [CatalogItemProductType](#type-catalogitemproducttype) for possible values
	ProductType *CatalogItemProductType `json:"product_type,omitempty" url:"product_type,omitempty"`
	// If `false`, the Square Point of Sale app will present the `CatalogItem`'s
	// details screen immediately, allowing the merchant to choose `CatalogModifier`s
	// before adding the item to the cart. This is the default behavior.
	//
	// If `true`, the Square Point of Sale app will immediately add the item to the cart with the pre-selected
	// modifiers, and merchants can edit modifiers by drilling down onto the item's details.
	//
	// Third-party clients are encouraged to implement similar behaviors.
	SkipModifierScreen *bool `json:"skip_modifier_screen,omitempty" url:"skip_modifier_screen,omitempty"`
	// List of item options IDs for this item. Used to manage and group item
	// variations in a specified order.
	//
	// Maximum: 6 item options.
	ItemOptions []*CatalogItemOptionForItem `json:"item_options,omitempty" url:"item_options,omitempty"`
	// The IDs of images associated with this `CatalogItem` instance.
	// These images will be shown to customers in Square Online Store.
	// The first image will show up as the icon for this item in POS.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// A name to sort the item by. If this name is unspecified, namely, the `sort_name` field is absent, the regular `name` field is used for sorting.
	// Its value must not be empty.
	//
	// It is currently supported for sellers of the Japanese locale only.
	SortName *string `json:"sort_name,omitempty" url:"sort_name,omitempty"`
	// The list of categories.
	Categories []*CatalogObjectCategory `json:"categories,omitempty" url:"categories,omitempty"`
	// The item's description as expressed in valid HTML elements. The length of this field value, including those of HTML tags,
	// is of Unicode points. With application query filters, the text values of the HTML elements and attributes are searchable. Invalid or
	// unsupported HTML elements or attributes are ignored.
	//
	// Supported HTML elements include:
	//
	// - `a`: Link. Supports linking to website URLs, email address, and telephone numbers.
	// - `b`, `strong`: Bold text
	// - `br`: Line break
	// - `code`: Computer code
	// - `div`: Section
	// - `h1-h6`: Headings
	// - `i`, `em`: Italics
	// - `li`: List element
	// - `ol`: Numbered list
	// - `p`: Paragraph
	// - `ul`: Bullet list
	// - `u`: Underline
	//
	// Supported HTML attributes include:
	//
	// - `align`: Alignment of the text content
	// - `href`: Link destination
	// - `rel`: Relationship between link's target and source
	// - `target`: Place to open the linked document
	DescriptionHTML *string `json:"description_html,omitempty" url:"description_html,omitempty"`
	// A server-generated plaintext version of the `description_html` field, without formatting tags.
	DescriptionPlaintext *string `json:"description_plaintext,omitempty" url:"description_plaintext,omitempty"`
	// A list of IDs representing channels, such as a Square Online site, where the item can be made visible or available.
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	// Indicates whether this item is archived (`true`) or not (`false`).
	IsArchived *bool `json:"is_archived,omitempty" url:"is_archived,omitempty"`
	// The SEO data for a seller's Square Online store.
	EcomSeoData *CatalogEcomSeoData `json:"ecom_seo_data,omitempty" url:"ecom_seo_data,omitempty"`
	// The food and beverage-specific details for the `FOOD_AND_BEV` item.
	FoodAndBeverageDetails *CatalogItemFoodAndBeverageDetails `json:"food_and_beverage_details,omitempty" url:"food_and_beverage_details,omitempty"`
	// The item's reporting category.
	ReportingCategory *CatalogObjectCategory `json:"reporting_category,omitempty" url:"reporting_category,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The food and beverage-specific details of a `FOOD_AND_BEV` item.
type CatalogItemFoodAndBeverageDetails struct {
	// The calorie count (in the unit of kcal) for the `FOOD_AND_BEV` type of items.
	CalorieCount *int `json:"calorie_count,omitempty" url:"calorie_count,omitempty"`
	// The dietary preferences for the `FOOD_AND_BEV` item.
	DietaryPreferences []*CatalogItemFoodAndBeverageDetailsDietaryPreference `json:"dietary_preferences,omitempty" url:"dietary_preferences,omitempty"`
	// The ingredients for the `FOOD_AND_BEV` type item.
	Ingredients []*CatalogItemFoodAndBeverageDetailsIngredient `json:"ingredients,omitempty" url:"ingredients,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemFoodAndBeverageDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemFoodAndBeverageDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemFoodAndBeverageDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemFoodAndBeverageDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemFoodAndBeverageDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Dietary preferences that can be assigned to an `FOOD_AND_BEV` item and its ingredients.
type CatalogItemFoodAndBeverageDetailsDietaryPreference struct {
	// The dietary preference type. Supported values include `STANDARD` and `CUSTOM` as specified in `FoodAndBeverageDetails.DietaryPreferenceType`.
	// See [DietaryPreferenceType](#type-dietarypreferencetype) for possible values
	Type *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType `json:"type,omitempty" url:"type,omitempty"`
	// The name of the dietary preference from a standard pre-defined list. This should be null if it's a custom dietary preference.
	// See [StandardDietaryPreference](#type-standarddietarypreference) for possible values
	StandardName *CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference `json:"standard_name,omitempty" url:"standard_name,omitempty"`
	// The name of a user-defined custom dietary preference. This should be null if it's a standard dietary preference.
	CustomName *string `json:"custom_name,omitempty" url:"custom_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemFoodAndBeverageDetailsDietaryPreference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemFoodAndBeverageDetailsDietaryPreference(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Standard dietary preferences for food and beverage items that are recommended on item creation.
type CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference string

const (
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceDairyFree  CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "DAIRY_FREE"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceGlutenFree CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "GLUTEN_FREE"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceHalal      CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "HALAL"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceKosher     CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "KOSHER"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceNutFree    CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "NUT_FREE"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegan      CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "VEGAN"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegetarian CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "VEGETARIAN"
)

func NewCatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceFromString(s string) (CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference, error) {
	switch s {
	case "DAIRY_FREE":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceDairyFree, nil
	case "GLUTEN_FREE":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceGlutenFree, nil
	case "HALAL":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceHalal, nil
	case "KOSHER":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceKosher, nil
	case "NUT_FREE":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceNutFree, nil
	case "VEGAN":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegan, nil
	case "VEGETARIAN":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegetarian, nil
	}
	var t CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference) Ptr() *CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference {
	return &c
}

// The type of dietary preference for the `FOOD_AND_BEV` type of items and integredients.
type CatalogItemFoodAndBeverageDetailsDietaryPreferenceType string

const (
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeStandard CatalogItemFoodAndBeverageDetailsDietaryPreferenceType = "STANDARD"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeCustom   CatalogItemFoodAndBeverageDetailsDietaryPreferenceType = "CUSTOM"
)

func NewCatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeFromString(s string) (CatalogItemFoodAndBeverageDetailsDietaryPreferenceType, error) {
	switch s {
	case "STANDARD":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeStandard, nil
	case "CUSTOM":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeCustom, nil
	}
	var t CatalogItemFoodAndBeverageDetailsDietaryPreferenceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemFoodAndBeverageDetailsDietaryPreferenceType) Ptr() *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType {
	return &c
}

// Describes the ingredient used in a `FOOD_AND_BEV` item.
type CatalogItemFoodAndBeverageDetailsIngredient struct {
	// The dietary preference type of the ingredient. Supported values include `STANDARD` and `CUSTOM` as specified in `FoodAndBeverageDetails.DietaryPreferenceType`.
	// See [DietaryPreferenceType](#type-dietarypreferencetype) for possible values
	Type *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType `json:"type,omitempty" url:"type,omitempty"`
	// The name of the ingredient from a standard pre-defined list. This should be null if it's a custom dietary preference.
	// See [StandardIngredient](#type-standardingredient) for possible values
	StandardName *CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient `json:"standard_name,omitempty" url:"standard_name,omitempty"`
	// The name of a custom user-defined ingredient. This should be null if it's a standard dietary preference.
	CustomName *string `json:"custom_name,omitempty" url:"custom_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemFoodAndBeverageDetailsIngredient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemFoodAndBeverageDetailsIngredient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Standard ingredients for food and beverage items that are recommended on item creation.
type CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient string

const (
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCelery      CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "CELERY"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCrustaceans CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "CRUSTACEANS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientEggs        CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "EGGS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientFish        CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "FISH"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientGluten      CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "GLUTEN"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientLupin       CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "LUPIN"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMilk        CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "MILK"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMolluscs    CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "MOLLUSCS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMustard     CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "MUSTARD"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientPeanuts     CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "PEANUTS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSesame      CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "SESAME"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSoy         CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "SOY"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSulphites   CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "SULPHITES"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientTreeNuts    CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "TREE_NUTS"
)

func NewCatalogItemFoodAndBeverageDetailsIngredientStandardIngredientFromString(s string) (CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient, error) {
	switch s {
	case "CELERY":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCelery, nil
	case "CRUSTACEANS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCrustaceans, nil
	case "EGGS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientEggs, nil
	case "FISH":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientFish, nil
	case "GLUTEN":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientGluten, nil
	case "LUPIN":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientLupin, nil
	case "MILK":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMilk, nil
	case "MOLLUSCS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMolluscs, nil
	case "MUSTARD":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMustard, nil
	case "PEANUTS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientPeanuts, nil
	case "SESAME":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSesame, nil
	case "SOY":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSoy, nil
	case "SULPHITES":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSulphites, nil
	case "TREE_NUTS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientTreeNuts, nil
	}
	var t CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient) Ptr() *CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient {
	return &c
}

// References a text-based modifier or a list of non text-based modifiers applied to a `CatalogItem` instance
// and specifies supported behaviors of the application.
type CatalogItemModifierListInfo struct {
	// The ID of the `CatalogModifierList` controlled by this `CatalogModifierListInfo`.
	ModifierListID string `json:"modifier_list_id" url:"modifier_list_id"`
	// A set of `CatalogModifierOverride` objects that override whether a given `CatalogModifier` is enabled by default.
	ModifierOverrides []*CatalogModifierOverride `json:"modifier_overrides,omitempty" url:"modifier_overrides,omitempty"`
	// If 0 or larger, the smallest number of `CatalogModifier`s that must be selected from this `CatalogModifierList`.
	// The default value is `-1`.
	//
	// When `CatalogModifierList.selection_type` is `MULTIPLE`, `CatalogModifierListInfo.min_selected_modifiers=-1`
	// and `CatalogModifierListInfo.max_selected_modifier=-1` means that from zero to the maximum number of modifiers of
	// the `CatalogModifierList` can be selected from the `CatalogModifierList`.
	//
	// When the `CatalogModifierList.selection_type` is `SINGLE`, `CatalogModifierListInfo.min_selected_modifiers=-1`
	// and `CatalogModifierListInfo.max_selected_modifier=-1` means that exactly one modifier must be present in
	// and can be selected from the `CatalogModifierList`
	MinSelectedModifiers *int `json:"min_selected_modifiers,omitempty" url:"min_selected_modifiers,omitempty"`
	// If 0 or larger, the largest number of `CatalogModifier`s that can be selected from this `CatalogModifierList`.
	// The default value is `-1`.
	//
	// When `CatalogModifierList.selection_type` is `MULTIPLE`, `CatalogModifierListInfo.min_selected_modifiers=-1`
	// and `CatalogModifierListInfo.max_selected_modifier=-1` means that from zero to the maximum number of modifiers of
	// the `CatalogModifierList` can be selected from the `CatalogModifierList`.
	//
	// When the `CatalogModifierList.selection_type` is `SINGLE`, `CatalogModifierListInfo.min_selected_modifiers=-1`
	// and `CatalogModifierListInfo.max_selected_modifier=-1` means that exactly one modifier must be present in
	// and can be selected from the `CatalogModifierList`
	MaxSelectedModifiers *int `json:"max_selected_modifiers,omitempty" url:"max_selected_modifiers,omitempty"`
	// If `true`, enable this `CatalogModifierList`. The default value is `true`.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The position of this `CatalogItemModifierListInfo` object within the `modifier_list_info` list applied
	// to a `CatalogItem` instance.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemModifierListInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemModifierListInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemModifierListInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemModifierListInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemModifierListInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A group of variations for a `CatalogItem`.
type CatalogItemOption struct {
	// The item option's display name for the seller. Must be unique across
	// all item options. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item option's display name for the customer. This is a searchable attribute for use in applicable query filters.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The item option's human-readable description. Displayed in the Square
	// Point of Sale app for the seller and in the Online Store or on receipts for
	// the buyer. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// If true, display colors for entries in `values` when present.
	ShowColors *bool `json:"show_colors,omitempty" url:"show_colors,omitempty"`
	// A list of CatalogObjects containing the
	// `CatalogItemOptionValue`s for this item.
	Values []*CatalogObject `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOption) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An option that can be assigned to an item.
// For example, a t-shirt item may offer a color option or a size option.
type CatalogItemOptionForItem struct {
	// The unique id of the item option, used to form the dimensions of the item option matrix in a specified order.
	ItemOptionID *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionForItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionForItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionForItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionForItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionForItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An enumerated value that can link a
// `CatalogItemVariation` to an item option as one of
// its item option values.
type CatalogItemOptionValue struct {
	// Unique ID of the associated item option.
	ItemOptionID *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// Name of this item option value. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A human-readable description for the option value. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The HTML-supported hex color for the item option (e.g., "#ff8d4e85").
	// Only displayed if `show_colors` is enabled on the parent `ItemOption`. When
	// left unset, `color` defaults to white ("#ffffff") when `show_colors` is
	// enabled on the parent `ItemOption`.
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// Determines where this option value appears in a list of option values.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A `CatalogItemOptionValue` links an item variation to an item option as
// an item option value. For example, a t-shirt item may offer a color option and
// a size option. An item option value would represent each variation of t-shirt:
// For example, "Color:Red, Size:Small" or "Color:Blue, Size:Medium".
type CatalogItemOptionValueForItemVariation struct {
	// The unique id of an item option.
	ItemOptionID *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// The unique id of the selected value for the item option.
	ItemOptionValueID *string `json:"item_option_value_id,omitempty" url:"item_option_value_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionValueForItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValueForItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValueForItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValueForItemVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValueForItemVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of a CatalogItem. Connect V2 only allows the creation of `REGULAR` or `APPOINTMENTS_SERVICE` items.
type CatalogItemProductType string

const (
	CatalogItemProductTypeRegular                      CatalogItemProductType = "REGULAR"
	CatalogItemProductTypeGiftCard                     CatalogItemProductType = "GIFT_CARD"
	CatalogItemProductTypeAppointmentsService          CatalogItemProductType = "APPOINTMENTS_SERVICE"
	CatalogItemProductTypeFoodAndBev                   CatalogItemProductType = "FOOD_AND_BEV"
	CatalogItemProductTypeEvent                        CatalogItemProductType = "EVENT"
	CatalogItemProductTypeDigital                      CatalogItemProductType = "DIGITAL"
	CatalogItemProductTypeDonation                     CatalogItemProductType = "DONATION"
	CatalogItemProductTypeLegacySquareOnlineService    CatalogItemProductType = "LEGACY_SQUARE_ONLINE_SERVICE"
	CatalogItemProductTypeLegacySquareOnlineMembership CatalogItemProductType = "LEGACY_SQUARE_ONLINE_MEMBERSHIP"
)

func NewCatalogItemProductTypeFromString(s string) (CatalogItemProductType, error) {
	switch s {
	case "REGULAR":
		return CatalogItemProductTypeRegular, nil
	case "GIFT_CARD":
		return CatalogItemProductTypeGiftCard, nil
	case "APPOINTMENTS_SERVICE":
		return CatalogItemProductTypeAppointmentsService, nil
	case "FOOD_AND_BEV":
		return CatalogItemProductTypeFoodAndBev, nil
	case "EVENT":
		return CatalogItemProductTypeEvent, nil
	case "DIGITAL":
		return CatalogItemProductTypeDigital, nil
	case "DONATION":
		return CatalogItemProductTypeDonation, nil
	case "LEGACY_SQUARE_ONLINE_SERVICE":
		return CatalogItemProductTypeLegacySquareOnlineService, nil
	case "LEGACY_SQUARE_ONLINE_MEMBERSHIP":
		return CatalogItemProductTypeLegacySquareOnlineMembership, nil
	}
	var t CatalogItemProductType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemProductType) Ptr() *CatalogItemProductType {
	return &c
}

// An item variation, representing a product for sale, in the Catalog object model. Each [item]($m/CatalogItem) must have at least one
// item variation and can have at most 250 item variations.
//
// An item variation can be sellable, stockable, or both if it has a unit of measure for its count for the sold number of the variation, the stocked
// number of the variation, or both. For example, when a variation representing wine is stocked and sold by the bottle, the variation is both
// stockable and sellable. But when a variation of the wine is sold by the glass, the sold units cannot be used as a measure of the stocked units. This by-the-glass
// variation is sellable, but not stockable. To accurately keep track of the wine's inventory count at any time, the sellable count must be
// converted to stockable count. Typically, the seller defines this unit conversion. For example, 1 bottle equals 5 glasses. The Square API exposes
// the `stockable_conversion` property on the variation to specify the conversion. Thus, when two glasses of the wine are sold, the sellable count
// decreases by 2, and the stockable count automatically decreases by 0.4 bottle according to the conversion.
type CatalogItemVariation struct {
	// The ID of the `CatalogItem` associated with this item variation.
	ItemID *string `json:"item_id,omitempty" url:"item_id,omitempty"`
	// The item variation's name. This is a searchable attribute for use in applicable query filters.
	//
	// Its value has a maximum length of 255 Unicode code points. However, when the parent [item](entity:CatalogItem)
	// uses [item options](entity:CatalogItemOption), this attribute is auto-generated, read-only, and can be
	// longer than 255 Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item variation's SKU, if any. This is a searchable attribute for use in applicable query filters.
	Sku *string `json:"sku,omitempty" url:"sku,omitempty"`
	// The universal product code (UPC) of the item variation, if any. This is a searchable attribute for use in applicable query filters.
	//
	// The value of this attribute should be a number of 12-14 digits long. This restriction is enforced on the Square Seller Dashboard,
	// Square Point of Sale or Retail Point of Sale apps, where this attribute shows in the GTIN field. If a non-compliant UPC value is assigned
	// to this attribute using the API, the value is not editable on the Seller Dashboard, Square Point of Sale or Retail Point of Sale apps
	// unless it is updated to fit the expected format.
	Upc *string `json:"upc,omitempty" url:"upc,omitempty"`
	// The order in which this item variation should be displayed. This value is read-only. On writes, the ordinal
	// for each item variation within a parent `CatalogItem` is set according to the item variations's
	// position. On reads, the value is not guaranteed to be sequential or unique.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// Indicates whether the item variation's price is fixed or determined at the time
	// of sale.
	// See [CatalogPricingType](#type-catalogpricingtype) for possible values
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	// The item variation's price, if fixed pricing is used.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Per-location price and inventory overrides.
	LocationOverrides []*ItemVariationLocationOverrides `json:"location_overrides,omitempty" url:"location_overrides,omitempty"`
	// If `true`, inventory tracking is active for the variation.
	TrackInventory *bool `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	// Indicates whether the item variation displays an alert when its inventory quantity is less than or equal
	// to its `inventory_alert_threshold`.
	// See [InventoryAlertType](#type-inventoryalerttype) for possible values
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Arbitrary user metadata to associate with the item variation. This attribute value length is of Unicode code points.
	UserData *string `json:"user_data,omitempty" url:"user_data,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, then this is the duration of the service in milliseconds. For
	// example, a 30 minute appointment would have the value `1800000`, which is equal to
	// 30 (minutes) _ 60 (seconds per minute) _ 1000 (milliseconds per second).
	ServiceDuration *int64 `json:"service_duration,omitempty" url:"service_duration,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, a bool representing whether this service is available for booking.
	AvailableForBooking *bool `json:"available_for_booking,omitempty" url:"available_for_booking,omitempty"`
	// List of item option values associated with this item variation. Listed
	// in the same order as the item options of the parent item.
	ItemOptionValues []*CatalogItemOptionValueForItemVariation `json:"item_option_values,omitempty" url:"item_option_values,omitempty"`
	// ID of the ‘CatalogMeasurementUnit’ that is used to measure the quantity
	// sold of this item variation. If left unset, the item will be sold in
	// whole quantities.
	MeasurementUnitID *string `json:"measurement_unit_id,omitempty" url:"measurement_unit_id,omitempty"`
	// Whether this variation can be sold. The inventory count of a sellable variation indicates
	// the number of units available for sale. When a variation is both stockable and sellable,
	// its sellable inventory count can be smaller than or equal to its stockable count.
	Sellable *bool `json:"sellable,omitempty" url:"sellable,omitempty"`
	// Whether stock is counted directly on this variation (TRUE) or only on its components (FALSE).
	// When a variation is both stockable and sellable, the inventory count of a stockable variation keeps track of the number of units of this variation in stock
	// and is not an indicator of the number of units of the variation that can be sold.
	Stockable *bool `json:"stockable,omitempty" url:"stockable,omitempty"`
	// The IDs of images associated with this `CatalogItemVariation` instance.
	// These images will be shown to customers in Square Online Store.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// Tokens of employees that can perform the service represented by this variation. Only valid for
	// variations of type `APPOINTMENTS_SERVICE`.
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`
	// The unit conversion rule, as prescribed by the [CatalogStockConversion]($m/CatalogStockConversion) type,
	// that describes how this non-stockable (i.e., sellable/receivable) item variation is converted
	// to/from the stockable item variation sharing the same parent item. With the stock conversion,
	// you can accurately track inventory when an item variation is sold in one unit, but stocked in
	// another unit.
	StockableConversion *CatalogStockConversion `json:"stockable_conversion,omitempty" url:"stockable_conversion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the unit used to measure a `CatalogItemVariation` and
// specifies the precision for decimal quantities.
type CatalogMeasurementUnit struct {
	// Indicates the unit used to measure the quantity of a catalog item variation.
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in quantities measured with this unit.
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 3
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogMeasurementUnit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogMeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogMeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogMeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogMeasurementUnit) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A modifier applicable to items at the time of sale. An example of a modifier is a Cheese add-on to a Burger item.
type CatalogModifier struct {
	// The modifier name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The modifier price.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Determines where this `CatalogModifier` appears in the `CatalogModifierList`.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// The ID of the `CatalogModifierList` associated with this modifier.
	ModifierListID *string `json:"modifier_list_id,omitempty" url:"modifier_list_id,omitempty"`
	// Location-specific price overrides.
	LocationOverrides []*ModifierLocationOverrides `json:"location_overrides,omitempty" url:"location_overrides,omitempty"`
	// The ID of the image associated with this `CatalogModifier` instance.
	// Currently this image is not displayed by Square, but is free to be displayed in 3rd party applications.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifier) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// For a text-based modifier, this encapsulates the modifier's text when its `modifier_type` is `TEXT`.
// For example, to sell T-shirts with custom prints, a text-based modifier can be used to capture the buyer-supplied
// text string to be selected for the T-shirt at the time of sale.
//
// For non text-based modifiers, this encapsulates a non-empty list of modifiers applicable to items
// at the time of sale. Each element of the modifier list is a `CatalogObject` instance of the `MODIFIER` type.
// For example, a "Condiments" modifier list applicable to a "Hot Dog" item
// may contain "Ketchup", "Mustard", and "Relish" modifiers.
//
// A non text-based modifier can be applied to the modified item once or multiple times, if the `selection_type` field
// is set to `SINGLE` or `MULTIPLE`, respectively. On the other hand, a text-based modifier can be applied to the item
// only once and the `selection_type` field is always set to `SINGLE`.
type CatalogModifierList struct {
	// The name of the `CatalogModifierList` instance. This is a searchable attribute for use in applicable query filters, and its value length is of
	// Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The position of this `CatalogModifierList` within a list of `CatalogModifierList` instances.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// Indicates whether a single (`SINGLE`) or multiple (`MULTIPLE`) modifiers from the list
	// can be applied to a single `CatalogItem`.
	//
	// For text-based modifiers, the `selection_type` attribute is always `SINGLE`. The other value is ignored.
	// See [CatalogModifierListSelectionType](#type-catalogmodifierlistselectiontype) for possible values
	SelectionType *CatalogModifierListSelectionType `json:"selection_type,omitempty" url:"selection_type,omitempty"`
	// A non-empty list of `CatalogModifier` objects to be included in the `CatalogModifierList`,
	// for non text-based modifiers when the `modifier_type` attribute is `LIST`. Each element of this list
	// is a `CatalogObject` instance of the `MODIFIER` type, containing the following attributes:
	//
	// ```
	// {
	// "id": "{{catalog_modifier_id}}",
	// "type": "MODIFIER",
	// "modifier_data": {{a CatalogModifier instance>}}
	// }
	// ```
	Modifiers []*CatalogObject `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The IDs of images associated with this `CatalogModifierList` instance.
	// Currently these images are not displayed on Square products, but may be displayed in 3rd-party applications.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// The type of the modifier.
	//
	// When this `modifier_type` value is `TEXT`, the `CatalogModifierList` represents a text-based modifier.
	// When this `modifier_type` value is `LIST`, the `CatalogModifierList` contains a list of `CatalogModifier` objects.
	// See [CatalogModifierListModifierType](#type-catalogmodifierlistmodifiertype) for possible values
	ModifierType *CatalogModifierListModifierType `json:"modifier_type,omitempty" url:"modifier_type,omitempty"`
	// The maximum length, in Unicode points, of the text string of the text-based modifier as represented by
	// this `CatalogModifierList` object with the `modifier_type` set to `TEXT`.
	MaxLength *int `json:"max_length,omitempty" url:"max_length,omitempty"`
	// Whether the text string must be a non-empty string (`true`) or not (`false`) for a text-based modifier
	// as represented by this `CatalogModifierList` object with the `modifier_type` set to `TEXT`.
	TextRequired *bool `json:"text_required,omitempty" url:"text_required,omitempty"`
	// A note for internal use by the business.
	//
	// For example, for a text-based modifier applied to a T-shirt item, if the buyer-supplied text of "Hello, Kitty!"
	// is to be printed on the T-shirt, this `internal_name` attribute can be "Use italic face" as
	// an instruction for the business to follow.
	//
	// For non text-based modifiers, this `internal_name` attribute can be
	// used to include SKUs, internal codes, or supplemental descriptions for internal use.
	InternalName *string `json:"internal_name,omitempty" url:"internal_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierList) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the type of `CatalogModifierList`.
type CatalogModifierListModifierType string

const (
	CatalogModifierListModifierTypeList CatalogModifierListModifierType = "LIST"
	CatalogModifierListModifierTypeText CatalogModifierListModifierType = "TEXT"
)

func NewCatalogModifierListModifierTypeFromString(s string) (CatalogModifierListModifierType, error) {
	switch s {
	case "LIST":
		return CatalogModifierListModifierTypeList, nil
	case "TEXT":
		return CatalogModifierListModifierTypeText, nil
	}
	var t CatalogModifierListModifierType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogModifierListModifierType) Ptr() *CatalogModifierListModifierType {
	return &c
}

// Indicates whether a CatalogModifierList supports multiple selections.
type CatalogModifierListSelectionType string

const (
	CatalogModifierListSelectionTypeSingle   CatalogModifierListSelectionType = "SINGLE"
	CatalogModifierListSelectionTypeMultiple CatalogModifierListSelectionType = "MULTIPLE"
)

func NewCatalogModifierListSelectionTypeFromString(s string) (CatalogModifierListSelectionType, error) {
	switch s {
	case "SINGLE":
		return CatalogModifierListSelectionTypeSingle, nil
	case "MULTIPLE":
		return CatalogModifierListSelectionTypeMultiple, nil
	}
	var t CatalogModifierListSelectionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogModifierListSelectionType) Ptr() *CatalogModifierListSelectionType {
	return &c
}

// Options to control how to override the default behavior of the specified modifier.
type CatalogModifierOverride struct {
	// The ID of the `CatalogModifier` whose default behavior is being overridden.
	ModifierID string `json:"modifier_id" url:"modifier_id"`
	// If `true`, this `CatalogModifier` should be selected by default for this `CatalogItem`.
	OnByDefault *bool `json:"on_by_default,omitempty" url:"on_by_default,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifierOverride) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierOverride(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierOverride) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The wrapper object for the catalog entries of a given object type.
//
// Depending on the `type` attribute value, a `CatalogObject` instance assumes a type-specific data to yield the corresponding type of catalog object.
//
// For example, if `type=ITEM`, the `CatalogObject` instance must have the ITEM-specific data set on the `item_data` attribute. The resulting `CatalogObject` instance is also a `CatalogItem` instance.
//
// In general, if `type=<OBJECT_TYPE>`, the `CatalogObject` instance must have the `<OBJECT_TYPE>`-specific data set on the `<object_type>_data` attribute. The resulting `CatalogObject` instance is also a `Catalog<ObjectType>` instance.
//
// For a more detailed discussion of the Catalog data model, please see the
// [Design a Catalog](https://developer.squareup.com/docs/catalog-api/design-a-catalog) guide.
type CatalogObject struct {
	Type                      string
	Item                      *CatalogObjectItem
	Image                     *CatalogObjectImage
	Category                  *CatalogObjectCategory
	ItemVariation             *CatalogObjectItemVariation
	Tax                       *CatalogObjectTax
	Discount                  *CatalogObjectDiscount
	ModifierList              *CatalogObjectModifierList
	Modifier                  *CatalogObjectModifier
	DiningOption              *CatalogObjectDiningOption
	TaxExemption              *CatalogObjectTaxExemption
	ServiceCharge             *CatalogObjectServiceCharge
	PricingRule               *CatalogObjectPricingRule
	ProductSet                *CatalogObjectProductSet
	TimePeriod                *CatalogObjectTimePeriod
	MeasurementUnit           *CatalogObjectMeasurementUnit
	SubscriptionPlan          *CatalogObjectSubscriptionPlan
	ItemOption                *CatalogObjectItemOption
	ItemOptionVal             *CatalogObjectItemOptionValue
	CustomAttributeDefinition *CatalogObjectCustomAttributeDefinition
	QuickAmountsSettings      *CatalogObjectQuickAmountsSettings
	Component                 *CatalogObjectComponent
	Composition               *CatalogObjectComposition
	Resource                  *CatalogObjectResource
	CheckoutLink              *CatalogObjectCheckoutLink
	Address                   *CatalogObjectAddress
	SubscriptionProduct       *CatalogObjectSubscriptionProduct
}

func (c *CatalogObject) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "ITEM":
		value := new(CatalogObjectItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Item = value
	case "IMAGE":
		value := new(CatalogObjectImage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Image = value
	case "CATEGORY":
		value := new(CatalogObjectCategory)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Category = value
	case "ITEM_VARIATION":
		value := new(CatalogObjectItemVariation)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ItemVariation = value
	case "TAX":
		value := new(CatalogObjectTax)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Tax = value
	case "DISCOUNT":
		value := new(CatalogObjectDiscount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Discount = value
	case "MODIFIER_LIST":
		value := new(CatalogObjectModifierList)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ModifierList = value
	case "MODIFIER":
		value := new(CatalogObjectModifier)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Modifier = value
	case "DINING_OPTION":
		value := new(CatalogObjectDiningOption)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.DiningOption = value
	case "TAX_EXEMPTION":
		value := new(CatalogObjectTaxExemption)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.TaxExemption = value
	case "SERVICE_CHARGE":
		value := new(CatalogObjectServiceCharge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ServiceCharge = value
	case "PRICING_RULE":
		value := new(CatalogObjectPricingRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.PricingRule = value
	case "PRODUCT_SET":
		value := new(CatalogObjectProductSet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ProductSet = value
	case "TIME_PERIOD":
		value := new(CatalogObjectTimePeriod)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.TimePeriod = value
	case "MEASUREMENT_UNIT":
		value := new(CatalogObjectMeasurementUnit)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.MeasurementUnit = value
	case "SUBSCRIPTION_PLAN":
		value := new(CatalogObjectSubscriptionPlan)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.SubscriptionPlan = value
	case "ITEM_OPTION":
		value := new(CatalogObjectItemOption)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ItemOption = value
	case "ITEM_OPTION_VAL":
		value := new(CatalogObjectItemOptionValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ItemOptionVal = value
	case "CUSTOM_ATTRIBUTE_DEFINITION":
		value := new(CatalogObjectCustomAttributeDefinition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.CustomAttributeDefinition = value
	case "QUICK_AMOUNTS_SETTINGS":
		value := new(CatalogObjectQuickAmountsSettings)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.QuickAmountsSettings = value
	case "COMPONENT":
		value := new(CatalogObjectComponent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Component = value
	case "COMPOSITION":
		value := new(CatalogObjectComposition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Composition = value
	case "RESOURCE":
		value := new(CatalogObjectResource)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Resource = value
	case "CHECKOUT_LINK":
		value := new(CatalogObjectCheckoutLink)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.CheckoutLink = value
	case "ADDRESS":
		value := new(CatalogObjectAddress)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Address = value
	case "SUBSCRIPTION_PRODUCT":
		value := new(CatalogObjectSubscriptionProduct)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.SubscriptionProduct = value
	}
	return nil
}

func (c CatalogObject) MarshalJSON() ([]byte, error) {
	if c.Item != nil {
		return core.MarshalJSONWithExtraProperty(c.Item, "type", "ITEM")
	}
	if c.Image != nil {
		return core.MarshalJSONWithExtraProperty(c.Image, "type", "IMAGE")
	}
	if c.Category != nil {
		return core.MarshalJSONWithExtraProperty(c.Category, "type", "CATEGORY")
	}
	if c.ItemVariation != nil {
		return core.MarshalJSONWithExtraProperty(c.ItemVariation, "type", "ITEM_VARIATION")
	}
	if c.Tax != nil {
		return core.MarshalJSONWithExtraProperty(c.Tax, "type", "TAX")
	}
	if c.Discount != nil {
		return core.MarshalJSONWithExtraProperty(c.Discount, "type", "DISCOUNT")
	}
	if c.ModifierList != nil {
		return core.MarshalJSONWithExtraProperty(c.ModifierList, "type", "MODIFIER_LIST")
	}
	if c.Modifier != nil {
		return core.MarshalJSONWithExtraProperty(c.Modifier, "type", "MODIFIER")
	}
	if c.DiningOption != nil {
		return core.MarshalJSONWithExtraProperty(c.DiningOption, "type", "DINING_OPTION")
	}
	if c.TaxExemption != nil {
		return core.MarshalJSONWithExtraProperty(c.TaxExemption, "type", "TAX_EXEMPTION")
	}
	if c.ServiceCharge != nil {
		return core.MarshalJSONWithExtraProperty(c.ServiceCharge, "type", "SERVICE_CHARGE")
	}
	if c.PricingRule != nil {
		return core.MarshalJSONWithExtraProperty(c.PricingRule, "type", "PRICING_RULE")
	}
	if c.ProductSet != nil {
		return core.MarshalJSONWithExtraProperty(c.ProductSet, "type", "PRODUCT_SET")
	}
	if c.TimePeriod != nil {
		return core.MarshalJSONWithExtraProperty(c.TimePeriod, "type", "TIME_PERIOD")
	}
	if c.MeasurementUnit != nil {
		return core.MarshalJSONWithExtraProperty(c.MeasurementUnit, "type", "MEASUREMENT_UNIT")
	}
	if c.SubscriptionPlan != nil {
		return core.MarshalJSONWithExtraProperty(c.SubscriptionPlan, "type", "SUBSCRIPTION_PLAN")
	}
	if c.ItemOption != nil {
		return core.MarshalJSONWithExtraProperty(c.ItemOption, "type", "ITEM_OPTION")
	}
	if c.ItemOptionVal != nil {
		return core.MarshalJSONWithExtraProperty(c.ItemOptionVal, "type", "ITEM_OPTION_VAL")
	}
	if c.CustomAttributeDefinition != nil {
		return core.MarshalJSONWithExtraProperty(c.CustomAttributeDefinition, "type", "CUSTOM_ATTRIBUTE_DEFINITION")
	}
	if c.QuickAmountsSettings != nil {
		return core.MarshalJSONWithExtraProperty(c.QuickAmountsSettings, "type", "QUICK_AMOUNTS_SETTINGS")
	}
	if c.Component != nil {
		return core.MarshalJSONWithExtraProperty(c.Component, "type", "COMPONENT")
	}
	if c.Composition != nil {
		return core.MarshalJSONWithExtraProperty(c.Composition, "type", "COMPOSITION")
	}
	if c.Resource != nil {
		return core.MarshalJSONWithExtraProperty(c.Resource, "type", "RESOURCE")
	}
	if c.CheckoutLink != nil {
		return core.MarshalJSONWithExtraProperty(c.CheckoutLink, "type", "CHECKOUT_LINK")
	}
	if c.Address != nil {
		return core.MarshalJSONWithExtraProperty(c.Address, "type", "ADDRESS")
	}
	if c.SubscriptionProduct != nil {
		return core.MarshalJSONWithExtraProperty(c.SubscriptionProduct, "type", "SUBSCRIPTION_PRODUCT")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CatalogObjectVisitor interface {
	VisitItem(*CatalogObjectItem) error
	VisitImage(*CatalogObjectImage) error
	VisitCategory(*CatalogObjectCategory) error
	VisitItemVariation(*CatalogObjectItemVariation) error
	VisitTax(*CatalogObjectTax) error
	VisitDiscount(*CatalogObjectDiscount) error
	VisitModifierList(*CatalogObjectModifierList) error
	VisitModifier(*CatalogObjectModifier) error
	VisitDiningOption(*CatalogObjectDiningOption) error
	VisitTaxExemption(*CatalogObjectTaxExemption) error
	VisitServiceCharge(*CatalogObjectServiceCharge) error
	VisitPricingRule(*CatalogObjectPricingRule) error
	VisitProductSet(*CatalogObjectProductSet) error
	VisitTimePeriod(*CatalogObjectTimePeriod) error
	VisitMeasurementUnit(*CatalogObjectMeasurementUnit) error
	VisitSubscriptionPlan(*CatalogObjectSubscriptionPlan) error
	VisitItemOption(*CatalogObjectItemOption) error
	VisitItemOptionVal(*CatalogObjectItemOptionValue) error
	VisitCustomAttributeDefinition(*CatalogObjectCustomAttributeDefinition) error
	VisitQuickAmountsSettings(*CatalogObjectQuickAmountsSettings) error
	VisitComponent(*CatalogObjectComponent) error
	VisitComposition(*CatalogObjectComposition) error
	VisitResource(*CatalogObjectResource) error
	VisitCheckoutLink(*CatalogObjectCheckoutLink) error
	VisitAddress(*CatalogObjectAddress) error
	VisitSubscriptionProduct(*CatalogObjectSubscriptionProduct) error
}

func (c *CatalogObject) Accept(visitor CatalogObjectVisitor) error {
	if c.Item != nil {
		return visitor.VisitItem(c.Item)
	}
	if c.Image != nil {
		return visitor.VisitImage(c.Image)
	}
	if c.Category != nil {
		return visitor.VisitCategory(c.Category)
	}
	if c.ItemVariation != nil {
		return visitor.VisitItemVariation(c.ItemVariation)
	}
	if c.Tax != nil {
		return visitor.VisitTax(c.Tax)
	}
	if c.Discount != nil {
		return visitor.VisitDiscount(c.Discount)
	}
	if c.ModifierList != nil {
		return visitor.VisitModifierList(c.ModifierList)
	}
	if c.Modifier != nil {
		return visitor.VisitModifier(c.Modifier)
	}
	if c.DiningOption != nil {
		return visitor.VisitDiningOption(c.DiningOption)
	}
	if c.TaxExemption != nil {
		return visitor.VisitTaxExemption(c.TaxExemption)
	}
	if c.ServiceCharge != nil {
		return visitor.VisitServiceCharge(c.ServiceCharge)
	}
	if c.PricingRule != nil {
		return visitor.VisitPricingRule(c.PricingRule)
	}
	if c.ProductSet != nil {
		return visitor.VisitProductSet(c.ProductSet)
	}
	if c.TimePeriod != nil {
		return visitor.VisitTimePeriod(c.TimePeriod)
	}
	if c.MeasurementUnit != nil {
		return visitor.VisitMeasurementUnit(c.MeasurementUnit)
	}
	if c.SubscriptionPlan != nil {
		return visitor.VisitSubscriptionPlan(c.SubscriptionPlan)
	}
	if c.ItemOption != nil {
		return visitor.VisitItemOption(c.ItemOption)
	}
	if c.ItemOptionVal != nil {
		return visitor.VisitItemOptionVal(c.ItemOptionVal)
	}
	if c.CustomAttributeDefinition != nil {
		return visitor.VisitCustomAttributeDefinition(c.CustomAttributeDefinition)
	}
	if c.QuickAmountsSettings != nil {
		return visitor.VisitQuickAmountsSettings(c.QuickAmountsSettings)
	}
	if c.Component != nil {
		return visitor.VisitComponent(c.Component)
	}
	if c.Composition != nil {
		return visitor.VisitComposition(c.Composition)
	}
	if c.Resource != nil {
		return visitor.VisitResource(c.Resource)
	}
	if c.CheckoutLink != nil {
		return visitor.VisitCheckoutLink(c.CheckoutLink)
	}
	if c.Address != nil {
		return visitor.VisitAddress(c.Address)
	}
	if c.SubscriptionProduct != nil {
		return visitor.VisitSubscriptionProduct(c.SubscriptionProduct)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CatalogObjectAddress struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectAddress) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectAddress) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectAddress
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectAddress(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectAddress) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectBase struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectBase) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectBase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectBase) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A batch of catalog objects.
type CatalogObjectBatch struct {
	// A list of CatalogObjects belonging to this batch.
	Objects []*CatalogObject `json:"objects,omitempty" url:"objects,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectBatch) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectBatch) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectBatch
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectBatch(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectBatch) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A category that can be assigned to an item or a parent category that can be assigned
// to another category. For example, a clothing category can be assigned to a t-shirt item or
// be made as the parent category to the pants category.
type CatalogObjectCategory struct {
	// The ID of the object's category.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The order of the object within the context of the category.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// Structured data for a `CatalogCategory`, set for CatalogObjects of type `CATEGORY`.
	CategoryData *CatalogCategory `json:"category_data,omitempty" url:"category_data,omitempty"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectCategory) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectCategory(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectCategory) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectCheckoutLink struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectCheckoutLink) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectCheckoutLink) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectCheckoutLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectCheckoutLink(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectCheckoutLink) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectComponent struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectComponent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectComponent) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectComponent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectComponent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectComponent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectComposition struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectComposition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectComposition) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectComposition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectComposition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectComposition) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectCustomAttributeDefinition struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogCustomAttributeDefinition`, set for CatalogObjects of type `CUSTOM_ATTRIBUTE_DEFINITION`.
	CustomAttributeDefinitionData *CatalogCustomAttributeDefinition `json:"custom_attribute_definition_data,omitempty" url:"custom_attribute_definition_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectCustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectCustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectCustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectCustomAttributeDefinition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectCustomAttributeDefinition) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectDiningOption struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectDiningOption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectDiningOption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectDiningOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectDiningOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectDiningOption) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectDiscount struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogDiscount`, set for CatalogObjects of type `DISCOUNT`.
	DiscountData *CatalogDiscount `json:"discount_data,omitempty" url:"discount_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectDiscount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectDiscount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectImage struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogImage`, set for CatalogObjects of type `IMAGE`.
	ImageData *CatalogImage `json:"image_data,omitempty" url:"image_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectImage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectImage) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectImage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectImage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItem struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItem`, set for CatalogObjects of type `ITEM`.
	ItemData *CatalogItem `json:"item_data,omitempty" url:"item_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItemOption struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItemOption`, set for CatalogObjects of type `ITEM_OPTION`.
	ItemOptionData *CatalogItemOption `json:"item_option_data,omitempty" url:"item_option_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectItemOption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItemOption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItemOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItemOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItemOption) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItemOptionValue struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItemOptionValue`, set for CatalogObjects of type `ITEM_OPTION_VAL`.
	ItemOptionValueData *CatalogItemOptionValue `json:"item_option_value_data,omitempty" url:"item_option_value_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectItemOptionValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItemOptionValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItemOptionValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItemOptionValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItemOptionValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItemVariation struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItemVariation`, set for CatalogObjects of type `ITEM_VARIATION`.
	ItemVariationData *CatalogItemVariation `json:"item_variation_data,omitempty" url:"item_variation_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItemVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItemVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectMeasurementUnit struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogMeasurementUnit`, set for CatalogObjects of type `MEASUREMENT_UNIT`.
	MeasurementUnitData *CatalogMeasurementUnit `json:"measurement_unit_data,omitempty" url:"measurement_unit_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectMeasurementUnit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectMeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectMeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectMeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectMeasurementUnit) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectModifier struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogModifier`, set for CatalogObjects of type `MODIFIER`.
	ModifierData *CatalogModifier `json:"modifier_data,omitempty" url:"modifier_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectModifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectModifier) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectModifierList struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogModifierList`, set for CatalogObjects of type `MODIFIER_LIST`.
	ModifierListData *CatalogModifierList `json:"modifier_list_data,omitempty" url:"modifier_list_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectModifierList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectModifierList) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectPricingRule struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogPricingRule`, set for CatalogObjects of type `PRICING_RULE`.
	// A `CatalogPricingRule` object often works with a `CatalogProductSet` object or a `CatalogTimePeriod` object.
	PricingRuleData *CatalogPricingRule `json:"pricing_rule_data,omitempty" url:"pricing_rule_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectPricingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectPricingRule) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectPricingRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectPricingRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectPricingRule) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectProductSet struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogProductSet`, set for CatalogObjects of type `PRODUCT_SET`.
	ProductSetData *CatalogProductSet `json:"product_set_data,omitempty" url:"product_set_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectProductSet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectProductSet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectProductSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectProductSet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectProductSet) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectQuickAmountsSettings struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogQuickAmountsSettings`, set for CatalogObjects of type `QUICK_AMOUNTS_SETTINGS`.
	QuickAmountsSettingsData *CatalogQuickAmountsSettings `json:"quick_amounts_settings_data,omitempty" url:"quick_amounts_settings_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectQuickAmountsSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectQuickAmountsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectQuickAmountsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectQuickAmountsSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectQuickAmountsSettings) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A reference to a Catalog object at a specific version. In general this is
// used as an entry point into a graph of catalog objects, where the objects exist
// at a specific version.
type CatalogObjectReference struct {
	// The ID of the referenced object.
	ObjectID *string `json:"object_id,omitempty" url:"object_id,omitempty"`
	// The version of the object.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectReference) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectReference) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectReference(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectReference) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectResource struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectResource) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectResource) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectResource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectResource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectResource) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectServiceCharge struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectServiceCharge) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectServiceCharge) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectSubscriptionPlan struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogSubscriptionPlan`, set for CatalogObjects of type `SUBSCRIPTION_PLAN`.
	SubscriptionPlanData *CatalogSubscriptionPlan `json:"subscription_plan_data,omitempty" url:"subscription_plan_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectSubscriptionPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectSubscriptionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectSubscriptionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectSubscriptionPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectSubscriptionPlan) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectSubscriptionProduct struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectSubscriptionProduct) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectSubscriptionProduct) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectSubscriptionProduct
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectSubscriptionProduct(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectSubscriptionProduct) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectTax struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogTax`, set for CatalogObjects of type `TAX`.
	TaxData *CatalogTax `json:"tax_data,omitempty" url:"tax_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectTax) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectTaxExemption struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectTaxExemption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectTaxExemption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectTaxExemption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectTaxExemption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectTaxExemption) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectTimePeriod struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogTimePeriod`, set for CatalogObjects of type `TIME_PERIOD`.
	TimePeriodData *CatalogTimePeriod `json:"time_period_data,omitempty" url:"time_period_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObjectTimePeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectTimePeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectTimePeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectTimePeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectTimePeriod) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Possible types of CatalogObjects returned from the catalog, each
// containing type-specific properties in the `*_data` field corresponding to the specified object type.
type CatalogObjectType string

const (
	CatalogObjectTypeItem                      CatalogObjectType = "ITEM"
	CatalogObjectTypeImage                     CatalogObjectType = "IMAGE"
	CatalogObjectTypeCategory                  CatalogObjectType = "CATEGORY"
	CatalogObjectTypeItemVariation             CatalogObjectType = "ITEM_VARIATION"
	CatalogObjectTypeTax                       CatalogObjectType = "TAX"
	CatalogObjectTypeDiscount                  CatalogObjectType = "DISCOUNT"
	CatalogObjectTypeModifierList              CatalogObjectType = "MODIFIER_LIST"
	CatalogObjectTypeModifier                  CatalogObjectType = "MODIFIER"
	CatalogObjectTypePricingRule               CatalogObjectType = "PRICING_RULE"
	CatalogObjectTypeProductSet                CatalogObjectType = "PRODUCT_SET"
	CatalogObjectTypeTimePeriod                CatalogObjectType = "TIME_PERIOD"
	CatalogObjectTypeMeasurementUnit           CatalogObjectType = "MEASUREMENT_UNIT"
	CatalogObjectTypeSubscriptionPlanVariation CatalogObjectType = "SUBSCRIPTION_PLAN_VARIATION"
	CatalogObjectTypeItemOption                CatalogObjectType = "ITEM_OPTION"
	CatalogObjectTypeItemOptionVal             CatalogObjectType = "ITEM_OPTION_VAL"
	CatalogObjectTypeCustomAttributeDefinition CatalogObjectType = "CUSTOM_ATTRIBUTE_DEFINITION"
	CatalogObjectTypeQuickAmountsSettings      CatalogObjectType = "QUICK_AMOUNTS_SETTINGS"
	CatalogObjectTypeSubscriptionPlan          CatalogObjectType = "SUBSCRIPTION_PLAN"
	CatalogObjectTypeAvailabilityPeriod        CatalogObjectType = "AVAILABILITY_PERIOD"
)

func NewCatalogObjectTypeFromString(s string) (CatalogObjectType, error) {
	switch s {
	case "ITEM":
		return CatalogObjectTypeItem, nil
	case "IMAGE":
		return CatalogObjectTypeImage, nil
	case "CATEGORY":
		return CatalogObjectTypeCategory, nil
	case "ITEM_VARIATION":
		return CatalogObjectTypeItemVariation, nil
	case "TAX":
		return CatalogObjectTypeTax, nil
	case "DISCOUNT":
		return CatalogObjectTypeDiscount, nil
	case "MODIFIER_LIST":
		return CatalogObjectTypeModifierList, nil
	case "MODIFIER":
		return CatalogObjectTypeModifier, nil
	case "PRICING_RULE":
		return CatalogObjectTypePricingRule, nil
	case "PRODUCT_SET":
		return CatalogObjectTypeProductSet, nil
	case "TIME_PERIOD":
		return CatalogObjectTypeTimePeriod, nil
	case "MEASUREMENT_UNIT":
		return CatalogObjectTypeMeasurementUnit, nil
	case "SUBSCRIPTION_PLAN_VARIATION":
		return CatalogObjectTypeSubscriptionPlanVariation, nil
	case "ITEM_OPTION":
		return CatalogObjectTypeItemOption, nil
	case "ITEM_OPTION_VAL":
		return CatalogObjectTypeItemOptionVal, nil
	case "CUSTOM_ATTRIBUTE_DEFINITION":
		return CatalogObjectTypeCustomAttributeDefinition, nil
	case "QUICK_AMOUNTS_SETTINGS":
		return CatalogObjectTypeQuickAmountsSettings, nil
	case "SUBSCRIPTION_PLAN":
		return CatalogObjectTypeSubscriptionPlan, nil
	case "AVAILABILITY_PERIOD":
		return CatalogObjectTypeAvailabilityPeriod, nil
	}
	var t CatalogObjectType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogObjectType) Ptr() *CatalogObjectType {
	return &c
}

// Defines how discounts are automatically applied to a set of items that match the pricing rule
// during the active time period.
type CatalogPricingRule struct {
	// User-defined name for the pricing rule. For example, "Buy one get one
	// free" or "10% off".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A list of unique IDs for the catalog time periods when
	// this pricing rule is in effect. If left unset, the pricing rule is always
	// in effect.
	TimePeriodIDs []string `json:"time_period_ids,omitempty" url:"time_period_ids,omitempty"`
	// Unique ID for the `CatalogDiscount` to take off
	// the price of all matched items.
	DiscountID *string `json:"discount_id,omitempty" url:"discount_id,omitempty"`
	// Unique ID for the `CatalogProductSet` that will be matched by this rule. A match rule
	// matches within the entire cart, and can match multiple times. This field will always be set.
	MatchProductsID *string `json:"match_products_id,omitempty" url:"match_products_id,omitempty"`
	// **Deprecated**: Please use the `exclude_products_id` field to apply
	// an exclude set instead. Exclude sets allow better control over quantity
	// ranges and offer more flexibility for which matched items receive a discount.
	//
	// `CatalogProductSet` to apply the pricing to.
	// An apply rule matches within the subset of the cart that fits the match rules (the match set).
	// An apply rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ApplyProductsID *string `json:"apply_products_id,omitempty" url:"apply_products_id,omitempty"`
	// `CatalogProductSet` to exclude from the pricing rule.
	// An exclude rule matches within the subset of the cart that fits the match rules (the match set).
	// An exclude rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ExcludeProductsID *string `json:"exclude_products_id,omitempty" url:"exclude_products_id,omitempty"`
	// Represents the date the Pricing Rule is valid from. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidFromDate *string `json:"valid_from_date,omitempty" url:"valid_from_date,omitempty"`
	// Represents the local time the pricing rule should be valid from. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidFromLocalTime *string `json:"valid_from_local_time,omitempty" url:"valid_from_local_time,omitempty"`
	// Represents the date the Pricing Rule is valid until. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidUntilDate *string `json:"valid_until_date,omitempty" url:"valid_until_date,omitempty"`
	// Represents the local time the pricing rule should be valid until. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidUntilLocalTime *string `json:"valid_until_local_time,omitempty" url:"valid_until_local_time,omitempty"`
	// If an `exclude_products_id` was given, controls which subset of matched
	// products is excluded from any discounts.
	//
	// Default value: `LEAST_EXPENSIVE`
	// See [ExcludeStrategy](#type-excludestrategy) for possible values
	ExcludeStrategy *ExcludeStrategy `json:"exclude_strategy,omitempty" url:"exclude_strategy,omitempty"`
	// The minimum order subtotal (before discounts or taxes are applied)
	// that must be met before this rule may be applied.
	MinimumOrderSubtotalMoney *Money `json:"minimum_order_subtotal_money,omitempty" url:"minimum_order_subtotal_money,omitempty"`
	// A list of IDs of customer groups, the members of which are eligible for discounts specified in this pricing rule.
	// Notice that a group ID is generated by the Customers API.
	// If this field is not set, the specified discount applies to matched products sold to anyone whether the buyer
	// has a customer profile created or not. If this `customer_group_ids_any` field is set, the specified discount
	// applies only to matched products sold to customers belonging to the specified customer groups.
	CustomerGroupIDsAny []string `json:"customer_group_ids_any,omitempty" url:"customer_group_ids_any,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogPricingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogPricingRule) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogPricingRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogPricingRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogPricingRule) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether the price of a CatalogItemVariation should be entered manually at the time of sale.
type CatalogPricingType string

const (
	CatalogPricingTypeFixedPricing    CatalogPricingType = "FIXED_PRICING"
	CatalogPricingTypeVariablePricing CatalogPricingType = "VARIABLE_PRICING"
)

func NewCatalogPricingTypeFromString(s string) (CatalogPricingType, error) {
	switch s {
	case "FIXED_PRICING":
		return CatalogPricingTypeFixedPricing, nil
	case "VARIABLE_PRICING":
		return CatalogPricingTypeVariablePricing, nil
	}
	var t CatalogPricingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogPricingType) Ptr() *CatalogPricingType {
	return &c
}

// Represents a collection of catalog objects for the purpose of applying a
// `PricingRule`. Including a catalog object will include all of its subtypes.
// For example, including a category in a product set will include all of its
// items and associated item variations in the product set. Including an item in
// a product set will also include its item variations.
type CatalogProductSet struct {
	// User-defined name for the product set. For example, "Clearance Items"
	// or "Winter Sale Items".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Unique IDs for any `CatalogObject` included in this product set. Any
	// number of these catalog objects can be in an order for a pricing rule to apply.
	//
	// This can be used with `product_ids_all` in a parent `CatalogProductSet` to
	// match groups of products for a bulk discount, such as a discount for an
	// entree and side combo.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIDsAny []string `json:"product_ids_any,omitempty" url:"product_ids_any,omitempty"`
	// Unique IDs for any `CatalogObject` included in this product set.
	// All objects in this set must be included in an order for a pricing rule to apply.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIDsAll []string `json:"product_ids_all,omitempty" url:"product_ids_all,omitempty"`
	// If set, there must be exactly this many items from `products_any` or `products_all`
	// in the cart for the discount to apply.
	//
	// Cannot be combined with either `quantity_min` or `quantity_max`.
	QuantityExact *int64 `json:"quantity_exact,omitempty" url:"quantity_exact,omitempty"`
	// If set, there must be at least this many items from `products_any` or `products_all`
	// in a cart for the discount to apply. See `quantity_exact`. Defaults to 0 if
	// `quantity_exact`, `quantity_min` and `quantity_max` are all unspecified.
	QuantityMin *int64 `json:"quantity_min,omitempty" url:"quantity_min,omitempty"`
	// If set, the pricing rule will apply to a maximum of this many items from
	// `products_any` or `products_all`.
	QuantityMax *int64 `json:"quantity_max,omitempty" url:"quantity_max,omitempty"`
	// If set to `true`, the product set will include every item in the catalog.
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	AllProducts *bool `json:"all_products,omitempty" url:"all_products,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogProductSet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogProductSet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogProductSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogProductSet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogProductSet) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A query composed of one or more different types of filters to narrow the scope of targeted objects when calling the `SearchCatalogObjects` endpoint.
//
// Although a query can have multiple filters, only certain query types can be combined per call to [SearchCatalogObjects]($e/Catalog/SearchCatalogObjects).
// Any combination of the following types may be used together:
//
// - [exact_query]($m/CatalogQueryExact)
// - [prefix_query]($m/CatalogQueryPrefix)
// - [range_query]($m/CatalogQueryRange)
// - [sorted_attribute_query]($m/CatalogQuerySortedAttribute)
// - [text_query]($m/CatalogQueryText)
//
// All other query types cannot be combined with any others.
//
// When a query filter is based on an attribute, the attribute must be searchable.
// Searchable attributes are listed as follows, along their parent types that can be searched for with applicable query filters.
//
// Searchable attribute and objects queryable by searchable attributes:
//
// - `name`: `CatalogItem`, `CatalogItemVariation`, `CatalogCategory`, `CatalogTax`, `CatalogDiscount`, `CatalogModifier`, `CatalogModifierList`, `CatalogItemOption`, `CatalogItemOptionValue`
// - `description`: `CatalogItem`, `CatalogItemOptionValue`
// - `abbreviation`: `CatalogItem`
// - `upc`: `CatalogItemVariation`
// - `sku`: `CatalogItemVariation`
// - `caption`: `CatalogImage`
// - `display_name`: `CatalogItemOption`
//
// For example, to search for [CatalogItem]($m/CatalogItem) objects by searchable attributes, you can use
// the `"name"`, `"description"`, or `"abbreviation"` attribute in an applicable query filter.
type CatalogQuery struct {
	// A query expression to sort returned query result by the given attribute.
	SortedAttributeQuery *CatalogQuerySortedAttribute `json:"sorted_attribute_query,omitempty" url:"sorted_attribute_query,omitempty"`
	// An exact query expression to return objects with attribute name and value
	// matching the specified attribute name and value exactly. Value matching is case insensitive.
	ExactQuery *CatalogQueryExact `json:"exact_query,omitempty" url:"exact_query,omitempty"`
	// A set query expression to return objects with attribute name and value
	// matching the specified attribute name and any of the specified attribute values exactly.
	// Value matching is case insensitive.
	SetQuery *CatalogQuerySet `json:"set_query,omitempty" url:"set_query,omitempty"`
	// A prefix query expression to return objects with attribute values
	// that have a prefix matching the specified string value. Value matching is case insensitive.
	PrefixQuery *CatalogQueryPrefix `json:"prefix_query,omitempty" url:"prefix_query,omitempty"`
	// A range query expression to return objects with numeric values
	// that lie in the specified range.
	RangeQuery *CatalogQueryRange `json:"range_query,omitempty" url:"range_query,omitempty"`
	// A text query expression to return objects whose searchable attributes contain all of the given
	// keywords, irrespective of their order. For example, if a `CatalogItem` contains custom attribute values of
	// `{"name": "t-shirt"}` and `{"description": "Small, Purple"}`, the query filter of `{"keywords": ["shirt", "sma", "purp"]}`
	// returns this item.
	TextQuery *CatalogQueryText `json:"text_query,omitempty" url:"text_query,omitempty"`
	// A query expression to return items that have any of the specified taxes (as identified by the corresponding `CatalogTax` object IDs) enabled.
	ItemsForTaxQuery *CatalogQueryItemsForTax `json:"items_for_tax_query,omitempty" url:"items_for_tax_query,omitempty"`
	// A query expression to return items that have any of the given modifier list (as identified by the corresponding `CatalogModifierList`s IDs) enabled.
	ItemsForModifierListQuery *CatalogQueryItemsForModifierList `json:"items_for_modifier_list_query,omitempty" url:"items_for_modifier_list_query,omitempty"`
	// A query expression to return items that contains the specified item options (as identified the corresponding `CatalogItemOption` IDs).
	ItemsForItemOptionsQuery *CatalogQueryItemsForItemOptions `json:"items_for_item_options_query,omitempty" url:"items_for_item_options_query,omitempty"`
	// A query expression to return item variations (of the [CatalogItemVariation](entity:CatalogItemVariation) type) that
	// contain all of the specified `CatalogItemOption` IDs.
	ItemVariationsForItemOptionValuesQuery *CatalogQueryItemVariationsForItemOptionValues `json:"item_variations_for_item_option_values_query,omitempty" url:"item_variations_for_item_option_values_query,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuery) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuery) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result by exact match of the specified attribute name and value.
type CatalogQueryExact struct {
	// The name of the attribute to be searched. Matching of the attribute name is exact.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired value of the search attribute. Matching of the attribute value is case insensitive and can be partial.
	// For example, if a specified value of "sma", objects with the named attribute value of "Small", "small" are both matched.
	AttributeValue string `json:"attribute_value" url:"attribute_value"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryExact) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryExact) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryExact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryExact(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryExact) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the item variations containing the specified item option value IDs.
type CatalogQueryItemVariationsForItemOptionValues struct {
	// A set of `CatalogItemOptionValue` IDs to be used to find associated
	// `CatalogItemVariation`s. All ItemVariations that contain all of the given
	// Item Option Values (in any order) will be returned.
	ItemOptionValueIDs []string `json:"item_option_value_ids,omitempty" url:"item_option_value_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemVariationsForItemOptionValues) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemVariationsForItemOptionValues) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemVariationsForItemOptionValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemVariationsForItemOptionValues(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemVariationsForItemOptionValues) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the items containing the specified item option IDs.
type CatalogQueryItemsForItemOptions struct {
	// A set of `CatalogItemOption` IDs to be used to find associated
	// `CatalogItem`s. All Items that contain all of the given Item Options (in any order)
	// will be returned.
	ItemOptionIDs []string `json:"item_option_ids,omitempty" url:"item_option_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemsForItemOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemsForItemOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemsForItemOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemsForItemOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemsForItemOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the items containing the specified modifier list IDs.
type CatalogQueryItemsForModifierList struct {
	// A set of `CatalogModifierList` IDs to be used to find associated `CatalogItem`s.
	ModifierListIDs []string `json:"modifier_list_ids,omitempty" url:"modifier_list_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemsForModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemsForModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemsForModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemsForModifierList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemsForModifierList) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the items containing the specified tax IDs.
type CatalogQueryItemsForTax struct {
	// A set of `CatalogTax` IDs to be used to find associated `CatalogItem`s.
	TaxIDs []string `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryItemsForTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryItemsForTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryItemsForTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryItemsForTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryItemsForTax) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result whose named attribute values are prefixed by the specified attribute value.
type CatalogQueryPrefix struct {
	// The name of the attribute to be searched.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired prefix of the search attribute value.
	AttributePrefix string `json:"attribute_prefix" url:"attribute_prefix"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryPrefix) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryPrefix) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryPrefix
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryPrefix(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryPrefix) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result whose named attribute values fall between the specified range.
type CatalogQueryRange struct {
	// The name of the attribute to be searched.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired minimum value for the search attribute (inclusive).
	AttributeMinValue *int64 `json:"attribute_min_value,omitempty" url:"attribute_min_value,omitempty"`
	// The desired maximum value for the search attribute (inclusive).
	AttributeMaxValue *int64 `json:"attribute_max_value,omitempty" url:"attribute_max_value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryRange) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryRange) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryRange) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result(s) by exact match of the specified `attribute_name` and any of
// the `attribute_values`.
type CatalogQuerySet struct {
	// The name of the attribute to be searched. Matching of the attribute name is exact.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The desired values of the search attribute. Matching of the attribute values is exact and case insensitive.
	// A maximum of 250 values may be searched in a request.
	AttributeValues []string `json:"attribute_values,omitempty" url:"attribute_values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuerySet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuerySet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuerySet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuerySet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuerySet) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query expression to specify the key to sort search results.
type CatalogQuerySortedAttribute struct {
	// The attribute whose value is used as the sort key.
	AttributeName string `json:"attribute_name" url:"attribute_name"`
	// The first attribute value to be returned by the query. Ascending sorts will return only
	// objects with this value or greater, while descending sorts will return only objects with this value
	// or less. If unset, start at the beginning (for ascending sorts) or end (for descending sorts).
	InitialAttributeValue *string `json:"initial_attribute_value,omitempty" url:"initial_attribute_value,omitempty"`
	// The desired sort order, `"ASC"` (ascending) or `"DESC"` (descending).
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuerySortedAttribute) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuerySortedAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuerySortedAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuerySortedAttribute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuerySortedAttribute) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The query filter to return the search result whose searchable attribute values contain all of the specified keywords or tokens, independent of the token order or case.
type CatalogQueryText struct {
	// A list of 1, 2, or 3 search keywords. Keywords with fewer than 3 alphanumeric characters are ignored.
	Keywords []string `json:"keywords,omitempty" url:"keywords,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQueryText) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQueryText) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQueryText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQueryText(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQueryText) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a Quick Amount in the Catalog.
type CatalogQuickAmount struct {
	// Represents the type of the Quick Amount.
	// See [CatalogQuickAmountType](#type-catalogquickamounttype) for possible values
	Type CatalogQuickAmountType `json:"type" url:"type"`
	// Represents the actual amount of the Quick Amount with Money type.
	Amount *Money `json:"amount,omitempty" url:"amount,omitempty"`
	// Describes the ranking of the Quick Amount provided by machine learning model, in the range [0, 100].
	// MANUAL type amount will always have score = 100.
	Score *int64 `json:"score,omitempty" url:"score,omitempty"`
	// The order in which this Quick Amount should be displayed.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuickAmount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines the type of a specific Quick Amount.
type CatalogQuickAmountType string

const (
	CatalogQuickAmountTypeQuickAmountTypeManual CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_MANUAL"
	CatalogQuickAmountTypeQuickAmountTypeAuto   CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_AUTO"
)

func NewCatalogQuickAmountTypeFromString(s string) (CatalogQuickAmountType, error) {
	switch s {
	case "QUICK_AMOUNT_TYPE_MANUAL":
		return CatalogQuickAmountTypeQuickAmountTypeManual, nil
	case "QUICK_AMOUNT_TYPE_AUTO":
		return CatalogQuickAmountTypeQuickAmountTypeAuto, nil
	}
	var t CatalogQuickAmountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountType) Ptr() *CatalogQuickAmountType {
	return &c
}

// A parent Catalog Object model represents a set of Quick Amounts and the settings control the amounts.
type CatalogQuickAmountsSettings struct {
	// Represents the option seller currently uses on Quick Amounts.
	// See [CatalogQuickAmountsSettingsOption](#type-catalogquickamountssettingsoption) for possible values
	Option CatalogQuickAmountsSettingsOption `json:"option" url:"option"`
	// Represents location's eligibility for auto amounts
	// The boolean should be consistent with whether there are AUTO amounts in the `amounts`.
	EligibleForAutoAmounts *bool `json:"eligible_for_auto_amounts,omitempty" url:"eligible_for_auto_amounts,omitempty"`
	// Represents a set of Quick Amounts at this location.
	Amounts []*CatalogQuickAmount `json:"amounts,omitempty" url:"amounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuickAmountsSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmountsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmountsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmountsSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmountsSettings) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines a seller's option on Quick Amounts feature.
type CatalogQuickAmountsSettingsOption string

const (
	CatalogQuickAmountsSettingsOptionDisabled CatalogQuickAmountsSettingsOption = "DISABLED"
	CatalogQuickAmountsSettingsOptionManual   CatalogQuickAmountsSettingsOption = "MANUAL"
	CatalogQuickAmountsSettingsOptionAuto     CatalogQuickAmountsSettingsOption = "AUTO"
)

func NewCatalogQuickAmountsSettingsOptionFromString(s string) (CatalogQuickAmountsSettingsOption, error) {
	switch s {
	case "DISABLED":
		return CatalogQuickAmountsSettingsOptionDisabled, nil
	case "MANUAL":
		return CatalogQuickAmountsSettingsOptionManual, nil
	case "AUTO":
		return CatalogQuickAmountsSettingsOptionAuto, nil
	}
	var t CatalogQuickAmountsSettingsOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountsSettingsOption) Ptr() *CatalogQuickAmountsSettingsOption {
	return &c
}

// Represents the rule of conversion between a stockable [CatalogItemVariation]($m/CatalogItemVariation)
// and a non-stockable sell-by or receive-by `CatalogItemVariation` that
// share the same underlying stock.
type CatalogStockConversion struct {
	// References to the stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// for this stock conversion. Selling, receiving or recounting the non-stockable `CatalogItemVariation`
	// defined with a stock conversion results in adjustments of this stockable `CatalogItemVariation`.
	// This immutable field must reference a stockable `CatalogItemVariation`
	// that shares the parent [CatalogItem](entity:CatalogItem) of the converted `CatalogItemVariation.`
	StockableItemVariationID string `json:"stockable_item_variation_id" url:"stockable_item_variation_id"`
	// The quantity of the stockable item variation (as identified by `stockable_item_variation_id`)
	// equivalent to the non-stockable item variation quantity (as specified in `nonstockable_quantity`)
	// as defined by this stock conversion. It accepts a decimal number in a string format that can take
	// up to 10 digits before the decimal point and up to 5 digits after the decimal point.
	StockableQuantity string `json:"stockable_quantity" url:"stockable_quantity"`
	// The converted equivalent quantity of the non-stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// in its measurement unit. The `stockable_quantity` value and this `nonstockable_quantity` value together
	// define the conversion ratio between stockable item variation and the non-stockable item variation.
	// It accepts a decimal number in a string format that can take up to 10 digits before the decimal point
	// and up to 5 digits after the decimal point.
	NonstockableQuantity string `json:"nonstockable_quantity" url:"nonstockable_quantity"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogStockConversion) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogStockConversion) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogStockConversion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogStockConversion(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogStockConversion) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a subscription plan. A subscription plan represents what you want to sell in a subscription model, and includes references to each of the associated subscription plan variations.
// For more information, see [Subscription Plans and Variations](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations).
type CatalogSubscriptionPlan struct {
	// The name of the plan.
	Name string `json:"name" url:"name"`
	// A list of SubscriptionPhase containing the [SubscriptionPhase](entity:SubscriptionPhase) for this plan.
	// This field it required. Not including this field will throw a REQUIRED_FIELD_MISSING error
	Phases []*SubscriptionPhase `json:"phases,omitempty" url:"phases,omitempty"`
	// The list of subscription plan variations available for this product
	SubscriptionPlanVariations []*CatalogObject `json:"subscription_plan_variations,omitempty" url:"subscription_plan_variations,omitempty"`
	// The list of IDs of `CatalogItems` that are eligible for subscription by this SubscriptionPlan's variations.
	EligibleItemIDs []string `json:"eligible_item_ids,omitempty" url:"eligible_item_ids,omitempty"`
	// The list of IDs of `CatalogCategory` that are eligible for subscription by this SubscriptionPlan's variations.
	EligibleCategoryIDs []string `json:"eligible_category_ids,omitempty" url:"eligible_category_ids,omitempty"`
	// If true, all items in the merchant's catalog are subscribable by this SubscriptionPlan.
	AllItems *bool `json:"all_items,omitempty" url:"all_items,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogSubscriptionPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogSubscriptionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogSubscriptionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogSubscriptionPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogSubscriptionPlan) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a subscription plan variation. A subscription plan variation represents how the subscription for a product or service is sold.
// For more information, see [Subscription Plans and Variations](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations).
type CatalogSubscriptionPlanVariation struct {
	// The name of the plan variation.
	Name string `json:"name" url:"name"`
	// A list containing each [SubscriptionPhase](entity:SubscriptionPhase) for this plan variation.
	Phases []*SubscriptionPhase `json:"phases,omitempty" url:"phases,omitempty"`
	// The id of the subscription plan, if there is one.
	SubscriptionPlanID *string `json:"subscription_plan_id,omitempty" url:"subscription_plan_id,omitempty"`
	// The day of the month the billing period starts.
	MonthlyBillingAnchorDate *int64 `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// Whether bills for this plan variation can be split for proration.
	CanProrate *bool `json:"can_prorate,omitempty" url:"can_prorate,omitempty"`
	// The ID of a "successor" plan variation to this one. If the field is set, and this object is disabled at all
	// locations, it indicates that this variation is deprecated and the object identified by the successor ID be used in
	// its stead.
	SuccessorPlanVariationID *string `json:"successor_plan_variation_id,omitempty" url:"successor_plan_variation_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogSubscriptionPlanVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogSubscriptionPlanVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogSubscriptionPlanVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogSubscriptionPlanVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogSubscriptionPlanVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A tax applicable to an item.
type CatalogTax struct {
	// The tax's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Whether the tax is calculated based on a payment's subtotal or total.
	// See [TaxCalculationPhase](#type-taxcalculationphase) for possible values
	CalculationPhase *TaxCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Whether the tax is `ADDITIVE` or `INCLUSIVE`.
	// See [TaxInclusionType](#type-taxinclusiontype) for possible values
	InclusionType *TaxInclusionType `json:"inclusion_type,omitempty" url:"inclusion_type,omitempty"`
	// The percentage of the tax in decimal form, using a `'.'` as the decimal separator and without a `'%'` sign.
	// A value of `7.5` corresponds to 7.5%. For a location-specific tax rate, contact the tax authority of the location or a tax consultant.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// If `true`, the fee applies to custom amounts entered into the Square Point of Sale
	// app that are not associated with a particular `CatalogItem`.
	AppliesToCustomAmounts *bool `json:"applies_to_custom_amounts,omitempty" url:"applies_to_custom_amounts,omitempty"`
	// A Boolean flag to indicate whether the tax is displayed as enabled (`true`) in the Square Point of Sale app or not (`false`).
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The ID of a `CatalogProductSet` object. If set, the tax is applicable to all products in the product set.
	AppliesToProductSetID *string `json:"applies_to_product_set_id,omitempty" url:"applies_to_product_set_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTax) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a time period - either a single period or a repeating period.
type CatalogTimePeriod struct {
	// An iCalendar (RFC 5545) [event](https://tools.ietf.org/html/rfc5545#section-3.6.1), which
	// specifies the name, timing, duration and recurrence of this time period.
	//
	// Example:
	//
	// ```
	// DTSTART:20190707T180000
	// DURATION:P2H
	// RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR
	// ```
	//
	// Only `SUMMARY`, `DTSTART`, `DURATION` and `RRULE` fields are supported.
	// `DTSTART` must be in local (unzoned) time format. Note that while `BEGIN:VEVENT`
	// and `END:VEVENT` is not required in the request. The response will always
	// include them.
	Event *string `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogTimePeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTimePeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTimePeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTimePeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTimePeriod) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A Square API V1 identifier of an item, including the object ID and its associated location ID.
type CatalogV1ID struct {
	// The ID for an object used in the Square API V1, if the object ID differs from the Square API V2 object ID.
	CatalogV1ID *string `json:"catalog_v1_id,omitempty" url:"catalog_v1_id,omitempty"`
	// The ID of the `Location` this Connect V1 ID is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogV1ID) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogV1ID) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogV1ID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogV1ID(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogV1ID) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A node in the path from a retrieved category to its root node.
type CategoryPathToRootNode struct {
	// The category's ID.
	CategoryID *string `json:"category_id,omitempty" url:"category_id,omitempty"`
	// The category's name.
	CategoryName *string `json:"category_name,omitempty" url:"category_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CategoryPathToRootNode) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CategoryPathToRootNode) UnmarshalJSON(data []byte) error {
	type unmarshaler CategoryPathToRootNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CategoryPathToRootNode(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CategoryPathToRootNode) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines output parameters in a request to the
// [ChangeBillingAnchorDate]($e/Subscriptions/ChangeBillingAnchorDate) endpoint.
type ChangeBillingAnchorDateResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The specified subscription for updating billing anchor date.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a single billing anchor date change for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChangeBillingAnchorDateResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChangeBillingAnchorDateResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChangeBillingAnchorDateResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChangeBillingAnchorDateResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChangeBillingAnchorDateResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Supported timings when a pending change, as an action, takes place to a subscription.
type ChangeTiming string

const (
	ChangeTimingImmediate         ChangeTiming = "IMMEDIATE"
	ChangeTimingEndOfBillingCycle ChangeTiming = "END_OF_BILLING_CYCLE"
)

func NewChangeTimingFromString(s string) (ChangeTiming, error) {
	switch s {
	case "IMMEDIATE":
		return ChangeTimingImmediate, nil
	case "END_OF_BILLING_CYCLE":
		return ChangeTimingEndOfBillingCycle, nil
	}
	var t ChangeTiming
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChangeTiming) Ptr() *ChangeTiming {
	return &c
}

// Defines the parameters that can be included in the body of
// a request to the [Charge](api-endpoint:Transactions-Charge) endpoint.
//
// Deprecated - recommend using [CreatePayment](api-endpoint:Payments-CreatePayment)
type ChargeRequest struct {
	// A value you specify that uniquely identifies this
	// transaction among transactions you've created.
	//
	// If you're unsure whether a particular transaction succeeded,
	// you can reattempt it with the same idempotency key without
	// worrying about double-charging the buyer.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/working-with-apis/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The amount of money to charge.
	//
	// Note that you specify the amount in the
	// **smallest denomination of the applicable currency**. For example, US dollar
	// amounts are specified in cents. See
	// [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.
	//
	// The value of `currency` must match the currency associated with the business
	// that is charging the card.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A payment token generated from the [Card.tokenize()](https://developer.squareup.com/reference/sdks/web/payments/objects/Card#Card.tokenize) that represents the card
	// to charge.
	//
	// The application that provides a payment token to this endpoint must be the
	// _same application_ that generated the payment token with the Web Payments SDK.
	// Otherwise, the nonce is invalid.
	//
	// Do not provide a value for this field if you provide a value for
	// `customer_card_id`.
	CardNonce *string `json:"card_nonce,omitempty" url:"card_nonce,omitempty"`
	// The ID of the customer card on file to charge. Do
	// not provide a value for this field if you provide a value for `card_nonce`.
	//
	// If you provide this value, you _must_ also provide a value for
	// `customer_id`.
	CustomerCardID *string `json:"customer_card_id,omitempty" url:"customer_card_id,omitempty"`
	// If `true`, the request will only perform an Auth on the provided
	// card. You can then later perform either a Capture (with the
	// [CaptureTransaction](api-endpoint:Transactions-CaptureTransaction) endpoint) or a Void
	// (with the [VoidTransaction](api-endpoint:Transactions-VoidTransaction) endpoint).
	//
	// Default value: `false`
	DelayCapture *bool `json:"delay_capture,omitempty" url:"delay_capture,omitempty"`
	// An optional ID you can associate with the transaction for your own
	// purposes (such as to associate the transaction with an entity ID in your
	// own database).
	//
	// This value cannot exceed 40 characters.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// An optional note to associate with the transaction.
	//
	// This value cannot exceed 60 characters.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The ID of the customer to associate this transaction with. This field
	// is required if you provide a value for `customer_card_id`, and optional
	// otherwise.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The buyer's billing address. This value is optional, but this transaction
	// is ineligible for chargeback protection if neither this parameter nor
	// `shipping_address` is provided.
	BillingAddress *Address `json:"billing_address,omitempty" url:"billing_address,omitempty"`
	// The buyer's shipping address, if available. This value is optional,
	// but this transaction is ineligible for chargeback protection if neither this
	// parameter nor `billing_address` is provided.
	ShippingAddress *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// The buyer's email address, if available. This value is optional,
	// but this transaction is ineligible for chargeback protection if it is not
	// provided.
	BuyerEmailAddress *string `json:"buyer_email_address,omitempty" url:"buyer_email_address,omitempty"`
	// The ID of the order to associate with this transaction.
	//
	// If you provide this value, the `amount_money` value of your request must
	// **exactly match** the value of the order's `total_money` field.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The basic primitive of multi-party transaction. The value is optional.
	// The transaction facilitated by you can be split from here.
	//
	// If you provide this value, the `amount_money` value in your additional_recipients
	// must not be more than 90% of the `amount_money` value in the charge request.
	// The `location_id` must be the valid location of the app owner merchant.
	//
	// This field requires the `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission.
	//
	// This field is currently not supported in sandbox.
	AdditionalRecipients []*ChargeRequestAdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`
	// A token generated by SqPaymentForm's verifyBuyer() that represents
	// customer's device info and 3ds challenge result.
	VerificationToken *string `json:"verification_token,omitempty" url:"verification_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChargeRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChargeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChargeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChargeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChargeRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents an additional recipient (other than the merchant) entitled to a portion of the tender.
// Support is currently limited to USD, CAD and GBP currencies
type ChargeRequestAdditionalRecipient struct {
	// The location ID for a recipient (other than the merchant) receiving a portion of the tender.
	LocationID string `json:"location_id" url:"location_id"`
	// The description of the additional recipient.
	Description string `json:"description" url:"description"`
	// The amount of money distributed to the recipient.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChargeRequestAdditionalRecipient) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChargeRequestAdditionalRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler ChargeRequestAdditionalRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChargeRequestAdditionalRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChargeRequestAdditionalRecipient) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [Charge](api-endpoint:Transactions-Charge) endpoint.
//
// One of `errors` or `transaction` is present in a given response (never both).
type ChargeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created transaction.
	Transaction *Transaction `json:"transaction,omitempty" url:"transaction,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ChargeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChargeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ChargeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChargeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChargeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Square Checkout lets merchants accept online payments for supported
// payment types using a checkout workflow hosted on squareup.com.
type Checkout struct {
	// ID generated by Square Checkout when a new checkout is requested.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The URL that the buyer's browser should be redirected to after the
	// checkout is completed.
	CheckoutPageURL *string `json:"checkout_page_url,omitempty" url:"checkout_page_url,omitempty"`
	// If `true`, Square Checkout will collect shipping information on your
	// behalf and store that information with the transaction information in your
	// Square Dashboard.
	//
	// Default: `false`.
	AskForShippingAddress *bool `json:"ask_for_shipping_address,omitempty" url:"ask_for_shipping_address,omitempty"`
	// The email address to display on the Square Checkout confirmation page
	// and confirmation email that the buyer can use to contact the merchant.
	//
	// If this value is not set, the confirmation page and email will display the
	// primary email address associated with the merchant's Square account.
	//
	// Default: none; only exists if explicitly set.
	MerchantSupportEmail *string `json:"merchant_support_email,omitempty" url:"merchant_support_email,omitempty"`
	// If provided, the buyer's email is pre-populated on the checkout page
	// as an editable text field.
	//
	// Default: none; only exists if explicitly set.
	PrePopulateBuyerEmail *string `json:"pre_populate_buyer_email,omitempty" url:"pre_populate_buyer_email,omitempty"`
	// If provided, the buyer's shipping info is pre-populated on the
	// checkout page as editable text fields.
	//
	// Default: none; only exists if explicitly set.
	PrePopulateShippingAddress *Address `json:"pre_populate_shipping_address,omitempty" url:"pre_populate_shipping_address,omitempty"`
	// The URL to redirect to after checkout is completed with `checkoutId`,
	// Square's `orderId`, `transactionId`, and `referenceId` appended as URL
	// parameters. For example, if the provided redirect_url is
	// `http://www.example.com/order-complete`, a successful transaction redirects
	// the customer to:
	//
	// <pre><code>http://www.example.com/order-complete?checkoutId=xxxxxx&amp;orderId=xxxxxx&amp;referenceId=xxxxxx&amp;transactionId=xxxxxx</code></pre>
	//
	// If you do not provide a redirect URL, Square Checkout will display an order
	// confirmation page on your behalf; however Square strongly recommends that
	// you provide a redirect URL so you can verify the transaction results and
	// finalize the order through your existing/normal confirmation workflow.
	RedirectURL *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	// Order to be checked out.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// The time when the checkout was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this checkout.
	// For example, fees assessed on the purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Checkout) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Checkout) UnmarshalJSON(data []byte) error {
	type unmarshaler Checkout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Checkout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Checkout) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutLocationSettings struct {
	// The ID of the location that these settings apply to.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Indicates whether customers are allowed to leave notes at checkout.
	CustomerNotesEnabled *bool `json:"customer_notes_enabled,omitempty" url:"customer_notes_enabled,omitempty"`
	// Policy information is displayed at the bottom of the checkout pages.
	// You can set a maximum of two policies.
	Policies []*CheckoutLocationSettingsPolicy `json:"policies,omitempty" url:"policies,omitempty"`
	// The branding settings for this location.
	Branding *CheckoutLocationSettingsBranding `json:"branding,omitempty" url:"branding,omitempty"`
	// The tip settings for this location.
	Tipping *CheckoutLocationSettingsTipping `json:"tipping,omitempty" url:"tipping,omitempty"`
	// The coupon settings for this location.
	Coupons *CheckoutLocationSettingsCoupons `json:"coupons,omitempty" url:"coupons,omitempty"`
	// The timestamp when the settings were last updated, in RFC 3339 format.
	// Examples for January 25th, 2020 6:25:34pm Pacific Standard Time:
	// UTC: 2020-01-26T02:25:34Z
	// Pacific Standard Time with UTC offset: 2020-01-25T18:25:34-08:00
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutLocationSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutLocationSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutLocationSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutLocationSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutLocationSettings) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutLocationSettingsBranding struct {
	// Show the location logo on the checkout page.
	// See [HeaderType](#type-headertype) for possible values
	HeaderType *CheckoutLocationSettingsBrandingHeaderType `json:"header_type,omitempty" url:"header_type,omitempty"`
	// The HTML-supported hex color for the button on the checkout page (for example, "#FFFFFF").
	ButtonColor *string `json:"button_color,omitempty" url:"button_color,omitempty"`
	// The shape of the button on the checkout page.
	// See [ButtonShape](#type-buttonshape) for possible values
	ButtonShape *CheckoutLocationSettingsBrandingButtonShape `json:"button_shape,omitempty" url:"button_shape,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutLocationSettingsBranding) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutLocationSettingsBranding) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutLocationSettingsBranding
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutLocationSettingsBranding(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutLocationSettingsBranding) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutLocationSettingsBrandingButtonShape string

const (
	CheckoutLocationSettingsBrandingButtonShapeSquared CheckoutLocationSettingsBrandingButtonShape = "SQUARED"
	CheckoutLocationSettingsBrandingButtonShapeRounded CheckoutLocationSettingsBrandingButtonShape = "ROUNDED"
	CheckoutLocationSettingsBrandingButtonShapePill    CheckoutLocationSettingsBrandingButtonShape = "PILL"
)

func NewCheckoutLocationSettingsBrandingButtonShapeFromString(s string) (CheckoutLocationSettingsBrandingButtonShape, error) {
	switch s {
	case "SQUARED":
		return CheckoutLocationSettingsBrandingButtonShapeSquared, nil
	case "ROUNDED":
		return CheckoutLocationSettingsBrandingButtonShapeRounded, nil
	case "PILL":
		return CheckoutLocationSettingsBrandingButtonShapePill, nil
	}
	var t CheckoutLocationSettingsBrandingButtonShape
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckoutLocationSettingsBrandingButtonShape) Ptr() *CheckoutLocationSettingsBrandingButtonShape {
	return &c
}

type CheckoutLocationSettingsBrandingHeaderType string

const (
	CheckoutLocationSettingsBrandingHeaderTypeBusinessName  CheckoutLocationSettingsBrandingHeaderType = "BUSINESS_NAME"
	CheckoutLocationSettingsBrandingHeaderTypeFramedLogo    CheckoutLocationSettingsBrandingHeaderType = "FRAMED_LOGO"
	CheckoutLocationSettingsBrandingHeaderTypeFullWidthLogo CheckoutLocationSettingsBrandingHeaderType = "FULL_WIDTH_LOGO"
)

func NewCheckoutLocationSettingsBrandingHeaderTypeFromString(s string) (CheckoutLocationSettingsBrandingHeaderType, error) {
	switch s {
	case "BUSINESS_NAME":
		return CheckoutLocationSettingsBrandingHeaderTypeBusinessName, nil
	case "FRAMED_LOGO":
		return CheckoutLocationSettingsBrandingHeaderTypeFramedLogo, nil
	case "FULL_WIDTH_LOGO":
		return CheckoutLocationSettingsBrandingHeaderTypeFullWidthLogo, nil
	}
	var t CheckoutLocationSettingsBrandingHeaderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckoutLocationSettingsBrandingHeaderType) Ptr() *CheckoutLocationSettingsBrandingHeaderType {
	return &c
}

type CheckoutLocationSettingsCoupons struct {
	// Indicates whether coupons are enabled for this location.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutLocationSettingsCoupons) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutLocationSettingsCoupons) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutLocationSettingsCoupons
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutLocationSettingsCoupons(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutLocationSettingsCoupons) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutLocationSettingsPolicy struct {
	// A unique ID to identify the policy when making changes. You must set the UID for policy updates, but it’s optional when setting new policies.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The title of the policy. This is required when setting the description, though you can update it in a different request.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The description of the policy.
	Description *string `json:"description,omitempty" url:"description,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutLocationSettingsPolicy) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutLocationSettingsPolicy) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutLocationSettingsPolicy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutLocationSettingsPolicy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutLocationSettingsPolicy) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutLocationSettingsTipping struct {
	// Set three custom percentage amounts that buyers can select at checkout. If Smart Tip is enabled, this only applies to transactions totaling $10 or more.
	Percentages []int `json:"percentages,omitempty" url:"percentages,omitempty"`
	// Enables Smart Tip Amounts. If Smart Tip Amounts is enabled, tipping works as follows:
	// If a transaction is less than $10, the available tipping options include No Tip, $1, $2, or $3.
	// If a transaction is $10 or more, the available tipping options include No Tip, 15%, 20%, or 25%.
	// You can set custom percentage amounts with the `percentages` field.
	SmartTippingEnabled *bool `json:"smart_tipping_enabled,omitempty" url:"smart_tipping_enabled,omitempty"`
	// Set the pre-selected percentage amounts that appear at checkout. If Smart Tip is enabled, this only applies to transactions totaling $10 or more.
	DefaultPercent *int `json:"default_percent,omitempty" url:"default_percent,omitempty"`
	// Show the Smart Tip Amounts for this location.
	SmartTips []*Money `json:"smart_tips,omitempty" url:"smart_tips,omitempty"`
	// Set the pre-selected whole amount that appears at checkout when Smart Tip is enabled and the transaction amount is less than $10.
	DefaultSmartTip *Money `json:"default_smart_tip,omitempty" url:"default_smart_tip,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutLocationSettingsTipping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutLocationSettingsTipping) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutLocationSettingsTipping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutLocationSettingsTipping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutLocationSettingsTipping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutMerchantSettings struct {
	// The set of payment methods accepted for the merchant's account.
	PaymentMethods *CheckoutMerchantSettingsPaymentMethods `json:"payment_methods,omitempty" url:"payment_methods,omitempty"`
	// The timestamp when the settings were last updated, in RFC 3339 format.
	// Examples for January 25th, 2020 6:25:34pm Pacific Standard Time:
	// UTC: 2020-01-26T02:25:34Z
	// Pacific Standard Time with UTC offset: 2020-01-25T18:25:34-08:00
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutMerchantSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutMerchantSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutMerchantSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutMerchantSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutMerchantSettings) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutMerchantSettingsPaymentMethods struct {
	ApplePay         *CheckoutMerchantSettingsPaymentMethodsPaymentMethod    `json:"apple_pay,omitempty" url:"apple_pay,omitempty"`
	GooglePay        *CheckoutMerchantSettingsPaymentMethodsPaymentMethod    `json:"google_pay,omitempty" url:"google_pay,omitempty"`
	CashApp          *CheckoutMerchantSettingsPaymentMethodsPaymentMethod    `json:"cash_app,omitempty" url:"cash_app,omitempty"`
	AfterpayClearpay *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpay `json:"afterpay_clearpay,omitempty" url:"afterpay_clearpay,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutMerchantSettingsPaymentMethods) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutMerchantSettingsPaymentMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutMerchantSettingsPaymentMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutMerchantSettingsPaymentMethods(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutMerchantSettingsPaymentMethods) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The settings allowed for AfterpayClearpay.
type CheckoutMerchantSettingsPaymentMethodsAfterpayClearpay struct {
	// Afterpay is shown as an option for order totals falling within the configured range.
	OrderEligibilityRange *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange `json:"order_eligibility_range,omitempty" url:"order_eligibility_range,omitempty"`
	// Afterpay is shown as an option for item totals falling within the configured range.
	ItemEligibilityRange *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange `json:"item_eligibility_range,omitempty" url:"item_eligibility_range,omitempty"`
	// Indicates whether the payment method is enabled for the account.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpay) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpay) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutMerchantSettingsPaymentMethodsAfterpayClearpay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutMerchantSettingsPaymentMethodsAfterpayClearpay(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpay) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A range of purchase price that qualifies.
type CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange struct {
	Min *Money `json:"min,omitempty" url:"min,omitempty"`
	Max *Money `json:"max,omitempty" url:"max,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutMerchantSettingsPaymentMethodsAfterpayClearpayEligibilityRange) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The settings allowed for a payment method.
type CheckoutMerchantSettingsPaymentMethodsPaymentMethod struct {
	// Indicates whether the payment method is enabled for the account.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutMerchantSettingsPaymentMethodsPaymentMethod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutMerchantSettingsPaymentMethodsPaymentMethod) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutMerchantSettingsPaymentMethodsPaymentMethod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutMerchantSettingsPaymentMethodsPaymentMethod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutMerchantSettingsPaymentMethodsPaymentMethod) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutOptions struct {
	// Indicates whether the payment allows tipping.
	AllowTipping *bool `json:"allow_tipping,omitempty" url:"allow_tipping,omitempty"`
	// The custom fields requesting information from the buyer.
	CustomFields []*CustomField `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The ID of the subscription plan for the buyer to pay and subscribe.
	// For more information, see [Subscription Plan Checkout](https://developer.squareup.com/docs/checkout-api/subscription-plan-checkout).
	SubscriptionPlanID *string `json:"subscription_plan_id,omitempty" url:"subscription_plan_id,omitempty"`
	// The confirmation page URL to redirect the buyer to after Square processes the payment.
	RedirectURL *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	// The email address that buyers can use to contact the seller.
	MerchantSupportEmail *string `json:"merchant_support_email,omitempty" url:"merchant_support_email,omitempty"`
	// Indicates whether to include the address fields in the payment form.
	AskForShippingAddress *bool `json:"ask_for_shipping_address,omitempty" url:"ask_for_shipping_address,omitempty"`
	// The methods allowed for buyers during checkout.
	AcceptedPaymentMethods *AcceptedPaymentMethods `json:"accepted_payment_methods,omitempty" url:"accepted_payment_methods,omitempty"`
	// The amount of money that the developer is taking as a fee for facilitating the payment on behalf of the seller.
	//
	// The amount cannot be more than 90% of the total amount of the payment.
	//
	// The amount must be specified in the smallest denomination of the applicable currency (for example, US dollar amounts are specified in cents). For more information, see [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/common-data-types/working-with-monetary-amounts).
	//
	// The fee currency code must match the currency associated with the seller that is accepting the payment. The application must be from a developer account in the same country and using the same currency code as the seller. For more information about the application fee scenario, see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// To set this field, `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission is required. For more information, see [Permissions](https://developer.squareup.com/docs/payments-api/collect-fees/additional-considerations#permissions).
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// The fee associated with shipping to be applied to the `Order` as a service charge.
	ShippingFee *ShippingFee `json:"shipping_fee,omitempty" url:"shipping_fee,omitempty"`
	// Indicates whether to include the `Add coupon` section for the buyer to provide a Square marketing coupon in the payment form.
	EnableCoupon *bool `json:"enable_coupon,omitempty" url:"enable_coupon,omitempty"`
	// Indicates whether to include the `REWARDS` section for the buyer to opt in to loyalty, redeem rewards in the payment form, or both.
	EnableLoyalty *bool `json:"enable_loyalty,omitempty" url:"enable_loyalty,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CheckoutOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutOptionsPaymentType string

const (
	CheckoutOptionsPaymentTypeCardPresent               CheckoutOptionsPaymentType = "CARD_PRESENT"
	CheckoutOptionsPaymentTypeManualCardEntry           CheckoutOptionsPaymentType = "MANUAL_CARD_ENTRY"
	CheckoutOptionsPaymentTypeFelicaID                  CheckoutOptionsPaymentType = "FELICA_ID"
	CheckoutOptionsPaymentTypeFelicaQuicpay             CheckoutOptionsPaymentType = "FELICA_QUICPAY"
	CheckoutOptionsPaymentTypeFelicaTransportationGroup CheckoutOptionsPaymentType = "FELICA_TRANSPORTATION_GROUP"
	CheckoutOptionsPaymentTypeFelicaAll                 CheckoutOptionsPaymentType = "FELICA_ALL"
	CheckoutOptionsPaymentTypePaypay                    CheckoutOptionsPaymentType = "PAYPAY"
)

func NewCheckoutOptionsPaymentTypeFromString(s string) (CheckoutOptionsPaymentType, error) {
	switch s {
	case "CARD_PRESENT":
		return CheckoutOptionsPaymentTypeCardPresent, nil
	case "MANUAL_CARD_ENTRY":
		return CheckoutOptionsPaymentTypeManualCardEntry, nil
	case "FELICA_ID":
		return CheckoutOptionsPaymentTypeFelicaID, nil
	case "FELICA_QUICPAY":
		return CheckoutOptionsPaymentTypeFelicaQuicpay, nil
	case "FELICA_TRANSPORTATION_GROUP":
		return CheckoutOptionsPaymentTypeFelicaTransportationGroup, nil
	case "FELICA_ALL":
		return CheckoutOptionsPaymentTypeFelicaAll, nil
	case "PAYPAY":
		return CheckoutOptionsPaymentTypePaypay, nil
	}
	var t CheckoutOptionsPaymentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckoutOptionsPaymentType) Ptr() *CheckoutOptionsPaymentType {
	return &c
}

// Additional details about Clearpay payments.
type ClearpayDetails struct {
	// Email address on the buyer's Clearpay account.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClearpayDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClearpayDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClearpayDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClearpayDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClearpayDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CloneOrder]($e/Orders/CloneOrder) endpoint.
type CloneOrderResponse struct {
	// The cloned order.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CloneOrderResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CloneOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CloneOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CloneOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CloneOrderResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CollectedData struct {
	// The buyer's input text.
	InputText *string `json:"input_text,omitempty" url:"input_text,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CollectedData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CollectedData) UnmarshalJSON(data []byte) error {
	type unmarshaler CollectedData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CollectedData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CollectedData) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the response returned by[CompletePayment]($e/Payments/CompletePayment).
type CompletePaymentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully completed payment.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CompletePaymentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CompletePaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CompletePaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CompletePaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CompletePaymentResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The wrapper object for the component entries of a given component type.
type Component struct {
	// The type of this component. Each component type has expected properties expressed
	// in a structured format within its corresponding `*_details` field.
	// See [ComponentType](#type-componenttype) for possible values
	Type ComponentComponentType `json:"type" url:"type"`
	// Structured data for an `Application`, set for Components of type `APPLICATION`.
	ApplicationDetails *DeviceComponentDetailsApplicationDetails `json:"application_details,omitempty" url:"application_details,omitempty"`
	// Structured data for a `CardReader`, set for Components of type `CARD_READER`.
	CardReaderDetails *DeviceComponentDetailsCardReaderDetails `json:"card_reader_details,omitempty" url:"card_reader_details,omitempty"`
	// Structured data for a `Battery`, set for Components of type `BATTERY`.
	BatteryDetails *DeviceComponentDetailsBatteryDetails `json:"battery_details,omitempty" url:"battery_details,omitempty"`
	// Structured data for a `WiFi` interface, set for Components of type `WIFI`.
	WifiDetails *DeviceComponentDetailsWiFiDetails `json:"wifi_details,omitempty" url:"wifi_details,omitempty"`
	// Structured data for an `Ethernet` interface, set for Components of type `ETHERNET`.
	EthernetDetails *DeviceComponentDetailsEthernetDetails `json:"ethernet_details,omitempty" url:"ethernet_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Component) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Component) UnmarshalJSON(data []byte) error {
	type unmarshaler Component
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Component(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Component) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An enum for ComponentType.
type ComponentComponentType string

const (
	ComponentComponentTypeApplication ComponentComponentType = "APPLICATION"
	ComponentComponentTypeCardReader  ComponentComponentType = "CARD_READER"
	ComponentComponentTypeBattery     ComponentComponentType = "BATTERY"
	ComponentComponentTypeWifi        ComponentComponentType = "WIFI"
	ComponentComponentTypeEthernet    ComponentComponentType = "ETHERNET"
	ComponentComponentTypePrinter     ComponentComponentType = "PRINTER"
)

func NewComponentComponentTypeFromString(s string) (ComponentComponentType, error) {
	switch s {
	case "APPLICATION":
		return ComponentComponentTypeApplication, nil
	case "CARD_READER":
		return ComponentComponentTypeCardReader, nil
	case "BATTERY":
		return ComponentComponentTypeBattery, nil
	case "WIFI":
		return ComponentComponentTypeWifi, nil
	case "ETHERNET":
		return ComponentComponentTypeEthernet, nil
	case "PRINTER":
		return ComponentComponentTypePrinter, nil
	}
	var t ComponentComponentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ComponentComponentType) Ptr() *ComponentComponentType {
	return &c
}

type ConfirmationDecision struct {
	// The buyer's decision to the displayed terms.
	HasAgreed *bool `json:"has_agreed,omitempty" url:"has_agreed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConfirmationDecision) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConfirmationDecision) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfirmationDecision
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfirmationDecision(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfirmationDecision) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConfirmationOptions struct {
	// The title text to display in the confirmation screen flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The agreement details to display in the confirmation flow on the Terminal.
	Body string `json:"body" url:"body"`
	// The button text to display indicating the customer agrees to the displayed terms.
	AgreeButtonText string `json:"agree_button_text" url:"agree_button_text"`
	// The button text to display indicating the customer does not agree to the displayed terms.
	DisagreeButtonText *string `json:"disagree_button_text,omitempty" url:"disagree_button_text,omitempty"`
	// The result of the buyer’s actions when presented with the confirmation screen.
	Decision *ConfirmationDecision `json:"decision,omitempty" url:"decision,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ConfirmationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConfirmationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfirmationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfirmationOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfirmationOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Latitude and longitude coordinates.
type Coordinates struct {
	// The latitude of the coordinate expressed in degrees.
	Latitude *float64 `json:"latitude,omitempty" url:"latitude,omitempty"`
	// The longitude of the coordinate expressed in degrees.
	Longitude *float64 `json:"longitude,omitempty" url:"longitude,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Coordinates) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Coordinates) UnmarshalJSON(data []byte) error {
	type unmarshaler Coordinates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Coordinates(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Coordinates) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the country associated with another entity, such as a business.
// Values are in [ISO 3166-1-alpha-2 format](http://www.iso.org/iso/home/standards/country_codes.htm).
type Country string

const (
	CountryZz Country = "ZZ"
	CountryAd Country = "AD"
	CountryAe Country = "AE"
	CountryAf Country = "AF"
	CountryAg Country = "AG"
	CountryAi Country = "AI"
	CountryAl Country = "AL"
	CountryAm Country = "AM"
	CountryAo Country = "AO"
	CountryAq Country = "AQ"
	CountryAr Country = "AR"
	CountryAs Country = "AS"
	CountryAt Country = "AT"
	CountryAu Country = "AU"
	CountryAw Country = "AW"
	CountryAx Country = "AX"
	CountryAz Country = "AZ"
	CountryBa Country = "BA"
	CountryBb Country = "BB"
	CountryBd Country = "BD"
	CountryBe Country = "BE"
	CountryBf Country = "BF"
	CountryBg Country = "BG"
	CountryBh Country = "BH"
	CountryBi Country = "BI"
	CountryBj Country = "BJ"
	CountryBl Country = "BL"
	CountryBm Country = "BM"
	CountryBn Country = "BN"
	CountryBo Country = "BO"
	CountryBq Country = "BQ"
	CountryBr Country = "BR"
	CountryBs Country = "BS"
	CountryBt Country = "BT"
	CountryBv Country = "BV"
	CountryBw Country = "BW"
	CountryBy Country = "BY"
	CountryBz Country = "BZ"
	CountryCa Country = "CA"
	CountryCc Country = "CC"
	CountryCd Country = "CD"
	CountryCf Country = "CF"
	CountryCg Country = "CG"
	CountryCh Country = "CH"
	CountryCi Country = "CI"
	CountryCk Country = "CK"
	CountryCl Country = "CL"
	CountryCm Country = "CM"
	CountryCn Country = "CN"
	CountryCo Country = "CO"
	CountryCr Country = "CR"
	CountryCu Country = "CU"
	CountryCv Country = "CV"
	CountryCw Country = "CW"
	CountryCx Country = "CX"
	CountryCy Country = "CY"
	CountryCz Country = "CZ"
	CountryDe Country = "DE"
	CountryDj Country = "DJ"
	CountryDk Country = "DK"
	CountryDm Country = "DM"
	CountryDo Country = "DO"
	CountryDz Country = "DZ"
	CountryEc Country = "EC"
	CountryEe Country = "EE"
	CountryEg Country = "EG"
	CountryEh Country = "EH"
	CountryEr Country = "ER"
	CountryEs Country = "ES"
	CountryEt Country = "ET"
	CountryFi Country = "FI"
	CountryFj Country = "FJ"
	CountryFk Country = "FK"
	CountryFm Country = "FM"
	CountryFo Country = "FO"
	CountryFr Country = "FR"
	CountryGa Country = "GA"
	CountryGb Country = "GB"
	CountryGd Country = "GD"
	CountryGe Country = "GE"
	CountryGf Country = "GF"
	CountryGg Country = "GG"
	CountryGh Country = "GH"
	CountryGi Country = "GI"
	CountryGl Country = "GL"
	CountryGm Country = "GM"
	CountryGn Country = "GN"
	CountryGp Country = "GP"
	CountryGq Country = "GQ"
	CountryGr Country = "GR"
	CountryGs Country = "GS"
	CountryGt Country = "GT"
	CountryGu Country = "GU"
	CountryGw Country = "GW"
	CountryGy Country = "GY"
	CountryHk Country = "HK"
	CountryHm Country = "HM"
	CountryHn Country = "HN"
	CountryHr Country = "HR"
	CountryHt Country = "HT"
	CountryHu Country = "HU"
	CountryID Country = "ID"
	CountryIe Country = "IE"
	CountryIl Country = "IL"
	CountryIm Country = "IM"
	CountryIn Country = "IN"
	CountryIo Country = "IO"
	CountryIq Country = "IQ"
	CountryIr Country = "IR"
	CountryIs Country = "IS"
	CountryIt Country = "IT"
	CountryJe Country = "JE"
	CountryJm Country = "JM"
	CountryJo Country = "JO"
	CountryJp Country = "JP"
	CountryKe Country = "KE"
	CountryKg Country = "KG"
	CountryKh Country = "KH"
	CountryKi Country = "KI"
	CountryKm Country = "KM"
	CountryKn Country = "KN"
	CountryKp Country = "KP"
	CountryKr Country = "KR"
	CountryKw Country = "KW"
	CountryKy Country = "KY"
	CountryKz Country = "KZ"
	CountryLa Country = "LA"
	CountryLb Country = "LB"
	CountryLc Country = "LC"
	CountryLi Country = "LI"
	CountryLk Country = "LK"
	CountryLr Country = "LR"
	CountryLs Country = "LS"
	CountryLt Country = "LT"
	CountryLu Country = "LU"
	CountryLv Country = "LV"
	CountryLy Country = "LY"
	CountryMa Country = "MA"
	CountryMc Country = "MC"
	CountryMd Country = "MD"
	CountryMe Country = "ME"
	CountryMf Country = "MF"
	CountryMg Country = "MG"
	CountryMh Country = "MH"
	CountryMk Country = "MK"
	CountryMl Country = "ML"
	CountryMm Country = "MM"
	CountryMn Country = "MN"
	CountryMo Country = "MO"
	CountryMp Country = "MP"
	CountryMq Country = "MQ"
	CountryMr Country = "MR"
	CountryMs Country = "MS"
	CountryMt Country = "MT"
	CountryMu Country = "MU"
	CountryMv Country = "MV"
	CountryMw Country = "MW"
	CountryMx Country = "MX"
	CountryMy Country = "MY"
	CountryMz Country = "MZ"
	CountryNa Country = "NA"
	CountryNc Country = "NC"
	CountryNe Country = "NE"
	CountryNf Country = "NF"
	CountryNg Country = "NG"
	CountryNi Country = "NI"
	CountryNl Country = "NL"
	CountryNo Country = "NO"
	CountryNp Country = "NP"
	CountryNr Country = "NR"
	CountryNu Country = "NU"
	CountryNz Country = "NZ"
	CountryOm Country = "OM"
	CountryPa Country = "PA"
	CountryPe Country = "PE"
	CountryPf Country = "PF"
	CountryPg Country = "PG"
	CountryPh Country = "PH"
	CountryPk Country = "PK"
	CountryPl Country = "PL"
	CountryPm Country = "PM"
	CountryPn Country = "PN"
	CountryPr Country = "PR"
	CountryPs Country = "PS"
	CountryPt Country = "PT"
	CountryPw Country = "PW"
	CountryPy Country = "PY"
	CountryQa Country = "QA"
	CountryRe Country = "RE"
	CountryRo Country = "RO"
	CountryRs Country = "RS"
	CountryRu Country = "RU"
	CountryRw Country = "RW"
	CountrySa Country = "SA"
	CountrySb Country = "SB"
	CountrySc Country = "SC"
	CountrySd Country = "SD"
	CountrySe Country = "SE"
	CountrySg Country = "SG"
	CountrySh Country = "SH"
	CountrySi Country = "SI"
	CountrySj Country = "SJ"
	CountrySk Country = "SK"
	CountrySl Country = "SL"
	CountrySm Country = "SM"
	CountrySn Country = "SN"
	CountrySo Country = "SO"
	CountrySr Country = "SR"
	CountrySs Country = "SS"
	CountrySt Country = "ST"
	CountrySv Country = "SV"
	CountrySx Country = "SX"
	CountrySy Country = "SY"
	CountrySz Country = "SZ"
	CountryTc Country = "TC"
	CountryTd Country = "TD"
	CountryTf Country = "TF"
	CountryTg Country = "TG"
	CountryTh Country = "TH"
	CountryTj Country = "TJ"
	CountryTk Country = "TK"
	CountryTl Country = "TL"
	CountryTm Country = "TM"
	CountryTn Country = "TN"
	CountryTo Country = "TO"
	CountryTr Country = "TR"
	CountryTt Country = "TT"
	CountryTv Country = "TV"
	CountryTw Country = "TW"
	CountryTz Country = "TZ"
	CountryUa Country = "UA"
	CountryUg Country = "UG"
	CountryUm Country = "UM"
	CountryUs Country = "US"
	CountryUy Country = "UY"
	CountryUz Country = "UZ"
	CountryVa Country = "VA"
	CountryVc Country = "VC"
	CountryVe Country = "VE"
	CountryVg Country = "VG"
	CountryVi Country = "VI"
	CountryVn Country = "VN"
	CountryVu Country = "VU"
	CountryWf Country = "WF"
	CountryWs Country = "WS"
	CountryYe Country = "YE"
	CountryYt Country = "YT"
	CountryZa Country = "ZA"
	CountryZm Country = "ZM"
	CountryZw Country = "ZW"
)

func NewCountryFromString(s string) (Country, error) {
	switch s {
	case "ZZ":
		return CountryZz, nil
	case "AD":
		return CountryAd, nil
	case "AE":
		return CountryAe, nil
	case "AF":
		return CountryAf, nil
	case "AG":
		return CountryAg, nil
	case "AI":
		return CountryAi, nil
	case "AL":
		return CountryAl, nil
	case "AM":
		return CountryAm, nil
	case "AO":
		return CountryAo, nil
	case "AQ":
		return CountryAq, nil
	case "AR":
		return CountryAr, nil
	case "AS":
		return CountryAs, nil
	case "AT":
		return CountryAt, nil
	case "AU":
		return CountryAu, nil
	case "AW":
		return CountryAw, nil
	case "AX":
		return CountryAx, nil
	case "AZ":
		return CountryAz, nil
	case "BA":
		return CountryBa, nil
	case "BB":
		return CountryBb, nil
	case "BD":
		return CountryBd, nil
	case "BE":
		return CountryBe, nil
	case "BF":
		return CountryBf, nil
	case "BG":
		return CountryBg, nil
	case "BH":
		return CountryBh, nil
	case "BI":
		return CountryBi, nil
	case "BJ":
		return CountryBj, nil
	case "BL":
		return CountryBl, nil
	case "BM":
		return CountryBm, nil
	case "BN":
		return CountryBn, nil
	case "BO":
		return CountryBo, nil
	case "BQ":
		return CountryBq, nil
	case "BR":
		return CountryBr, nil
	case "BS":
		return CountryBs, nil
	case "BT":
		return CountryBt, nil
	case "BV":
		return CountryBv, nil
	case "BW":
		return CountryBw, nil
	case "BY":
		return CountryBy, nil
	case "BZ":
		return CountryBz, nil
	case "CA":
		return CountryCa, nil
	case "CC":
		return CountryCc, nil
	case "CD":
		return CountryCd, nil
	case "CF":
		return CountryCf, nil
	case "CG":
		return CountryCg, nil
	case "CH":
		return CountryCh, nil
	case "CI":
		return CountryCi, nil
	case "CK":
		return CountryCk, nil
	case "CL":
		return CountryCl, nil
	case "CM":
		return CountryCm, nil
	case "CN":
		return CountryCn, nil
	case "CO":
		return CountryCo, nil
	case "CR":
		return CountryCr, nil
	case "CU":
		return CountryCu, nil
	case "CV":
		return CountryCv, nil
	case "CW":
		return CountryCw, nil
	case "CX":
		return CountryCx, nil
	case "CY":
		return CountryCy, nil
	case "CZ":
		return CountryCz, nil
	case "DE":
		return CountryDe, nil
	case "DJ":
		return CountryDj, nil
	case "DK":
		return CountryDk, nil
	case "DM":
		return CountryDm, nil
	case "DO":
		return CountryDo, nil
	case "DZ":
		return CountryDz, nil
	case "EC":
		return CountryEc, nil
	case "EE":
		return CountryEe, nil
	case "EG":
		return CountryEg, nil
	case "EH":
		return CountryEh, nil
	case "ER":
		return CountryEr, nil
	case "ES":
		return CountryEs, nil
	case "ET":
		return CountryEt, nil
	case "FI":
		return CountryFi, nil
	case "FJ":
		return CountryFj, nil
	case "FK":
		return CountryFk, nil
	case "FM":
		return CountryFm, nil
	case "FO":
		return CountryFo, nil
	case "FR":
		return CountryFr, nil
	case "GA":
		return CountryGa, nil
	case "GB":
		return CountryGb, nil
	case "GD":
		return CountryGd, nil
	case "GE":
		return CountryGe, nil
	case "GF":
		return CountryGf, nil
	case "GG":
		return CountryGg, nil
	case "GH":
		return CountryGh, nil
	case "GI":
		return CountryGi, nil
	case "GL":
		return CountryGl, nil
	case "GM":
		return CountryGm, nil
	case "GN":
		return CountryGn, nil
	case "GP":
		return CountryGp, nil
	case "GQ":
		return CountryGq, nil
	case "GR":
		return CountryGr, nil
	case "GS":
		return CountryGs, nil
	case "GT":
		return CountryGt, nil
	case "GU":
		return CountryGu, nil
	case "GW":
		return CountryGw, nil
	case "GY":
		return CountryGy, nil
	case "HK":
		return CountryHk, nil
	case "HM":
		return CountryHm, nil
	case "HN":
		return CountryHn, nil
	case "HR":
		return CountryHr, nil
	case "HT":
		return CountryHt, nil
	case "HU":
		return CountryHu, nil
	case "ID":
		return CountryID, nil
	case "IE":
		return CountryIe, nil
	case "IL":
		return CountryIl, nil
	case "IM":
		return CountryIm, nil
	case "IN":
		return CountryIn, nil
	case "IO":
		return CountryIo, nil
	case "IQ":
		return CountryIq, nil
	case "IR":
		return CountryIr, nil
	case "IS":
		return CountryIs, nil
	case "IT":
		return CountryIt, nil
	case "JE":
		return CountryJe, nil
	case "JM":
		return CountryJm, nil
	case "JO":
		return CountryJo, nil
	case "JP":
		return CountryJp, nil
	case "KE":
		return CountryKe, nil
	case "KG":
		return CountryKg, nil
	case "KH":
		return CountryKh, nil
	case "KI":
		return CountryKi, nil
	case "KM":
		return CountryKm, nil
	case "KN":
		return CountryKn, nil
	case "KP":
		return CountryKp, nil
	case "KR":
		return CountryKr, nil
	case "KW":
		return CountryKw, nil
	case "KY":
		return CountryKy, nil
	case "KZ":
		return CountryKz, nil
	case "LA":
		return CountryLa, nil
	case "LB":
		return CountryLb, nil
	case "LC":
		return CountryLc, nil
	case "LI":
		return CountryLi, nil
	case "LK":
		return CountryLk, nil
	case "LR":
		return CountryLr, nil
	case "LS":
		return CountryLs, nil
	case "LT":
		return CountryLt, nil
	case "LU":
		return CountryLu, nil
	case "LV":
		return CountryLv, nil
	case "LY":
		return CountryLy, nil
	case "MA":
		return CountryMa, nil
	case "MC":
		return CountryMc, nil
	case "MD":
		return CountryMd, nil
	case "ME":
		return CountryMe, nil
	case "MF":
		return CountryMf, nil
	case "MG":
		return CountryMg, nil
	case "MH":
		return CountryMh, nil
	case "MK":
		return CountryMk, nil
	case "ML":
		return CountryMl, nil
	case "MM":
		return CountryMm, nil
	case "MN":
		return CountryMn, nil
	case "MO":
		return CountryMo, nil
	case "MP":
		return CountryMp, nil
	case "MQ":
		return CountryMq, nil
	case "MR":
		return CountryMr, nil
	case "MS":
		return CountryMs, nil
	case "MT":
		return CountryMt, nil
	case "MU":
		return CountryMu, nil
	case "MV":
		return CountryMv, nil
	case "MW":
		return CountryMw, nil
	case "MX":
		return CountryMx, nil
	case "MY":
		return CountryMy, nil
	case "MZ":
		return CountryMz, nil
	case "NA":
		return CountryNa, nil
	case "NC":
		return CountryNc, nil
	case "NE":
		return CountryNe, nil
	case "NF":
		return CountryNf, nil
	case "NG":
		return CountryNg, nil
	case "NI":
		return CountryNi, nil
	case "NL":
		return CountryNl, nil
	case "NO":
		return CountryNo, nil
	case "NP":
		return CountryNp, nil
	case "NR":
		return CountryNr, nil
	case "NU":
		return CountryNu, nil
	case "NZ":
		return CountryNz, nil
	case "OM":
		return CountryOm, nil
	case "PA":
		return CountryPa, nil
	case "PE":
		return CountryPe, nil
	case "PF":
		return CountryPf, nil
	case "PG":
		return CountryPg, nil
	case "PH":
		return CountryPh, nil
	case "PK":
		return CountryPk, nil
	case "PL":
		return CountryPl, nil
	case "PM":
		return CountryPm, nil
	case "PN":
		return CountryPn, nil
	case "PR":
		return CountryPr, nil
	case "PS":
		return CountryPs, nil
	case "PT":
		return CountryPt, nil
	case "PW":
		return CountryPw, nil
	case "PY":
		return CountryPy, nil
	case "QA":
		return CountryQa, nil
	case "RE":
		return CountryRe, nil
	case "RO":
		return CountryRo, nil
	case "RS":
		return CountryRs, nil
	case "RU":
		return CountryRu, nil
	case "RW":
		return CountryRw, nil
	case "SA":
		return CountrySa, nil
	case "SB":
		return CountrySb, nil
	case "SC":
		return CountrySc, nil
	case "SD":
		return CountrySd, nil
	case "SE":
		return CountrySe, nil
	case "SG":
		return CountrySg, nil
	case "SH":
		return CountrySh, nil
	case "SI":
		return CountrySi, nil
	case "SJ":
		return CountrySj, nil
	case "SK":
		return CountrySk, nil
	case "SL":
		return CountrySl, nil
	case "SM":
		return CountrySm, nil
	case "SN":
		return CountrySn, nil
	case "SO":
		return CountrySo, nil
	case "SR":
		return CountrySr, nil
	case "SS":
		return CountrySs, nil
	case "ST":
		return CountrySt, nil
	case "SV":
		return CountrySv, nil
	case "SX":
		return CountrySx, nil
	case "SY":
		return CountrySy, nil
	case "SZ":
		return CountrySz, nil
	case "TC":
		return CountryTc, nil
	case "TD":
		return CountryTd, nil
	case "TF":
		return CountryTf, nil
	case "TG":
		return CountryTg, nil
	case "TH":
		return CountryTh, nil
	case "TJ":
		return CountryTj, nil
	case "TK":
		return CountryTk, nil
	case "TL":
		return CountryTl, nil
	case "TM":
		return CountryTm, nil
	case "TN":
		return CountryTn, nil
	case "TO":
		return CountryTo, nil
	case "TR":
		return CountryTr, nil
	case "TT":
		return CountryTt, nil
	case "TV":
		return CountryTv, nil
	case "TW":
		return CountryTw, nil
	case "TZ":
		return CountryTz, nil
	case "UA":
		return CountryUa, nil
	case "UG":
		return CountryUg, nil
	case "UM":
		return CountryUm, nil
	case "US":
		return CountryUs, nil
	case "UY":
		return CountryUy, nil
	case "UZ":
		return CountryUz, nil
	case "VA":
		return CountryVa, nil
	case "VC":
		return CountryVc, nil
	case "VE":
		return CountryVe, nil
	case "VG":
		return CountryVg, nil
	case "VI":
		return CountryVi, nil
	case "VN":
		return CountryVn, nil
	case "VU":
		return CountryVu, nil
	case "WF":
		return CountryWf, nil
	case "WS":
		return CountryWs, nil
	case "YE":
		return CountryYe, nil
	case "YT":
		return CountryYt, nil
	case "ZA":
		return CountryZa, nil
	case "ZM":
		return CountryZm, nil
	case "ZW":
		return CountryZw, nil
	}
	var t Country
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Country) Ptr() *Country {
	return &c
}

// Represents a [CreateBookingCustomAttributeDefinition]($e/BookingCustomAttributes/CreateBookingCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateBookingCustomAttributeDefinitionResponse struct {
	// The newly created custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBookingCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBookingCustomAttributeDefinitionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateBookingResponse struct {
	// The booking that was created.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateBookingResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBookingResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response to the request to create a `BreakType`. The response contains
// the created `BreakType` object and might contain a set of `Error` objects if
// the request resulted in errors.
type CreateBreakTypeResponse struct {
	// The `BreakType` that was created by the request.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBreakTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBreakTypeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateCard]($e/Cards/CreateCard) endpoint.
//
// Note: if there are errors processing the request, the card field will not be
// present.
type CreateCardResponse struct {
	// Errors resulting from the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The card created by the request.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCatalogImageRequest struct {
	// A unique string that identifies this CreateCatalogImage request.
	// Keys can be any valid string but must be unique for every CreateCatalogImage request.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// Unique ID of the `CatalogObject` to attach this `CatalogImage` object to. Leave this
	// field empty to create unattached images, for example if you are building an integration
	// where an image can be attached to catalog items at a later time.
	ObjectID *string `json:"object_id,omitempty" url:"object_id,omitempty"`
	// The new `CatalogObject` of the `IMAGE` type, namely, a `CatalogImage` object, to encapsulate the specified image file.
	Image *CatalogObject `json:"image,omitempty" url:"image,omitempty"`
	// If this is set to `true`, the image created will be the primary, or first image of the object referenced by `object_id`.
	// If the `CatalogObject` already has a primary `CatalogImage`, setting this field to `true` will replace the primary image.
	// If this is set to `false` and you use the Square API version 2021-12-15 or later, the image id will be appended to the list of `image_ids` on the object.
	//
	// With Square API version 2021-12-15 or later, the default value is `false`. Otherwise, the effective default value is `true`.
	IsPrimary *bool `json:"is_primary,omitempty" url:"is_primary,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCatalogImageRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCatalogImageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCatalogImageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCatalogImageRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCatalogImageRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCatalogImageResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created `CatalogImage` including a Square-generated
	// URL for the encapsulated image file.
	Image *CatalogObject `json:"image,omitempty" url:"image,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCatalogImageResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCatalogImageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCatalogImageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCatalogImageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCatalogImageResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the `CreateCheckout` endpoint.
type CreateCheckoutResponse struct {
	// The newly created `checkout` object associated with the provided idempotency key.
	Checkout *Checkout `json:"checkout,omitempty" url:"checkout,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCheckoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the `CreateCustomerCard` endpoint.
//
// Either `errors` or `card` is present in a given response (never both).
type CreateCustomerCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created card on file.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomerCardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerCardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateCustomerCustomAttributeDefinition]($e/CustomerCustomAttributes/CreateCustomerCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateCustomerCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateCustomerGroup]($e/CustomerGroups/CreateCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type CreateCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerGroupResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateCustomer]($e/Customers/CreateCustomer) or
// [BulkCreateCustomers]($e/Customers/BulkCreateCustomers) endpoint.
//
// Either `errors` or `customer` is present in a given response (never both).
type CreateCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateCustomerResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeviceCodeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created DeviceCode object containing the device code string.
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDeviceCodeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeviceCodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDeviceCodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDeviceCodeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeviceCodeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the parameters for a `CreateDisputeEvidenceFile` request.
type CreateDisputeEvidenceFileRequest struct {
	// A unique key identifying the request. For more information, see [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency).
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The type of evidence you are uploading.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`
	// The MIME type of the uploaded file.
	// The type can be image/heic, image/heif, image/jpeg, application/pdf, image/png, or image/tiff.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDisputeEvidenceFileRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDisputeEvidenceFileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDisputeEvidenceFileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDisputeEvidenceFileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDisputeEvidenceFileRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields in a `CreateDisputeEvidenceFile` response.
type CreateDisputeEvidenceFileResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The metadata of the newly uploaded dispute evidence.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDisputeEvidenceFileResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDisputeEvidenceFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDisputeEvidenceFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDisputeEvidenceFileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDisputeEvidenceFileResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields in a `CreateDisputeEvidenceText` response.
type CreateDisputeEvidenceTextResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly uploaded dispute evidence metadata.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateDisputeEvidenceTextResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDisputeEvidenceTextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDisputeEvidenceTextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDisputeEvidenceTextResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDisputeEvidenceTextResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that contains a `GiftCardActivity` that was created.
// The response might contain a set of `Error` objects if the request resulted in errors.
type CreateGiftCardActivityResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The gift card activity that was created.
	GiftCardActivity *GiftCardActivity `json:"gift_card_activity,omitempty" url:"gift_card_activity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGiftCardActivityResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGiftCardActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateGiftCardActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateGiftCardActivityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGiftCardActivityResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that contains a `GiftCard`. The response might contain a set of `Error` objects if the request
// resulted in errors.
type CreateGiftCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new gift card.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateGiftCardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGiftCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateGiftCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateGiftCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGiftCardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateInvoiceAttachment]($e/Invoices/CreateInvoiceAttachment) response.
type CreateInvoiceAttachmentResponse struct {
	// Metadata about the attachment that was added to the invoice.
	Attachment *InvoiceAttachment `json:"attachment,omitempty" url:"attachment,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateInvoiceAttachmentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateInvoiceAttachmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateInvoiceAttachmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateInvoiceAttachmentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateInvoiceAttachmentResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response returned by the `CreateInvoice` request.
type CreateInvoiceResponse struct {
	// The newly created invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateInvoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateInvoiceResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateLocationCustomAttributeDefinition]($e/LocationCustomAttributes/CreateLocationCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateLocationCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLocationCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLocationCustomAttributeDefinitionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response object returned by the [CreateLocation]($e/Locations/CreateLocation) endpoint.
type CreateLocationResponse struct {
	// Information about [errors](https://developer.squareup.com/docs/build-basics/handling-errors) encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created `Location` object.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLocationResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLocationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLocationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLocationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLocationResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that includes loyalty account created.
type CreateLoyaltyAccountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created loyalty account.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLoyaltyAccountResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyAccountResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyAccountResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateLoyaltyPromotion]($e/Loyalty/CreateLoyaltyPromotion) response.
// Either `loyalty_promotion` or `errors` is present in the response.
type CreateLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyPromotionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyPromotionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that includes the loyalty reward created.
type CreateLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty reward created.
	Reward *LoyaltyReward `json:"reward,omitempty" url:"reward,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyRewardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateMerchantCustomAttributeDefinition]($e/MerchantCustomAttributes/CreateMerchantCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateMerchantCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateMerchantCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the `CreateMobileAuthorizationCode` endpoint.
type CreateMobileAuthorizationCodeResponse struct {
	// The generated authorization code that connects a mobile application instance
	// to a Square account.
	AuthorizationCode *string `json:"authorization_code,omitempty" url:"authorization_code,omitempty"`
	// The timestamp when `authorization_code` expires, in
	// [RFC 3339](https://tools.ietf.org/html/rfc3339) format (for example, "2016-09-04T23:59:33.123Z").
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateMobileAuthorizationCodeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMobileAuthorizationCodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateMobileAuthorizationCodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateMobileAuthorizationCodeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMobileAuthorizationCodeResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a response from creating an order custom attribute definition.
type CreateOrderCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderCustomAttributeDefinitionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOrderRequest struct {
	// The order to create. If this field is set, the only other top-level field that can be
	// set is the `idempotency_key`.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// A value you specify that uniquely identifies this
	// order among orders you have created.
	//
	// If you are unsure whether a particular order was created successfully,
	// you can try it again with the same idempotency key without
	// worrying about creating duplicate orders.
	//
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrderRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the `CreateOrder` endpoint.
//
// Either `errors` or `order` is present in a given response, but never both.
type CreateOrderResponse struct {
	// The newly created order.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrderResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePaymentLinkResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created payment link.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`
	// The list of related objects.
	RelatedResources *PaymentLinkRelatedResources `json:"related_resources,omitempty" url:"related_resources,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreatePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreatePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreatePaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePaymentLinkResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the response returned by [CreatePayment]($e/Payments/CreatePayment).
//
// If there are errors processing the request, the `payment` field might not be
// present, or it might be present with a status of `FAILED`.
type CreatePaymentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created payment.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreatePaymentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreatePaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreatePaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePaymentResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the body parameters that can be included in
// a request to the [CreateRefund](api-endpoint:Transactions-CreateRefund) endpoint.
//
// Deprecated - recommend using [RefundPayment](api-endpoint:Refunds-RefundPayment)
type CreateRefundRequest struct {
	// A value you specify that uniquely identifies this
	// refund among refunds you've created for the tender.
	//
	// If you're unsure whether a particular refund succeeded,
	// you can reattempt it with the same idempotency key without
	// worrying about duplicating the refund.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/working-with-apis/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The ID of the tender to refund.
	//
	// A [`Transaction`](entity:Transaction) has one or more `tenders` (i.e., methods
	// of payment) associated with it, and you refund each tender separately with
	// the Connect API.
	TenderID string `json:"tender_id" url:"tender_id"`
	// A description of the reason for the refund.
	//
	// Default value: `Refund via API`
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// The amount of money to refund.
	//
	// Note that you specify the amount in the
	// **smallest denomination of the applicable currency**. For example, US dollar
	// amounts are specified in cents. See
	// [Working with monetary amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts) for details.
	//
	// This amount cannot exceed the amount that was originally charged to the
	// tender that corresponds to `tender_id`.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateRefundRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRefundRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateRefund](api-endpoint:Transactions-CreateRefund) endpoint.
//
// One of `errors` or `refund` is present in a given response (never both).
type CreateRefundResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created refund.
	Refund *Refund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateRefundResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response to a request to create a `Shift`. The response contains
// the created `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type CreateShiftResponse struct {
	// The `Shift` that was created on the request.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateShiftResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateShiftResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines output parameters in a response from the
// [CreateSubscription]($e/Subscriptions/CreateSubscription) endpoint.
type CreateSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created subscription.
	//
	// For more information, see
	// [Subscription object](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#subscription-object).
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateSubscriptionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a create request for a `TeamMember` object.
type CreateTeamMemberRequest struct {
	// A unique string that identifies this `CreateTeamMember` request.
	// Keys can be any valid string, but must be unique for every request.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	//
	// The minimum length is 1 and the maximum length is 45.
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`
	// **Required** The data used to create the `TeamMember` object.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTeamMemberRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTeamMemberRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTeamMemberRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTeamMemberRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTeamMemberRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a response from a create request containing the created `TeamMember` object or error messages.
type CreateTeamMemberResponse struct {
	// The successfully created `TeamMember` object.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTeamMemberResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTeamMemberResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTeamMemberResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTeamMemberResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTeamMemberResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalActionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalCheckoutResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalRefund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalRefundResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents an output from a call to [CreateVendor]($e/Vendors/CreateVendor).
type CreateVendorResponse struct {
	// Errors encountered when the request fails.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created [Vendor](entity:Vendor) object.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateVendorResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateVendorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateVendorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateVendorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateVendorResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateWebhookSubscription]($e/WebhookSubscriptions/CreateWebhookSubscription) endpoint.
//
// Note: if there are errors processing the request, the [Subscription]($m/WebhookSubscription) will not be
// present.
type CreateWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebhookSubscriptionResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the associated currency for an amount of money. Values correspond
// to [ISO 4217](https://wikipedia.org/wiki/ISO_4217).
type Currency string

const (
	CurrencyUnknownCurrency Currency = "UNKNOWN_CURRENCY"
	CurrencyAed             Currency = "AED"
	CurrencyAfn             Currency = "AFN"
	CurrencyAll             Currency = "ALL"
	CurrencyAmd             Currency = "AMD"
	CurrencyAng             Currency = "ANG"
	CurrencyAoa             Currency = "AOA"
	CurrencyArs             Currency = "ARS"
	CurrencyAud             Currency = "AUD"
	CurrencyAwg             Currency = "AWG"
	CurrencyAzn             Currency = "AZN"
	CurrencyBam             Currency = "BAM"
	CurrencyBbd             Currency = "BBD"
	CurrencyBdt             Currency = "BDT"
	CurrencyBgn             Currency = "BGN"
	CurrencyBhd             Currency = "BHD"
	CurrencyBif             Currency = "BIF"
	CurrencyBmd             Currency = "BMD"
	CurrencyBnd             Currency = "BND"
	CurrencyBob             Currency = "BOB"
	CurrencyBov             Currency = "BOV"
	CurrencyBrl             Currency = "BRL"
	CurrencyBsd             Currency = "BSD"
	CurrencyBtn             Currency = "BTN"
	CurrencyBwp             Currency = "BWP"
	CurrencyByr             Currency = "BYR"
	CurrencyBzd             Currency = "BZD"
	CurrencyCad             Currency = "CAD"
	CurrencyCdf             Currency = "CDF"
	CurrencyChe             Currency = "CHE"
	CurrencyChf             Currency = "CHF"
	CurrencyChw             Currency = "CHW"
	CurrencyClf             Currency = "CLF"
	CurrencyClp             Currency = "CLP"
	CurrencyCny             Currency = "CNY"
	CurrencyCop             Currency = "COP"
	CurrencyCou             Currency = "COU"
	CurrencyCrc             Currency = "CRC"
	CurrencyCuc             Currency = "CUC"
	CurrencyCup             Currency = "CUP"
	CurrencyCve             Currency = "CVE"
	CurrencyCzk             Currency = "CZK"
	CurrencyDjf             Currency = "DJF"
	CurrencyDkk             Currency = "DKK"
	CurrencyDop             Currency = "DOP"
	CurrencyDzd             Currency = "DZD"
	CurrencyEgp             Currency = "EGP"
	CurrencyErn             Currency = "ERN"
	CurrencyEtb             Currency = "ETB"
	CurrencyEur             Currency = "EUR"
	CurrencyFjd             Currency = "FJD"
	CurrencyFkp             Currency = "FKP"
	CurrencyGbp             Currency = "GBP"
	CurrencyGel             Currency = "GEL"
	CurrencyGhs             Currency = "GHS"
	CurrencyGip             Currency = "GIP"
	CurrencyGmd             Currency = "GMD"
	CurrencyGnf             Currency = "GNF"
	CurrencyGtq             Currency = "GTQ"
	CurrencyGyd             Currency = "GYD"
	CurrencyHkd             Currency = "HKD"
	CurrencyHnl             Currency = "HNL"
	CurrencyHrk             Currency = "HRK"
	CurrencyHtg             Currency = "HTG"
	CurrencyHuf             Currency = "HUF"
	CurrencyIdr             Currency = "IDR"
	CurrencyIls             Currency = "ILS"
	CurrencyInr             Currency = "INR"
	CurrencyIqd             Currency = "IQD"
	CurrencyIrr             Currency = "IRR"
	CurrencyIsk             Currency = "ISK"
	CurrencyJmd             Currency = "JMD"
	CurrencyJod             Currency = "JOD"
	CurrencyJpy             Currency = "JPY"
	CurrencyKes             Currency = "KES"
	CurrencyKgs             Currency = "KGS"
	CurrencyKhr             Currency = "KHR"
	CurrencyKmf             Currency = "KMF"
	CurrencyKpw             Currency = "KPW"
	CurrencyKrw             Currency = "KRW"
	CurrencyKwd             Currency = "KWD"
	CurrencyKyd             Currency = "KYD"
	CurrencyKzt             Currency = "KZT"
	CurrencyLak             Currency = "LAK"
	CurrencyLbp             Currency = "LBP"
	CurrencyLkr             Currency = "LKR"
	CurrencyLrd             Currency = "LRD"
	CurrencyLsl             Currency = "LSL"
	CurrencyLtl             Currency = "LTL"
	CurrencyLvl             Currency = "LVL"
	CurrencyLyd             Currency = "LYD"
	CurrencyMad             Currency = "MAD"
	CurrencyMdl             Currency = "MDL"
	CurrencyMga             Currency = "MGA"
	CurrencyMkd             Currency = "MKD"
	CurrencyMmk             Currency = "MMK"
	CurrencyMnt             Currency = "MNT"
	CurrencyMop             Currency = "MOP"
	CurrencyMro             Currency = "MRO"
	CurrencyMur             Currency = "MUR"
	CurrencyMvr             Currency = "MVR"
	CurrencyMwk             Currency = "MWK"
	CurrencyMxn             Currency = "MXN"
	CurrencyMxv             Currency = "MXV"
	CurrencyMyr             Currency = "MYR"
	CurrencyMzn             Currency = "MZN"
	CurrencyNad             Currency = "NAD"
	CurrencyNgn             Currency = "NGN"
	CurrencyNio             Currency = "NIO"
	CurrencyNok             Currency = "NOK"
	CurrencyNpr             Currency = "NPR"
	CurrencyNzd             Currency = "NZD"
	CurrencyOmr             Currency = "OMR"
	CurrencyPab             Currency = "PAB"
	CurrencyPen             Currency = "PEN"
	CurrencyPgk             Currency = "PGK"
	CurrencyPhp             Currency = "PHP"
	CurrencyPkr             Currency = "PKR"
	CurrencyPln             Currency = "PLN"
	CurrencyPyg             Currency = "PYG"
	CurrencyQar             Currency = "QAR"
	CurrencyRon             Currency = "RON"
	CurrencyRsd             Currency = "RSD"
	CurrencyRub             Currency = "RUB"
	CurrencyRwf             Currency = "RWF"
	CurrencySar             Currency = "SAR"
	CurrencySbd             Currency = "SBD"
	CurrencyScr             Currency = "SCR"
	CurrencySdg             Currency = "SDG"
	CurrencySek             Currency = "SEK"
	CurrencySgd             Currency = "SGD"
	CurrencyShp             Currency = "SHP"
	CurrencySll             Currency = "SLL"
	CurrencySos             Currency = "SOS"
	CurrencySrd             Currency = "SRD"
	CurrencySsp             Currency = "SSP"
	CurrencyStd             Currency = "STD"
	CurrencySvc             Currency = "SVC"
	CurrencySyp             Currency = "SYP"
	CurrencySzl             Currency = "SZL"
	CurrencyThb             Currency = "THB"
	CurrencyTjs             Currency = "TJS"
	CurrencyTmt             Currency = "TMT"
	CurrencyTnd             Currency = "TND"
	CurrencyTop             Currency = "TOP"
	CurrencyTry             Currency = "TRY"
	CurrencyTtd             Currency = "TTD"
	CurrencyTwd             Currency = "TWD"
	CurrencyTzs             Currency = "TZS"
	CurrencyUah             Currency = "UAH"
	CurrencyUgx             Currency = "UGX"
	CurrencyUsd             Currency = "USD"
	CurrencyUsn             Currency = "USN"
	CurrencyUss             Currency = "USS"
	CurrencyUyi             Currency = "UYI"
	CurrencyUyu             Currency = "UYU"
	CurrencyUzs             Currency = "UZS"
	CurrencyVef             Currency = "VEF"
	CurrencyVnd             Currency = "VND"
	CurrencyVuv             Currency = "VUV"
	CurrencyWst             Currency = "WST"
	CurrencyXaf             Currency = "XAF"
	CurrencyXag             Currency = "XAG"
	CurrencyXau             Currency = "XAU"
	CurrencyXba             Currency = "XBA"
	CurrencyXbb             Currency = "XBB"
	CurrencyXbc             Currency = "XBC"
	CurrencyXbd             Currency = "XBD"
	CurrencyXcd             Currency = "XCD"
	CurrencyXdr             Currency = "XDR"
	CurrencyXof             Currency = "XOF"
	CurrencyXpd             Currency = "XPD"
	CurrencyXpf             Currency = "XPF"
	CurrencyXpt             Currency = "XPT"
	CurrencyXts             Currency = "XTS"
	CurrencyXxx             Currency = "XXX"
	CurrencyYer             Currency = "YER"
	CurrencyZar             Currency = "ZAR"
	CurrencyZmk             Currency = "ZMK"
	CurrencyZmw             Currency = "ZMW"
	CurrencyBtc             Currency = "BTC"
	CurrencyXus             Currency = "XUS"
)

func NewCurrencyFromString(s string) (Currency, error) {
	switch s {
	case "UNKNOWN_CURRENCY":
		return CurrencyUnknownCurrency, nil
	case "AED":
		return CurrencyAed, nil
	case "AFN":
		return CurrencyAfn, nil
	case "ALL":
		return CurrencyAll, nil
	case "AMD":
		return CurrencyAmd, nil
	case "ANG":
		return CurrencyAng, nil
	case "AOA":
		return CurrencyAoa, nil
	case "ARS":
		return CurrencyArs, nil
	case "AUD":
		return CurrencyAud, nil
	case "AWG":
		return CurrencyAwg, nil
	case "AZN":
		return CurrencyAzn, nil
	case "BAM":
		return CurrencyBam, nil
	case "BBD":
		return CurrencyBbd, nil
	case "BDT":
		return CurrencyBdt, nil
	case "BGN":
		return CurrencyBgn, nil
	case "BHD":
		return CurrencyBhd, nil
	case "BIF":
		return CurrencyBif, nil
	case "BMD":
		return CurrencyBmd, nil
	case "BND":
		return CurrencyBnd, nil
	case "BOB":
		return CurrencyBob, nil
	case "BOV":
		return CurrencyBov, nil
	case "BRL":
		return CurrencyBrl, nil
	case "BSD":
		return CurrencyBsd, nil
	case "BTN":
		return CurrencyBtn, nil
	case "BWP":
		return CurrencyBwp, nil
	case "BYR":
		return CurrencyByr, nil
	case "BZD":
		return CurrencyBzd, nil
	case "CAD":
		return CurrencyCad, nil
	case "CDF":
		return CurrencyCdf, nil
	case "CHE":
		return CurrencyChe, nil
	case "CHF":
		return CurrencyChf, nil
	case "CHW":
		return CurrencyChw, nil
	case "CLF":
		return CurrencyClf, nil
	case "CLP":
		return CurrencyClp, nil
	case "CNY":
		return CurrencyCny, nil
	case "COP":
		return CurrencyCop, nil
	case "COU":
		return CurrencyCou, nil
	case "CRC":
		return CurrencyCrc, nil
	case "CUC":
		return CurrencyCuc, nil
	case "CUP":
		return CurrencyCup, nil
	case "CVE":
		return CurrencyCve, nil
	case "CZK":
		return CurrencyCzk, nil
	case "DJF":
		return CurrencyDjf, nil
	case "DKK":
		return CurrencyDkk, nil
	case "DOP":
		return CurrencyDop, nil
	case "DZD":
		return CurrencyDzd, nil
	case "EGP":
		return CurrencyEgp, nil
	case "ERN":
		return CurrencyErn, nil
	case "ETB":
		return CurrencyEtb, nil
	case "EUR":
		return CurrencyEur, nil
	case "FJD":
		return CurrencyFjd, nil
	case "FKP":
		return CurrencyFkp, nil
	case "GBP":
		return CurrencyGbp, nil
	case "GEL":
		return CurrencyGel, nil
	case "GHS":
		return CurrencyGhs, nil
	case "GIP":
		return CurrencyGip, nil
	case "GMD":
		return CurrencyGmd, nil
	case "GNF":
		return CurrencyGnf, nil
	case "GTQ":
		return CurrencyGtq, nil
	case "GYD":
		return CurrencyGyd, nil
	case "HKD":
		return CurrencyHkd, nil
	case "HNL":
		return CurrencyHnl, nil
	case "HRK":
		return CurrencyHrk, nil
	case "HTG":
		return CurrencyHtg, nil
	case "HUF":
		return CurrencyHuf, nil
	case "IDR":
		return CurrencyIdr, nil
	case "ILS":
		return CurrencyIls, nil
	case "INR":
		return CurrencyInr, nil
	case "IQD":
		return CurrencyIqd, nil
	case "IRR":
		return CurrencyIrr, nil
	case "ISK":
		return CurrencyIsk, nil
	case "JMD":
		return CurrencyJmd, nil
	case "JOD":
		return CurrencyJod, nil
	case "JPY":
		return CurrencyJpy, nil
	case "KES":
		return CurrencyKes, nil
	case "KGS":
		return CurrencyKgs, nil
	case "KHR":
		return CurrencyKhr, nil
	case "KMF":
		return CurrencyKmf, nil
	case "KPW":
		return CurrencyKpw, nil
	case "KRW":
		return CurrencyKrw, nil
	case "KWD":
		return CurrencyKwd, nil
	case "KYD":
		return CurrencyKyd, nil
	case "KZT":
		return CurrencyKzt, nil
	case "LAK":
		return CurrencyLak, nil
	case "LBP":
		return CurrencyLbp, nil
	case "LKR":
		return CurrencyLkr, nil
	case "LRD":
		return CurrencyLrd, nil
	case "LSL":
		return CurrencyLsl, nil
	case "LTL":
		return CurrencyLtl, nil
	case "LVL":
		return CurrencyLvl, nil
	case "LYD":
		return CurrencyLyd, nil
	case "MAD":
		return CurrencyMad, nil
	case "MDL":
		return CurrencyMdl, nil
	case "MGA":
		return CurrencyMga, nil
	case "MKD":
		return CurrencyMkd, nil
	case "MMK":
		return CurrencyMmk, nil
	case "MNT":
		return CurrencyMnt, nil
	case "MOP":
		return CurrencyMop, nil
	case "MRO":
		return CurrencyMro, nil
	case "MUR":
		return CurrencyMur, nil
	case "MVR":
		return CurrencyMvr, nil
	case "MWK":
		return CurrencyMwk, nil
	case "MXN":
		return CurrencyMxn, nil
	case "MXV":
		return CurrencyMxv, nil
	case "MYR":
		return CurrencyMyr, nil
	case "MZN":
		return CurrencyMzn, nil
	case "NAD":
		return CurrencyNad, nil
	case "NGN":
		return CurrencyNgn, nil
	case "NIO":
		return CurrencyNio, nil
	case "NOK":
		return CurrencyNok, nil
	case "NPR":
		return CurrencyNpr, nil
	case "NZD":
		return CurrencyNzd, nil
	case "OMR":
		return CurrencyOmr, nil
	case "PAB":
		return CurrencyPab, nil
	case "PEN":
		return CurrencyPen, nil
	case "PGK":
		return CurrencyPgk, nil
	case "PHP":
		return CurrencyPhp, nil
	case "PKR":
		return CurrencyPkr, nil
	case "PLN":
		return CurrencyPln, nil
	case "PYG":
		return CurrencyPyg, nil
	case "QAR":
		return CurrencyQar, nil
	case "RON":
		return CurrencyRon, nil
	case "RSD":
		return CurrencyRsd, nil
	case "RUB":
		return CurrencyRub, nil
	case "RWF":
		return CurrencyRwf, nil
	case "SAR":
		return CurrencySar, nil
	case "SBD":
		return CurrencySbd, nil
	case "SCR":
		return CurrencyScr, nil
	case "SDG":
		return CurrencySdg, nil
	case "SEK":
		return CurrencySek, nil
	case "SGD":
		return CurrencySgd, nil
	case "SHP":
		return CurrencyShp, nil
	case "SLL":
		return CurrencySll, nil
	case "SOS":
		return CurrencySos, nil
	case "SRD":
		return CurrencySrd, nil
	case "SSP":
		return CurrencySsp, nil
	case "STD":
		return CurrencyStd, nil
	case "SVC":
		return CurrencySvc, nil
	case "SYP":
		return CurrencySyp, nil
	case "SZL":
		return CurrencySzl, nil
	case "THB":
		return CurrencyThb, nil
	case "TJS":
		return CurrencyTjs, nil
	case "TMT":
		return CurrencyTmt, nil
	case "TND":
		return CurrencyTnd, nil
	case "TOP":
		return CurrencyTop, nil
	case "TRY":
		return CurrencyTry, nil
	case "TTD":
		return CurrencyTtd, nil
	case "TWD":
		return CurrencyTwd, nil
	case "TZS":
		return CurrencyTzs, nil
	case "UAH":
		return CurrencyUah, nil
	case "UGX":
		return CurrencyUgx, nil
	case "USD":
		return CurrencyUsd, nil
	case "USN":
		return CurrencyUsn, nil
	case "USS":
		return CurrencyUss, nil
	case "UYI":
		return CurrencyUyi, nil
	case "UYU":
		return CurrencyUyu, nil
	case "UZS":
		return CurrencyUzs, nil
	case "VEF":
		return CurrencyVef, nil
	case "VND":
		return CurrencyVnd, nil
	case "VUV":
		return CurrencyVuv, nil
	case "WST":
		return CurrencyWst, nil
	case "XAF":
		return CurrencyXaf, nil
	case "XAG":
		return CurrencyXag, nil
	case "XAU":
		return CurrencyXau, nil
	case "XBA":
		return CurrencyXba, nil
	case "XBB":
		return CurrencyXbb, nil
	case "XBC":
		return CurrencyXbc, nil
	case "XBD":
		return CurrencyXbd, nil
	case "XCD":
		return CurrencyXcd, nil
	case "XDR":
		return CurrencyXdr, nil
	case "XOF":
		return CurrencyXof, nil
	case "XPD":
		return CurrencyXpd, nil
	case "XPF":
		return CurrencyXpf, nil
	case "XPT":
		return CurrencyXpt, nil
	case "XTS":
		return CurrencyXts, nil
	case "XXX":
		return CurrencyXxx, nil
	case "YER":
		return CurrencyYer, nil
	case "ZAR":
		return CurrencyZar, nil
	case "ZMK":
		return CurrencyZmk, nil
	case "ZMW":
		return CurrencyZmw, nil
	case "BTC":
		return CurrencyBtc, nil
	case "XUS":
		return CurrencyXus, nil
	}
	var t Currency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Currency) Ptr() *Currency {
	return &c
}

// A custom attribute value. Each custom attribute value has a corresponding
// `CustomAttributeDefinition` object.
type CustomAttribute struct {
	// The identifier
	// of the custom attribute definition and its corresponding custom attributes. This value
	// can be a simple key, which is the key that is provided when the custom attribute definition
	// is created, or a qualified key, if the requesting
	// application is not the definition owner. The qualified key consists of the application ID
	// of the custom attribute definition owner
	// followed by the simple key that was provided when the definition was created. It has the
	// format application_id:simple key.
	//
	// The value for a simple key can contain up to 60 alphanumeric characters, periods (.),
	// underscores (\_), and hyphens (-).
	Key   *string     `json:"key,omitempty" url:"key,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Read only. The current version of the custom attribute. This field is incremented when the custom attribute is changed.
	// When updating an existing custom attribute value, you can provide this field
	// and specify the current version of the custom attribute to enable
	// [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency).
	// This field can also be used to enforce strong consistency for reads. For more information about strong consistency for reads,
	// see [Custom Attributes Overview](https://developer.squareup.com/docs/devtools/customattributes/overview).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A copy of the `visibility` field value for the associated custom attribute definition.
	// See [CustomAttributeDefinitionVisibility](#type-customattributedefinitionvisibility) for possible values
	Visibility *CustomAttributeDefinitionVisibility `json:"visibility,omitempty" url:"visibility,omitempty"`
	// A copy of the associated custom attribute definition object. This field is only set when
	// the optional field is specified on the request.
	Definition *CustomAttributeDefinition `json:"definition,omitempty" url:"definition,omitempty"`
	// The timestamp that indicates when the custom attribute was created or was most recently
	// updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp that indicates when the custom attribute was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttribute) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttribute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttribute) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a definition for custom attribute values. A custom attribute definition
// specifies the key, visibility, schema, and other properties for a custom attribute.
type CustomAttributeDefinition struct {
	// The identifier
	// of the custom attribute definition and its corresponding custom attributes. This value
	// can be a simple key, which is the key that is provided when the custom attribute definition
	// is created, or a qualified key, if the requesting
	// application is not the definition owner. The qualified key consists of the application ID
	// of the custom attribute definition owner
	// followed by the simple key that was provided when the definition was created. It has the
	// format application_id:simple key.
	//
	// The value for a simple key can contain up to 60 alphanumeric characters, periods (.),
	// underscores (\_), and hyphens (-).
	//
	// This field can not be changed
	// after the custom attribute definition is created. This field is required when creating
	// a definition and must be unique per application, seller, and resource type.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// The JSON schema for the custom attribute definition, which determines the data type of the corresponding custom attributes. For more information,
	// see [Custom Attributes Overview](https://developer.squareup.com/docs/devtools/customattributes/overview). This field is required when creating a definition.
	Schema map[string]interface{} `json:"schema,omitempty" url:"schema,omitempty"`
	// The name of the custom attribute definition for API and seller-facing UI purposes. The name must
	// be unique within the seller and application pair. This field is required if the
	// `visibility` field is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Seller-oriented description of the custom attribute definition, including any constraints
	// that the seller should observe. May be displayed as a tooltip in Square UIs. This field is
	// required if the `visibility` field is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Specifies how the custom attribute definition and its values should be shared with
	// the seller and other applications. If no value is specified, the value defaults to `VISIBILITY_HIDDEN`.
	// See [Visibility](#type-visibility) for possible values
	Visibility *CustomAttributeDefinitionVisibility `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Read only. The current version of the custom attribute definition.
	// The value is incremented each time the custom attribute definition is updated.
	// When updating a custom attribute definition, you can provide this field
	// and specify the current version of the custom attribute definition to enable
	// [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency).
	//
	// On writes, this field must be set to the latest version. Stale writes are rejected.
	//
	// This field can also be used to enforce strong consistency for reads. For more information about strong consistency for reads,
	// see [Custom Attributes Overview](https://developer.squareup.com/docs/devtools/customattributes/overview).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp that indicates when the custom attribute definition was created or most recently updated,
	// in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp that indicates when the custom attribute definition was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeDefinition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeDefinition) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The level of permission that a seller or other applications requires to
// view this custom attribute definition.
// The `Visibility` field controls who can read and write the custom attribute values
// and custom attribute definition.
type CustomAttributeDefinitionVisibility string

const (
	CustomAttributeDefinitionVisibilityVisibilityHidden          CustomAttributeDefinitionVisibility = "VISIBILITY_HIDDEN"
	CustomAttributeDefinitionVisibilityVisibilityReadOnly        CustomAttributeDefinitionVisibility = "VISIBILITY_READ_ONLY"
	CustomAttributeDefinitionVisibilityVisibilityReadWriteValues CustomAttributeDefinitionVisibility = "VISIBILITY_READ_WRITE_VALUES"
)

func NewCustomAttributeDefinitionVisibilityFromString(s string) (CustomAttributeDefinitionVisibility, error) {
	switch s {
	case "VISIBILITY_HIDDEN":
		return CustomAttributeDefinitionVisibilityVisibilityHidden, nil
	case "VISIBILITY_READ_ONLY":
		return CustomAttributeDefinitionVisibilityVisibilityReadOnly, nil
	case "VISIBILITY_READ_WRITE_VALUES":
		return CustomAttributeDefinitionVisibilityVisibilityReadWriteValues, nil
	}
	var t CustomAttributeDefinitionVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomAttributeDefinitionVisibility) Ptr() *CustomAttributeDefinitionVisibility {
	return &c
}

// Supported custom attribute query expressions for calling the
// [SearchCatalogItems]($e/Catalog/SearchCatalogItems)
// endpoint to search for items or item variations.
type CustomAttributeFilter struct {
	// A query expression to filter items or item variations by matching their custom attributes'
	// `custom_attribute_definition_id` property value against the the specified id.
	// Exactly one of `custom_attribute_definition_id` or `key` must be specified.
	CustomAttributeDefinitionID *string `json:"custom_attribute_definition_id,omitempty" url:"custom_attribute_definition_id,omitempty"`
	// A query expression to filter items or item variations by matching their custom attributes'
	// `key` property value against the specified key.
	// Exactly one of `custom_attribute_definition_id` or `key` must be specified.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// A query expression to filter items or item variations by matching their custom attributes'
	// `string_value` property value against the specified text.
	// Exactly one of `string_filter`, `number_filter`, `selection_uids_filter`, or `bool_filter` must be specified.
	StringFilter *string `json:"string_filter,omitempty" url:"string_filter,omitempty"`
	// A query expression to filter items or item variations with their custom attributes
	// containing a number value within the specified range.
	// Exactly one of `string_filter`, `number_filter`, `selection_uids_filter`, or `bool_filter` must be specified.
	NumberFilter *Range `json:"number_filter,omitempty" url:"number_filter,omitempty"`
	// A query expression to filter items or item variations by matching their custom attributes'
	// `selection_uid_values` values against the specified selection uids.
	// Exactly one of `string_filter`, `number_filter`, `selection_uids_filter`, or `bool_filter` must be specified.
	SelectionUIDsFilter []string `json:"selection_uids_filter,omitempty" url:"selection_uids_filter,omitempty"`
	// A query expression to filter items or item variations by matching their custom attributes'
	// `boolean_value` property values against the specified Boolean expression.
	// Exactly one of `string_filter`, `number_filter`, `selection_uids_filter`, or `bool_filter` must be specified.
	BoolFilter *bool `json:"bool_filter,omitempty" url:"bool_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomAttributeFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a custom form field to add to the checkout page to collect more information from buyers during checkout.
// For more information,
// see [Specify checkout options](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations#specify-checkout-options-1).
type CustomField struct {
	// The title of the custom field.
	Title string `json:"title" url:"title"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomField) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomField) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomField) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a Square customer profile in the Customer Directory of a Square seller.
type Customer struct {
	// A unique Square-assigned ID for the customer profile.
	//
	// If you need this ID for an API request, use the ID returned when you created the customer profile or call the [SearchCustomers](api-endpoint:Customers-SearchCustomers)
	// or [ListCustomers](api-endpoint:Customers-ListCustomers) endpoint.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The timestamp when the customer profile was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the customer profile was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Payment details of the credit, debit, and gift cards stored on file for the customer profile.
	//
	// DEPRECATED at version 2021-06-16 and will be RETIRED at version 2024-12-18. Replaced by calling [ListCards](api-endpoint:Cards-ListCards) (for credit and debit cards on file)
	// or [ListGiftCards](api-endpoint:GiftCards-ListGiftCards) (for gift cards on file) and including the `customer_id` query parameter.
	// For more information, see [Migration notes](https://developer.squareup.com/docs/customers-api/what-it-does#migrate-customer-cards).
	Cards []*Card `json:"cards,omitempty" url:"cards,omitempty"`
	// The given name (that is, the first name) associated with the customer profile.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The family name (that is, the last name) associated with the customer profile.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// A nickname for the customer profile.
	Nickname *string `json:"nickname,omitempty" url:"nickname,omitempty"`
	// A business name associated with the customer profile.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// The email address associated with the customer profile.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The physical address associated with the customer profile.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The phone number associated with the customer profile.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The birthday associated with the customer profile, in `YYYY-MM-DD` format. For example, `1998-09-21`
	// represents September 21, 1998, and `0000-09-21` represents September 21 (without a birth year).
	Birthday *string `json:"birthday,omitempty" url:"birthday,omitempty"`
	// An optional second ID used to associate the customer profile with an
	// entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// A custom note associated with the customer profile.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// Represents general customer preferences.
	Preferences *CustomerPreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// The method used to create the customer profile.
	// See [CustomerCreationSource](#type-customercreationsource) for possible values
	CreationSource *CustomerCreationSource `json:"creation_source,omitempty" url:"creation_source,omitempty"`
	// The IDs of [customer groups](entity:CustomerGroup) the customer belongs to.
	GroupIDs []string `json:"group_ids,omitempty" url:"group_ids,omitempty"`
	// The IDs of [customer segments](entity:CustomerSegment) the customer belongs to.
	SegmentIDs []string `json:"segment_ids,omitempty" url:"segment_ids,omitempty"`
	// The Square-assigned version number of the customer profile. The version number is incremented each time an update is committed to the customer profile, except for changes to customer segment membership and cards on file.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The tax ID associated with the customer profile. This field is present only for customers of sellers in EU countries or the United Kingdom.
	// For more information, see [Customer tax IDs](https://developer.squareup.com/docs/customers-api/what-it-does#customer-tax-ids).
	TaxIDs *CustomerTaxIDs `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Customer) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Customer) UnmarshalJSON(data []byte) error {
	type unmarshaler Customer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Customer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Customer) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The customer address filter. This filter is used in a [CustomerCustomAttributeFilterValue]($m/CustomerCustomAttributeFilterValue) filter when
// searching by an `Address`-type custom attribute.
type CustomerAddressFilter struct {
	// The postal code to search for. Only an `exact` match is supported.
	PostalCode *CustomerTextFilter `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// The country code to search for.
	// See [Country](#type-country) for possible values
	Country *Country `json:"country,omitempty" url:"country,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerAddressFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerAddressFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerAddressFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerAddressFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerAddressFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the method used to create the customer profile.
type CustomerCreationSource string

const (
	CustomerCreationSourceOther            CustomerCreationSource = "OTHER"
	CustomerCreationSourceAppointments     CustomerCreationSource = "APPOINTMENTS"
	CustomerCreationSourceCoupon           CustomerCreationSource = "COUPON"
	CustomerCreationSourceDeletionRecovery CustomerCreationSource = "DELETION_RECOVERY"
	CustomerCreationSourceDirectory        CustomerCreationSource = "DIRECTORY"
	CustomerCreationSourceEgifting         CustomerCreationSource = "EGIFTING"
	CustomerCreationSourceEmailCollection  CustomerCreationSource = "EMAIL_COLLECTION"
	CustomerCreationSourceFeedback         CustomerCreationSource = "FEEDBACK"
	CustomerCreationSourceImport           CustomerCreationSource = "IMPORT"
	CustomerCreationSourceInvoices         CustomerCreationSource = "INVOICES"
	CustomerCreationSourceLoyalty          CustomerCreationSource = "LOYALTY"
	CustomerCreationSourceMarketing        CustomerCreationSource = "MARKETING"
	CustomerCreationSourceMerge            CustomerCreationSource = "MERGE"
	CustomerCreationSourceOnlineStore      CustomerCreationSource = "ONLINE_STORE"
	CustomerCreationSourceInstantProfile   CustomerCreationSource = "INSTANT_PROFILE"
	CustomerCreationSourceTerminal         CustomerCreationSource = "TERMINAL"
	CustomerCreationSourceThirdParty       CustomerCreationSource = "THIRD_PARTY"
	CustomerCreationSourceThirdPartyImport CustomerCreationSource = "THIRD_PARTY_IMPORT"
	CustomerCreationSourceUnmergeRecovery  CustomerCreationSource = "UNMERGE_RECOVERY"
)

func NewCustomerCreationSourceFromString(s string) (CustomerCreationSource, error) {
	switch s {
	case "OTHER":
		return CustomerCreationSourceOther, nil
	case "APPOINTMENTS":
		return CustomerCreationSourceAppointments, nil
	case "COUPON":
		return CustomerCreationSourceCoupon, nil
	case "DELETION_RECOVERY":
		return CustomerCreationSourceDeletionRecovery, nil
	case "DIRECTORY":
		return CustomerCreationSourceDirectory, nil
	case "EGIFTING":
		return CustomerCreationSourceEgifting, nil
	case "EMAIL_COLLECTION":
		return CustomerCreationSourceEmailCollection, nil
	case "FEEDBACK":
		return CustomerCreationSourceFeedback, nil
	case "IMPORT":
		return CustomerCreationSourceImport, nil
	case "INVOICES":
		return CustomerCreationSourceInvoices, nil
	case "LOYALTY":
		return CustomerCreationSourceLoyalty, nil
	case "MARKETING":
		return CustomerCreationSourceMarketing, nil
	case "MERGE":
		return CustomerCreationSourceMerge, nil
	case "ONLINE_STORE":
		return CustomerCreationSourceOnlineStore, nil
	case "INSTANT_PROFILE":
		return CustomerCreationSourceInstantProfile, nil
	case "TERMINAL":
		return CustomerCreationSourceTerminal, nil
	case "THIRD_PARTY":
		return CustomerCreationSourceThirdParty, nil
	case "THIRD_PARTY_IMPORT":
		return CustomerCreationSourceThirdPartyImport, nil
	case "UNMERGE_RECOVERY":
		return CustomerCreationSourceUnmergeRecovery, nil
	}
	var t CustomerCreationSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomerCreationSource) Ptr() *CustomerCreationSource {
	return &c
}

// The creation source filter.
//
// If one or more creation sources are set, customer profiles are included in,
// or excluded from, the result if they match at least one of the filter criteria.
type CustomerCreationSourceFilter struct {
	// The list of creation sources used as filtering criteria.
	// See [CustomerCreationSource](#type-customercreationsource) for possible values
	Values []CustomerCreationSource `json:"values,omitempty" url:"values,omitempty"`
	// Indicates whether a customer profile matching the filter criteria
	// should be included in the result or excluded from the result.
	//
	// Default: `INCLUDE`.
	// See [CustomerInclusionExclusion](#type-customerinclusionexclusion) for possible values
	Rule *CustomerInclusionExclusion `json:"rule,omitempty" url:"rule,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCreationSourceFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreationSourceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreationSourceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreationSourceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreationSourceFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The custom attribute filter. Use this filter in a set of [custom attribute filters]($m/CustomerCustomAttributeFilters) to search
// based on the value or last updated date of a customer-related [custom attribute]($m/CustomAttribute).
type CustomerCustomAttributeFilter struct {
	// The `key` of the [custom attribute](entity:CustomAttribute) to filter by. The key is the identifier of the custom attribute
	// (and the corresponding custom attribute definition) and can be retrieved using the [Customer Custom Attributes API](api:CustomerCustomAttributes).
	Key string `json:"key" url:"key"`
	// A filter that corresponds to the data type of the target custom attribute. For example, provide the `phone` filter to
	// search based on the value of a `PhoneNumber`-type custom attribute. The data type is specified by the schema field of the custom attribute definition,
	// which can be retrieved using the [Customer Custom Attributes API](api:CustomerCustomAttributes).
	//
	// You must provide this `filter` field, the `updated_at` field, or both.
	Filter *CustomerCustomAttributeFilterValue `json:"filter,omitempty" url:"filter,omitempty"`
	// The date range for when the custom attribute was last updated. The date range can include `start_at`, `end_at`, or
	// both. Range boundaries are inclusive. Dates are specified as RFC 3339 timestamps.
	//
	// You must provide this `updated_at` field, the `filter` field, or both.
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A type-specific filter used in a [custom attribute filter]($m/CustomerCustomAttributeFilter) to search based on the value
// of a customer-related [custom attribute]($m/CustomAttribute).
type CustomerCustomAttributeFilterValue struct {
	// A filter for a query based on the value of an `Email`-type custom attribute. This filter is case-insensitive and can
	// include `exact` or `fuzzy`, but not both.
	//
	// For an `exact` match, provide the complete email address.
	//
	// For a `fuzzy` match, provide a query expression containing one or more query tokens to match against the email address. Square removes
	// any punctuation (including periods (.), underscores (\_), and the @ symbol) and tokenizes the email addresses on spaces. A match is found
	// if a tokenized email address contains all the tokens in the search query, irrespective of the token order. For example, `Steven gmail`
	// matches steven.jones@gmail.com and mygmail@stevensbakery.com.
	Email *CustomerTextFilter `json:"email,omitempty" url:"email,omitempty"`
	// A filter for a query based on the value of a `PhoneNumber`-type custom attribute. This filter is case-insensitive and
	// can include `exact` or `fuzzy`, but not both.
	//
	// For an `exact` match, provide the complete phone number. This is always an E.164-compliant phone number that starts
	// with the + sign followed by the country code and subscriber number. For example, the format for a US phone number is +12061112222.
	//
	// For a `fuzzy` match, provide a query expression containing one or more query tokens to match against the phone number.
	// Square removes any punctuation and tokenizes the expression on spaces. A match is found if a tokenized phone number contains
	// all the tokens in the search query, irrespective of the token order. For example, `415 123 45` is tokenized to `415`, `123`, and `45`,
	// which matches +14151234567 and +12345674158, but does not match +1234156780. Similarly, the expression `415` matches
	// +14151234567, +12345674158, and +1234156780.
	Phone *CustomerTextFilter `json:"phone,omitempty" url:"phone,omitempty"`
	// A filter for a query based on the value of a `String`-type custom attribute. This filter is case-insensitive and
	// can include `exact` or `fuzzy`, but not both.
	//
	// For an `exact` match, provide the complete string.
	//
	// For a `fuzzy` match, provide a query expression containing one or more query tokens in any order that contain complete words
	// to match against the string. Square tokenizes the expression using a grammar-based tokenizer. For example, the expressions `quick brown`,
	// `brown quick`, and `quick fox` match "The quick brown fox jumps over the lazy dog". However, `quick foxes` and `qui` do not match.
	Text *CustomerTextFilter `json:"text,omitempty" url:"text,omitempty"`
	// A filter for a query based on the display name for a `Selection`-type custom attribute value. This filter is case-sensitive
	// and can contain `any`, `all`, or both. The `none` condition is not supported.
	//
	// Provide the display name of each item that you want to search for. To find the display names for the selection, use the
	// [Customer Custom Attributes API](api:CustomerCustomAttributes) to retrieve the corresponding custom attribute definition
	// and then check the `schema.items.names` field. For more information, see
	// [Search based on selection](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#custom-attribute-value-filter-selection).
	//
	// Note that when a `Selection`-type custom attribute is assigned to a customer profile, the custom attribute value is a list of one
	// or more UUIDs (sourced from the `schema.items.enum` field) that map to the item names. These UUIDs are unique per seller.
	Selection *FilterValue `json:"selection,omitempty" url:"selection,omitempty"`
	// A filter for a query based on the value of a `Date`-type custom attribute.
	//
	// Provide a date range for this filter using `start_at`, `end_at`, or both. Range boundaries are inclusive. Dates can be specified
	// in `YYYY-MM-DD` format or as RFC 3339 timestamps.
	Date *TimeRange `json:"date,omitempty" url:"date,omitempty"`
	// A filter for a query based on the value of a `Number`-type custom attribute, which can be an integer or a decimal with up to
	// 5 digits of precision.
	//
	// Provide a numerical range for this filter using `start_at`, `end_at`, or both. Range boundaries are inclusive. Numbers are specified
	// as decimals or integers. The absolute value of range boundaries must not exceed `(2^63-1)/10^5`, or 92233720368547.
	Number *FloatNumberRange `json:"number,omitempty" url:"number,omitempty"`
	// A filter for a query based on the value of a `Boolean`-type custom attribute.
	Boolean *bool `json:"boolean,omitempty" url:"boolean,omitempty"`
	// A filter for a query based on the value of an `Address`-type custom attribute. The filter can include `postal_code`, `country`, or both.
	Address *CustomerAddressFilter `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeFilterValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeFilterValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeFilterValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeFilterValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeFilterValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The custom attribute filters in a set of [customer filters]($m/CustomerFilter) used in a search query. Use this filter
// to search based on [custom attributes]($m/CustomAttribute) that are assigned to customer profiles. For more information, see
// [Search by custom attribute](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-custom-attribute).
type CustomerCustomAttributeFilters struct {
	// The custom attribute filters. Each filter must specify `key` and include the `filter` field with a type-specific filter,
	// the `updated_at` field, or both. The provided keys must be unique within the list of custom attribute filters.
	Filters []*CustomerCustomAttributeFilter `json:"filters,omitempty" url:"filters,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerCustomAttributeFilters) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeFilters) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeFilters
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeFilters(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeFilters) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Details about the customer making the payment.
type CustomerDetails struct {
	// Indicates whether the customer initiated the payment.
	CustomerInitiated *bool `json:"customer_initiated,omitempty" url:"customer_initiated,omitempty"`
	// Indicates that the seller keyed in payment details on behalf of the customer.
	// This is used to flag a payment as Mail Order / Telephone Order (MOTO).
	SellerKeyedIn *bool `json:"seller_keyed_in,omitempty" url:"seller_keyed_in,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the filtering criteria in a [search query]($m/CustomerQuery) that defines how to filter
// customer profiles returned in [SearchCustomers]($e/Customers/SearchCustomers) results.
type CustomerFilter struct {
	// A filter to select customers based on their creation source.
	CreationSource *CustomerCreationSourceFilter `json:"creation_source,omitempty" url:"creation_source,omitempty"`
	// A filter to select customers based on when they were created.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A filter to select customers based on when they were last updated.
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// A filter to [select customers by their email address](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-email-address)
	// visible to the seller.
	// This filter is case-insensitive.
	//
	// For [exact matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-email-address), this
	// filter causes the search to return customer profiles
	// whose `email_address` field value are identical to the email address provided
	// in the query.
	//
	// For [fuzzy matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-email-address),
	// this filter causes the search to return customer profiles
	// whose `email_address` field value has a token-wise partial match against the filtering
	// expression in the query. For example, with `Steven gmail` provided in a search
	// query, the search returns customers whose email address is `steven.johnson@gmail.com`
	// or `mygmail@stevensbakery.com`. Square removes any punctuation (including periods (.),
	// underscores (\_), and the @ symbol) and tokenizes the email addresses on spaces. A match is
	// found if a tokenized email address contains all the tokens in the search query,
	// irrespective of the token order.
	EmailAddress *CustomerTextFilter `json:"email_address,omitempty" url:"email_address,omitempty"`
	// A filter to [select customers by their phone numbers](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-phone-number)
	// visible to the seller.
	//
	// For [exact matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-phone-number),
	// this filter returns customers whose phone number matches the specified query expression. The number in the query must be of an
	// E.164-compliant form. In particular, it must include the leading `+` sign followed by a country code and then a subscriber number.
	// For example, the standard E.164 form of a US phone number is `+12062223333` and an E.164-compliant variation is `+1 (206) 222-3333`.
	// To match the query expression, stored customer phone numbers are converted to the standard E.164 form.
	//
	// For [fuzzy matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-phone-number),
	// this filter returns customers whose phone number matches the token or tokens provided in the query expression. For example, with `415`
	// provided in a search query, the search returns customers with the phone numbers `+1-415-212-1200`, `+1-212-415-1234`, and `+1 (551) 234-1567`.
	// Similarly, a search query of `415 123` returns customers with the phone numbers `+1-212-415-1234` and `+1 (551) 234-1567` but not
	// `+1-212-415-1200`. A match is found if a tokenized phone number contains all the tokens in the search query, irrespective of the token order.
	PhoneNumber *CustomerTextFilter `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// A filter to [select customers by their reference IDs](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-reference-id).
	// This filter is case-insensitive.
	//
	// [Exact matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#exact-search-by-reference-id)
	// of a customer's reference ID against a query's reference ID is evaluated as an
	// exact match between two strings, character by character in the given order.
	//
	// [Fuzzy matching](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#fuzzy-search-by-reference-id)
	// of stored reference IDs against queried reference IDs works
	// exactly the same as fuzzy matching on email addresses. Non-alphanumeric characters
	// are replaced by spaces to tokenize stored and queried reference IDs. A match is found
	// if a tokenized stored reference ID contains all tokens specified in any order in the query. For example,
	// a query of `NYC M` matches customer profiles with the `reference_id` value of `NYC_M_35_JOHNSON`
	// and `NYC_27_MURRAY`.
	ReferenceID *CustomerTextFilter `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// A filter to select customers based on the [groups](entity:CustomerGroup) they belong to.
	// Group membership is controlled by sellers and developers.
	//
	// The `group_ids` filter has the following syntax:
	//
	// ```
	// "group_ids": {
	// "any":  ["{group_a_id}", "{group_b_id}", ...],
	// "all":  ["{group_1_id}", "{group_2_id}", ...],
	// "none": ["{group_i_id}", "{group_ii_id}", ...]
	// }
	// ```
	//
	// You can use any combination of the `any`, `all`, and `none` fields in the filter.
	// With `any`, the search returns customers in groups `a` or `b` or any other group specified in the list.
	// With `all`, the search returns customers in groups `1` and `2` and all other groups specified in the list.
	// With `none`, the search returns customers not in groups `i` or `ii` or any other group specified in the list.
	//
	// If any of the search conditions are not met, including when an invalid or non-existent group ID is provided,
	// the result is an empty object (`{}`).
	GroupIDs *FilterValue `json:"group_ids,omitempty" url:"group_ids,omitempty"`
	// A filter to select customers based on one or more custom attributes.
	// This filter can contain up to 10 custom attribute filters. Each custom attribute filter specifies filtering criteria for a target custom
	// attribute. If multiple custom attribute filters are provided, they are combined as an `AND` operation.
	//
	// To be valid for a search, the custom attributes must be visible to the requesting application. For more information, including example queries,
	// see [Search by custom attribute](https://developer.squareup.com/docs/customers-api/use-the-api/search-customers#search-by-custom-attribute).
	//
	// Square returns matching customer profiles, which do not contain custom attributes. To retrieve customer-related custom attributes,
	// use the [Customer Custom Attributes API](api:CustomerCustomAttributes). For example, you can call
	// [RetrieveCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-RetrieveCustomerCustomAttribute) using a customer ID from the result set.
	CustomAttribute *CustomerCustomAttributeFilters `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// A filter to select customers based on the [segments](entity:CustomerSegment) they belong to.
	// Segment membership is dynamic and adjusts automatically based on whether customers meet the segment criteria.
	//
	// You can provide up to three segment IDs in the filter, using any combination of the `all`, `any`, and `none` fields.
	// For the following example, the results include customers who belong to both segment A and segment B but do not belong to segment C.
	//
	// ```
	// "segment_ids": {
	// "all":  ["{segment_A_id}", "{segment_B_id}"],
	// "none":  ["{segment_C_id}"]
	// }
	// ```
	//
	// If an invalid or non-existent segment ID is provided in the filter, Square stops processing the request
	// and returns a `400 BAD_REQUEST` error that includes the segment ID.
	SegmentIDs *FilterValue `json:"segment_ids,omitempty" url:"segment_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a group of customer profiles.
//
// Customer groups can be created, be modified, and have their membership defined using
// the Customers API or within the Customer Directory in the Square Seller Dashboard or Point of Sale.
type CustomerGroup struct {
	// A unique Square-generated ID for the customer group.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the customer group.
	Name string `json:"name" url:"name"`
	// The timestamp when the customer group was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the customer group was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerGroup) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerGroup) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether customers should be included in, or excluded from,
// the result set when they match the filtering criteria.
type CustomerInclusionExclusion string

const (
	CustomerInclusionExclusionInclude CustomerInclusionExclusion = "INCLUDE"
	CustomerInclusionExclusionExclude CustomerInclusionExclusion = "EXCLUDE"
)

func NewCustomerInclusionExclusionFromString(s string) (CustomerInclusionExclusion, error) {
	switch s {
	case "INCLUDE":
		return CustomerInclusionExclusionInclude, nil
	case "EXCLUDE":
		return CustomerInclusionExclusionExclude, nil
	}
	var t CustomerInclusionExclusion
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomerInclusionExclusion) Ptr() *CustomerInclusionExclusion {
	return &c
}

// Represents communication preferences for the customer profile.
type CustomerPreferences struct {
	// Indicates whether the customer has unsubscribed from marketing campaign emails. A value of `true` means that the customer chose to opt out of email marketing from the current Square seller or from all Square sellers. This value is read-only from the Customers API.
	EmailUnsubscribed *bool `json:"email_unsubscribed,omitempty" url:"email_unsubscribed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerPreferences) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerPreferences(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerPreferences) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents filtering and sorting criteria for a [SearchCustomers]($e/Customers/SearchCustomers) request.
type CustomerQuery struct {
	// The filtering criteria for the search query. A query can contain multiple filters in any combination.
	// Multiple filters are combined as `AND` statements.
	//
	// **Note:** Combining multiple filters as `OR` statements is not supported. Instead, send multiple single-filter
	// searches and join the result sets.
	Filter *CustomerFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Sorting criteria for query results. The default behavior is to sort
	// customers alphabetically by `given_name` and `family_name`.
	Sort *CustomerSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerQuery) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerQuery) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a group of customer profiles that match one or more predefined filter criteria.
//
// Segments (also known as Smart Groups) are defined and created within the Customer Directory in the
// Square Seller Dashboard or Point of Sale.
type CustomerSegment struct {
	// A unique Square-generated ID for the segment.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the segment.
	Name string `json:"name" url:"name"`
	// The timestamp when the segment was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the segment was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerSegment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerSegment) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerSegment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerSegment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerSegment) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the sorting criteria in a [search query]($m/CustomerQuery) that defines how to sort
// customer profiles returned in [SearchCustomers]($e/Customers/SearchCustomers) results.
type CustomerSort struct {
	// Indicates the fields to use as the sort key, which is either the default set of fields or `created_at`.
	//
	// The default value is `DEFAULT`.
	// See [CustomerSortField](#type-customersortfield) for possible values
	Field *CustomerSortField `json:"field,omitempty" url:"field,omitempty"`
	// Indicates the order in which results should be sorted based on the
	// sort field value. Strings use standard alphabetic comparison
	// to determine order. Strings representing numbers are sorted as strings.
	//
	// The default value is `ASC`.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerSort) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerSort) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerSort) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Specifies customer attributes as the sort key to customer profiles returned from a search.
type CustomerSortField string

const (
	CustomerSortFieldDefault   CustomerSortField = "DEFAULT"
	CustomerSortFieldCreatedAt CustomerSortField = "CREATED_AT"
)

func NewCustomerSortFieldFromString(s string) (CustomerSortField, error) {
	switch s {
	case "DEFAULT":
		return CustomerSortFieldDefault, nil
	case "CREATED_AT":
		return CustomerSortFieldCreatedAt, nil
	}
	var t CustomerSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomerSortField) Ptr() *CustomerSortField {
	return &c
}

// Represents the tax ID associated with a [customer profile]($m/Customer). The corresponding `tax_ids` field is available only for customers of sellers in EU countries or the United Kingdom.
// For more information, see [Customer tax IDs](https://developer.squareup.com/docs/customers-api/what-it-does#customer-tax-ids).
type CustomerTaxIDs struct {
	// The EU VAT identification number for the customer. For example, `IE3426675K`. The ID can contain alphanumeric characters only.
	EuVat *string `json:"eu_vat,omitempty" url:"eu_vat,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerTaxIDs) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerTaxIDs) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerTaxIDs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerTaxIDs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerTaxIDs) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A filter to select customers based on exact or fuzzy matching of
// customer attributes against a specified query. Depending on the customer attributes,
// the filter can be case-sensitive. This filter can be exact or fuzzy, but it cannot be both.
type CustomerTextFilter struct {
	// Use the exact filter to select customers whose attributes match exactly the specified query.
	Exact *string `json:"exact,omitempty" url:"exact,omitempty"`
	// Use the fuzzy filter to select customers whose attributes match the specified query
	// in a fuzzy manner. When the fuzzy option is used, search queries are tokenized, and then
	// each query token must be matched somewhere in the searched attribute. For single token queries,
	// this is effectively the same behavior as a partial match operation.
	Fuzzy *string `json:"fuzzy,omitempty" url:"fuzzy,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerTextFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerTextFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerTextFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerTextFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerTextFilter) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DataCollectionOptions struct {
	// The title text to display in the data collection flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display under the title in the data collection screen flow on the
	// Terminal.
	Body string `json:"body" url:"body"`
	// Represents the type of the input text.
	// See [InputType](#type-inputtype) for possible values
	InputType DataCollectionOptionsInputType `json:"input_type" url:"input_type"`
	// The buyer’s input text from the data collection screen.
	CollectedData *CollectedData `json:"collected_data,omitempty" url:"collected_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DataCollectionOptions) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataCollectionOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler DataCollectionOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataCollectionOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataCollectionOptions) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Describes the input type of the data.
type DataCollectionOptionsInputType string

const (
	DataCollectionOptionsInputTypeEmail       DataCollectionOptionsInputType = "EMAIL"
	DataCollectionOptionsInputTypePhoneNumber DataCollectionOptionsInputType = "PHONE_NUMBER"
)

func NewDataCollectionOptionsInputTypeFromString(s string) (DataCollectionOptionsInputType, error) {
	switch s {
	case "EMAIL":
		return DataCollectionOptionsInputTypeEmail, nil
	case "PHONE_NUMBER":
		return DataCollectionOptionsInputTypePhoneNumber, nil
	}
	var t DataCollectionOptionsInputType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DataCollectionOptionsInputType) Ptr() *DataCollectionOptionsInputType {
	return &d
}

// A range defined by two dates. Used for filtering a query for Connect v2
// objects that have date properties.
type DateRange struct {
	// A string in `YYYY-MM-DD` format, such as `2017-10-31`, per the ISO 8601
	// extended format for calendar dates.
	// The beginning of a date range (inclusive).
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// A string in `YYYY-MM-DD` format, such as `2017-10-31`, per the ISO 8601
	// extended format for calendar dates.
	// The end of a date range (inclusive).
	EndDate *string `json:"end_date,omitempty" url:"end_date,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DateRange) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateRange) UnmarshalJSON(data []byte) error {
	type unmarshaler DateRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateRange) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Indicates the specific day of the week.
type DayOfWeek string

const (
	DayOfWeekSun DayOfWeek = "SUN"
	DayOfWeekMon DayOfWeek = "MON"
	DayOfWeekTue DayOfWeek = "TUE"
	DayOfWeekWed DayOfWeek = "WED"
	DayOfWeekThu DayOfWeek = "THU"
	DayOfWeekFri DayOfWeek = "FRI"
	DayOfWeekSat DayOfWeek = "SAT"
)

func NewDayOfWeekFromString(s string) (DayOfWeek, error) {
	switch s {
	case "SUN":
		return DayOfWeekSun, nil
	case "MON":
		return DayOfWeekMon, nil
	case "TUE":
		return DayOfWeekTue, nil
	case "WED":
		return DayOfWeekWed, nil
	case "THU":
		return DayOfWeekThu, nil
	case "FRI":
		return DayOfWeekFri, nil
	case "SAT":
		return DayOfWeekSat, nil
	}
	var t DayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfWeek) Ptr() *DayOfWeek {
	return &d
}

// Represents a [DeleteBookingCustomAttributeDefinition]($e/BookingCustomAttributes/DeleteBookingCustomAttributeDefinition) request.
type DeleteBookingCustomAttributeDefinitionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBookingCustomAttributeDefinitionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBookingCustomAttributeDefinitionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBookingCustomAttributeDefinitionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBookingCustomAttributeDefinitionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBookingCustomAttributeDefinitionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteBookingCustomAttributeDefinition]($e/BookingCustomAttributes/DeleteBookingCustomAttributeDefinition) response
// containing error messages when errors occurred during the request. The successful response does not contain any payload.
type DeleteBookingCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBookingCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBookingCustomAttributeDefinitionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteBookingCustomAttribute]($e/BookingCustomAttributes/DeleteBookingCustomAttribute) request.
type DeleteBookingCustomAttributeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBookingCustomAttributeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBookingCustomAttributeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBookingCustomAttributeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBookingCustomAttributeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBookingCustomAttributeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteBookingCustomAttribute]($e/BookingCustomAttributes/DeleteBookingCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteBookingCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBookingCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBookingCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBookingCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBookingCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBookingCustomAttributeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A request to delete a `BreakType`.
type DeleteBreakTypeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBreakTypeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBreakTypeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBreakTypeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBreakTypeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBreakTypeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The response to a request to delete a `BreakType`. The response might contain a set
// of `Error` objects if the request resulted in errors.
type DeleteBreakTypeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBreakTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBreakTypeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteCatalogObjectRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCatalogObjectRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCatalogObjectRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCatalogObjectRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCatalogObjectRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCatalogObjectRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The IDs of all catalog objects deleted by this request.
	// Multiple IDs may be returned when associated objects are also deleted, for example
	// a catalog item variation will be deleted (and its ID included in this field)
	// when its parent catalog item is deleted.
	DeletedObjectIDs []string `json:"deleted_object_ids,omitempty" url:"deleted_object_ids,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// of this deletion in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
	DeletedAt *string `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCatalogObjectResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in requests to the
// `DeleteCustomerCard` endpoint.
type DeleteCustomerCardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCardRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCardRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the `DeleteCustomerCard` endpoint.
type DeleteCustomerCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCardResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteCustomerCustomAttributeDefinition]($e/CustomerCustomAttributes/DeleteCustomerCustomAttributeDefinition) request.
type DeleteCustomerCustomAttributeDefinitionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCustomAttributeDefinitionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeDefinitionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeDefinitionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeDefinitionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeDefinitionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from a delete request containing error messages if there are any.
type DeleteCustomerCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeDefinitionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteCustomerCustomAttribute]($e/CustomerCustomAttributes/DeleteCustomerCustomAttribute) request.
type DeleteCustomerCustomAttributeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCustomAttributeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteCustomerCustomAttribute]($e/CustomerCustomAttributes/DeleteCustomerCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteCustomerCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that can be included in a request to the
// [DeleteCustomerGroup]($e/CustomerGroups/DeleteCustomerGroup) endpoint.
type DeleteCustomerGroupRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerGroupRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerGroupRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerGroupRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerGroupRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerGroupRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DeleteCustomerGroup]($e/CustomerGroups/DeleteCustomerGroup) endpoint.
type DeleteCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerGroupResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in a request to the `DeleteCustomer`
// endpoint.
type DeleteCustomerRequest struct {
	// The current version of the customer profile.
	//
	// As a best practice, you should include this parameter to enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency) control. For more information, see [Delete a customer profile](https://developer.squareup.com/docs/customers-api/use-the-api/keep-records#delete-customer-profile).
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the `DeleteCustomer` endpoint.
type DeleteCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the parameters for a `DeleteDisputeEvidence` request.
type DeleteDisputeEvidenceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteDisputeEvidenceRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteDisputeEvidenceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteDisputeEvidenceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteDisputeEvidenceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteDisputeEvidenceRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields in a `DeleteDisputeEvidence` response.
type DeleteDisputeEvidenceResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteDisputeEvidenceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteDisputeEvidenceResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteInvoiceAttachment]($e/Invoices/DeleteInvoiceAttachment) request.
type DeleteInvoiceAttachmentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteInvoiceAttachmentRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteInvoiceAttachmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInvoiceAttachmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInvoiceAttachmentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInvoiceAttachmentRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteInvoiceAttachment]($e/Invoices/DeleteInvoiceAttachment) response.
type DeleteInvoiceAttachmentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteInvoiceAttachmentResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteInvoiceAttachmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInvoiceAttachmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInvoiceAttachmentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInvoiceAttachmentResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Describes a `DeleteInvoice` request.
type DeleteInvoiceRequest struct {
	// The version of the [invoice](entity:Invoice) to delete.
	// If you do not know the version, you can call [GetInvoice](api-endpoint:Invoices-GetInvoice) or
	// [ListInvoices](api-endpoint:Invoices-ListInvoices).
	Version *int `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteInvoiceRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteInvoiceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInvoiceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInvoiceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInvoiceRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Describes a `DeleteInvoice` response.
type DeleteInvoiceResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteInvoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteInvoiceResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteLocationCustomAttributeDefinition]($e/LocationCustomAttributes/DeleteLocationCustomAttributeDefinition) request.
type DeleteLocationCustomAttributeDefinitionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLocationCustomAttributeDefinitionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLocationCustomAttributeDefinitionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLocationCustomAttributeDefinitionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLocationCustomAttributeDefinitionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLocationCustomAttributeDefinitionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from a delete request containing error messages if there are any.
type DeleteLocationCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLocationCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLocationCustomAttributeDefinitionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteLocationCustomAttribute]($e/LocationCustomAttributes/DeleteLocationCustomAttribute) request.
type DeleteLocationCustomAttributeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLocationCustomAttributeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLocationCustomAttributeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLocationCustomAttributeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLocationCustomAttributeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLocationCustomAttributeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteLocationCustomAttribute]($e/LocationCustomAttributes/DeleteLocationCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteLocationCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLocationCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLocationCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLocationCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLocationCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLocationCustomAttributeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A request to delete a loyalty reward.
type DeleteLoyaltyRewardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLoyaltyRewardRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLoyaltyRewardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLoyaltyRewardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLoyaltyRewardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLoyaltyRewardRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A response returned by the API call.
type DeleteLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLoyaltyRewardResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteMerchantCustomAttributeDefinition]($e/MerchantCustomAttributes/DeleteMerchantCustomAttributeDefinition) request.
type DeleteMerchantCustomAttributeDefinitionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteMerchantCustomAttributeDefinitionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteMerchantCustomAttributeDefinitionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteMerchantCustomAttributeDefinitionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteMerchantCustomAttributeDefinitionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteMerchantCustomAttributeDefinitionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from a delete request containing error messages if there are any.
type DeleteMerchantCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteMerchantCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteMerchantCustomAttributeDefinitionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteMerchantCustomAttribute]($e/MerchantCustomAttributes/DeleteMerchantCustomAttribute) request.
type DeleteMerchantCustomAttributeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteMerchantCustomAttributeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteMerchantCustomAttributeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteMerchantCustomAttributeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteMerchantCustomAttributeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteMerchantCustomAttributeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteMerchantCustomAttribute]($e/MerchantCustomAttributes/DeleteMerchantCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteMerchantCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteMerchantCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteMerchantCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteMerchantCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteMerchantCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteMerchantCustomAttributeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a delete request for an order custom attribute definition.
type DeleteOrderCustomAttributeDefinitionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteOrderCustomAttributeDefinitionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteOrderCustomAttributeDefinitionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteOrderCustomAttributeDefinitionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteOrderCustomAttributeDefinitionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteOrderCustomAttributeDefinitionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from deleting an order custom attribute definition.
type DeleteOrderCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteOrderCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteOrderCustomAttributeDefinitionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a delete request for an order custom attribute.
type DeleteOrderCustomAttributeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteOrderCustomAttributeRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteOrderCustomAttributeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteOrderCustomAttributeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteOrderCustomAttributeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteOrderCustomAttributeRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from deleting an order custom attribute.
type DeleteOrderCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteOrderCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteOrderCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteOrderCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteOrderCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteOrderCustomAttributeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeletePaymentLinkRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeletePaymentLinkRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletePaymentLinkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePaymentLinkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePaymentLinkRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePaymentLinkRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeletePaymentLinkResponse struct {
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The ID of the link that is deleted.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the order that is canceled. When a payment link is deleted, Square updates the
	// the `state` (of the order that the checkout link created) to CANCELED.
	CancelledOrderID *string `json:"cancelled_order_id,omitempty" url:"cancelled_order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeletePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePaymentLinkResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A request to delete a `Shift`.
type DeleteShiftRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteShiftRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteShiftRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteShiftRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteShiftRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteShiftRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The response to a request to delete a `Shift`. The response might contain a set of
// `Error` objects if the request resulted in errors.
type DeleteShiftResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteShiftResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteShiftResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a `DeleteSnippet` request.
type DeleteSnippetRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteSnippetRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSnippetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSnippetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSnippetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSnippetRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a `DeleteSnippet` response.
type DeleteSnippetResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteSnippetResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSnippetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSnippetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSnippetResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSnippetResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines input parameters in a call to the
// [DeleteSubscriptionAction]($e/Subscriptions/DeleteSubscriptionAction)
// endpoint.
type DeleteSubscriptionActionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteSubscriptionActionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSubscriptionActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSubscriptionActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSubscriptionActionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSubscriptionActionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines output parameters in a response of the [DeleteSubscriptionAction]($e/Subscriptions/DeleteSubscriptionAction)
// endpoint.
type DeleteSubscriptionActionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription that has the specified action deleted.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteSubscriptionActionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteSubscriptionActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteSubscriptionActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteSubscriptionActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteSubscriptionActionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Deletes a [Subscription]($m/WebhookSubscription).
type DeleteWebhookSubscriptionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteWebhookSubscriptionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteWebhookSubscriptionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteWebhookSubscriptionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteWebhookSubscriptionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteWebhookSubscriptionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DeleteWebhookSubscription]($e/WebhookSubscriptions/DeleteWebhookSubscription) endpoint.
type DeleteWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteWebhookSubscriptionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the parameters for a `DeprecatedCreateDisputeEvidenceFile` request.
type DeprecatedCreateDisputeEvidenceFileRequest struct {
	// The Unique ID. For more information, see [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency).
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The type of evidence you are uploading.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`
	// The MIME type of the uploaded file.
	// The type can be image/heic, image/heif, image/jpeg, application/pdf, image/png, or image/tiff.
	ContentType *string `json:"content_type,omitempty" url:"content_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceFileRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceFileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceFileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceFileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceFileRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields in a `DeprecatedCreateDisputeEvidenceFile` response.
type DeprecatedCreateDisputeEvidenceFileResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The metadata of the newly uploaded dispute evidence.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceFileResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceFileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceFileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceFileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceFileResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the parameters for a `DeprecatedCreateDisputeEvidenceText` request.
type DeprecatedCreateDisputeEvidenceTextRequest struct {
	// The Unique ID. For more information, see [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency).
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// The type of evidence you are uploading.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`
	// The evidence string.
	EvidenceText string `json:"evidence_text" url:"evidence_text"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceTextRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceTextRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceTextRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceTextRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceTextRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields in a `DeprecatedCreateDisputeEvidenceText` response.
type DeprecatedCreateDisputeEvidenceTextResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly uploaded dispute evidence metadata.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeprecatedCreateDisputeEvidenceTextResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeprecatedCreateDisputeEvidenceTextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeprecatedCreateDisputeEvidenceTextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeprecatedCreateDisputeEvidenceTextResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeprecatedCreateDisputeEvidenceTextResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Information about the destination against which the payout was made.
type Destination struct {
	// Type of the destination such as a bank account or debit card.
	// See [DestinationType](#type-destinationtype) for possible values
	Type *DestinationType `json:"type,omitempty" url:"type,omitempty"`
	// Square issued unique ID (also known as the instrument ID) associated with this destination.
	ID *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Destination) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Destination) UnmarshalJSON(data []byte) error {
	type unmarshaler Destination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Destination(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Destination) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Details about a refund's destination.
type DestinationDetails struct {
	// Details about a card refund. Only populated if the destination_type is `CARD`.
	CardDetails *DestinationDetailsCardRefundDetails `json:"card_details,omitempty" url:"card_details,omitempty"`
	// Details about a cash refund. Only populated if the destination_type is `CASH`.
	CashDetails *DestinationDetailsCashRefundDetails `json:"cash_details,omitempty" url:"cash_details,omitempty"`
	// Details about an external refund. Only populated if the destination_type is `EXTERNAL`.
	ExternalDetails *DestinationDetailsExternalRefundDetails `json:"external_details,omitempty" url:"external_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DestinationDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DestinationDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DestinationDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DestinationDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DestinationDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DestinationDetailsCardRefundDetails struct {
	// The card's non-confidential details.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`
	// The method used to enter the card's details for the refund. The method can be
	// `KEYED`, `SWIPED`, `EMV`, `ON_FILE`, or `CONTACTLESS`.
	EntryMethod *string `json:"entry_method,omitempty" url:"entry_method,omitempty"`
	// The authorization code provided by the issuer when a refund is approved.
	AuthResultCode *string `json:"auth_result_code,omitempty" url:"auth_result_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DestinationDetailsCardRefundDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DestinationDetailsCardRefundDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DestinationDetailsCardRefundDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DestinationDetailsCardRefundDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DestinationDetailsCardRefundDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Stores details about a cash refund. Contains only non-confidential information.
type DestinationDetailsCashRefundDetails struct {
	// The amount and currency of the money supplied by the seller.
	SellerSuppliedMoney *Money `json:"seller_supplied_money,omitempty" url:"seller_supplied_money,omitempty"`
	// The amount of change due back to the seller.
	// This read-only field is calculated
	// from the `amount_money` and `seller_supplied_money` fields.
	ChangeBackMoney *Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DestinationDetailsCashRefundDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DestinationDetailsCashRefundDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DestinationDetailsCashRefundDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DestinationDetailsCashRefundDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DestinationDetailsCashRefundDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Stores details about an external refund. Contains only non-confidential information.
type DestinationDetailsExternalRefundDetails struct {
	// The type of external refund the seller paid to the buyer. It can be one of the
	// following:
	//
	// - CHECK - Refunded using a physical check.
	// - BANK_TRANSFER - Refunded using external bank transfer.
	// - OTHER_GIFT_CARD - Refunded using a non-Square gift card.
	// - CRYPTO - Refunded using a crypto currency.
	// - SQUARE_CASH - Refunded using Square Cash App.
	// - SOCIAL - Refunded using peer-to-peer payment applications.
	// - EXTERNAL - A third-party application gathered this refund outside of Square.
	// - EMONEY - Refunded using an E-money provider.
	// - CARD - A credit or debit card that Square does not support.
	// - STORED_BALANCE - Use for house accounts, store credit, and so forth.
	// - FOOD_VOUCHER - Restaurant voucher provided by employers to employees to pay for meals
	// - OTHER - A type not listed here.
	Type string `json:"type" url:"type"`
	// A description of the external refund source. For example,
	// "Food Delivery Service".
	Source string `json:"source" url:"source"`
	// An ID to associate the refund to its originating source.
	SourceID *string `json:"source_id,omitempty" url:"source_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DestinationDetailsExternalRefundDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DestinationDetailsExternalRefundDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DestinationDetailsExternalRefundDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DestinationDetailsExternalRefundDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DestinationDetailsExternalRefundDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// List of possible destinations against which a payout can be made.
type DestinationType string

const (
	DestinationTypeBankAccount         DestinationType = "BANK_ACCOUNT"
	DestinationTypeCard                DestinationType = "CARD"
	DestinationTypeSquareBalance       DestinationType = "SQUARE_BALANCE"
	DestinationTypeSquareStoredBalance DestinationType = "SQUARE_STORED_BALANCE"
)

func NewDestinationTypeFromString(s string) (DestinationType, error) {
	switch s {
	case "BANK_ACCOUNT":
		return DestinationTypeBankAccount, nil
	case "CARD":
		return DestinationTypeCard, nil
	case "SQUARE_BALANCE":
		return DestinationTypeSquareBalance, nil
	case "SQUARE_STORED_BALANCE":
		return DestinationTypeSquareStoredBalance, nil
	}
	var t DestinationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationType) Ptr() *DestinationType {
	return &d
}

type Device struct {
	// A synthetic identifier for the device. The identifier includes a standardized prefix and
	// is otherwise an opaque id generated from key device fields.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// A collection of DeviceAttributes representing the device.
	Attributes *DeviceAttributes `json:"attributes,omitempty" url:"attributes,omitempty"`
	// A list of components applicable to the device.
	Components []*Component `json:"components,omitempty" url:"components,omitempty"`
	// The current status of the device.
	Status *DeviceStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Device) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Device) UnmarshalJSON(data []byte) error {
	type unmarshaler Device
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Device(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Device) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceAttributes struct {
	// The device type.
	// See [DeviceType](#type-devicetype) for possible values
	Type DeviceAttributesDeviceType `json:"type,omitempty" url:"type,omitempty"`
	// The maker of the device.
	Manufacturer string `json:"manufacturer" url:"manufacturer"`
	// The specific model of the device.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// A seller-specified name for the device.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The manufacturer-supplied identifier for the device (where available). In many cases,
	// this identifier will be a serial number.
	ManufacturersID *string `json:"manufacturers_id,omitempty" url:"manufacturers_id,omitempty"`
	// The RFC 3339-formatted value of the most recent update to the device information.
	// (Could represent any field update on the device.)
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The current version of software installed on the device.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The merchant_token identifying the merchant controlling the device.
	MerchantToken *string `json:"merchant_token,omitempty" url:"merchant_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceAttributes) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceAttributes) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceAttributes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceAttributes(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceAttributes) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// An enum identifier of the device type.
type DeviceAttributesDeviceType = string

type DeviceCheckoutOptions struct {
	// The unique ID of the device intended for this `TerminalCheckout`.
	// A list of `DeviceCode` objects can be retrieved from the /v2/devices/codes endpoint.
	// Match a `DeviceCode.device_id` value with `device_id` to get the associated device code.
	DeviceID string `json:"device_id" url:"device_id"`
	// Instructs the device to skip the receipt screen. Defaults to false.
	SkipReceiptScreen *bool `json:"skip_receipt_screen,omitempty" url:"skip_receipt_screen,omitempty"`
	// Indicates that signature collection is desired during checkout. Defaults to false.
	CollectSignature *bool `json:"collect_signature,omitempty" url:"collect_signature,omitempty"`
	// Tip-specific settings.
	TipSettings *TipSettings `json:"tip_settings,omitempty" url:"tip_settings,omitempty"`
	// Show the itemization screen prior to taking a payment. This field is only meaningful when the
	// checkout includes an order ID. Defaults to true.
	ShowItemizedCart *bool `json:"show_itemized_cart,omitempty" url:"show_itemized_cart,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceCheckoutOptions) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCheckoutOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCheckoutOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCheckoutOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCheckoutOptions) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCode struct {
	// The unique id for this device code.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional user-defined name for the device code.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique code that can be used to login.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// The unique id of the device that used this code. Populated when the device is paired up.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The targeting product type of the device code.
	ProductType ProductType `json:"product_type,omitempty" url:"product_type,omitempty"`
	// The location assigned to this code.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The pairing status of the device code.
	// See [DeviceCodeStatus](#type-devicecodestatus) for possible values
	Status *DeviceCodeStatus `json:"status,omitempty" url:"status,omitempty"`
	// When this DeviceCode will expire and no longer login. Timestamp in RFC 3339 format.
	PairBy *string `json:"pair_by,omitempty" url:"pair_by,omitempty"`
	// When this DeviceCode was created. Timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// When this DeviceCode's status was last changed. Timestamp in RFC 3339 format.
	StatusChangedAt *string `json:"status_changed_at,omitempty" url:"status_changed_at,omitempty"`
	// When this DeviceCode was paired. Timestamp in RFC 3339 format.
	PairedAt *string `json:"paired_at,omitempty" url:"paired_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceCode) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCode) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCode(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCode) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DeviceCode.Status enum.
type DeviceCodeStatus string

const (
	DeviceCodeStatusUnknown  DeviceCodeStatus = "UNKNOWN"
	DeviceCodeStatusUnpaired DeviceCodeStatus = "UNPAIRED"
	DeviceCodeStatusPaired   DeviceCodeStatus = "PAIRED"
	DeviceCodeStatusExpired  DeviceCodeStatus = "EXPIRED"
)

func NewDeviceCodeStatusFromString(s string) (DeviceCodeStatus, error) {
	switch s {
	case "UNKNOWN":
		return DeviceCodeStatusUnknown, nil
	case "UNPAIRED":
		return DeviceCodeStatusUnpaired, nil
	case "PAIRED":
		return DeviceCodeStatusPaired, nil
	case "EXPIRED":
		return DeviceCodeStatusExpired, nil
	}
	var t DeviceCodeStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceCodeStatus) Ptr() *DeviceCodeStatus {
	return &d
}

type DeviceComponentDetails struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceComponentDetailsApplicationDetails struct {
	// The type of application.
	// See [ApplicationType](#type-applicationtype) for possible values
	ApplicationType *ApplicationType `json:"application_type,omitempty" url:"application_type,omitempty"`
	// The version of the application.
	Version *string `json:"version,omitempty" url:"version,omitempty"`
	// The location_id of the session for the application.
	SessionLocation *string `json:"session_location,omitempty" url:"session_location,omitempty"`
	// The id of the device code that was used to log in to the device.
	DeviceCodeID *string `json:"device_code_id,omitempty" url:"device_code_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetailsApplicationDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetailsApplicationDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetailsApplicationDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetailsApplicationDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetailsApplicationDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceComponentDetailsBatteryDetails struct {
	// The battery charge percentage as displayed on the device.
	VisiblePercent *int `json:"visible_percent,omitempty" url:"visible_percent,omitempty"`
	// The status of external_power.
	// See [ExternalPower](#type-externalpower) for possible values
	ExternalPower *DeviceComponentDetailsExternalPower `json:"external_power,omitempty" url:"external_power,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetailsBatteryDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetailsBatteryDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetailsBatteryDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetailsBatteryDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetailsBatteryDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceComponentDetailsCardReaderDetails struct {
	// The version of the card reader.
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetailsCardReaderDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetailsCardReaderDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetailsCardReaderDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetailsCardReaderDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetailsCardReaderDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceComponentDetailsEthernetDetails struct {
	// A boolean to represent whether the Ethernet interface is currently active.
	Active *bool `json:"active,omitempty" url:"active,omitempty"`
	// The string representation of the device’s IPv4 address.
	IPAddressV4 *string `json:"ip_address_v4,omitempty" url:"ip_address_v4,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetailsEthernetDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetailsEthernetDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetailsEthernetDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetailsEthernetDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetailsEthernetDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// An enum for ExternalPower.
type DeviceComponentDetailsExternalPower string

const (
	DeviceComponentDetailsExternalPowerAvailableCharging     DeviceComponentDetailsExternalPower = "AVAILABLE_CHARGING"
	DeviceComponentDetailsExternalPowerAvailableNotInUse     DeviceComponentDetailsExternalPower = "AVAILABLE_NOT_IN_USE"
	DeviceComponentDetailsExternalPowerUnavailable           DeviceComponentDetailsExternalPower = "UNAVAILABLE"
	DeviceComponentDetailsExternalPowerAvailableInsufficient DeviceComponentDetailsExternalPower = "AVAILABLE_INSUFFICIENT"
)

func NewDeviceComponentDetailsExternalPowerFromString(s string) (DeviceComponentDetailsExternalPower, error) {
	switch s {
	case "AVAILABLE_CHARGING":
		return DeviceComponentDetailsExternalPowerAvailableCharging, nil
	case "AVAILABLE_NOT_IN_USE":
		return DeviceComponentDetailsExternalPowerAvailableNotInUse, nil
	case "UNAVAILABLE":
		return DeviceComponentDetailsExternalPowerUnavailable, nil
	case "AVAILABLE_INSUFFICIENT":
		return DeviceComponentDetailsExternalPowerAvailableInsufficient, nil
	}
	var t DeviceComponentDetailsExternalPower
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceComponentDetailsExternalPower) Ptr() *DeviceComponentDetailsExternalPower {
	return &d
}

// A value qualified by unit of measure.
type DeviceComponentDetailsMeasurement struct {
	Value *int `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetailsMeasurement) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetailsMeasurement) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetailsMeasurement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetailsMeasurement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetailsMeasurement) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceComponentDetailsNetworkInterfaceDetails struct {
	// The string representation of the device’s IPv4 address.
	IPAddressV4 *string `json:"ip_address_v4,omitempty" url:"ip_address_v4,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetailsNetworkInterfaceDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetailsNetworkInterfaceDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetailsNetworkInterfaceDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetailsNetworkInterfaceDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetailsNetworkInterfaceDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceComponentDetailsWiFiDetails struct {
	// A boolean to represent whether the WiFI interface is currently active.
	Active *bool `json:"active,omitempty" url:"active,omitempty"`
	// The name of the connected WIFI network.
	Ssid *string `json:"ssid,omitempty" url:"ssid,omitempty"`
	// The string representation of the device’s IPv4 address.
	IPAddressV4 *string `json:"ip_address_v4,omitempty" url:"ip_address_v4,omitempty"`
	// The security protocol for a secure connection (e.g. WPA2). None provided if the connection
	// is unsecured.
	SecureConnection *string `json:"secure_connection,omitempty" url:"secure_connection,omitempty"`
	// A representation of signal strength of the WIFI network connection.
	SignalStrength *DeviceComponentDetailsMeasurement `json:"signal_strength,omitempty" url:"signal_strength,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceComponentDetailsWiFiDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceComponentDetailsWiFiDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceComponentDetailsWiFiDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceComponentDetailsWiFiDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceComponentDetailsWiFiDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Details about the device that took the payment.
type DeviceDetails struct {
	// The Square-issued ID of the device.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The Square-issued installation ID for the device.
	DeviceInstallationID *string `json:"device_installation_id,omitempty" url:"device_installation_id,omitempty"`
	// The name of the device set by the seller.
	DeviceName *string `json:"device_name,omitempty" url:"device_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceMetadata struct {
	// The Terminal’s remaining battery percentage, between 1-100.
	BatteryPercentage *string `json:"battery_percentage,omitempty" url:"battery_percentage,omitempty"`
	// The current charging state of the Terminal.
	// Options: `CHARGING`, `NOT_CHARGING`
	ChargingState *string `json:"charging_state,omitempty" url:"charging_state,omitempty"`
	// The ID of the Square seller business location associated with the Terminal.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the Square merchant account that is currently signed-in to the Terminal.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The Terminal’s current network connection type.
	// Options: `WIFI`, `ETHERNET`
	NetworkConnectionType *string `json:"network_connection_type,omitempty" url:"network_connection_type,omitempty"`
	// The country in which the Terminal is authorized to take payments.
	PaymentRegion *string `json:"payment_region,omitempty" url:"payment_region,omitempty"`
	// The unique identifier assigned to the Terminal, which can be found on the lower back
	// of the device.
	SerialNumber *string `json:"serial_number,omitempty" url:"serial_number,omitempty"`
	// The current version of the Terminal’s operating system.
	OsVersion *string `json:"os_version,omitempty" url:"os_version,omitempty"`
	// The current version of the application running on the Terminal.
	AppVersion *string `json:"app_version,omitempty" url:"app_version,omitempty"`
	// The name of the Wi-Fi network to which the Terminal is connected.
	WifiNetworkName *string `json:"wifi_network_name,omitempty" url:"wifi_network_name,omitempty"`
	// The signal strength of the Wi-FI network connection.
	// Options: `POOR`, `FAIR`, `GOOD`, `EXCELLENT`
	WifiNetworkStrength *string `json:"wifi_network_strength,omitempty" url:"wifi_network_strength,omitempty"`
	// The IP address of the Terminal.
	IPAddress *string `json:"ip_address,omitempty" url:"ip_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceMetadata) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceMetadata) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceStatus struct {
	// See [Category](#type-category) for possible values
	Category *DeviceStatusCategory `json:"category,omitempty" url:"category,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceStatus) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceStatus) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceStatus
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceStatus(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceStatus) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceStatusCategory string

const (
	DeviceStatusCategoryAvailable      DeviceStatusCategory = "AVAILABLE"
	DeviceStatusCategoryNeedsAttention DeviceStatusCategory = "NEEDS_ATTENTION"
	DeviceStatusCategoryOffline        DeviceStatusCategory = "OFFLINE"
)

func NewDeviceStatusCategoryFromString(s string) (DeviceStatusCategory, error) {
	switch s {
	case "AVAILABLE":
		return DeviceStatusCategoryAvailable, nil
	case "NEEDS_ATTENTION":
		return DeviceStatusCategoryNeedsAttention, nil
	case "OFFLINE":
		return DeviceStatusCategoryOffline, nil
	}
	var t DeviceStatusCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceStatusCategory) Ptr() *DeviceStatusCategory {
	return &d
}

// Additional details about `WALLET` type payments. Contains only non-confidential information.
type DigitalWalletDetails struct {
	// The status of the `WALLET` payment. The status can be `AUTHORIZED`, `CAPTURED`, `VOIDED`, or
	// `FAILED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The brand used for the `WALLET` payment. The brand can be `CASH_APP`, `PAYPAY`, `ALIPAY`,
	// `RAKUTEN_PAY`, `AU_PAY`, `D_BARAI`, `MERPAY`, `WECHAT_PAY` or `UNKNOWN`.
	Brand *string `json:"brand,omitempty" url:"brand,omitempty"`
	// Brand-specific details for payments with the `brand` of `CASH_APP`.
	CashAppDetails *CashAppDetails `json:"cash_app_details,omitempty" url:"cash_app_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DigitalWalletDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DigitalWalletDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DigitalWalletDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DigitalWalletDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DigitalWalletDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Disables the card, preventing any further updates or charges. Disabling
// an already disabled card is allowed but has no effect. Accessible via
// HTTP requests at POST https://connect.squareup.com/v2/cards/{card_id}/disable
type DisableCardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisableCardRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisableCardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DisableCardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisableCardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisableCardRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DisableCard]($e/Cards/DisableCard) endpoint.
//
// Note: if there are errors processing the request, the card field will not be
// present.
type DisableCardResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisableCardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisableCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DisableCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisableCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisableCardResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Disables [Event]($m/Event)s for your application.
type DisableEventsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisableEventsRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisableEventsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DisableEventsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisableEventsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisableEventsRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DisableEvents]($e/Events/DisableEvents) endpoint.
//
// Note: if there are errors processing the request, the events field will not be
// present.
type DisableEventsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisableEventsResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisableEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DisableEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisableEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisableEventsResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DismissTerminalActionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DismissTerminalActionRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DismissTerminalActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DismissTerminalActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DismissTerminalActionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DismissTerminalActionRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DismissTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Current state of the action to be dismissed.
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DismissTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DismissTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DismissTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DismissTerminalActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DismissTerminalActionResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DismissTerminalCheckoutRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DismissTerminalCheckoutRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DismissTerminalCheckoutRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DismissTerminalCheckoutRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DismissTerminalCheckoutRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DismissTerminalCheckoutRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DismissTerminalCheckoutResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Current state of the checkout to be dismissed.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DismissTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DismissTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DismissTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DismissTerminalCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DismissTerminalCheckoutResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DismissTerminalRefundRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DismissTerminalRefundRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DismissTerminalRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DismissTerminalRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DismissTerminalRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DismissTerminalRefundRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DismissTerminalRefundResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Current state of the refund to be dismissed.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DismissTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DismissTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DismissTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DismissTerminalRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DismissTerminalRefundResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [dispute](https://developer.squareup.com/docs/disputes-api/overview) a cardholder initiated with their bank.
type Dispute struct {
	// The unique ID for this `Dispute`, generated by Square.
	DisputeID *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`
	// The unique ID for this `Dispute`, generated by Square.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The disputed amount, which can be less than the total transaction amount.
	// For instance, if multiple items were purchased but the cardholder only initiates a dispute over some of the items.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The reason why the cardholder initiated the dispute.
	// See [DisputeReason](#type-disputereason) for possible values
	Reason *DisputeReason `json:"reason,omitempty" url:"reason,omitempty"`
	// The current state of this dispute.
	// See [DisputeState](#type-disputestate) for possible values
	State *DisputeState `json:"state,omitempty" url:"state,omitempty"`
	// The deadline by which the seller must respond to the dispute, in [RFC 3339 format](https://developer.squareup.com/docs/build-basics/common-data-types/working-with-dates).
	DueAt *string `json:"due_at,omitempty" url:"due_at,omitempty"`
	// The payment challenged in this dispute.
	DisputedPayment *DisputedPayment `json:"disputed_payment,omitempty" url:"disputed_payment,omitempty"`
	// The IDs of the evidence associated with the dispute.
	EvidenceIDs []string `json:"evidence_ids,omitempty" url:"evidence_ids,omitempty"`
	// The card brand used in the disputed payment.
	// See [CardBrand](#type-cardbrand) for possible values
	CardBrand *CardBrand `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The timestamp when the dispute was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the dispute was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the dispute in the card brand system, generated by the card brand.
	BrandDisputeID *string `json:"brand_dispute_id,omitempty" url:"brand_dispute_id,omitempty"`
	// The timestamp when the dispute was reported, in RFC 3339 format.
	ReportedDate *string `json:"reported_date,omitempty" url:"reported_date,omitempty"`
	// The timestamp when the dispute was reported, in RFC 3339 format.
	ReportedAt *string `json:"reported_at,omitempty" url:"reported_at,omitempty"`
	// The current version of the `Dispute`.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the location where the dispute originated.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Dispute) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Dispute) UnmarshalJSON(data []byte) error {
	type unmarshaler Dispute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Dispute(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dispute) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidence struct {
	// The Square-generated ID of the evidence.
	EvidenceID *string `json:"evidence_id,omitempty" url:"evidence_id,omitempty"`
	// The Square-generated ID of the evidence.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the dispute the evidence is associated with.
	DisputeID *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`
	// Image, PDF, TXT
	EvidenceFile *DisputeEvidenceFile `json:"evidence_file,omitempty" url:"evidence_file,omitempty"`
	// Raw text
	EvidenceText *string `json:"evidence_text,omitempty" url:"evidence_text,omitempty"`
	// The time when the evidence was uploaded, in RFC 3339 format.
	UploadedAt *string `json:"uploaded_at,omitempty" url:"uploaded_at,omitempty"`
	// The type of the evidence.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidence) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidence) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidence(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidence) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A file to be uploaded as dispute evidence.
type DisputeEvidenceFile struct {
	// The file name including the file extension. For example: "receipt.tiff".
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	// Dispute evidence files must be application/pdf, image/heic, image/heif, image/jpeg, image/png, or image/tiff formats.
	Filetype *string `json:"filetype,omitempty" url:"filetype,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputeEvidenceFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceFile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceFile) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of the dispute evidence.
type DisputeEvidenceType string

const (
	DisputeEvidenceTypeGenericEvidence                   DisputeEvidenceType = "GENERIC_EVIDENCE"
	DisputeEvidenceTypeOnlineOrAppAccessLog              DisputeEvidenceType = "ONLINE_OR_APP_ACCESS_LOG"
	DisputeEvidenceTypeAuthorizationDocumentation        DisputeEvidenceType = "AUTHORIZATION_DOCUMENTATION"
	DisputeEvidenceTypeCancellationOrRefundDocumentation DisputeEvidenceType = "CANCELLATION_OR_REFUND_DOCUMENTATION"
	DisputeEvidenceTypeCardholderCommunication           DisputeEvidenceType = "CARDHOLDER_COMMUNICATION"
	DisputeEvidenceTypeCardholderInformation             DisputeEvidenceType = "CARDHOLDER_INFORMATION"
	DisputeEvidenceTypePurchaseAcknowledgement           DisputeEvidenceType = "PURCHASE_ACKNOWLEDGEMENT"
	DisputeEvidenceTypeDuplicateChargeDocumentation      DisputeEvidenceType = "DUPLICATE_CHARGE_DOCUMENTATION"
	DisputeEvidenceTypeProductOrServiceDescription       DisputeEvidenceType = "PRODUCT_OR_SERVICE_DESCRIPTION"
	DisputeEvidenceTypeReceipt                           DisputeEvidenceType = "RECEIPT"
	DisputeEvidenceTypeServiceReceivedDocumentation      DisputeEvidenceType = "SERVICE_RECEIVED_DOCUMENTATION"
	DisputeEvidenceTypeProofOfDeliveryDocumentation      DisputeEvidenceType = "PROOF_OF_DELIVERY_DOCUMENTATION"
	DisputeEvidenceTypeRelatedTransactionDocumentation   DisputeEvidenceType = "RELATED_TRANSACTION_DOCUMENTATION"
	DisputeEvidenceTypeRebuttalExplanation               DisputeEvidenceType = "REBUTTAL_EXPLANATION"
	DisputeEvidenceTypeTrackingNumber                    DisputeEvidenceType = "TRACKING_NUMBER"
)

func NewDisputeEvidenceTypeFromString(s string) (DisputeEvidenceType, error) {
	switch s {
	case "GENERIC_EVIDENCE":
		return DisputeEvidenceTypeGenericEvidence, nil
	case "ONLINE_OR_APP_ACCESS_LOG":
		return DisputeEvidenceTypeOnlineOrAppAccessLog, nil
	case "AUTHORIZATION_DOCUMENTATION":
		return DisputeEvidenceTypeAuthorizationDocumentation, nil
	case "CANCELLATION_OR_REFUND_DOCUMENTATION":
		return DisputeEvidenceTypeCancellationOrRefundDocumentation, nil
	case "CARDHOLDER_COMMUNICATION":
		return DisputeEvidenceTypeCardholderCommunication, nil
	case "CARDHOLDER_INFORMATION":
		return DisputeEvidenceTypeCardholderInformation, nil
	case "PURCHASE_ACKNOWLEDGEMENT":
		return DisputeEvidenceTypePurchaseAcknowledgement, nil
	case "DUPLICATE_CHARGE_DOCUMENTATION":
		return DisputeEvidenceTypeDuplicateChargeDocumentation, nil
	case "PRODUCT_OR_SERVICE_DESCRIPTION":
		return DisputeEvidenceTypeProductOrServiceDescription, nil
	case "RECEIPT":
		return DisputeEvidenceTypeReceipt, nil
	case "SERVICE_RECEIVED_DOCUMENTATION":
		return DisputeEvidenceTypeServiceReceivedDocumentation, nil
	case "PROOF_OF_DELIVERY_DOCUMENTATION":
		return DisputeEvidenceTypeProofOfDeliveryDocumentation, nil
	case "RELATED_TRANSACTION_DOCUMENTATION":
		return DisputeEvidenceTypeRelatedTransactionDocumentation, nil
	case "REBUTTAL_EXPLANATION":
		return DisputeEvidenceTypeRebuttalExplanation, nil
	case "TRACKING_NUMBER":
		return DisputeEvidenceTypeTrackingNumber, nil
	}
	var t DisputeEvidenceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DisputeEvidenceType) Ptr() *DisputeEvidenceType {
	return &d
}

// The list of possible reasons why a cardholder might initiate a
// dispute with their bank.
type DisputeReason string

const (
	DisputeReasonAmountDiffers          DisputeReason = "AMOUNT_DIFFERS"
	DisputeReasonCancelled              DisputeReason = "CANCELLED"
	DisputeReasonDuplicate              DisputeReason = "DUPLICATE"
	DisputeReasonNoKnowledge            DisputeReason = "NO_KNOWLEDGE"
	DisputeReasonNotAsDescribed         DisputeReason = "NOT_AS_DESCRIBED"
	DisputeReasonNotReceived            DisputeReason = "NOT_RECEIVED"
	DisputeReasonPaidByOtherMeans       DisputeReason = "PAID_BY_OTHER_MEANS"
	DisputeReasonCustomerRequestsCredit DisputeReason = "CUSTOMER_REQUESTS_CREDIT"
	DisputeReasonEmvLiabilityShift      DisputeReason = "EMV_LIABILITY_SHIFT"
)

func NewDisputeReasonFromString(s string) (DisputeReason, error) {
	switch s {
	case "AMOUNT_DIFFERS":
		return DisputeReasonAmountDiffers, nil
	case "CANCELLED":
		return DisputeReasonCancelled, nil
	case "DUPLICATE":
		return DisputeReasonDuplicate, nil
	case "NO_KNOWLEDGE":
		return DisputeReasonNoKnowledge, nil
	case "NOT_AS_DESCRIBED":
		return DisputeReasonNotAsDescribed, nil
	case "NOT_RECEIVED":
		return DisputeReasonNotReceived, nil
	case "PAID_BY_OTHER_MEANS":
		return DisputeReasonPaidByOtherMeans, nil
	case "CUSTOMER_REQUESTS_CREDIT":
		return DisputeReasonCustomerRequestsCredit, nil
	case "EMV_LIABILITY_SHIFT":
		return DisputeReasonEmvLiabilityShift, nil
	}
	var t DisputeReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DisputeReason) Ptr() *DisputeReason {
	return &d
}

// The list of possible dispute states.
type DisputeState string

const (
	DisputeStateInquiryEvidenceRequired DisputeState = "INQUIRY_EVIDENCE_REQUIRED"
	DisputeStateInquiryProcessing       DisputeState = "INQUIRY_PROCESSING"
	DisputeStateInquiryClosed           DisputeState = "INQUIRY_CLOSED"
	DisputeStateEvidenceRequired        DisputeState = "EVIDENCE_REQUIRED"
	DisputeStateProcessing              DisputeState = "PROCESSING"
	DisputeStateWon                     DisputeState = "WON"
	DisputeStateLost                    DisputeState = "LOST"
	DisputeStateAccepted                DisputeState = "ACCEPTED"
)

func NewDisputeStateFromString(s string) (DisputeState, error) {
	switch s {
	case "INQUIRY_EVIDENCE_REQUIRED":
		return DisputeStateInquiryEvidenceRequired, nil
	case "INQUIRY_PROCESSING":
		return DisputeStateInquiryProcessing, nil
	case "INQUIRY_CLOSED":
		return DisputeStateInquiryClosed, nil
	case "EVIDENCE_REQUIRED":
		return DisputeStateEvidenceRequired, nil
	case "PROCESSING":
		return DisputeStateProcessing, nil
	case "WON":
		return DisputeStateWon, nil
	case "LOST":
		return DisputeStateLost, nil
	case "ACCEPTED":
		return DisputeStateAccepted, nil
	}
	var t DisputeState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DisputeState) Ptr() *DisputeState {
	return &d
}

// The payment the cardholder disputed.
type DisputedPayment struct {
	// Square-generated unique ID of the payment being disputed.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DisputedPayment) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputedPayment) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputedPayment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputedPayment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputedPayment) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Determines item visibility in Ecom (Online Store) and Online Checkout.
type EcomVisibility string

const (
	EcomVisibilityUnindexed   EcomVisibility = "UNINDEXED"
	EcomVisibilityUnavailable EcomVisibility = "UNAVAILABLE"
	EcomVisibilityHidden      EcomVisibility = "HIDDEN"
	EcomVisibilityVisible     EcomVisibility = "VISIBLE"
)

func NewEcomVisibilityFromString(s string) (EcomVisibility, error) {
	switch s {
	case "UNINDEXED":
		return EcomVisibilityUnindexed, nil
	case "UNAVAILABLE":
		return EcomVisibilityUnavailable, nil
	case "HIDDEN":
		return EcomVisibilityHidden, nil
	case "VISIBLE":
		return EcomVisibilityVisible, nil
	}
	var t EcomVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EcomVisibility) Ptr() *EcomVisibility {
	return &e
}

// An employee object that is used by the external API.
//
// DEPRECATED at version 2020-08-26. Replaced by [TeamMember](entity:TeamMember).
type Employee struct {
	// UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The employee's first name.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// The employee's last name.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`
	// The employee's email address
	Email *string `json:"email,omitempty" url:"email,omitempty"`
	// The employee's phone number in E.164 format, i.e. "+12125554250"
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// A list of location IDs where this employee has access to.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Specifies the status of the employees being fetched.
	// See [EmployeeStatus](#type-employeestatus) for possible values
	Status *EmployeeStatus `json:"status,omitempty" url:"status,omitempty"`
	// Whether this employee is the owner of the merchant. Each merchant
	// has one owner employee, and that employee has full authority over
	// the account.
	IsOwner *bool `json:"is_owner,omitempty" url:"is_owner,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Employee) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Employee) UnmarshalJSON(data []byte) error {
	type unmarshaler Employee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Employee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Employee) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The status of the Employee being retrieved.
//
// DEPRECATED at version 2020-08-26. Replaced by [TeamMemberStatus](entity:TeamMemberStatus).
type EmployeeStatus string

const (
	EmployeeStatusActive   EmployeeStatus = "ACTIVE"
	EmployeeStatusInactive EmployeeStatus = "INACTIVE"
)

func NewEmployeeStatusFromString(s string) (EmployeeStatus, error) {
	switch s {
	case "ACTIVE":
		return EmployeeStatusActive, nil
	case "INACTIVE":
		return EmployeeStatusInactive, nil
	}
	var t EmployeeStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmployeeStatus) Ptr() *EmployeeStatus {
	return &e
}

// The hourly wage rate that an employee earns on a `Shift` for doing the job specified by the `title` property of this object. Deprecated at version 2020-08-26. Use [TeamMemberWage](entity:TeamMemberWage).
type EmployeeWage struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The `Employee` that this wage is assigned to.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The job title that this wage relates to.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EmployeeWage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmployeeWage) UnmarshalJSON(data []byte) error {
	type unmarshaler EmployeeWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmployeeWage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmployeeWage) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Enables [Event]($m/Event)s for your application.
type EnableEventsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnableEventsRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnableEventsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EnableEventsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnableEventsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnableEventsRequest) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Defines the fields that are included in the response body of
// a request to the [EnableEvents]($e/Events/EnableEvents) endpoint.
//
// Note: if there are errors processing the request, the events field will not be
// present.
type EnableEventsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EnableEventsResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EnableEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EnableEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EnableEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EnableEventsResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents an error encountered during a request to the Connect API.
//
// See [Handling errors](https://developer.squareup.com/docs/build-basics/handling-errors) for more information.
type Error struct {
	// The high-level category for the error.
	// See [ErrorCategory](#type-errorcategory) for possible values
	Category ErrorCategory `json:"category" url:"category"`
	// The specific code of the error.
	// See [ErrorCode](#type-errorcode) for possible values
	Code ErrorCode `json:"code" url:"code"`
	// A human-readable description of the error for debugging purposes.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// The name of the field provided in the original request (if any) that
	// the error pertains to.
	Field *string `json:"field,omitempty" url:"field,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which high-level category of error has occurred during a
// request to the Connect API.
type ErrorCategory string

const (
	ErrorCategoryAPIError                  ErrorCategory = "API_ERROR"
	ErrorCategoryAuthenticationError       ErrorCategory = "AUTHENTICATION_ERROR"
	ErrorCategoryInvalidRequestError       ErrorCategory = "INVALID_REQUEST_ERROR"
	ErrorCategoryRateLimitError            ErrorCategory = "RATE_LIMIT_ERROR"
	ErrorCategoryPaymentMethodError        ErrorCategory = "PAYMENT_METHOD_ERROR"
	ErrorCategoryRefundError               ErrorCategory = "REFUND_ERROR"
	ErrorCategoryMerchantSubscriptionError ErrorCategory = "MERCHANT_SUBSCRIPTION_ERROR"
	ErrorCategoryExternalVendorError       ErrorCategory = "EXTERNAL_VENDOR_ERROR"
)

func NewErrorCategoryFromString(s string) (ErrorCategory, error) {
	switch s {
	case "API_ERROR":
		return ErrorCategoryAPIError, nil
	case "AUTHENTICATION_ERROR":
		return ErrorCategoryAuthenticationError, nil
	case "INVALID_REQUEST_ERROR":
		return ErrorCategoryInvalidRequestError, nil
	case "RATE_LIMIT_ERROR":
		return ErrorCategoryRateLimitError, nil
	case "PAYMENT_METHOD_ERROR":
		return ErrorCategoryPaymentMethodError, nil
	case "REFUND_ERROR":
		return ErrorCategoryRefundError, nil
	case "MERCHANT_SUBSCRIPTION_ERROR":
		return ErrorCategoryMerchantSubscriptionError, nil
	case "EXTERNAL_VENDOR_ERROR":
		return ErrorCategoryExternalVendorError, nil
	}
	var t ErrorCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCategory) Ptr() *ErrorCategory {
	return &e
}

// Indicates the specific error that occurred during a request to a
// Square API.
type ErrorCode string

const (
	ErrorCodeInternalServerError                           ErrorCode = "INTERNAL_SERVER_ERROR"
	ErrorCodeUnauthorized                                  ErrorCode = "UNAUTHORIZED"
	ErrorCodeAccessTokenExpired                            ErrorCode = "ACCESS_TOKEN_EXPIRED"
	ErrorCodeAccessTokenRevoked                            ErrorCode = "ACCESS_TOKEN_REVOKED"
	ErrorCodeClientDisabled                                ErrorCode = "CLIENT_DISABLED"
	ErrorCodeForbidden                                     ErrorCode = "FORBIDDEN"
	ErrorCodeInsufficientScopes                            ErrorCode = "INSUFFICIENT_SCOPES"
	ErrorCodeApplicationDisabled                           ErrorCode = "APPLICATION_DISABLED"
	ErrorCodeV1Application                                 ErrorCode = "V1_APPLICATION"
	ErrorCodeV1AccessToken                                 ErrorCode = "V1_ACCESS_TOKEN"
	ErrorCodeCardProcessingNotEnabled                      ErrorCode = "CARD_PROCESSING_NOT_ENABLED"
	ErrorCodeMerchantSubscriptionNotFound                  ErrorCode = "MERCHANT_SUBSCRIPTION_NOT_FOUND"
	ErrorCodeBadRequest                                    ErrorCode = "BAD_REQUEST"
	ErrorCodeMissingRequiredParameter                      ErrorCode = "MISSING_REQUIRED_PARAMETER"
	ErrorCodeIncorrectType                                 ErrorCode = "INCORRECT_TYPE"
	ErrorCodeInvalidTime                                   ErrorCode = "INVALID_TIME"
	ErrorCodeInvalidTimeRange                              ErrorCode = "INVALID_TIME_RANGE"
	ErrorCodeInvalidValue                                  ErrorCode = "INVALID_VALUE"
	ErrorCodeInvalidCursor                                 ErrorCode = "INVALID_CURSOR"
	ErrorCodeUnknownQueryParameter                         ErrorCode = "UNKNOWN_QUERY_PARAMETER"
	ErrorCodeConflictingParameters                         ErrorCode = "CONFLICTING_PARAMETERS"
	ErrorCodeExpectedJSONBody                              ErrorCode = "EXPECTED_JSON_BODY"
	ErrorCodeInvalidSortOrder                              ErrorCode = "INVALID_SORT_ORDER"
	ErrorCodeValueRegexMismatch                            ErrorCode = "VALUE_REGEX_MISMATCH"
	ErrorCodeValueTooShort                                 ErrorCode = "VALUE_TOO_SHORT"
	ErrorCodeValueTooLong                                  ErrorCode = "VALUE_TOO_LONG"
	ErrorCodeValueTooLow                                   ErrorCode = "VALUE_TOO_LOW"
	ErrorCodeValueTooHigh                                  ErrorCode = "VALUE_TOO_HIGH"
	ErrorCodeValueEmpty                                    ErrorCode = "VALUE_EMPTY"
	ErrorCodeArrayLengthTooLong                            ErrorCode = "ARRAY_LENGTH_TOO_LONG"
	ErrorCodeArrayLengthTooShort                           ErrorCode = "ARRAY_LENGTH_TOO_SHORT"
	ErrorCodeArrayEmpty                                    ErrorCode = "ARRAY_EMPTY"
	ErrorCodeExpectedBoolean                               ErrorCode = "EXPECTED_BOOLEAN"
	ErrorCodeExpectedInteger                               ErrorCode = "EXPECTED_INTEGER"
	ErrorCodeExpectedFloat                                 ErrorCode = "EXPECTED_FLOAT"
	ErrorCodeExpectedString                                ErrorCode = "EXPECTED_STRING"
	ErrorCodeExpectedObject                                ErrorCode = "EXPECTED_OBJECT"
	ErrorCodeExpectedArray                                 ErrorCode = "EXPECTED_ARRAY"
	ErrorCodeExpectedMap                                   ErrorCode = "EXPECTED_MAP"
	ErrorCodeExpectedBase64EncodedByteArray                ErrorCode = "EXPECTED_BASE64_ENCODED_BYTE_ARRAY"
	ErrorCodeInvalidArrayValue                             ErrorCode = "INVALID_ARRAY_VALUE"
	ErrorCodeInvalidEnumValue                              ErrorCode = "INVALID_ENUM_VALUE"
	ErrorCodeInvalidContentType                            ErrorCode = "INVALID_CONTENT_TYPE"
	ErrorCodeInvalidFormValue                              ErrorCode = "INVALID_FORM_VALUE"
	ErrorCodeCustomerNotFound                              ErrorCode = "CUSTOMER_NOT_FOUND"
	ErrorCodeOneInstrumentExpected                         ErrorCode = "ONE_INSTRUMENT_EXPECTED"
	ErrorCodeNoFieldsSet                                   ErrorCode = "NO_FIELDS_SET"
	ErrorCodeTooManyMapEntries                             ErrorCode = "TOO_MANY_MAP_ENTRIES"
	ErrorCodeMapKeyLengthTooShort                          ErrorCode = "MAP_KEY_LENGTH_TOO_SHORT"
	ErrorCodeMapKeyLengthTooLong                           ErrorCode = "MAP_KEY_LENGTH_TOO_LONG"
	ErrorCodeCustomerMissingName                           ErrorCode = "CUSTOMER_MISSING_NAME"
	ErrorCodeCustomerMissingEmail                          ErrorCode = "CUSTOMER_MISSING_EMAIL"
	ErrorCodeInvalidPauseLength                            ErrorCode = "INVALID_PAUSE_LENGTH"
	ErrorCodeInvalidDate                                   ErrorCode = "INVALID_DATE"
	ErrorCodeUnsupportedCountry                            ErrorCode = "UNSUPPORTED_COUNTRY"
	ErrorCodeUnsupportedCurrency                           ErrorCode = "UNSUPPORTED_CURRENCY"
	ErrorCodeAppleTtpPinToken                              ErrorCode = "APPLE_TTP_PIN_TOKEN"
	ErrorCodeCardExpired                                   ErrorCode = "CARD_EXPIRED"
	ErrorCodeInvalidExpiration                             ErrorCode = "INVALID_EXPIRATION"
	ErrorCodeInvalidExpirationYear                         ErrorCode = "INVALID_EXPIRATION_YEAR"
	ErrorCodeInvalidExpirationDate                         ErrorCode = "INVALID_EXPIRATION_DATE"
	ErrorCodeUnsupportedCardBrand                          ErrorCode = "UNSUPPORTED_CARD_BRAND"
	ErrorCodeUnsupportedEntryMethod                        ErrorCode = "UNSUPPORTED_ENTRY_METHOD"
	ErrorCodeInvalidEncryptedCard                          ErrorCode = "INVALID_ENCRYPTED_CARD"
	ErrorCodeInvalidCard                                   ErrorCode = "INVALID_CARD"
	ErrorCodePaymentAmountMismatch                         ErrorCode = "PAYMENT_AMOUNT_MISMATCH"
	ErrorCodeGenericDecline                                ErrorCode = "GENERIC_DECLINE"
	ErrorCodeCvvFailure                                    ErrorCode = "CVV_FAILURE"
	ErrorCodeAddressVerificationFailure                    ErrorCode = "ADDRESS_VERIFICATION_FAILURE"
	ErrorCodeInvalidAccount                                ErrorCode = "INVALID_ACCOUNT"
	ErrorCodeCurrencyMismatch                              ErrorCode = "CURRENCY_MISMATCH"
	ErrorCodeInsufficientFunds                             ErrorCode = "INSUFFICIENT_FUNDS"
	ErrorCodeInsufficientPermissions                       ErrorCode = "INSUFFICIENT_PERMISSIONS"
	ErrorCodeCardholderInsufficientPermissions             ErrorCode = "CARDHOLDER_INSUFFICIENT_PERMISSIONS"
	ErrorCodeInvalidLocation                               ErrorCode = "INVALID_LOCATION"
	ErrorCodeTransactionLimit                              ErrorCode = "TRANSACTION_LIMIT"
	ErrorCodeVoiceFailure                                  ErrorCode = "VOICE_FAILURE"
	ErrorCodePanFailure                                    ErrorCode = "PAN_FAILURE"
	ErrorCodeExpirationFailure                             ErrorCode = "EXPIRATION_FAILURE"
	ErrorCodeCardNotSupported                              ErrorCode = "CARD_NOT_SUPPORTED"
	ErrorCodeInvalidPin                                    ErrorCode = "INVALID_PIN"
	ErrorCodeMissingPin                                    ErrorCode = "MISSING_PIN"
	ErrorCodeMissingAccountType                            ErrorCode = "MISSING_ACCOUNT_TYPE"
	ErrorCodeInvalidPostalCode                             ErrorCode = "INVALID_POSTAL_CODE"
	ErrorCodeInvalidFees                                   ErrorCode = "INVALID_FEES"
	ErrorCodeManuallyEnteredPaymentNotSupported            ErrorCode = "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED"
	ErrorCodePaymentLimitExceeded                          ErrorCode = "PAYMENT_LIMIT_EXCEEDED"
	ErrorCodeGiftCardAvailableAmount                       ErrorCode = "GIFT_CARD_AVAILABLE_AMOUNT"
	ErrorCodeAccountUnusable                               ErrorCode = "ACCOUNT_UNUSABLE"
	ErrorCodeBuyerRefusedPayment                           ErrorCode = "BUYER_REFUSED_PAYMENT"
	ErrorCodeDelayedTransactionExpired                     ErrorCode = "DELAYED_TRANSACTION_EXPIRED"
	ErrorCodeDelayedTransactionCanceled                    ErrorCode = "DELAYED_TRANSACTION_CANCELED"
	ErrorCodeDelayedTransactionCaptured                    ErrorCode = "DELAYED_TRANSACTION_CAPTURED"
	ErrorCodeDelayedTransactionFailed                      ErrorCode = "DELAYED_TRANSACTION_FAILED"
	ErrorCodeCardTokenExpired                              ErrorCode = "CARD_TOKEN_EXPIRED"
	ErrorCodeCardTokenUsed                                 ErrorCode = "CARD_TOKEN_USED"
	ErrorCodeAmountTooHigh                                 ErrorCode = "AMOUNT_TOO_HIGH"
	ErrorCodeUnsupportedInstrumentType                     ErrorCode = "UNSUPPORTED_INSTRUMENT_TYPE"
	ErrorCodeRefundAmountInvalid                           ErrorCode = "REFUND_AMOUNT_INVALID"
	ErrorCodeRefundAlreadyPending                          ErrorCode = "REFUND_ALREADY_PENDING"
	ErrorCodePaymentNotRefundable                          ErrorCode = "PAYMENT_NOT_REFUNDABLE"
	ErrorCodeRefundDeclined                                ErrorCode = "REFUND_DECLINED"
	ErrorCodeInsufficientPermissionsForRefund              ErrorCode = "INSUFFICIENT_PERMISSIONS_FOR_REFUND"
	ErrorCodeInvalidCardData                               ErrorCode = "INVALID_CARD_DATA"
	ErrorCodeSourceUsed                                    ErrorCode = "SOURCE_USED"
	ErrorCodeSourceExpired                                 ErrorCode = "SOURCE_EXPIRED"
	ErrorCodeUnsupportedLoyaltyRewardTier                  ErrorCode = "UNSUPPORTED_LOYALTY_REWARD_TIER"
	ErrorCodeLocationMismatch                              ErrorCode = "LOCATION_MISMATCH"
	ErrorCodeIdempotencyKeyReused                          ErrorCode = "IDEMPOTENCY_KEY_REUSED"
	ErrorCodeUnexpectedValue                               ErrorCode = "UNEXPECTED_VALUE"
	ErrorCodeSandboxNotSupported                           ErrorCode = "SANDBOX_NOT_SUPPORTED"
	ErrorCodeInvalidEmailAddress                           ErrorCode = "INVALID_EMAIL_ADDRESS"
	ErrorCodeInvalidPhoneNumber                            ErrorCode = "INVALID_PHONE_NUMBER"
	ErrorCodeCheckoutExpired                               ErrorCode = "CHECKOUT_EXPIRED"
	ErrorCodeBadCertificate                                ErrorCode = "BAD_CERTIFICATE"
	ErrorCodeInvalidSquareVersionFormat                    ErrorCode = "INVALID_SQUARE_VERSION_FORMAT"
	ErrorCodeAPIVersionIncompatible                        ErrorCode = "API_VERSION_INCOMPATIBLE"
	ErrorCodeCardPresenceRequired                          ErrorCode = "CARD_PRESENCE_REQUIRED"
	ErrorCodeUnsupportedSourceType                         ErrorCode = "UNSUPPORTED_SOURCE_TYPE"
	ErrorCodeCardMismatch                                  ErrorCode = "CARD_MISMATCH"
	ErrorCodePlaidError                                    ErrorCode = "PLAID_ERROR"
	ErrorCodePlaidErrorItemLoginRequired                   ErrorCode = "PLAID_ERROR_ITEM_LOGIN_REQUIRED"
	ErrorCodePlaidErrorRateLimit                           ErrorCode = "PLAID_ERROR_RATE_LIMIT"
	ErrorCodeCardDeclined                                  ErrorCode = "CARD_DECLINED"
	ErrorCodeVerifyCvvFailure                              ErrorCode = "VERIFY_CVV_FAILURE"
	ErrorCodeVerifyAvsFailure                              ErrorCode = "VERIFY_AVS_FAILURE"
	ErrorCodeCardDeclinedCallIssuer                        ErrorCode = "CARD_DECLINED_CALL_ISSUER"
	ErrorCodeCardDeclinedVerificationRequired              ErrorCode = "CARD_DECLINED_VERIFICATION_REQUIRED"
	ErrorCodeBadExpiration                                 ErrorCode = "BAD_EXPIRATION"
	ErrorCodeChipInsertionRequired                         ErrorCode = "CHIP_INSERTION_REQUIRED"
	ErrorCodeAllowablePinTriesExceeded                     ErrorCode = "ALLOWABLE_PIN_TRIES_EXCEEDED"
	ErrorCodeReservationDeclined                           ErrorCode = "RESERVATION_DECLINED"
	ErrorCodeUnknownBodyParameter                          ErrorCode = "UNKNOWN_BODY_PARAMETER"
	ErrorCodeNotFound                                      ErrorCode = "NOT_FOUND"
	ErrorCodeApplePaymentProcessingCertificateHashNotFound ErrorCode = "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND"
	ErrorCodeMethodNotAllowed                              ErrorCode = "METHOD_NOT_ALLOWED"
	ErrorCodeNotAcceptable                                 ErrorCode = "NOT_ACCEPTABLE"
	ErrorCodeRequestTimeout                                ErrorCode = "REQUEST_TIMEOUT"
	ErrorCodeConflict                                      ErrorCode = "CONFLICT"
	ErrorCodeGone                                          ErrorCode = "GONE"
	ErrorCodeRequestEntityTooLarge                         ErrorCode = "REQUEST_ENTITY_TOO_LARGE"
	ErrorCodeUnsupportedMediaType                          ErrorCode = "UNSUPPORTED_MEDIA_TYPE"
	ErrorCodeUnprocessableEntity                           ErrorCode = "UNPROCESSABLE_ENTITY"
	ErrorCodeRateLimited                                   ErrorCode = "RATE_LIMITED"
	ErrorCodeNotImplemented                                ErrorCode = "NOT_IMPLEMENTED"
	ErrorCodeBadGateway                                    ErrorCode = "BAD_GATEWAY"
	ErrorCodeServiceUnavailable                            ErrorCode = "SERVICE_UNAVAILABLE"
	ErrorCodeTemporaryError                                ErrorCode = "TEMPORARY_ERROR"
	ErrorCodeGatewayTimeout                                ErrorCode = "GATEWAY_TIMEOUT"
)

func NewErrorCodeFromString(s string) (ErrorCode, error) {
	switch s {
	case "INTERNAL_SERVER_ERROR":
		return ErrorCodeInternalServerError, nil
	case "UNAUTHORIZED":
		return ErrorCodeUnauthorized, nil
	case "ACCESS_TOKEN_EXPIRED":
		return ErrorCodeAccessTokenExpired, nil
	case "ACCESS_TOKEN_REVOKED":
		return ErrorCodeAccessTokenRevoked, nil
	case "CLIENT_DISABLED":
		return ErrorCodeClientDisabled, nil
	case "FORBIDDEN":
		return ErrorCodeForbidden, nil
	case "INSUFFICIENT_SCOPES":
		return ErrorCodeInsufficientScopes, nil
	case "APPLICATION_DISABLED":
		return ErrorCodeApplicationDisabled, nil
	case "V1_APPLICATION":
		return ErrorCodeV1Application, nil
	case "V1_ACCESS_TOKEN":
		return ErrorCodeV1AccessToken, nil
	case "CARD_PROCESSING_NOT_ENABLED":
		return ErrorCodeCardProcessingNotEnabled, nil
	case "MERCHANT_SUBSCRIPTION_NOT_FOUND":
		return ErrorCodeMerchantSubscriptionNotFound, nil
	case "BAD_REQUEST":
		return ErrorCodeBadRequest, nil
	case "MISSING_REQUIRED_PARAMETER":
		return ErrorCodeMissingRequiredParameter, nil
	case "INCORRECT_TYPE":
		return ErrorCodeIncorrectType, nil
	case "INVALID_TIME":
		return ErrorCodeInvalidTime, nil
	case "INVALID_TIME_RANGE":
		return ErrorCodeInvalidTimeRange, nil
	case "INVALID_VALUE":
		return ErrorCodeInvalidValue, nil
	case "INVALID_CURSOR":
		return ErrorCodeInvalidCursor, nil
	case "UNKNOWN_QUERY_PARAMETER":
		return ErrorCodeUnknownQueryParameter, nil
	case "CONFLICTING_PARAMETERS":
		return ErrorCodeConflictingParameters, nil
	case "EXPECTED_JSON_BODY":
		return ErrorCodeExpectedJSONBody, nil
	case "INVALID_SORT_ORDER":
		return ErrorCodeInvalidSortOrder, nil
	case "VALUE_REGEX_MISMATCH":
		return ErrorCodeValueRegexMismatch, nil
	case "VALUE_TOO_SHORT":
		return ErrorCodeValueTooShort, nil
	case "VALUE_TOO_LONG":
		return ErrorCodeValueTooLong, nil
	case "VALUE_TOO_LOW":
		return ErrorCodeValueTooLow, nil
	case "VALUE_TOO_HIGH":
		return ErrorCodeValueTooHigh, nil
	case "VALUE_EMPTY":
		return ErrorCodeValueEmpty, nil
	case "ARRAY_LENGTH_TOO_LONG":
		return ErrorCodeArrayLengthTooLong, nil
	case "ARRAY_LENGTH_TOO_SHORT":
		return ErrorCodeArrayLengthTooShort, nil
	case "ARRAY_EMPTY":
		return ErrorCodeArrayEmpty, nil
	case "EXPECTED_BOOLEAN":
		return ErrorCodeExpectedBoolean, nil
	case "EXPECTED_INTEGER":
		return ErrorCodeExpectedInteger, nil
	case "EXPECTED_FLOAT":
		return ErrorCodeExpectedFloat, nil
	case "EXPECTED_STRING":
		return ErrorCodeExpectedString, nil
	case "EXPECTED_OBJECT":
		return ErrorCodeExpectedObject, nil
	case "EXPECTED_ARRAY":
		return ErrorCodeExpectedArray, nil
	case "EXPECTED_MAP":
		return ErrorCodeExpectedMap, nil
	case "EXPECTED_BASE64_ENCODED_BYTE_ARRAY":
		return ErrorCodeExpectedBase64EncodedByteArray, nil
	case "INVALID_ARRAY_VALUE":
		return ErrorCodeInvalidArrayValue, nil
	case "INVALID_ENUM_VALUE":
		return ErrorCodeInvalidEnumValue, nil
	case "INVALID_CONTENT_TYPE":
		return ErrorCodeInvalidContentType, nil
	case "INVALID_FORM_VALUE":
		return ErrorCodeInvalidFormValue, nil
	case "CUSTOMER_NOT_FOUND":
		return ErrorCodeCustomerNotFound, nil
	case "ONE_INSTRUMENT_EXPECTED":
		return ErrorCodeOneInstrumentExpected, nil
	case "NO_FIELDS_SET":
		return ErrorCodeNoFieldsSet, nil
	case "TOO_MANY_MAP_ENTRIES":
		return ErrorCodeTooManyMapEntries, nil
	case "MAP_KEY_LENGTH_TOO_SHORT":
		return ErrorCodeMapKeyLengthTooShort, nil
	case "MAP_KEY_LENGTH_TOO_LONG":
		return ErrorCodeMapKeyLengthTooLong, nil
	case "CUSTOMER_MISSING_NAME":
		return ErrorCodeCustomerMissingName, nil
	case "CUSTOMER_MISSING_EMAIL":
		return ErrorCodeCustomerMissingEmail, nil
	case "INVALID_PAUSE_LENGTH":
		return ErrorCodeInvalidPauseLength, nil
	case "INVALID_DATE":
		return ErrorCodeInvalidDate, nil
	case "UNSUPPORTED_COUNTRY":
		return ErrorCodeUnsupportedCountry, nil
	case "UNSUPPORTED_CURRENCY":
		return ErrorCodeUnsupportedCurrency, nil
	case "APPLE_TTP_PIN_TOKEN":
		return ErrorCodeAppleTtpPinToken, nil
	case "CARD_EXPIRED":
		return ErrorCodeCardExpired, nil
	case "INVALID_EXPIRATION":
		return ErrorCodeInvalidExpiration, nil
	case "INVALID_EXPIRATION_YEAR":
		return ErrorCodeInvalidExpirationYear, nil
	case "INVALID_EXPIRATION_DATE":
		return ErrorCodeInvalidExpirationDate, nil
	case "UNSUPPORTED_CARD_BRAND":
		return ErrorCodeUnsupportedCardBrand, nil
	case "UNSUPPORTED_ENTRY_METHOD":
		return ErrorCodeUnsupportedEntryMethod, nil
	case "INVALID_ENCRYPTED_CARD":
		return ErrorCodeInvalidEncryptedCard, nil
	case "INVALID_CARD":
		return ErrorCodeInvalidCard, nil
	case "PAYMENT_AMOUNT_MISMATCH":
		return ErrorCodePaymentAmountMismatch, nil
	case "GENERIC_DECLINE":
		return ErrorCodeGenericDecline, nil
	case "CVV_FAILURE":
		return ErrorCodeCvvFailure, nil
	case "ADDRESS_VERIFICATION_FAILURE":
		return ErrorCodeAddressVerificationFailure, nil
	case "INVALID_ACCOUNT":
		return ErrorCodeInvalidAccount, nil
	case "CURRENCY_MISMATCH":
		return ErrorCodeCurrencyMismatch, nil
	case "INSUFFICIENT_FUNDS":
		return ErrorCodeInsufficientFunds, nil
	case "INSUFFICIENT_PERMISSIONS":
		return ErrorCodeInsufficientPermissions, nil
	case "CARDHOLDER_INSUFFICIENT_PERMISSIONS":
		return ErrorCodeCardholderInsufficientPermissions, nil
	case "INVALID_LOCATION":
		return ErrorCodeInvalidLocation, nil
	case "TRANSACTION_LIMIT":
		return ErrorCodeTransactionLimit, nil
	case "VOICE_FAILURE":
		return ErrorCodeVoiceFailure, nil
	case "PAN_FAILURE":
		return ErrorCodePanFailure, nil
	case "EXPIRATION_FAILURE":
		return ErrorCodeExpirationFailure, nil
	case "CARD_NOT_SUPPORTED":
		return ErrorCodeCardNotSupported, nil
	case "INVALID_PIN":
		return ErrorCodeInvalidPin, nil
	case "MISSING_PIN":
		return ErrorCodeMissingPin, nil
	case "MISSING_ACCOUNT_TYPE":
		return ErrorCodeMissingAccountType, nil
	case "INVALID_POSTAL_CODE":
		return ErrorCodeInvalidPostalCode, nil
	case "INVALID_FEES":
		return ErrorCodeInvalidFees, nil
	case "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED":
		return ErrorCodeManuallyEnteredPaymentNotSupported, nil
	case "PAYMENT_LIMIT_EXCEEDED":
		return ErrorCodePaymentLimitExceeded, nil
	case "GIFT_CARD_AVAILABLE_AMOUNT":
		return ErrorCodeGiftCardAvailableAmount, nil
	case "ACCOUNT_UNUSABLE":
		return ErrorCodeAccountUnusable, nil
	case "BUYER_REFUSED_PAYMENT":
		return ErrorCodeBuyerRefusedPayment, nil
	case "DELAYED_TRANSACTION_EXPIRED":
		return ErrorCodeDelayedTransactionExpired, nil
	case "DELAYED_TRANSACTION_CANCELED":
		return ErrorCodeDelayedTransactionCanceled, nil
	case "DELAYED_TRANSACTION_CAPTURED":
		return ErrorCodeDelayedTransactionCaptured, nil
	case "DELAYED_TRANSACTION_FAILED":
		return ErrorCodeDelayedTransactionFailed, nil
	case "CARD_TOKEN_EXPIRED":
		return ErrorCodeCardTokenExpired, nil
	case "CARD_TOKEN_USED":
		return ErrorCodeCardTokenUsed, nil
	case "AMOUNT_TOO_HIGH":
		return ErrorCodeAmountTooHigh, nil
	case "UNSUPPORTED_INSTRUMENT_TYPE":
		return ErrorCodeUnsupportedInstrumentType, nil
	case "REFUND_AMOUNT_INVALID":
		return ErrorCodeRefundAmountInvalid, nil
	case "REFUND_ALREADY_PENDING":
		return ErrorCodeRefundAlreadyPending, nil
	case "PAYMENT_NOT_REFUNDABLE":
		return ErrorCodePaymentNotRefundable, nil
	case "REFUND_DECLINED":
		return ErrorCodeRefundDeclined, nil
	case "INSUFFICIENT_PERMISSIONS_FOR_REFUND":
		return ErrorCodeInsufficientPermissionsForRefund, nil
	case "INVALID_CARD_DATA":
		return ErrorCodeInvalidCardData, nil
	case "SOURCE_USED":
		return ErrorCodeSourceUsed, nil
	case "SOURCE_EXPIRED":
		return ErrorCodeSourceExpired, nil
	case "UNSUPPORTED_LOYALTY_REWARD_TIER":
		return ErrorCodeUnsupportedLoyaltyRewardTier, nil
	case "LOCATION_MISMATCH":
		return ErrorCodeLocationMismatch, nil
	case "IDEMPOTENCY_KEY_REUSED":
		return ErrorCodeIdempotencyKeyReused, nil
	case "UNEXPECTED_VALUE":
		return ErrorCodeUnexpectedValue, nil
	case "SANDBOX_NOT_SUPPORTED":
		return ErrorCodeSandboxNotSupported, nil
	case "INVALID_EMAIL_ADDRESS":
		return ErrorCodeInvalidEmailAddress, nil
	case "INVALID_PHONE_NUMBER":
		return ErrorCodeInvalidPhoneNumber, nil
	case "CHECKOUT_EXPIRED":
		return ErrorCodeCheckoutExpired, nil
	case "BAD_CERTIFICATE":
		return ErrorCodeBadCertificate, nil
	case "INVALID_SQUARE_VERSION_FORMAT":
		return ErrorCodeInvalidSquareVersionFormat, nil
	case "API_VERSION_INCOMPATIBLE":
		return ErrorCodeAPIVersionIncompatible, nil
	case "CARD_PRESENCE_REQUIRED":
		return ErrorCodeCardPresenceRequired, nil
	case "UNSUPPORTED_SOURCE_TYPE":
		return ErrorCodeUnsupportedSourceType, nil
	case "CARD_MISMATCH":
		return ErrorCodeCardMismatch, nil
	case "PLAID_ERROR":
		return ErrorCodePlaidError, nil
	case "PLAID_ERROR_ITEM_LOGIN_REQUIRED":
		return ErrorCodePlaidErrorItemLoginRequired, nil
	case "PLAID_ERROR_RATE_LIMIT":
		return ErrorCodePlaidErrorRateLimit, nil
	case "CARD_DECLINED":
		return ErrorCodeCardDeclined, nil
	case "VERIFY_CVV_FAILURE":
		return ErrorCodeVerifyCvvFailure, nil
	case "VERIFY_AVS_FAILURE":
		return ErrorCodeVerifyAvsFailure, nil
	case "CARD_DECLINED_CALL_ISSUER":
		return ErrorCodeCardDeclinedCallIssuer, nil
	case "CARD_DECLINED_VERIFICATION_REQUIRED":
		return ErrorCodeCardDeclinedVerificationRequired, nil
	case "BAD_EXPIRATION":
		return ErrorCodeBadExpiration, nil
	case "CHIP_INSERTION_REQUIRED":
		return ErrorCodeChipInsertionRequired, nil
	case "ALLOWABLE_PIN_TRIES_EXCEEDED":
		return ErrorCodeAllowablePinTriesExceeded, nil
	case "RESERVATION_DECLINED":
		return ErrorCodeReservationDeclined, nil
	case "UNKNOWN_BODY_PARAMETER":
		return ErrorCodeUnknownBodyParameter, nil
	case "NOT_FOUND":
		return ErrorCodeNotFound, nil
	case "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND":
		return ErrorCodeApplePaymentProcessingCertificateHashNotFound, nil
	case "METHOD_NOT_ALLOWED":
		return ErrorCodeMethodNotAllowed, nil
	case "NOT_ACCEPTABLE":
		return ErrorCodeNotAcceptable, nil
	case "REQUEST_TIMEOUT":
		return ErrorCodeRequestTimeout, nil
	case "CONFLICT":
		return ErrorCodeConflict, nil
	case "GONE":
		return ErrorCodeGone, nil
	case "REQUEST_ENTITY_TOO_LARGE":
		return ErrorCodeRequestEntityTooLarge, nil
	case "UNSUPPORTED_MEDIA_TYPE":
		return ErrorCodeUnsupportedMediaType, nil
	case "UNPROCESSABLE_ENTITY":
		return ErrorCodeUnprocessableEntity, nil
	case "RATE_LIMITED":
		return ErrorCodeRateLimited, nil
	case "NOT_IMPLEMENTED":
		return ErrorCodeNotImplemented, nil
	case "BAD_GATEWAY":
		return ErrorCodeBadGateway, nil
	case "SERVICE_UNAVAILABLE":
		return ErrorCodeServiceUnavailable, nil
	case "TEMPORARY_ERROR":
		return ErrorCodeTemporaryError, nil
	case "GATEWAY_TIMEOUT":
		return ErrorCodeGatewayTimeout, nil
	}
	var t ErrorCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCode) Ptr() *ErrorCode {
	return &e
}

type Event struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *EventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Event) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Event) UnmarshalJSON(data []byte) error {
	type unmarshaler Event
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Event(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Event) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventData struct {
	// The name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// This is true if the affected object has been deleted; otherwise, it's absent.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`
	// An object containing fields and values relevant to the event. It is absent if the affected object has been deleted.
	Object map[string]interface{} `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventData) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventData) UnmarshalJSON(data []byte) error {
	type unmarshaler EventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventData) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Contains metadata about a particular [Event]($m/Event).
type EventMetadata struct {
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The API version of the event. This corresponds to the default API version of the developer application at the time when the event was created.
	APIVersion *string `json:"api_version,omitempty" url:"api_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventMetadata) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler EventMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventMetadata) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Contains the metadata of a webhook event type.
type EventTypeMetadata struct {
	// The event type.
	EventType *string `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The API version at which the event type was introduced.
	APIVersionIntroduced *string `json:"api_version_introduced,omitempty" url:"api_version_introduced,omitempty"`
	// The release status of the event type.
	ReleaseStatus *string `json:"release_status,omitempty" url:"release_status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EventTypeMetadata) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTypeMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTypeMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTypeMetadata(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTypeMetadata) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which products matched by a CatalogPricingRule
// will be excluded if the pricing rule uses an exclude set.
type ExcludeStrategy string

const (
	ExcludeStrategyLeastExpensive ExcludeStrategy = "LEAST_EXPENSIVE"
	ExcludeStrategyMostExpensive  ExcludeStrategy = "MOST_EXPENSIVE"
)

func NewExcludeStrategyFromString(s string) (ExcludeStrategy, error) {
	switch s {
	case "LEAST_EXPENSIVE":
		return ExcludeStrategyLeastExpensive, nil
	case "MOST_EXPENSIVE":
		return ExcludeStrategyMostExpensive, nil
	}
	var t ExcludeStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExcludeStrategy) Ptr() *ExcludeStrategy {
	return &e
}

// Stores details about an external payment. Contains only non-confidential information.
// For more information, see
// [Take External Payments](https://developer.squareup.com/docs/payments-api/take-payments/external-payments).
type ExternalPaymentDetails struct {
	// The type of external payment the seller received. It can be one of the following:
	//
	// - CHECK - Paid using a physical check.
	// - BANK_TRANSFER - Paid using external bank transfer.
	// - OTHER_GIFT_CARD - Paid using a non-Square gift card.
	// - CRYPTO - Paid using a crypto currency.
	// - SQUARE_CASH - Paid using Square Cash App.
	// - SOCIAL - Paid using peer-to-peer payment applications.
	// - EXTERNAL - A third-party application gathered this payment outside of Square.
	// - EMONEY - Paid using an E-money provider.
	// - CARD - A credit or debit card that Square does not support.
	// - STORED_BALANCE - Use for house accounts, store credit, and so forth.
	// - FOOD_VOUCHER - Restaurant voucher provided by employers to employees to pay for meals
	// - OTHER - A type not listed here.
	Type string `json:"type" url:"type"`
	// A description of the external payment source. For example,
	// "Food Delivery Service".
	Source string `json:"source" url:"source"`
	// An ID to associate the payment to its originating source.
	SourceID *string `json:"source_id,omitempty" url:"source_id,omitempty"`
	// The fees paid to the source. The `amount_money` minus this field is
	// the net amount seller receives.
	SourceFeeMoney *Money `json:"source_fee_money,omitempty" url:"source_fee_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalPaymentDetails) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalPaymentDetails) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// A filter to select resources based on an exact field value. For any given
// value, the value can only be in one property. Depending on the field, either
// all properties can be set or only a subset will be available.
//
// Refer to the documentation of the field.
type FilterValue struct {
	// A list of terms that must be present on the field of the resource.
	All []string `json:"all,omitempty" url:"all,omitempty"`
	// A list of terms where at least one of them must be present on the
	// field of the resource.
	Any []string `json:"any,omitempty" url:"any,omitempty"`
	// A list of terms that must not be present on the field the resource
	None []string `json:"none,omitempty" url:"none,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FilterValue) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterValue) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterValue) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Specifies a decimal number range.
type FloatNumberRange struct {
	// A decimal value indicating where the range starts.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// A decimal value indicating where the range ends.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FloatNumberRange) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FloatNumberRange) UnmarshalJSON(data []byte) error {
	type unmarshaler FloatNumberRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FloatNumberRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FloatNumberRange) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Contains details about how to fulfill this order.
// Orders can only be created with at most one fulfillment using the API.
// However, orders returned by the Orders API might contain multiple fulfillments because sellers can create multiple fulfillments using Square products such as Square Online.
type Fulfillment struct {
	// A unique ID that identifies the fulfillment only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The type of the fulfillment.
	// See [FulfillmentType](#type-fulfillmenttype) for possible values
	Type *FulfillmentType `json:"type,omitempty" url:"type,omitempty"`
	// The state of the fulfillment.
	// See [FulfillmentState](#type-fulfillmentstate) for possible values
	State *FulfillmentState `json:"state,omitempty" url:"state,omitempty"`
	// Describes what order line items this fulfillment applies to.
	// It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
	// See [FulfillmentFulfillmentLineItemApplication](#type-fulfillmentfulfillmentlineitemapplication) for possible values
	LineItemApplication *FulfillmentFulfillmentLineItemApplication `json:"line_item_application,omitempty" url:"line_item_application,omitempty"`
	// A list of entries pertaining to the fulfillment of an order. Each entry must reference
	// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
	// fulfill.
	//
	// Multiple entries can reference the same line item `uid`, as long as the total quantity among
	// all fulfillment entries referencing a single line item does not exceed the quantity of the
	// order's line item itself.
	//
	// An order cannot be marked as `COMPLETED` before all fulfillments are `COMPLETED`,
	// `CANCELED`, or `FAILED`. Fulfillments can be created and completed independently
	// before order completion.
	Entries []*FulfillmentFulfillmentEntry `json:"entries,omitempty" url:"entries,omitempty"`
	// Application-defined data attached to this fulfillment. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Contains details for a pickup fulfillment. These details are required when the fulfillment
	// type is `PICKUP`.
	PickupDetails *FulfillmentPickupDetails `json:"pickup_details,omitempty" url:"pickup_details,omitempty"`
	// Contains details for a shipment fulfillment. These details are required when the fulfillment type
	// is `SHIPMENT`.
	//
	// A shipment fulfillment's relationship to fulfillment `state`:
	// `PROPOSED`: A shipment is requested.
	// `RESERVED`: Fulfillment in progress. Shipment processing.
	// `PREPARED`: Shipment packaged. Shipping label created.
	// `COMPLETED`: Package has been shipped.
	// `CANCELED`: Shipment has been canceled.
	// `FAILED`: Shipment has failed.
	ShipmentDetails *FulfillmentShipmentDetails `json:"shipment_details,omitempty" url:"shipment_details,omitempty"`
	// Describes delivery details of an order fulfillment.
	DeliveryDetails *FulfillmentDeliveryDetails `json:"delivery_details,omitempty" url:"delivery_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *Fulfillment) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fulfillment) UnmarshalJSON(data []byte) error {
	type unmarshaler Fulfillment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fulfillment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fulfillment) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Describes delivery details of an order fulfillment.
type FulfillmentDeliveryDetails struct {
	// The contact information for the person to receive the fulfillment.
	Recipient *FulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// Indicates the fulfillment delivery schedule type. If `SCHEDULED`, then
	// `deliver_at` is required. If `ASAP`, then `prep_time_duration` is required. The default is `SCHEDULED`.
	// See [OrderFulfillmentDeliveryDetailsScheduleType](#type-orderfulfillmentdeliverydetailsscheduletype) for possible values
	ScheduleType *FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType `json:"schedule_type,omitempty" url:"schedule_type,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	//
	// Must be in RFC 3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the delivery period.
	// When the fulfillment `schedule_type` is `ASAP`, the field is automatically
	// set to the current time plus the `prep_time_duration`.
	// Otherwise, the application can set this field while the fulfillment `state` is
	// `PROPOSED`, `RESERVED`, or `PREPARED` (any time before the
	// terminal state such as `COMPLETED`, `CANCELED`, and `FAILED`).
	//
	// The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	DeliverAt *string `json:"deliver_at,omitempty" url:"deliver_at,omitempty"`
	// The duration of time it takes to prepare and deliver this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// The time period after `deliver_at` in which to deliver the order.
	// Applications can set this field when the fulfillment `state` is
	// `PROPOSED`, `RESERVED`, or `PREPARED` (any time before the terminal state
	// such as `COMPLETED`, `CANCELED`, and `FAILED`).
	//
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	DeliveryWindowDuration *string `json:"delivery_window_duration,omitempty" url:"delivery_window_duration,omitempty"`
	// Provides additional instructions about the delivery fulfillment.
	// It is displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicates when the seller completed the fulfillment.
	// This field is automatically set when fulfillment `state` changes to `COMPLETED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CompletedAt *string `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicates when the seller started processing the fulfillment.
	// This field is automatically set when the fulfillment `state` changes to `RESERVED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. This field is
	// automatically set when the fulfillment `state` changes to `FAILED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the seller marked the fulfillment as ready for
	// courier pickup. This field is automatically set when the fulfillment `state` changes
	// to PREPARED.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was delivered to the recipient.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	DeliveredAt *string `json:"delivered_at,omitempty" url:"delivered_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. This field is automatically
	// set when the fulfillment `state` changes to `CANCELED`.
	//
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// The delivery cancellation reason. Max length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when an order can be picked up by the courier for delivery.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CourierPickupAt *string `json:"courier_pickup_at,omitempty" url:"courier_pickup_at,omitempty"`
	// The time period after `courier_pickup_at` in which the courier should pick up the order.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	CourierPickupWindowDuration *string `json:"courier_pickup_window_duration,omitempty" url:"courier_pickup_window_duration,omitempty"`
	// Whether the delivery is preferred to be no contact.
	IsNoContactDelivery *bool `json:"is_no_contact_delivery,omitempty" url:"is_no_contact_delivery,omitempty"`
	// A note to provide additional instructions about how to deliver the order.
	DropoffNotes *string `json:"dropoff_notes,omitempty" url:"dropoff_notes,omitempty"`
	// The name of the courier provider.
	CourierProviderName *string `json:"courier_provider_name,omitempty" url:"courier_provider_name,omitempty"`
	// The support phone number of the courier.
	CourierSupportPhoneNumber *string `json:"courier_support_phone_number,omitempty" url:"courier_support_phone_number,omitempty"`
	// The identifier for the delivery created by Square.
	SquareDeliveryID *string `json:"square_delivery_id,omitempty" url:"square_delivery_id,omitempty"`
	// The identifier for the delivery created by the third-party courier service.
	ExternalDeliveryID *string `json:"external_delivery_id,omitempty" url:"external_delivery_id,omitempty"`
	// The flag to indicate the delivery is managed by a third party (ie DoorDash), which means
	// we may not receive all recipient information for PII purposes.
	ManagedDelivery *bool `json:"managed_delivery,omitempty" url:"managed_delivery,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FulfillmentDeliveryDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentDeliveryDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentDeliveryDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentDeliveryDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentDeliveryDetails) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The schedule type of the delivery fulfillment.
type FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType string

const (
	FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeScheduled FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType = "SCHEDULED"
	FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeAsap      FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType = "ASAP"
)

func NewFulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeFromString(s string) (FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeAsap, nil
	}
	var t FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType) Ptr() *FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType {
	return &f
}

// Links an order line item to a fulfillment. Each entry must reference
// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
// fulfill.
type FulfillmentFulfillmentEntry struct {
	// A unique ID that identifies the fulfillment entry only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` from the order line item.
	LineItemUID string `json:"line_item_uid" url:"line_item_uid"`
	// The quantity of the line item being fulfilled, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Fulfillments for line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// Application-defined data attached to this fulfillment entry. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FulfillmentFulfillmentEntry) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentFulfillmentEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentFulfillmentEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentFulfillmentEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentFulfillmentEntry) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The `line_item_application` describes what order line items this fulfillment applies
// to. It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
type FulfillmentFulfillmentLineItemApplication string

const (
	FulfillmentFulfillmentLineItemApplicationAll       FulfillmentFulfillmentLineItemApplication = "ALL"
	FulfillmentFulfillmentLineItemApplicationEntryList FulfillmentFulfillmentLineItemApplication = "ENTRY_LIST"
)

func NewFulfillmentFulfillmentLineItemApplicationFromString(s string) (FulfillmentFulfillmentLineItemApplication, error) {
	switch s {
	case "ALL":
		return FulfillmentFulfillmentLineItemApplicationAll, nil
	case "ENTRY_LIST":
		return FulfillmentFulfillmentLineItemApplicationEntryList, nil
	}
	var t FulfillmentFulfillmentLineItemApplication
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentFulfillmentLineItemApplication) Ptr() *FulfillmentFulfillmentLineItemApplication {
	return &f
}

// Contains details necessary to fulfill a pickup order.
type FulfillmentPickupDetails struct {
	// Information about the person to pick up this fulfillment from a physical
	// location.
	Recipient *FulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment expires if it is not marked in progress. The timestamp must be
	// in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z"). The expiration time can only be set
	// up to 7 days in the future. If `expires_at` is not set, any new payments attached to the order
	// are automatically completed.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The duration of time after which an in progress pickup fulfillment is automatically moved
	// to the `COMPLETED` state. The duration must be in RFC 3339 format (for example, "P1W3D").
	//
	// If not set, this pickup fulfillment remains in progress until it is canceled or completed.
	AutoCompleteDuration *string `json:"auto_complete_duration,omitempty" url:"auto_complete_duration,omitempty"`
	// The schedule type of the pickup fulfillment. Defaults to `SCHEDULED`.
	// See [FulfillmentPickupDetailsScheduleType](#type-fulfillmentpickupdetailsscheduletype) for possible values
	ScheduleType *FulfillmentPickupDetailsScheduleType `json:"schedule_type,omitempty" url:"schedule_type,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the pickup window. Must be in RFC 3339 timestamp format, e.g.,
	// "2016-09-04T23:59:33.123Z".
	//
	// For fulfillments with the schedule type `ASAP`, this is automatically set
	// to the current time plus the expected duration to prepare the fulfillment.
	PickupAt *string `json:"pickup_at,omitempty" url:"pickup_at,omitempty"`
	// The window of time in which the order should be picked up after the `pickup_at` timestamp.
	// Must be in RFC 3339 duration format, e.g., "P1W3D". Can be used as an
	// informational guideline for merchants.
	PickupWindowDuration *string `json:"pickup_window_duration,omitempty" url:"pickup_window_duration,omitempty"`
	// The duration of time it takes to prepare this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// A note to provide additional instructions about the pickup
	// fulfillment displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was marked in progress. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	AcceptedAt *string `json:"accepted_at,omitempty" url:"accepted_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment is marked as ready for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment expired. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ExpiredAt *string `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was picked up by the recipient. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PickedUpAt *string `json:"picked_up_at,omitempty" url:"picked_up_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the pickup was canceled. The maximum length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// If set to `true`, indicates that this pickup order is for curbside pickup, not in-store pickup.
	IsCurbsidePickup *bool `json:"is_curbside_pickup,omitempty" url:"is_curbside_pickup,omitempty"`
	// Specific details for curbside pickup. These details can only be populated if `is_curbside_pickup` is set to `true`.
	CurbsidePickupDetails *FulfillmentPickupDetailsCurbsidePickupDetails `json:"curbside_pickup_details,omitempty" url:"curbside_pickup_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FulfillmentPickupDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentPickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentPickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentPickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentPickupDetails) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Specific details for curbside pickup.
type FulfillmentPickupDetailsCurbsidePickupDetails struct {
	// Specific details for curbside pickup, such as parking number and vehicle model.
	CurbsideDetails *string `json:"curbside_details,omitempty" url:"curbside_details,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the buyer arrived and is waiting for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	BuyerArrivedAt *string `json:"buyer_arrived_at,omitempty" url:"buyer_arrived_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentPickupDetailsCurbsidePickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentPickupDetailsCurbsidePickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The schedule type of the pickup fulfillment.
type FulfillmentPickupDetailsScheduleType string

const (
	FulfillmentPickupDetailsScheduleTypeScheduled FulfillmentPickupDetailsScheduleType = "SCHEDULED"
	FulfillmentPickupDetailsScheduleTypeAsap      FulfillmentPickupDetailsScheduleType = "ASAP"
)

func NewFulfillmentPickupDetailsScheduleTypeFromString(s string) (FulfillmentPickupDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return FulfillmentPickupDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return FulfillmentPickupDetailsScheduleTypeAsap, nil
	}
	var t FulfillmentPickupDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentPickupDetailsScheduleType) Ptr() *FulfillmentPickupDetailsScheduleType {
	return &f
}

// Information about the fulfillment recipient.
type FulfillmentRecipient struct {
	// The ID of the customer associated with the fulfillment.
	//
	// If `customer_id` is provided, the fulfillment recipient's `display_name`,
	// `email_address`, and `phone_number` are automatically populated from the
	// targeted customer profile. If these fields are set in the request, the request
	// values override the information from the customer profile. If the
	// targeted customer profile does not contain the necessary information and
	// these fields are left unset, the request results in an error.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The display name of the fulfillment recipient. This field is required.
	//
	// If provided, the display name overrides the corresponding customer profile value
	// indicated by `customer_id`.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The email address of the fulfillment recipient.
	//
	// If provided, the email address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the fulfillment recipient. This field is required.
	//
	// If provided, the phone number overrides the corresponding customer profile value
	// indicated by `customer_id`.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The address of the fulfillment recipient. This field is required.
	//
	// If provided, the address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FulfillmentRecipient) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentRecipient) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Contains the details necessary to fulfill a shipment order.
type FulfillmentShipmentDetails struct {
	// Information about the person to receive this shipment fulfillment.
	Recipient *FulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The shipping carrier being used to ship this fulfillment (such as UPS, FedEx, or USPS).
	Carrier *string `json:"carrier,omitempty" url:"carrier,omitempty"`
	// A note with additional information for the shipping carrier.
	ShippingNote *string `json:"shipping_note,omitempty" url:"shipping_note,omitempty"`
	// A description of the type of shipping product purchased from the carrier
	// (such as First Class, Priority, or Express).
	ShippingType *string `json:"shipping_type,omitempty" url:"shipping_type,omitempty"`
	// The reference number provided by the carrier to track the shipment's progress.
	TrackingNumber *string `json:"tracking_number,omitempty" url:"tracking_number,omitempty"`
	// A link to the tracking webpage on the carrier's website.
	TrackingURL *string `json:"tracking_url,omitempty" url:"tracking_url,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment was requested. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `RESERVED` state, which indicates that preparation
	// of this shipment has begun. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `PREPARED` state, which indicates that the
	// fulfillment is packaged. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	PackagedAt *string `json:"packaged_at,omitempty" url:"packaged_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment is expected to be delivered to the shipping carrier.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ExpectedShippedAt *string `json:"expected_shipped_at,omitempty" url:"expected_shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `COMPLETED` state, which indicates that
	// the fulfillment has been given to the shipping carrier. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ShippedAt *string `json:"shipped_at,omitempty" url:"shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating the shipment was canceled.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the shipment was canceled.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment failed to be completed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	FailedAt *string `json:"failed_at,omitempty" url:"failed_at,omitempty"`
	// A description of why the shipment failed to be completed.
	FailureReason *string `json:"failure_reason,omitempty" url:"failure_reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FulfillmentShipmentDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentShipmentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentShipmentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentShipmentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentShipmentDetails) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The current state of this fulfillment.
type FulfillmentState string

const (
	FulfillmentStateProposed  FulfillmentState = "PROPOSED"
	FulfillmentStateReserved  FulfillmentState = "RESERVED"
	FulfillmentStatePrepared  FulfillmentState = "PREPARED"
	FulfillmentStateCompleted FulfillmentState = "COMPLETED"
	FulfillmentStateCanceled  FulfillmentState = "CANCELED"
	FulfillmentStateFailed    FulfillmentState = "FAILED"
)

func NewFulfillmentStateFromString(s string) (FulfillmentState, error) {
	switch s {
	case "PROPOSED":
		return FulfillmentStateProposed, nil
	case "RESERVED":
		return FulfillmentStateReserved, nil
	case "PREPARED":
		return FulfillmentStatePrepared, nil
	case "COMPLETED":
		return FulfillmentStateCompleted, nil
	case "CANCELED":
		return FulfillmentStateCanceled, nil
	case "FAILED":
		return FulfillmentStateFailed, nil
	}
	var t FulfillmentState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentState) Ptr() *FulfillmentState {
	return &f
}

// The type of fulfillment.
type FulfillmentType string

const (
	FulfillmentTypePickup   FulfillmentType = "PICKUP"
	FulfillmentTypeShipment FulfillmentType = "SHIPMENT"
	FulfillmentTypeDelivery FulfillmentType = "DELIVERY"
)

func NewFulfillmentTypeFromString(s string) (FulfillmentType, error) {
	switch s {
	case "PICKUP":
		return FulfillmentTypePickup, nil
	case "SHIPMENT":
		return FulfillmentTypeShipment, nil
	case "DELIVERY":
		return FulfillmentTypeDelivery, nil
	}
	var t FulfillmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentType) Ptr() *FulfillmentType {
	return &f
}

// Request object for fetching a specific `BankAccount`
// by the object ID.
type GetBankAccountByV1IDRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBankAccountByV1IDRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountByV1IDRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountByV1IDRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountByV1IDRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountByV1IDRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response object returned by GetBankAccountByV1Id.
type GetBankAccountByV1IDResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `BankAccount` object.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBankAccountByV1IDResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountByV1IDResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountByV1IDResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountByV1IDResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountByV1IDResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Request object to fetch a specific `BankAccount`
// by the object ID.
type GetBankAccountRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBankAccountRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response object returned by `GetBankAccount`.
type GetBankAccountResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `BankAccount` object.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBankAccountResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBookingRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBookingRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBookingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBookingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBookingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBookingRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBookingResponse struct {
	// The booking that was requested.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBookingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBookingResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get a `BreakType` by ID.
type GetBreakTypeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBreakTypeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBreakTypeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBreakTypeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBreakTypeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBreakTypeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The response to a request to get a `BreakType`. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetBreakTypeResponse struct {
	// The response object.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBreakTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBreakTypeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBusinessBookingProfileRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBusinessBookingProfileRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBusinessBookingProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBusinessBookingProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBusinessBookingProfileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBusinessBookingProfileRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBusinessBookingProfileResponse struct {
	// The seller's booking profile.
	BusinessBookingProfile *BusinessBookingProfile `json:"business_booking_profile,omitempty" url:"business_booking_profile,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetBusinessBookingProfileResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBusinessBookingProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBusinessBookingProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBusinessBookingProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBusinessBookingProfileResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Retrieves details for a specific Card. Accessible via
// HTTP requests at GET https://connect.squareup.com/v2/cards/{card_id}
type GetCardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCardRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCardRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the [RetrieveCard]($e/Cards/RetrieveCard) endpoint.
//
// Note: if there are errors processing the request, the card field will not be
// present.
type GetCardResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCardResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCardResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCashDrawerShiftResponse struct {
	// The cash drawer shift queried for.
	CashDrawerShift *CashDrawerShift `json:"cash_drawer_shift,omitempty" url:"cash_drawer_shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCashDrawerShiftResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCashDrawerShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCashDrawerShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCashDrawerShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCashDrawerShiftResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The `CatalogObject`s returned.
	Object *CatalogObject `json:"object,omitempty" url:"object,omitempty"`
	// A list of `CatalogObject`s referenced by the object in the `object` field.
	RelatedObjects []*CatalogObject `json:"related_objects,omitempty" url:"related_objects,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCatalogObjectResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveCustomerCustomAttributeDefinition]($e/CustomerCustomAttributes/RetrieveCustomerCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type GetCustomerCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerCustomAttributeDefinitionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveCustomerCustomAttribute]($e/CustomerCustomAttributes/RetrieveCustomerCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type GetCustomerCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerCustomAttributeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that can be included in a request to the
// [RetrieveCustomerGroup]($e/CustomerGroups/RetrieveCustomerGroup) endpoint.
type GetCustomerGroupRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerGroupRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerGroupRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerGroupRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerGroupRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerGroupRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the [RetrieveCustomerGroup]($e/CustomerGroups/RetrieveCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type GetCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerGroupResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in requests to the `RetrieveCustomer`
// endpoint.
type GetCustomerRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the `RetrieveCustomer` endpoint.
//
// Either `errors` or `customer` is present in a given response (never both).
type GetCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the valid parameters for requests to the `RetrieveCustomerSegmentRequest` endpoint.
type GetCustomerSegmentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerSegmentRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerSegmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerSegmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerSegmentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerSegmentRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body for requests to the `RetrieveCustomerSegment` endpoint.
//
// Either `errors` or `segment` is present in a given response (never both).
type GetCustomerSegmentResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved customer segment.
	Segment *CustomerSegment `json:"segment,omitempty" url:"segment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetCustomerSegmentResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerSegmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerSegmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerSegmentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerSegmentResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDeviceCodeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDeviceCodeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDeviceCodeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDeviceCodeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDeviceCodeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDeviceCodeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDeviceCodeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The queried DeviceCode.
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDeviceCodeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDeviceCodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDeviceCodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDeviceCodeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDeviceCodeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDeviceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDeviceRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDeviceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDeviceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDeviceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDeviceRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDeviceResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `Device`.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDeviceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDeviceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDeviceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDeviceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDeviceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the parameters for a `RetrieveDisputeEvidence` request.
type GetDisputeEvidenceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDisputeEvidenceRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeEvidenceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeEvidenceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeEvidenceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeEvidenceRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields in a `RetrieveDisputeEvidence` response.
type GetDisputeEvidenceResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Metadata about the dispute evidence file.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeEvidenceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeEvidenceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the request parameters for the `RetrieveDispute` endpoint.
type GetDisputeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDisputeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines fields in a `RetrieveDispute` response.
type GetDisputeResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Details about the requested `Dispute`.
	Dispute *Dispute `json:"dispute,omitempty" url:"dispute,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetDisputeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetEmployeeRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEmployeeRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetEmployeeResponse struct {
	Employee *Employee `json:"employee,omitempty" url:"employee,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEmployeeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get an `EmployeeWage`.
type GetEmployeeWageRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEmployeeWageRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeWageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeWageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeWageRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeWageRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response to a request to get an `EmployeeWage`. The response contains
// the requested `EmployeeWage` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetEmployeeWageResponse struct {
	// The requested `EmployeeWage` object.
	EmployeeWage *EmployeeWage `json:"employee_wage,omitempty" url:"employee_wage,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetEmployeeWageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeWageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeWageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeWageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeWageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that contains a `GiftCard`. This response might contain a set of `Error` objects
// if the request resulted in errors.
type GetGiftCardFromGanResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A gift card that was fetched, if present. It returns empty if an error occurred.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetGiftCardFromGanResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetGiftCardFromGanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetGiftCardFromGanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetGiftCardFromGanResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetGiftCardFromGanResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that contains a `GiftCard` object. If the request resulted in errors,
// the response contains a set of `Error` objects.
type GetGiftCardFromNonceResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved gift card.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetGiftCardFromNonceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetGiftCardFromNonceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetGiftCardFromNonceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetGiftCardFromNonceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetGiftCardFromNonceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve digital gift cards.
type GetGiftCardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetGiftCardRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetGiftCardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetGiftCardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetGiftCardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetGiftCardRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that contains a `GiftCard`. The response might contain a set of `Error` objects
// if the request resulted in errors.
type GetGiftCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The gift card retrieved.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetGiftCardResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetGiftCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetGiftCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetGiftCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetGiftCardResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryAdjustmentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryAdjustmentRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryAdjustmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryAdjustmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryAdjustmentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryAdjustmentRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryAdjustmentResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested [InventoryAdjustment](entity:InventoryAdjustment).
	Adjustment *InventoryAdjustment `json:"adjustment,omitempty" url:"adjustment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryAdjustmentResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryAdjustmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryAdjustmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryAdjustmentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryAdjustmentResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryChangesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The set of inventory changes for the requested object and locations.
	Changes []*InventoryChange `json:"changes,omitempty" url:"changes,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryChangesResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryChangesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryChangesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryChangesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryChangesResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryCountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The current calculated inventory counts for the requested object and
	// locations.
	Counts []*InventoryCount `json:"counts,omitempty" url:"counts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryCountResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryCountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryCountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryCountResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryCountResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryPhysicalCountRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryPhysicalCountRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryPhysicalCountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryPhysicalCountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryPhysicalCountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryPhysicalCountRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryPhysicalCountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested [InventoryPhysicalCount](entity:InventoryPhysicalCount).
	Count *InventoryPhysicalCount `json:"count,omitempty" url:"count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryPhysicalCountResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryPhysicalCountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryPhysicalCountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryPhysicalCountResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryPhysicalCountResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryTransferRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryTransferRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryTransferRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryTransferRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryTransferRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryTransferRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetInventoryTransferResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested [InventoryTransfer](entity:InventoryTransfer).
	Transfer *InventoryTransfer `json:"transfer,omitempty" url:"transfer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInventoryTransferResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInventoryTransferResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInventoryTransferResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInventoryTransferResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInventoryTransferResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Describes a `GetInvoice` request.
type GetInvoiceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInvoiceRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInvoiceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInvoiceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInvoiceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInvoiceRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Describes a `GetInvoice` response.
type GetInvoiceResponse struct {
	// The invoice requested.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetInvoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetInvoiceResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the request body for the
// [RetrieveLocation]($e/Locations/RetrieveLocation) endpoint.
type GetLocationRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLocationRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLocationRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLocationRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLocationRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLocationRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that the [RetrieveLocation]($e/Locations/RetrieveLocation)
// endpoint returns in a response.
type GetLocationResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested location.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLocationResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLocationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLocationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLocationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLocationResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve a loyalty account.
type GetLoyaltyAccountRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyAccountRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyAccountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyAccountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyAccountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyAccountRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that includes the loyalty account.
type GetLoyaltyAccountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty account.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyAccountResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyAccountResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyAccountResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve the [loyalty program]($m/LoyaltyProgram) that belongs to a seller. A seller can have only one loyalty program.
type GetLoyaltyProgramRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyProgramRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyProgramRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyProgramRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyProgramRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyProgramRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that contains the loyalty program.
type GetLoyaltyProgramResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty program that was requested.
	Program *LoyaltyProgram `json:"program,omitempty" url:"program,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyProgramResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyProgramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyProgramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyProgramResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyProgramResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveLoyaltyPromotionPromotions]($e/Loyalty/RetrieveLoyaltyPromotion) request.
type GetLoyaltyPromotionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyPromotionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyPromotionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyPromotionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyPromotionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyPromotionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveLoyaltyPromotionPromotions]($e/Loyalty/RetrieveLoyaltyPromotion) response.
type GetLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyPromotionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyPromotionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to retrieve a loyalty reward.
type GetLoyaltyRewardRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyRewardRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyRewardRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyRewardRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyRewardRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyRewardRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response that includes the loyalty reward.
type GetLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty reward retrieved.
	Reward *LoyaltyReward `json:"reward,omitempty" url:"reward,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyRewardResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Request object for the [RetrieveMerchant]($e/Merchants/RetrieveMerchant) endpoint.
type GetMerchantRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetMerchantRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetMerchantRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetMerchantRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetMerchantRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetMerchantRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The response object returned by the [RetrieveMerchant]($e/Merchants/RetrieveMerchant) endpoint.
type GetMerchantResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `Merchant` object.
	Merchant *Merchant `json:"merchant,omitempty" url:"merchant,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetMerchantResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetMerchantResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetMerchantResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetMerchantResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetMerchantResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetOrderRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrderRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrderRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetOrderResponse struct {
	// The requested order.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetOrderResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetOrderResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPaymentLinkRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentLinkRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentLinkRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentLinkRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentLinkRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentLinkRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPaymentLinkResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The payment link that is retrieved.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentLinkResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Describes a request to retrieve a refund using
// [GetPaymentRefund]($e/Refunds/GetPaymentRefund).
type GetPaymentRefundRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentRefundRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentRefundRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the response returned by [GetRefund]($e/Refunds/GetPaymentRefund).
//
// Note: If there are errors processing the request, the refund field might not be
// present or it might be present in a FAILED state.
type GetPaymentRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `PaymentRefund`.
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentRefundResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentRefundResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Describes a request to retrieve a payment using
// [GetPayment]($e/Payments/GetPayment).
type GetPaymentRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the response returned by [GetPayment]($e/Payments/GetPayment).
type GetPaymentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `Payment`.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPayoutRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPayoutRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPayoutRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPayoutRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPayoutRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPayoutRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPayoutResponse struct {
	// The requested payout.
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPayoutResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPayoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPayoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPayoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPayoutResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get a `Shift` by ID.
type GetShiftRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetShiftRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetShiftRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetShiftRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetShiftRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetShiftRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response to a request to get a `Shift`. The response contains
// the requested `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type GetShiftResponse struct {
	// The requested `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetShiftResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetShiftResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a `RetrieveSnippet` request.
type GetSnippetRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetSnippetRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetSnippetRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSnippetRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSnippetRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSnippetRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a `RetrieveSnippet` response. The response can include either `snippet` or `errors`.
type GetSnippetResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved snippet.
	Snippet *Snippet `json:"snippet,omitempty" url:"snippet,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetSnippetResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetSnippetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSnippetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSnippetResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSnippetResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines output parameters in a response from the
// [RetrieveSubscription]($e/Subscriptions/RetrieveSubscription) endpoint.
type GetSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription retrieved.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSubscriptionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTeamMemberBookingProfileRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberBookingProfileRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberBookingProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberBookingProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberBookingProfileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberBookingProfileRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTeamMemberBookingProfileResponse struct {
	// The returned team member booking profile.
	TeamMemberBookingProfile *TeamMemberBookingProfile `json:"team_member_booking_profile,omitempty" url:"team_member_booking_profile,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberBookingProfileResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberBookingProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberBookingProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberBookingProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberBookingProfileResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a retrieve request for a `TeamMember` object.
type GetTeamMemberRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a response from a retrieve request containing a `TeamMember` object or error messages.
type GetTeamMemberResponse struct {
	// The successfully retrieved `TeamMember` object.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A request to get a `TeamMemberWage`.
type GetTeamMemberWageRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberWageRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberWageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberWageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberWageRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberWageRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response to a request to get a `TeamMemberWage`. The response contains
// the requested `TeamMemberWage` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetTeamMemberWageResponse struct {
	// The requested `TeamMemberWage` object.
	TeamMemberWage *TeamMemberWage `json:"team_member_wage,omitempty" url:"team_member_wage,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTeamMemberWageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberWageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberWageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberWageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberWageResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalActionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalActionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalActionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalActionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalActionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalActionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalActionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalActionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalCheckoutRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalCheckoutRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalCheckoutRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalCheckoutRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalCheckoutRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalCheckoutRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalCheckoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalCheckoutResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalRefundRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalRefundRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalRefundRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalRefundRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalRefundRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalRefundRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `Refund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalRefundResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTransactionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTransactionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTransactionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTransactionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTransactionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTransactionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the [RetrieveTransaction](api-endpoint:Transactions-RetrieveTransaction) endpoint.
//
// One of `errors` or `transaction` is present in a given response (never both).
type GetTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested transaction.
	Transaction *Transaction `json:"transaction,omitempty" url:"transaction,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetTransactionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTransactionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTransactionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents an input to a call to [RetrieveVendor]($e/Vendors/RetrieveVendor).
type GetVendorRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetVendorRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetVendorRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVendorRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVendorRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVendorRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents an output from a call to [RetrieveVendor]($e/Vendors/RetrieveVendor).
type GetVendorResponse struct {
	// Errors encountered when the request fails.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully retrieved [Vendor](entity:Vendor) object.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetVendorResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetVendorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetVendorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetVendorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetVendorResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a retrieve request for the wage setting of a team member.
type GetWageSettingRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWageSettingRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWageSettingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWageSettingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWageSettingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWageSettingRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a response from a retrieve request containing the specified `WageSetting` object or error messages.
type GetWageSettingResponse struct {
	// The successfully retrieved `WageSetting` object.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWageSettingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWageSettingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWageSettingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWageSettingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWageSettingResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Retrieves a [Subscription]($m/WebhookSubscription) using its id.
type GetWebhookSubscriptionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWebhookSubscriptionRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWebhookSubscriptionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWebhookSubscriptionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWebhookSubscriptionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWebhookSubscriptionRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the fields that are included in the response body of
// a request to the [RetrieveWebhookSubscription]($e/WebhookSubscriptions/RetrieveWebhookSubscription) endpoint.
//
// Note: if there are errors processing the request, the [Subscription]($m/WebhookSubscription) will not be
// present.
type GetWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWebhookSubscriptionResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a Square gift card.
type GiftCard struct {
	// The Square-assigned ID of the gift card.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The gift card type.
	// See [Type](#type-type) for possible values
	Type GiftCardType `json:"type" url:"type"`
	// The source that generated the gift card account number (GAN). The default value is `SQUARE`.
	// See [GANSource](#type-gansource) for possible values
	GanSource *GiftCardGanSource `json:"gan_source,omitempty" url:"gan_source,omitempty"`
	// The current gift card state.
	// See [Status](#type-status) for possible values
	State *GiftCardStatus `json:"state,omitempty" url:"state,omitempty"`
	// The current gift card balance. This balance is always greater than or equal to zero.
	BalanceMoney *Money `json:"balance_money,omitempty" url:"balance_money,omitempty"`
	// The gift card account number (GAN). Buyers can use the GAN to make purchases or check
	// the gift card balance.
	Gan *string `json:"gan,omitempty" url:"gan,omitempty"`
	// The timestamp when the gift card was created, in RFC 3339 format.
	// In the case of a digital gift card, it is the time when you create a card
	// (using the Square Point of Sale application, Seller Dashboard, or Gift Cards API).
	// In the case of a plastic gift card, it is the time when Square associates the card with the
	// seller at the time of activation.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The IDs of the [customer profiles](entity:Customer) to whom this gift card is linked.
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCard) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCard) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCard
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCard(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCard) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents an action performed on a [gift card]($m/GiftCard) that affects its state or balance.
// A gift card activity contains information about a specific activity type. For example, a `REDEEM` activity
// includes a `redeem_activity_details` field that contains information about the redemption.
type GiftCardActivity struct {
	// The Square-assigned ID of the gift card activity.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of gift card activity.
	// See [Type](#type-type) for possible values
	Type GiftCardActivityType `json:"type" url:"type"`
	// The ID of the [business location](entity:Location) where the activity occurred.
	LocationID string `json:"location_id" url:"location_id"`
	// The timestamp when the gift card activity was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The gift card ID. When creating a gift card activity, `gift_card_id` is not required if
	// `gift_card_gan` is specified.
	GiftCardID *string `json:"gift_card_id,omitempty" url:"gift_card_id,omitempty"`
	// The gift card account number (GAN). When creating a gift card activity, `gift_card_gan`
	// is not required if `gift_card_id` is specified.
	GiftCardGan *string `json:"gift_card_gan,omitempty" url:"gift_card_gan,omitempty"`
	// The final balance on the gift card after the action is completed.
	GiftCardBalanceMoney *Money `json:"gift_card_balance_money,omitempty" url:"gift_card_balance_money,omitempty"`
	// Additional details about a `LOAD` activity, which is used to reload money onto a gift card.
	LoadActivityDetails *GiftCardActivityLoad `json:"load_activity_details,omitempty" url:"load_activity_details,omitempty"`
	// Additional details about an `ACTIVATE` activity, which is used to activate a gift card with
	// an initial balance.
	ActivateActivityDetails *GiftCardActivityActivate `json:"activate_activity_details,omitempty" url:"activate_activity_details,omitempty"`
	// Additional details about a `REDEEM` activity, which is used to redeem a gift card for a purchase.
	//
	// For applications that process payments using the Square Payments API, Square creates a `REDEEM` activity that
	// updates the gift card balance after the corresponding [CreatePayment](api-endpoint:Payments-CreatePayment)
	// request is completed. Applications that use a custom payment processing system must call
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) to create the `REDEEM` activity.
	RedeemActivityDetails *GiftCardActivityRedeem `json:"redeem_activity_details,omitempty" url:"redeem_activity_details,omitempty"`
	// Additional details about a `CLEAR_BALANCE` activity, which is used to set the balance of a gift card to zero.
	ClearBalanceActivityDetails *GiftCardActivityClearBalance `json:"clear_balance_activity_details,omitempty" url:"clear_balance_activity_details,omitempty"`
	// Additional details about a `DEACTIVATE` activity, which is used to deactivate a gift card.
	DeactivateActivityDetails *GiftCardActivityDeactivate `json:"deactivate_activity_details,omitempty" url:"deactivate_activity_details,omitempty"`
	// Additional details about an `ADJUST_INCREMENT` activity, which is used to add money to a gift card
	// outside of a typical `ACTIVATE`, `LOAD`, or `REFUND` activity flow.
	AdjustIncrementActivityDetails *GiftCardActivityAdjustIncrement `json:"adjust_increment_activity_details,omitempty" url:"adjust_increment_activity_details,omitempty"`
	// Additional details about an `ADJUST_DECREMENT` activity, which is used to deduct money from a gift
	// card outside of a typical `REDEEM` activity flow.
	AdjustDecrementActivityDetails *GiftCardActivityAdjustDecrement `json:"adjust_decrement_activity_details,omitempty" url:"adjust_decrement_activity_details,omitempty"`
	// Additional details about a `REFUND` activity, which is used to add money to a gift card when
	// refunding a payment.
	//
	// For applications that refund payments to a gift card using the Square Refunds API, Square automatically
	// creates a `REFUND` activity that updates the gift card balance after a [RefundPayment](api-endpoint:Refunds-RefundPayment)
	// request is completed. Applications that use a custom processing system must call
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) to create the `REFUND` activity.
	RefundActivityDetails *GiftCardActivityRefund `json:"refund_activity_details,omitempty" url:"refund_activity_details,omitempty"`
	// Additional details about an `UNLINKED_ACTIVITY_REFUND` activity. This activity is used to add money
	// to a gift card when refunding a payment that was processed using a custom payment processing system
	// and not linked to the gift card.
	UnlinkedActivityRefundActivityDetails *GiftCardActivityUnlinkedActivityRefund `json:"unlinked_activity_refund_activity_details,omitempty" url:"unlinked_activity_refund_activity_details,omitempty"`
	// Additional details about an `IMPORT` activity, which Square uses to import a third-party
	// gift card with a balance.
	ImportActivityDetails *GiftCardActivityImport `json:"import_activity_details,omitempty" url:"import_activity_details,omitempty"`
	// Additional details about a `BLOCK` activity, which Square uses to temporarily block a gift card.
	BlockActivityDetails *GiftCardActivityBlock `json:"block_activity_details,omitempty" url:"block_activity_details,omitempty"`
	// Additional details about an `UNBLOCK` activity, which Square uses to unblock a gift card.
	UnblockActivityDetails *GiftCardActivityUnblock `json:"unblock_activity_details,omitempty" url:"unblock_activity_details,omitempty"`
	// Additional details about an `IMPORT_REVERSAL` activity, which Square uses to reverse the
	// import of a third-party gift card.
	ImportReversalActivityDetails *GiftCardActivityImportReversal `json:"import_reversal_activity_details,omitempty" url:"import_reversal_activity_details,omitempty"`
	// Additional details about a `TRANSFER_BALANCE_TO` activity, which Square uses to add money to
	// a gift card as the result of a transfer from another gift card.
	TransferBalanceToActivityDetails *GiftCardActivityTransferBalanceTo `json:"transfer_balance_to_activity_details,omitempty" url:"transfer_balance_to_activity_details,omitempty"`
	// Additional details about a `TRANSFER_BALANCE_FROM` activity, which Square uses to deduct money from
	// a gift as the result of a transfer to another gift card.
	TransferBalanceFromActivityDetails *GiftCardActivityTransferBalanceFrom `json:"transfer_balance_from_activity_details,omitempty" url:"transfer_balance_from_activity_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivity) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivity(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivity) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `ACTIVATE` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityActivate struct {
	// The amount added to the gift card. This value is a positive integer.
	//
	// Applications that use a custom order processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the [order](entity:Order) that contains the `GIFT_CARD` line item.
	//
	// Applications that use the Square Orders API to process orders must specify the order ID
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The UID of the `GIFT_CARD` line item in the order that represents the gift card purchase.
	//
	// Applications that use the Square Orders API to process orders must specify the line item UID
	// in the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	LineItemUID *string `json:"line_item_uid,omitempty" url:"line_item_uid,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom order processing system can use this field to track information
	// related to an order or payment.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The payment instrument IDs used to process the gift card purchase, such as a credit card ID
	// or bank account ID.
	//
	// Applications that use a custom order processing system must specify payment instrument IDs in
	// the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	// Square uses this information to perform compliance checks.
	//
	// For applications that use the Square Orders API to process payments, Square has the necessary
	// instrument IDs to perform compliance checks.
	//
	// Each buyer payment instrument ID can contain a maximum of 255 characters.
	BuyerPaymentInstrumentIDs []string `json:"buyer_payment_instrument_ids,omitempty" url:"buyer_payment_instrument_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityActivate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityActivate) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityActivate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityActivate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityActivate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `ADJUST_DECREMENT` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityAdjustDecrement struct {
	// The amount deducted from the gift card balance. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The reason the gift card balance was adjusted.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityAdjustDecrementReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityAdjustDecrement) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityAdjustDecrement) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityAdjustDecrement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityAdjustDecrement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityAdjustDecrement) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for deducting money from a [gift card]($m/GiftCard).
type GiftCardActivityAdjustDecrementReason string

const (
	GiftCardActivityAdjustDecrementReasonSuspiciousActivity           GiftCardActivityAdjustDecrementReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityAdjustDecrementReasonBalanceAccidentallyIncreased GiftCardActivityAdjustDecrementReason = "BALANCE_ACCIDENTALLY_INCREASED"
	GiftCardActivityAdjustDecrementReasonSupportIssue                 GiftCardActivityAdjustDecrementReason = "SUPPORT_ISSUE"
	GiftCardActivityAdjustDecrementReasonPurchaseWasRefunded          GiftCardActivityAdjustDecrementReason = "PURCHASE_WAS_REFUNDED"
)

func NewGiftCardActivityAdjustDecrementReasonFromString(s string) (GiftCardActivityAdjustDecrementReason, error) {
	switch s {
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityAdjustDecrementReasonSuspiciousActivity, nil
	case "BALANCE_ACCIDENTALLY_INCREASED":
		return GiftCardActivityAdjustDecrementReasonBalanceAccidentallyIncreased, nil
	case "SUPPORT_ISSUE":
		return GiftCardActivityAdjustDecrementReasonSupportIssue, nil
	case "PURCHASE_WAS_REFUNDED":
		return GiftCardActivityAdjustDecrementReasonPurchaseWasRefunded, nil
	}
	var t GiftCardActivityAdjustDecrementReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityAdjustDecrementReason) Ptr() *GiftCardActivityAdjustDecrementReason {
	return &g
}

// Represents details about an `ADJUST_INCREMENT` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityAdjustIncrement struct {
	// The amount added to the gift card balance. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The reason the gift card balance was adjusted.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityAdjustIncrementReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityAdjustIncrement) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityAdjustIncrement) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityAdjustIncrement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityAdjustIncrement(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityAdjustIncrement) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for adding money to a [gift card]($m/GiftCard).
type GiftCardActivityAdjustIncrementReason string

const (
	GiftCardActivityAdjustIncrementReasonComplimentary     GiftCardActivityAdjustIncrementReason = "COMPLIMENTARY"
	GiftCardActivityAdjustIncrementReasonSupportIssue      GiftCardActivityAdjustIncrementReason = "SUPPORT_ISSUE"
	GiftCardActivityAdjustIncrementReasonTransactionVoided GiftCardActivityAdjustIncrementReason = "TRANSACTION_VOIDED"
)

func NewGiftCardActivityAdjustIncrementReasonFromString(s string) (GiftCardActivityAdjustIncrementReason, error) {
	switch s {
	case "COMPLIMENTARY":
		return GiftCardActivityAdjustIncrementReasonComplimentary, nil
	case "SUPPORT_ISSUE":
		return GiftCardActivityAdjustIncrementReasonSupportIssue, nil
	case "TRANSACTION_VOIDED":
		return GiftCardActivityAdjustIncrementReasonTransactionVoided, nil
	}
	var t GiftCardActivityAdjustIncrementReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityAdjustIncrementReason) Ptr() *GiftCardActivityAdjustIncrementReason {
	return &g
}

// Represents details about a `BLOCK` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityBlock struct {
	// The reason the gift card was blocked.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityBlockReason `json:"reason,omitempty" url:"reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityBlock) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityBlock) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityBlock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityBlock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityBlock) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for blocking a [gift card]($m/GiftCard).
type GiftCardActivityBlockReason = string

// Represents details about a `CLEAR_BALANCE` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityClearBalance struct {
	// The reason the gift card balance was cleared.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityClearBalanceReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityClearBalance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityClearBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityClearBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityClearBalance(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityClearBalance) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for clearing the balance of a [gift card]($m/GiftCard).
type GiftCardActivityClearBalanceReason string

const (
	GiftCardActivityClearBalanceReasonSuspiciousActivity GiftCardActivityClearBalanceReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityClearBalanceReasonReuseGiftcard      GiftCardActivityClearBalanceReason = "REUSE_GIFTCARD"
	GiftCardActivityClearBalanceReasonUnknownReason      GiftCardActivityClearBalanceReason = "UNKNOWN_REASON"
)

func NewGiftCardActivityClearBalanceReasonFromString(s string) (GiftCardActivityClearBalanceReason, error) {
	switch s {
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityClearBalanceReasonSuspiciousActivity, nil
	case "REUSE_GIFTCARD":
		return GiftCardActivityClearBalanceReasonReuseGiftcard, nil
	case "UNKNOWN_REASON":
		return GiftCardActivityClearBalanceReasonUnknownReason, nil
	}
	var t GiftCardActivityClearBalanceReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityClearBalanceReason) Ptr() *GiftCardActivityClearBalanceReason {
	return &g
}

// Represents details about a `DEACTIVATE` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityDeactivate struct {
	// The reason the gift card was deactivated.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityDeactivateReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityDeactivate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityDeactivate) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityDeactivate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityDeactivate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityDeactivate) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for deactivating a [gift card]($m/GiftCard).
type GiftCardActivityDeactivateReason string

const (
	GiftCardActivityDeactivateReasonSuspiciousActivity   GiftCardActivityDeactivateReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityDeactivateReasonUnknownReason        GiftCardActivityDeactivateReason = "UNKNOWN_REASON"
	GiftCardActivityDeactivateReasonChargebackDeactivate GiftCardActivityDeactivateReason = "CHARGEBACK_DEACTIVATE"
)

func NewGiftCardActivityDeactivateReasonFromString(s string) (GiftCardActivityDeactivateReason, error) {
	switch s {
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityDeactivateReasonSuspiciousActivity, nil
	case "UNKNOWN_REASON":
		return GiftCardActivityDeactivateReasonUnknownReason, nil
	case "CHARGEBACK_DEACTIVATE":
		return GiftCardActivityDeactivateReasonChargebackDeactivate, nil
	}
	var t GiftCardActivityDeactivateReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityDeactivateReason) Ptr() *GiftCardActivityDeactivateReason {
	return &g
}

// Represents details about an `IMPORT` [gift card activity type]($m/GiftCardActivityType).
// This activity type is used when Square imports a third-party gift card, in which case the
// `gan_source` of the gift card is set to `OTHER`.
type GiftCardActivityImport struct {
	// The balance amount on the imported gift card.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityImport) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityImport) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityImport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityImport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityImport) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `IMPORT_REVERSAL` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityImportReversal struct {
	// The amount of money cleared from the third-party gift card when
	// the import was reversed.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityImportReversal) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityImportReversal) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityImportReversal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityImportReversal(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityImportReversal) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `LOAD` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityLoad struct {
	// The amount added to the gift card. This value is a positive integer.
	//
	// Applications that use a custom order processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the [order](entity:Order) that contains the `GIFT_CARD` line item.
	//
	// Applications that use the Square Orders API to process orders must specify the order ID in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The UID of the `GIFT_CARD` line item in the order that represents the additional funds for the gift card.
	//
	// Applications that use the Square Orders API to process orders must specify the line item UID
	// in the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	LineItemUID *string `json:"line_item_uid,omitempty" url:"line_item_uid,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom order processing system can use this field to track information related to
	// an order or payment.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The payment instrument IDs used to process the order for the additional funds, such as a credit card ID
	// or bank account ID.
	//
	// Applications that use a custom order processing system must specify payment instrument IDs in
	// the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	// Square uses this information to perform compliance checks.
	//
	// For applications that use the Square Orders API to process payments, Square has the necessary
	// instrument IDs to perform compliance checks.
	//
	// Each buyer payment instrument ID can contain a maximum of 255 characters.
	BuyerPaymentInstrumentIDs []string `json:"buyer_payment_instrument_ids,omitempty" url:"buyer_payment_instrument_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityLoad) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityLoad) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityLoad
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityLoad(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityLoad) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `REDEEM` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityRedeem struct {
	// The amount deducted from the gift card for the redemption. This value is a positive integer.
	//
	// Applications that use a custom payment processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the payment that represents the gift card redemption. Square populates this field
	// if the payment was processed by Square.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom payment processing system can use this field to track information
	// related to an order or payment.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The status of the gift card redemption. Gift cards redeemed from Square Point of Sale or the
	// Square Seller Dashboard use a two-state process: `PENDING`
	// to `COMPLETED` or `PENDING` to `CANCELED`. Gift cards redeemed using the Gift Card Activities API
	// always have a `COMPLETED` status.
	// See [Status](#type-status) for possible values
	Status *GiftCardActivityRedeemStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityRedeem) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityRedeem) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityRedeem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityRedeem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityRedeem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the status of a [gift card]($m/GiftCard) redemption. This status is relevant only for
// redemptions made from Square products (such as Square Point of Sale) because Square products use a
// two-state process. Gift cards redeemed using the Gift Card Activities API always have a `COMPLETED` status.
type GiftCardActivityRedeemStatus string

const (
	GiftCardActivityRedeemStatusPending   GiftCardActivityRedeemStatus = "PENDING"
	GiftCardActivityRedeemStatusCompleted GiftCardActivityRedeemStatus = "COMPLETED"
	GiftCardActivityRedeemStatusCanceled  GiftCardActivityRedeemStatus = "CANCELED"
)

func NewGiftCardActivityRedeemStatusFromString(s string) (GiftCardActivityRedeemStatus, error) {
	switch s {
	case "PENDING":
		return GiftCardActivityRedeemStatusPending, nil
	case "COMPLETED":
		return GiftCardActivityRedeemStatusCompleted, nil
	case "CANCELED":
		return GiftCardActivityRedeemStatusCanceled, nil
	}
	var t GiftCardActivityRedeemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityRedeemStatus) Ptr() *GiftCardActivityRedeemStatus {
	return &g
}

// Represents details about a `REFUND` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityRefund struct {
	// The ID of the refunded `REDEEM` gift card activity. Square populates this field if the
	// `payment_id` in the corresponding [RefundPayment](api-endpoint:Refunds-RefundPayment) request
	// represents a gift card redemption.
	//
	// For applications that use a custom payment processing system, this field is required when creating
	// a `REFUND` activity. The provided `REDEEM` activity ID must be linked to the same gift card.
	RedeemActivityID *string `json:"redeem_activity_id,omitempty" url:"redeem_activity_id,omitempty"`
	// The amount added to the gift card for the refund. This value is a positive integer.
	//
	// This field is required when creating a `REFUND` activity. The amount can represent a full or partial refund.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The ID of the refunded payment. Square populates this field if the refund is for a
	// payment processed by Square. This field matches the `payment_id` in the corresponding
	// [RefundPayment](api-endpoint:Refunds-RefundPayment) request.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityRefund) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityRefund) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `TRANSFER_BALANCE_FROM` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityTransferBalanceFrom struct {
	// The ID of the gift card to which the specified amount was transferred.
	TransferToGiftCardID string `json:"transfer_to_gift_card_id" url:"transfer_to_gift_card_id"`
	// The amount deducted from the gift card for the transfer. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityTransferBalanceFrom) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityTransferBalanceFrom) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityTransferBalanceFrom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityTransferBalanceFrom(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityTransferBalanceFrom) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `TRANSFER_BALANCE_TO` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityTransferBalanceTo struct {
	// The ID of the gift card from which the specified amount was transferred.
	TransferFromGiftCardID string `json:"transfer_from_gift_card_id" url:"transfer_from_gift_card_id"`
	// The amount added to the gift card balance for the transfer. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityTransferBalanceTo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityTransferBalanceTo) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityTransferBalanceTo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityTransferBalanceTo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityTransferBalanceTo) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the type of [gift card activity]($m/GiftCardActivity).
type GiftCardActivityType string

const (
	GiftCardActivityTypeActivate               GiftCardActivityType = "ACTIVATE"
	GiftCardActivityTypeLoad                   GiftCardActivityType = "LOAD"
	GiftCardActivityTypeRedeem                 GiftCardActivityType = "REDEEM"
	GiftCardActivityTypeClearBalance           GiftCardActivityType = "CLEAR_BALANCE"
	GiftCardActivityTypeDeactivate             GiftCardActivityType = "DEACTIVATE"
	GiftCardActivityTypeAdjustIncrement        GiftCardActivityType = "ADJUST_INCREMENT"
	GiftCardActivityTypeAdjustDecrement        GiftCardActivityType = "ADJUST_DECREMENT"
	GiftCardActivityTypeRefund                 GiftCardActivityType = "REFUND"
	GiftCardActivityTypeUnlinkedActivityRefund GiftCardActivityType = "UNLINKED_ACTIVITY_REFUND"
	GiftCardActivityTypeImport                 GiftCardActivityType = "IMPORT"
	GiftCardActivityTypeBlock                  GiftCardActivityType = "BLOCK"
	GiftCardActivityTypeUnblock                GiftCardActivityType = "UNBLOCK"
	GiftCardActivityTypeImportReversal         GiftCardActivityType = "IMPORT_REVERSAL"
	GiftCardActivityTypeTransferBalanceFrom    GiftCardActivityType = "TRANSFER_BALANCE_FROM"
	GiftCardActivityTypeTransferBalanceTo      GiftCardActivityType = "TRANSFER_BALANCE_TO"
)

func NewGiftCardActivityTypeFromString(s string) (GiftCardActivityType, error) {
	switch s {
	case "ACTIVATE":
		return GiftCardActivityTypeActivate, nil
	case "LOAD":
		return GiftCardActivityTypeLoad, nil
	case "REDEEM":
		return GiftCardActivityTypeRedeem, nil
	case "CLEAR_BALANCE":
		return GiftCardActivityTypeClearBalance, nil
	case "DEACTIVATE":
		return GiftCardActivityTypeDeactivate, nil
	case "ADJUST_INCREMENT":
		return GiftCardActivityTypeAdjustIncrement, nil
	case "ADJUST_DECREMENT":
		return GiftCardActivityTypeAdjustDecrement, nil
	case "REFUND":
		return GiftCardActivityTypeRefund, nil
	case "UNLINKED_ACTIVITY_REFUND":
		return GiftCardActivityTypeUnlinkedActivityRefund, nil
	case "IMPORT":
		return GiftCardActivityTypeImport, nil
	case "BLOCK":
		return GiftCardActivityTypeBlock, nil
	case "UNBLOCK":
		return GiftCardActivityTypeUnblock, nil
	case "IMPORT_REVERSAL":
		return GiftCardActivityTypeImportReversal, nil
	case "TRANSFER_BALANCE_FROM":
		return GiftCardActivityTypeTransferBalanceFrom, nil
	case "TRANSFER_BALANCE_TO":
		return GiftCardActivityTypeTransferBalanceTo, nil
	}
	var t GiftCardActivityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityType) Ptr() *GiftCardActivityType {
	return &g
}

// Represents details about an `UNBLOCK` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityUnblock struct {
	// The reason the gift card was unblocked.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityUnblockReason `json:"reason,omitempty" url:"reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityUnblock) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUnblock) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUnblock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUnblock(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUnblock) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for unblocking a [gift card]($m/GiftCard).
type GiftCardActivityUnblockReason = string

// Represents details about an `UNLINKED_ACTIVITY_REFUND` [gift card activity type]($m/GiftCardActivityType).
type GiftCardActivityUnlinkedActivityRefund struct {
	// The amount added to the gift card for the refund. This value is a positive integer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The ID of the refunded payment. This field is not used starting in Square version 2022-06-16.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GiftCardActivityUnlinkedActivityRefund) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUnlinkedActivityRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUnlinkedActivityRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUnlinkedActivityRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUnlinkedActivityRefund) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the source that generated the gift card
// account number (GAN).
type GiftCardGanSource string

const (
	GiftCardGanSourceSquare GiftCardGanSource = "SQUARE"
	GiftCardGanSourceOther  GiftCardGanSource = "OTHER"
)

func NewGiftCardGanSourceFromString(s string) (GiftCardGanSource, error) {
	switch s {
	case "SQUARE":
		return GiftCardGanSourceSquare, nil
	case "OTHER":
		return GiftCardGanSourceOther, nil
	}
	var t GiftCardGanSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardGanSource) Ptr() *GiftCardGanSource {
	return &g
}

// Indicates the gift card state.
type GiftCardStatus string

const (
	GiftCardStatusActive      GiftCardStatus = "ACTIVE"
	GiftCardStatusDeactivated GiftCardStatus = "DEACTIVATED"
	GiftCardStatusBlocked     GiftCardStatus = "BLOCKED"
	GiftCardStatusPending     GiftCardStatus = "PENDING"
)

func NewGiftCardStatusFromString(s string) (GiftCardStatus, error) {
	switch s {
	case "ACTIVE":
		return GiftCardStatusActive, nil
	case "DEACTIVATED":
		return GiftCardStatusDeactivated, nil
	case "BLOCKED":
		return GiftCardStatusBlocked, nil
	case "PENDING":
		return GiftCardStatusPending, nil
	}
	var t GiftCardStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardStatus) Ptr() *GiftCardStatus {
	return &g
}

// Indicates the gift card type.
type GiftCardType string

const (
	GiftCardTypePhysical GiftCardType = "PHYSICAL"
	GiftCardTypeDigital  GiftCardType = "DIGITAL"
)

func NewGiftCardTypeFromString(s string) (GiftCardType, error) {
	switch s {
	case "PHYSICAL":
		return GiftCardTypePhysical, nil
	case "DIGITAL":
		return GiftCardTypeDigital, nil
	}
	var t GiftCardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardType) Ptr() *GiftCardType {
	return &g
}

// Represents a change in state or quantity of product inventory at a
// particular time and location.
type InventoryAdjustment struct {
	// A unique ID generated by Square for the
	// `InventoryAdjustment`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional ID provided by the application to tie the
	// `InventoryAdjustment` to an external
	// system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The [inventory state](entity:InventoryState) of the related quantity
	// of items before the adjustment.
	// See [InventoryState](#type-inventorystate) for possible values
	FromState *InventoryState `json:"from_state,omitempty" url:"from_state,omitempty"`
	// The [inventory state](entity:InventoryState) of the related quantity
	// of items after the adjustment.
	// See [InventoryState](#type-inventorystate) for possible values
	ToState *InventoryState `json:"to_state,omitempty" url:"to_state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The number of items affected by the adjustment as a decimal string.
	// Can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The total price paid for goods associated with the
	// adjustment. Present if and only if `to_state` is `SOLD`. Always
	// non-negative.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// A client-generated RFC 3339-formatted timestamp that indicates when
	// the inventory adjustment took place. For inventory adjustment updates, the `occurred_at`
	// timestamp cannot be older than 24 hours or in the future relative to the
	// time of the request.
	OccurredAt *string `json:"occurred_at,omitempty" url:"occurred_at,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the inventory adjustment is received.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Information about the application that caused the
	// inventory adjustment.
	Source *SourceApplication `json:"source,omitempty" url:"source,omitempty"`
	// The Square-generated ID of the [Employee](entity:Employee) responsible for the
	// inventory adjustment.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The Square-generated ID of the [Team Member](entity:TeamMember) responsible for the
	// inventory adjustment.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The Square-generated ID of the [Transaction](entity:Transaction) that
	// caused the adjustment. Only relevant for payment-related state
	// transitions.
	TransactionID *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The Square-generated ID of the [Refund](entity:Refund) that
	// caused the adjustment. Only relevant for refund-related state
	// transitions.
	RefundID *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`
	// The Square-generated ID of the purchase order that caused the
	// adjustment. Only relevant for state transitions from the Square for Retail
	// app.
	PurchaseOrderID *string `json:"purchase_order_id,omitempty" url:"purchase_order_id,omitempty"`
	// The Square-generated ID of the goods receipt that caused the
	// adjustment. Only relevant for state transitions from the Square for Retail
	// app.
	GoodsReceiptID *string `json:"goods_receipt_id,omitempty" url:"goods_receipt_id,omitempty"`
	// An adjustment group bundling the related adjustments of item variations through stock conversions in a single inventory event.
	AdjustmentGroup *InventoryAdjustmentGroup `json:"adjustment_group,omitempty" url:"adjustment_group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryAdjustment) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryAdjustment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryAdjustment) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InventoryAdjustmentGroup struct {
	// A unique ID generated by Square for the
	// `InventoryAdjustmentGroup`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The inventory adjustment of the composed variation.
	RootAdjustmentID *string `json:"root_adjustment_id,omitempty" url:"root_adjustment_id,omitempty"`
	// Representative `from_state` for adjustments within the group. For example, for a group adjustment from `IN_STOCK` to `SOLD`,
	// there can be two component adjustments in the group: one from `IN_STOCK`to `COMPOSED` and the other one from `COMPOSED` to `SOLD`.
	// Here, the representative `from_state` for the `InventoryAdjustmentGroup` is `IN_STOCK`.
	// See [InventoryState](#type-inventorystate) for possible values
	FromState *InventoryState `json:"from_state,omitempty" url:"from_state,omitempty"`
	// Representative `to_state` for adjustments within group. For example, for a group adjustment from `IN_STOCK` to `SOLD`,
	// the two component adjustments in the group can be from `IN_STOCK` to `COMPOSED` and from `COMPOSED` to `SOLD`.
	// Here, the representative `to_state` of the `InventoryAdjustmentGroup` is `SOLD`.
	// See [InventoryState](#type-inventorystate) for possible values
	ToState *InventoryState `json:"to_state,omitempty" url:"to_state,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryAdjustmentGroup) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryAdjustmentGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryAdjustmentGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryAdjustmentGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryAdjustmentGroup) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates whether Square should alert the merchant when the inventory quantity of a CatalogItemVariation is low.
type InventoryAlertType string

const (
	InventoryAlertTypeNone        InventoryAlertType = "NONE"
	InventoryAlertTypeLowQuantity InventoryAlertType = "LOW_QUANTITY"
)

func NewInventoryAlertTypeFromString(s string) (InventoryAlertType, error) {
	switch s {
	case "NONE":
		return InventoryAlertTypeNone, nil
	case "LOW_QUANTITY":
		return InventoryAlertTypeLowQuantity, nil
	}
	var t InventoryAlertType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryAlertType) Ptr() *InventoryAlertType {
	return &i
}

// Represents a single physical count, inventory, adjustment, or transfer
// that is part of the history of inventory changes for a particular
// [CatalogObject]($m/CatalogObject) instance.
type InventoryChange struct {
	// Indicates how the inventory change is applied. See
	// [InventoryChangeType](entity:InventoryChangeType) for all possible values.
	// See [InventoryChangeType](#type-inventorychangetype) for possible values
	Type *InventoryChangeType `json:"type,omitempty" url:"type,omitempty"`
	// Contains details about the physical count when `type` is
	// `PHYSICAL_COUNT`, and is unset for all other change types.
	PhysicalCount *InventoryPhysicalCount `json:"physical_count,omitempty" url:"physical_count,omitempty"`
	// Contains details about the inventory adjustment when `type` is
	// `ADJUSTMENT`, and is unset for all other change types.
	Adjustment *InventoryAdjustment `json:"adjustment,omitempty" url:"adjustment,omitempty"`
	// Contains details about the inventory transfer when `type` is
	// `TRANSFER`, and is unset for all other change types.
	//
	// _Note:_ An [InventoryTransfer](entity:InventoryTransfer) object can only be set in the input to the
	// [BatchChangeInventory](api-endpoint:Inventory-BatchChangeInventory) endpoint when the seller has an active Retail Plus subscription.
	Transfer *InventoryTransfer `json:"transfer,omitempty" url:"transfer,omitempty"`
	// The [CatalogMeasurementUnit](entity:CatalogMeasurementUnit) object representing the catalog measurement unit associated with the inventory change.
	MeasurementUnit *CatalogMeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// The ID of the [CatalogMeasurementUnit](entity:CatalogMeasurementUnit) object representing the catalog measurement unit associated with the inventory change.
	MeasurementUnitID *string `json:"measurement_unit_id,omitempty" url:"measurement_unit_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryChange) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryChange) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryChange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryChange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryChange) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates how the inventory change was applied to a tracked product quantity.
type InventoryChangeType string

const (
	InventoryChangeTypePhysicalCount InventoryChangeType = "PHYSICAL_COUNT"
	InventoryChangeTypeAdjustment    InventoryChangeType = "ADJUSTMENT"
	InventoryChangeTypeTransfer      InventoryChangeType = "TRANSFER"
)

func NewInventoryChangeTypeFromString(s string) (InventoryChangeType, error) {
	switch s {
	case "PHYSICAL_COUNT":
		return InventoryChangeTypePhysicalCount, nil
	case "ADJUSTMENT":
		return InventoryChangeTypeAdjustment, nil
	case "TRANSFER":
		return InventoryChangeTypeTransfer, nil
	}
	var t InventoryChangeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryChangeType) Ptr() *InventoryChangeType {
	return &i
}

// Represents Square-estimated quantity of items in a particular state at a
// particular seller location based on the known history of physical counts and
// inventory adjustments.
type InventoryCount struct {
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The current [inventory state](entity:InventoryState) for the related
	// quantity of items.
	// See [InventoryState](#type-inventorystate) for possible values
	State *InventoryState `json:"state,omitempty" url:"state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The number of items affected by the estimated count as a decimal string.
	// Can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the most recent physical count or adjustment affecting
	// the estimated count is received.
	CalculatedAt *string `json:"calculated_at,omitempty" url:"calculated_at,omitempty"`
	// Whether the inventory count is for composed variation (TRUE) or not (FALSE). If true, the inventory count will not be present in the response of
	// any of these endpoints: [BatchChangeInventory]($e/Inventory/BatchChangeInventory),
	// [BatchRetrieveInventoryChanges]($e/Inventory/BatchRetrieveInventoryChanges),
	// [BatchRetrieveInventoryCounts]($e/Inventory/BatchRetrieveInventoryCounts), and
	// [RetrieveInventoryChanges]($e/Inventory/RetrieveInventoryChanges).
	IsEstimated *bool `json:"is_estimated,omitempty" url:"is_estimated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryCount) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCount) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCount) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents the quantity of an item variation that is physically present
// at a specific location, verified by a seller or a seller's employee. For example,
// a physical count might come from an employee counting the item variations on
// hand or from syncing with an external system.
type InventoryPhysicalCount struct {
	// A unique Square-generated ID for the
	// [InventoryPhysicalCount](entity:InventoryPhysicalCount).
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional ID provided by the application to tie the
	// [InventoryPhysicalCount](entity:InventoryPhysicalCount) to an external
	// system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The current [inventory state](entity:InventoryState) for the related
	// quantity of items.
	// See [InventoryState](#type-inventorystate) for possible values
	State *InventoryState `json:"state,omitempty" url:"state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items is being tracked.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The number of items affected by the physical count as a decimal string.
	// The number can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// Information about the application with which the
	// physical count is submitted.
	Source *SourceApplication `json:"source,omitempty" url:"source,omitempty"`
	// The Square-generated ID of the [Employee](entity:Employee) responsible for the
	// physical count.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The Square-generated ID of the [Team Member](entity:TeamMember) responsible for the
	// physical count.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// A client-generated RFC 3339-formatted timestamp that indicates when
	// the physical count was examined. For physical count updates, the `occurred_at`
	// timestamp cannot be older than 24 hours or in the future relative to the
	// time of the request.
	OccurredAt *string `json:"occurred_at,omitempty" url:"occurred_at,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the physical count is received.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryPhysicalCount) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryPhysicalCount) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryPhysicalCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryPhysicalCount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryPhysicalCount) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates the state of a tracked item quantity in the lifecycle of goods.
type InventoryState string

const (
	InventoryStateCustom                  InventoryState = "CUSTOM"
	InventoryStateInStock                 InventoryState = "IN_STOCK"
	InventoryStateSold                    InventoryState = "SOLD"
	InventoryStateReturnedByCustomer      InventoryState = "RETURNED_BY_CUSTOMER"
	InventoryStateReservedForSale         InventoryState = "RESERVED_FOR_SALE"
	InventoryStateSoldOnline              InventoryState = "SOLD_ONLINE"
	InventoryStateOrderedFromVendor       InventoryState = "ORDERED_FROM_VENDOR"
	InventoryStateReceivedFromVendor      InventoryState = "RECEIVED_FROM_VENDOR"
	InventoryStateInTransitTo             InventoryState = "IN_TRANSIT_TO"
	InventoryStateNone                    InventoryState = "NONE"
	InventoryStateWaste                   InventoryState = "WASTE"
	InventoryStateUnlinkedReturn          InventoryState = "UNLINKED_RETURN"
	InventoryStateComposed                InventoryState = "COMPOSED"
	InventoryStateDecomposed              InventoryState = "DECOMPOSED"
	InventoryStateSupportedByNewerVersion InventoryState = "SUPPORTED_BY_NEWER_VERSION"
	InventoryStateInTransit               InventoryState = "IN_TRANSIT"
)

func NewInventoryStateFromString(s string) (InventoryState, error) {
	switch s {
	case "CUSTOM":
		return InventoryStateCustom, nil
	case "IN_STOCK":
		return InventoryStateInStock, nil
	case "SOLD":
		return InventoryStateSold, nil
	case "RETURNED_BY_CUSTOMER":
		return InventoryStateReturnedByCustomer, nil
	case "RESERVED_FOR_SALE":
		return InventoryStateReservedForSale, nil
	case "SOLD_ONLINE":
		return InventoryStateSoldOnline, nil
	case "ORDERED_FROM_VENDOR":
		return InventoryStateOrderedFromVendor, nil
	case "RECEIVED_FROM_VENDOR":
		return InventoryStateReceivedFromVendor, nil
	case "IN_TRANSIT_TO":
		return InventoryStateInTransitTo, nil
	case "NONE":
		return InventoryStateNone, nil
	case "WASTE":
		return InventoryStateWaste, nil
	case "UNLINKED_RETURN":
		return InventoryStateUnlinkedReturn, nil
	case "COMPOSED":
		return InventoryStateComposed, nil
	case "DECOMPOSED":
		return InventoryStateDecomposed, nil
	case "SUPPORTED_BY_NEWER_VERSION":
		return InventoryStateSupportedByNewerVersion, nil
	case "IN_TRANSIT":
		return InventoryStateInTransit, nil
	}
	var t InventoryState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryState) Ptr() *InventoryState {
	return &i
}

// Represents the transfer of a quantity of product inventory at a
// particular time from one location to another.
type InventoryTransfer struct {
	// A unique ID generated by Square for the
	// `InventoryTransfer`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional ID provided by the application to tie the
	// `InventoryTransfer` to an external system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The [inventory state](entity:InventoryState) for the quantity of
	// items being transferred.
	// See [InventoryState](#type-inventorystate) for possible values
	State *InventoryState `json:"state,omitempty" url:"state,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items was tracked before the transfer.
	FromLocationID *string `json:"from_location_id,omitempty" url:"from_location_id,omitempty"`
	// The Square-generated ID of the [Location](entity:Location) where the related
	// quantity of items was tracked after the transfer.
	ToLocationID *string `json:"to_location_id,omitempty" url:"to_location_id,omitempty"`
	// The Square-generated ID of the
	// [CatalogObject](entity:CatalogObject) being tracked.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The [type](entity:CatalogObjectType) of the [CatalogObject](entity:CatalogObject) being tracked.
	//
	// The Inventory API supports setting and reading the `"catalog_object_type": "ITEM_VARIATION"` field value.
	// In addition, it can also read the `"catalog_object_type": "ITEM"` field value that is set by the Square Restaurants app.
	CatalogObjectType *string `json:"catalog_object_type,omitempty" url:"catalog_object_type,omitempty"`
	// The number of items affected by the transfer as a decimal string.
	// Can support up to 5 digits after the decimal point.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// A client-generated RFC 3339-formatted timestamp that indicates when
	// the transfer took place. For write actions, the `occurred_at` timestamp
	// cannot be older than 24 hours or in the future relative to the time of the
	// request.
	OccurredAt *string `json:"occurred_at,omitempty" url:"occurred_at,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when Square
	// received the transfer request.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Information about the application that initiated the
	// inventory transfer.
	Source *SourceApplication `json:"source,omitempty" url:"source,omitempty"`
	// The Square-generated ID of the [Employee](entity:Employee) responsible for the
	// inventory transfer.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The Square-generated ID of the [Team Member](entity:TeamMember) responsible for the
	// inventory transfer.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InventoryTransfer) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryTransfer) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryTransfer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryTransfer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryTransfer) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Stores information about an invoice. You use the Invoices API to create and manage
// invoices. For more information, see [Invoices API Overview](https://developer.squareup.com/docs/invoices-api/overview).
type Invoice struct {
	// The Square-assigned ID of the invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The Square-assigned version number, which is incremented each time an update is committed to the invoice.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the location that this invoice is associated with.
	//
	// If specified in a `CreateInvoice` request, the value must match the `location_id` of the associated order.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the [order](entity:Order) for which the invoice is created.
	// This field is required when creating an invoice, and the order must be in the `OPEN` state.
	//
	// To view the line items and other information for the associated order, call the
	// [RetrieveOrder](api-endpoint:Orders-RetrieveOrder) endpoint using the order ID.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The customer who receives the invoice. This customer data is displayed on the invoice and used by Square to deliver the invoice.
	//
	// This field is required to publish an invoice, and it must specify the `customer_id`.
	PrimaryRecipient *InvoiceRecipient `json:"primary_recipient,omitempty" url:"primary_recipient,omitempty"`
	// The payment schedule for the invoice, represented by one or more payment requests that
	// define payment settings, such as amount due and due date. An invoice supports the following payment request combinations:
	//
	// - One balance
	// - One deposit with one balance
	// - 2–12 installments
	// - One deposit with 2–12 installments
	//
	// This field is required when creating an invoice. It must contain at least one payment request.
	// All payment requests for the invoice must equal the total order amount. For more information, see
	// [Configuring payment requests](https://developer.squareup.com/docs/invoices-api/create-publish-invoices#payment-requests).
	//
	// Adding `INSTALLMENT` payment requests to an invoice requires an
	// [Invoices Plus subscription](https://developer.squareup.com/docs/invoices-api/overview#invoices-plus-subscription).
	PaymentRequests []*InvoicePaymentRequest `json:"payment_requests,omitempty" url:"payment_requests,omitempty"`
	// The delivery method that Square uses to send the invoice, reminders, and receipts to
	// the customer. After the invoice is published, Square processes the invoice based on the delivery
	// method and payment request settings, either immediately or on the `scheduled_at` date, if specified.
	// For example, Square might send the invoice or receipt for an automatic payment. For invoices with
	// automatic payments, this field must be set to `EMAIL`.
	//
	// One of the following is required when creating an invoice:
	//
	//   - (Recommended) This `delivery_method` field. To configure an automatic payment, the
	//     `automatic_payment_source` field of the payment request is also required.
	//   - The deprecated `request_method` field of the payment request. Note that `invoice`
	//     objects returned in responses do not include `request_method`.
	//     See [InvoiceDeliveryMethod](#type-invoicedeliverymethod) for possible values
	DeliveryMethod *InvoiceDeliveryMethod `json:"delivery_method,omitempty" url:"delivery_method,omitempty"`
	// A user-friendly invoice number that is displayed on the invoice. The value is unique within a location.
	// If not provided when creating an invoice, Square assigns a value.
	// It increments from 1 and is padded with zeros making it 7 characters long
	// (for example, 0000001 and 0000002).
	InvoiceNumber *string `json:"invoice_number,omitempty" url:"invoice_number,omitempty"`
	// The title of the invoice, which is displayed on the invoice.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// The description of the invoice, which is displayed on the invoice.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The timestamp when the invoice is scheduled for processing, in RFC 3339 format.
	// After the invoice is published, Square processes the invoice on the specified date,
	// according to the delivery method and payment request settings.
	//
	// If the field is not set, Square processes the invoice immediately after it is published.
	ScheduledAt *string `json:"scheduled_at,omitempty" url:"scheduled_at,omitempty"`
	// The URL of the Square-hosted invoice page.
	// After you publish the invoice using the `PublishInvoice` endpoint, Square hosts the invoice
	// page and returns the page URL in the response.
	PublicURL *string `json:"public_url,omitempty" url:"public_url,omitempty"`
	// The current amount due for the invoice. In addition to the
	// amount due on the next payment request, this includes any overdue payment amounts.
	NextPaymentAmountMoney *Money `json:"next_payment_amount_money,omitempty" url:"next_payment_amount_money,omitempty"`
	// The status of the invoice.
	// See [InvoiceStatus](#type-invoicestatus) for possible values
	Status *InvoiceStatus `json:"status,omitempty" url:"status,omitempty"`
	// The time zone used to interpret calendar dates on the invoice, such as `due_date`.
	// When an invoice is created, this field is set to the `timezone` specified for the seller
	// location. The value cannot be changed.
	//
	// For example, a payment `due_date` of 2021-03-09 with a `timezone` of America/Los_Angeles
	// becomes overdue at midnight on March 9 in America/Los_Angeles (which equals a UTC timestamp
	// of 2021-03-10T08:00:00Z).
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// The timestamp when the invoice was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the invoice was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The payment methods that customers can use to pay the invoice on the Square-hosted
	// invoice page. This setting is independent of any automatic payment requests for the invoice.
	//
	// This field is required when creating an invoice and must set at least one payment method to `true`.
	AcceptedPaymentMethods *InvoiceAcceptedPaymentMethods `json:"accepted_payment_methods,omitempty" url:"accepted_payment_methods,omitempty"`
	// Additional seller-defined fields that are displayed on the invoice. For more information, see
	// [Custom fields](https://developer.squareup.com/docs/invoices-api/overview#custom-fields).
	//
	// Adding custom fields to an invoice requires an
	// [Invoices Plus subscription](https://developer.squareup.com/docs/invoices-api/overview#invoices-plus-subscription).
	//
	// Max: 2 custom fields
	CustomFields []*InvoiceCustomField `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The ID of the [subscription](entity:Subscription) associated with the invoice.
	// This field is present only on subscription billing invoices.
	SubscriptionID *string `json:"subscription_id,omitempty" url:"subscription_id,omitempty"`
	// The date of the sale or the date that the service is rendered, in `YYYY-MM-DD` format.
	// This field can be used to specify a past or future date which is displayed on the invoice.
	SaleOrServiceDate *string `json:"sale_or_service_date,omitempty" url:"sale_or_service_date,omitempty"`
	// **France only.** The payment terms and conditions that are displayed on the invoice. For more information,
	// see [Payment conditions](https://developer.squareup.com/docs/invoices-api/overview#payment-conditions).
	//
	// For countries other than France, Square returns an `INVALID_REQUEST_ERROR` with a `BAD_REQUEST` code and
	// "Payment conditions are not supported for this location's country" detail if this field is included in `CreateInvoice` or `UpdateInvoice` requests.
	PaymentConditions *string `json:"payment_conditions,omitempty" url:"payment_conditions,omitempty"`
	// Indicates whether to allow a customer to save a credit or debit card as a card on file or a bank transfer as a
	// bank account on file. If `true`, Square displays a **Save my card on file** or **Save my bank on file** checkbox on the
	// invoice payment page. Stored payment information can be used for future automatic payments. The default value is `false`.
	StorePaymentMethodEnabled *bool `json:"store_payment_method_enabled,omitempty" url:"store_payment_method_enabled,omitempty"`
	// Metadata about the attachments on the invoice. Invoice attachments are managed using the
	// [CreateInvoiceAttachment](api-endpoint:Invoices-CreateInvoiceAttachment) and [DeleteInvoiceAttachment](api-endpoint:Invoices-DeleteInvoiceAttachment) endpoints.
	Attachments []*InvoiceAttachment `json:"attachments,omitempty" url:"attachments,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *Invoice) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Invoice) UnmarshalJSON(data []byte) error {
	type unmarshaler Invoice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Invoice(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Invoice) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The payment methods that customers can use to pay an [invoice]($m/Invoice) on the Square-hosted invoice payment page.
type InvoiceAcceptedPaymentMethods struct {
	// Indicates whether credit card or debit card payments are accepted. The default value is `false`.
	Card *bool `json:"card,omitempty" url:"card,omitempty"`
	// Indicates whether Square gift card payments are accepted. The default value is `false`.
	SquareGiftCard *bool `json:"square_gift_card,omitempty" url:"square_gift_card,omitempty"`
	// Indicates whether ACH bank transfer payments are accepted. The default value is `false`.
	BankAccount *bool `json:"bank_account,omitempty" url:"bank_account,omitempty"`
	// Indicates whether Afterpay (also known as Clearpay) payments are accepted. The default value is `false`.
	//
	// This option is allowed only for invoices that have a single payment request of the `BALANCE` type. This payment method is
	// supported if the seller account accepts Afterpay payments and the seller location is in a country where Afterpay
	// invoice payments are supported. As a best practice, consider enabling an additional payment method when allowing
	// `buy_now_pay_later` payments. For more information, including detailed requirements and processing limits, see
	// [Buy Now Pay Later payments with Afterpay](https://developer.squareup.com/docs/invoices-api/overview#buy-now-pay-later).
	BuyNowPayLater *bool `json:"buy_now_pay_later,omitempty" url:"buy_now_pay_later,omitempty"`
	// Indicates whether Cash App payments are accepted. The default value is `false`.
	//
	// This payment method is supported only for seller [locations](entity:Location) in the United States.
	CashAppPay *bool `json:"cash_app_pay,omitempty" url:"cash_app_pay,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceAcceptedPaymentMethods) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceAcceptedPaymentMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceAcceptedPaymentMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceAcceptedPaymentMethods(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceAcceptedPaymentMethods) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents a file attached to an [invoice]($m/Invoice).
type InvoiceAttachment struct {
	// The Square-assigned ID of the attachment.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The file name of the attachment, which is displayed on the invoice.
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	// The description of the attachment, which is displayed on the invoice.
	// This field maps to the seller-defined **Message** field.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The file size of the attachment in bytes.
	Filesize *int `json:"filesize,omitempty" url:"filesize,omitempty"`
	// The MD5 hash that was generated from the file contents.
	Hash *string `json:"hash,omitempty" url:"hash,omitempty"`
	// The mime type of the attachment.
	// The following mime types are supported:
	// image/gif, image/jpeg, image/png, image/tiff, image/bmp, application/pdf.
	MimeType *string `json:"mime_type,omitempty" url:"mime_type,omitempty"`
	// The timestamp when the attachment was uploaded, in RFC 3339 format.
	UploadedAt *string `json:"uploaded_at,omitempty" url:"uploaded_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceAttachment) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceAttachment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceAttachment) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates the automatic payment method for an [invoice payment request]($m/InvoicePaymentRequest).
type InvoiceAutomaticPaymentSource string

const (
	InvoiceAutomaticPaymentSourceNone       InvoiceAutomaticPaymentSource = "NONE"
	InvoiceAutomaticPaymentSourceCardOnFile InvoiceAutomaticPaymentSource = "CARD_ON_FILE"
	InvoiceAutomaticPaymentSourceBankOnFile InvoiceAutomaticPaymentSource = "BANK_ON_FILE"
)

func NewInvoiceAutomaticPaymentSourceFromString(s string) (InvoiceAutomaticPaymentSource, error) {
	switch s {
	case "NONE":
		return InvoiceAutomaticPaymentSourceNone, nil
	case "CARD_ON_FILE":
		return InvoiceAutomaticPaymentSourceCardOnFile, nil
	case "BANK_ON_FILE":
		return InvoiceAutomaticPaymentSourceBankOnFile, nil
	}
	var t InvoiceAutomaticPaymentSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceAutomaticPaymentSource) Ptr() *InvoiceAutomaticPaymentSource {
	return &i
}

// An additional seller-defined and customer-facing field to include on the invoice. For more information,
// see [Custom fields](https://developer.squareup.com/docs/invoices-api/overview#custom-fields).
//
// Adding custom fields to an invoice requires an
// [Invoices Plus subscription](https://developer.squareup.com/docs/invoices-api/overview#invoices-plus-subscription).
type InvoiceCustomField struct {
	// The label or title of the custom field. This field is required for a custom field.
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// The text of the custom field. If omitted, only the label is rendered.
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// The location of the custom field on the invoice. This field is required for a custom field.
	// See [InvoiceCustomFieldPlacement](#type-invoicecustomfieldplacement) for possible values
	Placement *InvoiceCustomFieldPlacement `json:"placement,omitempty" url:"placement,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceCustomField) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCustomField) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCustomField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCustomField(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCustomField) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Indicates where to render a custom field on the Square-hosted invoice page and in emailed or PDF
// copies of the invoice.
type InvoiceCustomFieldPlacement string

const (
	InvoiceCustomFieldPlacementAboveLineItems InvoiceCustomFieldPlacement = "ABOVE_LINE_ITEMS"
	InvoiceCustomFieldPlacementBelowLineItems InvoiceCustomFieldPlacement = "BELOW_LINE_ITEMS"
)

func NewInvoiceCustomFieldPlacementFromString(s string) (InvoiceCustomFieldPlacement, error) {
	switch s {
	case "ABOVE_LINE_ITEMS":
		return InvoiceCustomFieldPlacementAboveLineItems, nil
	case "BELOW_LINE_ITEMS":
		return InvoiceCustomFieldPlacementBelowLineItems, nil
	}
	var t InvoiceCustomFieldPlacement
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceCustomFieldPlacement) Ptr() *InvoiceCustomFieldPlacement {
	return &i
}

// Indicates how Square delivers the [invoice]($m/Invoice) to the customer.
type InvoiceDeliveryMethod string

const (
	InvoiceDeliveryMethodEmail         InvoiceDeliveryMethod = "EMAIL"
	InvoiceDeliveryMethodShareManually InvoiceDeliveryMethod = "SHARE_MANUALLY"
	InvoiceDeliveryMethodSms           InvoiceDeliveryMethod = "SMS"
)

func NewInvoiceDeliveryMethodFromString(s string) (InvoiceDeliveryMethod, error) {
	switch s {
	case "EMAIL":
		return InvoiceDeliveryMethodEmail, nil
	case "SHARE_MANUALLY":
		return InvoiceDeliveryMethodShareManually, nil
	case "SMS":
		return InvoiceDeliveryMethodSms, nil
	}
	var t InvoiceDeliveryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceDeliveryMethod) Ptr() *InvoiceDeliveryMethod {
	return &i
}

// Describes query filters to apply.
type InvoiceFilter struct {
	// Limits the search to the specified locations. A location is required.
	// In the current implementation, only one location can be specified.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Limits the search to the specified customers, within the specified locations.
	// Specifying a customer is optional. In the current implementation,
	// a maximum of one customer can be specified.
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceFilter) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceFilter) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Describes a payment request reminder (automatic notification) that Square sends
// to the customer. You configure a reminder relative to the payment request
// `due_date`.
type InvoicePaymentReminder struct {
	// A Square-assigned ID that uniquely identifies the reminder within the
	// `InvoicePaymentRequest`.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The number of days before (a negative number) or after (a positive number)
	// the payment request `due_date` when the reminder is sent. For example, -3 indicates that
	// the reminder should be sent 3 days before the payment request `due_date`.
	RelativeScheduledDays *int `json:"relative_scheduled_days,omitempty" url:"relative_scheduled_days,omitempty"`
	// The reminder message.
	Message *string `json:"message,omitempty" url:"message,omitempty"`
	// The status of the reminder.
	// See [InvoicePaymentReminderStatus](#type-invoicepaymentreminderstatus) for possible values
	Status *InvoicePaymentReminderStatus `json:"status,omitempty" url:"status,omitempty"`
	// If sent, the timestamp when the reminder was sent, in RFC 3339 format.
	SentAt *string `json:"sent_at,omitempty" url:"sent_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePaymentReminder) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentReminder) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentReminder
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentReminder(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentReminder) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The status of a payment request reminder.
type InvoicePaymentReminderStatus string

const (
	InvoicePaymentReminderStatusPending       InvoicePaymentReminderStatus = "PENDING"
	InvoicePaymentReminderStatusNotApplicable InvoicePaymentReminderStatus = "NOT_APPLICABLE"
	InvoicePaymentReminderStatusSent          InvoicePaymentReminderStatus = "SENT"
)

func NewInvoicePaymentReminderStatusFromString(s string) (InvoicePaymentReminderStatus, error) {
	switch s {
	case "PENDING":
		return InvoicePaymentReminderStatusPending, nil
	case "NOT_APPLICABLE":
		return InvoicePaymentReminderStatusNotApplicable, nil
	case "SENT":
		return InvoicePaymentReminderStatusSent, nil
	}
	var t InvoicePaymentReminderStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoicePaymentReminderStatus) Ptr() *InvoicePaymentReminderStatus {
	return &i
}

// Represents a payment request for an [invoice]($m/Invoice). Invoices can specify a maximum
// of 13 payment requests, with up to 12 `INSTALLMENT` request types. For more information,
// see [Configuring payment requests](https://developer.squareup.com/docs/invoices-api/create-publish-invoices#payment-requests).
//
// Adding `INSTALLMENT` payment requests to an invoice requires an
// [Invoices Plus subscription](https://developer.squareup.com/docs/invoices-api/overview#invoices-plus-subscription).
type InvoicePaymentRequest struct {
	// The Square-generated ID of the payment request in an [invoice](entity:Invoice).
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Indicates how Square processes the payment request. DEPRECATED at version 2021-01-21. Replaced by the
	// `Invoice.delivery_method` and `InvoicePaymentRequest.automatic_payment_source` fields.
	//
	// One of the following is required when creating an invoice:
	//
	//   - (Recommended) The `delivery_method` field of the invoice. To configure an automatic payment, the
	//     `automatic_payment_source` field of the payment request is also required.
	//   - This `request_method` field. Note that `invoice` objects returned in responses do not include `request_method`.
	//     See [InvoiceRequestMethod](#type-invoicerequestmethod) for possible values
	RequestMethod *InvoiceRequestMethod `json:"request_method,omitempty" url:"request_method,omitempty"`
	// Identifies the payment request type. This type defines how the payment request amount is determined.
	// This field is required to create a payment request.
	// See [InvoiceRequestType](#type-invoicerequesttype) for possible values
	RequestType *InvoiceRequestType `json:"request_type,omitempty" url:"request_type,omitempty"`
	// The due date (in the invoice's time zone) for the payment request, in `YYYY-MM-DD` format. This field
	// is required to create a payment request. If an `automatic_payment_source` is defined for the request, Square
	// charges the payment source on this date.
	//
	// After this date, the invoice becomes overdue. For example, a payment `due_date` of 2021-03-09 with a `timezone`
	// of America/Los_Angeles becomes overdue at midnight on March 9 in America/Los_Angeles (which equals a UTC
	// timestamp of 2021-03-10T08:00:00Z).
	DueDate *string `json:"due_date,omitempty" url:"due_date,omitempty"`
	// If the payment request specifies `DEPOSIT` or `INSTALLMENT` as the `request_type`,
	// this indicates the request amount.
	// You cannot specify this when `request_type` is `BALANCE` or when the
	// payment request includes the `percentage_requested` field.
	FixedAmountRequestedMoney *Money `json:"fixed_amount_requested_money,omitempty" url:"fixed_amount_requested_money,omitempty"`
	// Specifies the amount for the payment request in percentage:
	//
	//   - When the payment `request_type` is `DEPOSIT`, it is the percentage of the order's total amount.
	//   - When the payment `request_type` is `INSTALLMENT`, it is the percentage of the order's total less
	//     the deposit, if requested. The sum of the `percentage_requested` in all installment
	//     payment requests must be equal to 100.
	//
	// You cannot specify this when the payment `request_type` is `BALANCE` or when the
	// payment request specifies the `fixed_amount_requested_money` field.
	PercentageRequested *string `json:"percentage_requested,omitempty" url:"percentage_requested,omitempty"`
	// If set to true, the Square-hosted invoice page (the `public_url` field of the invoice)
	// provides a place for the customer to pay a tip.
	//
	// This field is allowed only on the final payment request
	// and the payment `request_type` must be `BALANCE` or `INSTALLMENT`.
	TippingEnabled *bool `json:"tipping_enabled,omitempty" url:"tipping_enabled,omitempty"`
	// The payment method for an automatic payment.
	//
	// The default value is `NONE`.
	// See [InvoiceAutomaticPaymentSource](#type-invoiceautomaticpaymentsource) for possible values
	AutomaticPaymentSource *InvoiceAutomaticPaymentSource `json:"automatic_payment_source,omitempty" url:"automatic_payment_source,omitempty"`
	// The ID of the credit or debit card on file to charge for the payment request. To get the cards on file for a customer,
	// call [ListCards](api-endpoint:Cards-ListCards) and include the `customer_id` of the invoice recipient.
	CardID *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// A list of one or more reminders to send for the payment request.
	Reminders []*InvoicePaymentReminder `json:"reminders,omitempty" url:"reminders,omitempty"`
	// The amount of the payment request, computed using the order amount and information from the various payment
	// request fields (`request_type`, `fixed_amount_requested_money`, and `percentage_requested`).
	ComputedAmountMoney *Money `json:"computed_amount_money,omitempty" url:"computed_amount_money,omitempty"`
	// The amount of money already paid for the specific payment request.
	// This amount might include a rounding adjustment if the most recent invoice payment
	// was in cash in a currency that rounds cash payments (such as, `CAD` or `AUD`).
	TotalCompletedAmountMoney *Money `json:"total_completed_amount_money,omitempty" url:"total_completed_amount_money,omitempty"`
	// If the most recent payment was a cash payment
	// in a currency that rounds cash payments (such as, `CAD` or `AUD`) and the payment
	// is rounded from `computed_amount_money` in the payment request, then this
	// field specifies the rounding adjustment applied. This amount
	// might be negative.
	RoundingAdjustmentIncludedMoney *Money `json:"rounding_adjustment_included_money,omitempty" url:"rounding_adjustment_included_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoicePaymentRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Describes query criteria for searching invoices.
type InvoiceQuery struct {
	// Query filters to apply in searching invoices.
	// For more information, see [Search for invoices](https://developer.squareup.com/docs/invoices-api/retrieve-list-search-invoices#search-invoices).
	Filter *InvoiceFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Describes the sort order for the search result.
	Sort *InvoiceSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceQuery) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceQuery) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents a snapshot of customer data. This object stores customer data that is displayed on the invoice
// and that Square uses to deliver the invoice.
//
// When you provide a customer ID for a draft invoice, Square retrieves the associated customer profile and populates
// the remaining `InvoiceRecipient` fields. You cannot update these fields after the invoice is published.
// Square updates the customer ID in response to a merge operation, but does not update other fields.
type InvoiceRecipient struct {
	// The ID of the customer. This is the customer profile ID that
	// you provide when creating a draft invoice.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The recipient's given (that is, first) name.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The recipient's family (that is, last) name.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// The recipient's email address.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The recipient's physical address.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The recipient's phone number.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The name of the recipient's company.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// The recipient's tax IDs. The country of the seller account determines whether this field
	// is available for the customer. For more information, see [Invoice recipient tax IDs](https://developer.squareup.com/docs/invoices-api/overview#recipient-tax-ids).
	TaxIDs *InvoiceRecipientTaxIDs `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRecipient) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRecipient) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents the tax IDs for an invoice recipient. The country of the seller account determines
// whether the corresponding `tax_ids` field is available for the customer. For more information,
// see [Invoice recipient tax IDs](https://developer.squareup.com/docs/invoices-api/overview#recipient-tax-ids).
type InvoiceRecipientTaxIDs struct {
	// The EU VAT identification number for the invoice recipient. For example, `IE3426675K`.
	EuVat *string `json:"eu_vat,omitempty" url:"eu_vat,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceRecipientTaxIDs) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRecipientTaxIDs) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRecipientTaxIDs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRecipientTaxIDs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRecipientTaxIDs) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Specifies the action for Square to take for processing the invoice. For example,
// email the invoice, charge a customer's card on file, or do nothing. DEPRECATED at
// version 2021-01-21. The corresponding `request_method` field is replaced by the
// `Invoice.delivery_method` and `InvoicePaymentRequest.automatic_payment_source` fields.
type InvoiceRequestMethod string

const (
	InvoiceRequestMethodEmail               InvoiceRequestMethod = "EMAIL"
	InvoiceRequestMethodChargeCardOnFile    InvoiceRequestMethod = "CHARGE_CARD_ON_FILE"
	InvoiceRequestMethodShareManually       InvoiceRequestMethod = "SHARE_MANUALLY"
	InvoiceRequestMethodChargeBankOnFile    InvoiceRequestMethod = "CHARGE_BANK_ON_FILE"
	InvoiceRequestMethodSms                 InvoiceRequestMethod = "SMS"
	InvoiceRequestMethodSmsChargeCardOnFile InvoiceRequestMethod = "SMS_CHARGE_CARD_ON_FILE"
	InvoiceRequestMethodSmsChargeBankOnFile InvoiceRequestMethod = "SMS_CHARGE_BANK_ON_FILE"
)

func NewInvoiceRequestMethodFromString(s string) (InvoiceRequestMethod, error) {
	switch s {
	case "EMAIL":
		return InvoiceRequestMethodEmail, nil
	case "CHARGE_CARD_ON_FILE":
		return InvoiceRequestMethodChargeCardOnFile, nil
	case "SHARE_MANUALLY":
		return InvoiceRequestMethodShareManually, nil
	case "CHARGE_BANK_ON_FILE":
		return InvoiceRequestMethodChargeBankOnFile, nil
	case "SMS":
		return InvoiceRequestMethodSms, nil
	case "SMS_CHARGE_CARD_ON_FILE":
		return InvoiceRequestMethodSmsChargeCardOnFile, nil
	case "SMS_CHARGE_BANK_ON_FILE":
		return InvoiceRequestMethodSmsChargeBankOnFile, nil
	}
	var t InvoiceRequestMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceRequestMethod) Ptr() *InvoiceRequestMethod {
	return &i
}

// Indicates the type of the payment request. For more information, see
// [Configuring payment requests](https://developer.squareup.com/docs/invoices-api/create-publish-invoices#payment-requests).
type InvoiceRequestType string

const (
	InvoiceRequestTypeBalance     InvoiceRequestType = "BALANCE"
	InvoiceRequestTypeDeposit     InvoiceRequestType = "DEPOSIT"
	InvoiceRequestTypeInstallment InvoiceRequestType = "INSTALLMENT"
)

func NewInvoiceRequestTypeFromString(s string) (InvoiceRequestType, error) {
	switch s {
	case "BALANCE":
		return InvoiceRequestTypeBalance, nil
	case "DEPOSIT":
		return InvoiceRequestTypeDeposit, nil
	case "INSTALLMENT":
		return InvoiceRequestTypeInstallment, nil
	}
	var t InvoiceRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceRequestType) Ptr() *InvoiceRequestType {
	return &i
}

// Identifies the sort field and sort order.
type InvoiceSort struct {
	// The field to use for sorting.
	// See [InvoiceSortField](#type-invoicesortfield) for possible values
	Field InvoiceSortField `json:"field,omitempty" url:"field,omitempty"`
	// The order to use for sorting the results.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InvoiceSort) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceSort) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceSort) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// The field to use for sorting.
type InvoiceSortField = string

// Indicates the status of an invoice.
type InvoiceStatus string

const (
	InvoiceStatusDraft             InvoiceStatus = "DRAFT"
	InvoiceStatusUnpaid            InvoiceStatus = "UNPAID"
	InvoiceStatusScheduled         InvoiceStatus = "SCHEDULED"
	InvoiceStatusPartiallyPaid     InvoiceStatus = "PARTIALLY_PAID"
	InvoiceStatusPaid              InvoiceStatus = "PAID"
	InvoiceStatusPartiallyRefunded InvoiceStatus = "PARTIALLY_REFUNDED"
	InvoiceStatusRefunded          InvoiceStatus = "REFUNDED"
	InvoiceStatusCanceled          InvoiceStatus = "CANCELED"
	InvoiceStatusFailed            InvoiceStatus = "FAILED"
	InvoiceStatusPaymentPending    InvoiceStatus = "PAYMENT_PENDING"
)

func NewInvoiceStatusFromString(s string) (InvoiceStatus, error) {
	switch s {
	case "DRAFT":
		return InvoiceStatusDraft, nil
	case "UNPAID":
		return InvoiceStatusUnpaid, nil
	case "SCHEDULED":
		return InvoiceStatusScheduled, nil
	case "PARTIALLY_PAID":
		return InvoiceStatusPartiallyPaid, nil
	case "PAID":
		return InvoiceStatusPaid, nil
	case "PARTIALLY_REFUNDED":
		return InvoiceStatusPartiallyRefunded, nil
	case "REFUNDED":
		return InvoiceStatusRefunded, nil
	case "CANCELED":
		return InvoiceStatusCanceled, nil
	case "FAILED":
		return InvoiceStatusFailed, nil
	case "PAYMENT_PENDING":
		return InvoiceStatusPaymentPending, nil
	}
	var t InvoiceStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InvoiceStatus) Ptr() *InvoiceStatus {
	return &i
}

// Price and inventory alerting overrides for a `CatalogItemVariation` at a specific `Location`.
type ItemVariationLocationOverrides struct {
	// The ID of the `Location`. This can include locations that are deactivated.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The price of the `CatalogItemVariation` at the given `Location`, or blank for variable pricing.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// The pricing type (fixed or variable) for the `CatalogItemVariation` at the given `Location`.
	// See [CatalogPricingType](#type-catalogpricingtype) for possible values
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	// If `true`, inventory tracking is active for the `CatalogItemVariation` at this `Location`.
	TrackInventory *bool `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	// Indicates whether the `CatalogItemVariation` displays an alert when its inventory
	// quantity is less than or equal to its `inventory_alert_threshold`.
	// See [InventoryAlertType](#type-inventoryalerttype) for possible values
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Indicates whether the overridden item variation is sold out at the specified location.
	//
	// When inventory tracking is enabled on the item variation either globally or at the specified location,
	// the item variation is automatically marked as sold out when its inventory count reaches zero. The seller
	// can manually set the item variation as sold out even when the inventory count is greater than zero.
	// Attempts by an application to set this attribute are ignored. Regardless how the sold-out status is set,
	// applications should treat its inventory count as zero when this attribute value is `true`.
	SoldOut *bool `json:"sold_out,omitempty" url:"sold_out,omitempty"`
	// The seller-assigned timestamp, of the RFC 3339 format, to indicate when this sold-out variation
	// becomes available again at the specified location. Attempts by an application to set this attribute are ignored.
	// When the current time is later than this attribute value, the affected item variation is no longer sold out.
	SoldOutValidUntil *string `json:"sold_out_valid_until,omitempty" url:"sold_out_valid_until,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *ItemVariationLocationOverrides) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemVariationLocationOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemVariationLocationOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemVariationLocationOverrides(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemVariationLocationOverrides) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// An object describing a job that a team member is assigned to.
type JobAssignment struct {
	// The title of the job.
	JobTitle string `json:"job_title" url:"job_title"`
	// The current pay type for the job assignment used to
	// calculate the pay amount in a pay period.
	// See [JobAssignmentPayType](#type-jobassignmentpaytype) for possible values
	PayType JobAssignmentPayType `json:"pay_type" url:"pay_type"`
	// The hourly pay rate of the job.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// The total pay amount for a 12-month period on the job. Set if the job `PayType` is `SALARY`.
	AnnualRate *Money `json:"annual_rate,omitempty" url:"annual_rate,omitempty"`
	// The planned hours per week for the job. Set if the job `PayType` is `SALARY`.
	WeeklyHours *int `json:"weekly_hours,omitempty" url:"weekly_hours,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (j *JobAssignment) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobAssignment) UnmarshalJSON(data []byte) error {
	type unmarshaler JobAssignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobAssignment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties

	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobAssignment) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// Enumerates the possible pay types that a job can be assigned.
type JobAssignmentPayType string

const (
	JobAssignmentPayTypeNone   JobAssignmentPayType = "NONE"
	JobAssignmentPayTypeHourly JobAssignmentPayType = "HOURLY"
	JobAssignmentPayTypeSalary JobAssignmentPayType = "SALARY"
)

func NewJobAssignmentPayTypeFromString(s string) (JobAssignmentPayType, error) {
	switch s {
	case "NONE":
		return JobAssignmentPayTypeNone, nil
	case "HOURLY":
		return JobAssignmentPayTypeHourly, nil
	case "SALARY":
		return JobAssignmentPayTypeSalary, nil
	}
	var t JobAssignmentPayType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobAssignmentPayType) Ptr() *JobAssignmentPayType {
	return &j
}

// A response that contains the linked `GiftCard` object. If the request resulted in errors,
// the response contains a set of `Error` objects.
type LinkCustomerToGiftCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The gift card with the ID of the linked customer listed in the `customer_ids` field.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LinkCustomerToGiftCardResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LinkCustomerToGiftCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler LinkCustomerToGiftCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LinkCustomerToGiftCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LinkCustomerToGiftCardResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Request object for fetching all `BankAccount`
// objects linked to a account.
type ListBankAccountsRequest struct {
	// The pagination cursor returned by a previous call to this endpoint.
	// Use it in the next `ListBankAccounts` request to retrieve the next set
	// of results.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Upper limit on the number of bank accounts to return in the response.
	// Currently, 1000 is the largest supported limit. You can specify a limit
	// of up to 1000 bank accounts. This is also the default limit.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Location ID. You can specify this optional filter
	// to retrieve only the linked bank accounts belonging to a specific location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBankAccountsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBankAccountsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBankAccountsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBankAccountsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBankAccountsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Response object returned by ListBankAccounts.
type ListBankAccountsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// List of BankAccounts associated with this account.
	BankAccounts []*BankAccount `json:"bank_accounts,omitempty" url:"bank_accounts,omitempty"`
	// When a response is truncated, it includes a cursor that you can
	// use in a subsequent request to fetch next set of bank accounts.
	// If empty, this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBankAccountsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBankAccountsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBankAccountsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBankAccountsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBankAccountsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListBookingCustomAttributeDefinitions]($e/BookingCustomAttributes/ListBookingCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListBookingCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBookingCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBookingCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBookingCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBookingCustomAttributeDefinitionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBookingCustomAttributeDefinitionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListBookingCustomAttributes]($e/BookingCustomAttributes/ListBookingCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListBookingCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	//
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBookingCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBookingCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBookingCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBookingCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBookingCustomAttributesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBookingsRequest struct {
	// The maximum number of results per page to return in a paged response.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// The pagination cursor from the preceding response to return the next page of the results. Do not set this when retrieving the first page of the results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The [customer](entity:Customer) for whom to retrieve bookings. If this is not set, bookings for all customers are retrieved.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The team member for whom to retrieve bookings. If this is not set, bookings of all members are retrieved.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The location for which to retrieve bookings. If this is not set, all locations' bookings are retrieved.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The RFC 3339 timestamp specifying the earliest of the start time. If this is not set, the current time is used.
	StartAtMin *string `json:"start_at_min,omitempty" url:"start_at_min,omitempty"`
	// The RFC 3339 timestamp specifying the latest of the start time. If this is not set, the time of 31 days after `start_at_min` is used.
	StartAtMax *string `json:"start_at_max,omitempty" url:"start_at_max,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBookingsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBookingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBookingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBookingsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBookingsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBookingsResponse struct {
	// The list of targeted bookings.
	Bookings []*Booking `json:"bookings,omitempty" url:"bookings,omitempty"`
	// The pagination cursor to be used in the subsequent request to get the next page of the results. Stop retrieving the next page of the results when the cursor is not set.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBookingsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBookingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBookingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBookingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBookingsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request for a filtered set of `BreakType` objects.
type ListBreakTypesRequest struct {
	// Filter the returned `BreakType` results to only those that are associated with the
	// specified location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The maximum number of `BreakType` results to return per page. The number can range between 1
	// and 200. The default is 200.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// A pointer to the next page of `BreakType` results to fetch.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBreakTypesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBreakTypesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBreakTypesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBreakTypesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBreakTypesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `BreakType` objects. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type ListBreakTypesResponse struct {
	// A page of `BreakType` results.
	BreakTypes []*BreakType `json:"break_types,omitempty" url:"break_types,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `BreakType` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListBreakTypesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBreakTypesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBreakTypesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBreakTypesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBreakTypesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Retrieves details for a specific Card. Accessible via
// HTTP requests at GET https://connect.squareup.com/v2/cards
type ListCardsRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for your original query.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Limit results to cards associated with the customer supplied.
	// By default, all cards owned by the merchant are returned.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// Includes disabled cards.
	// By default, all enabled cards owned by the merchant are returned.
	IncludeDisabled *bool `json:"include_disabled,omitempty" url:"include_disabled,omitempty"`
	// Limit results to cards associated with the reference_id supplied.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Sorts the returned list by when the card was created with the specified order.
	// This field defaults to ASC.
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCardsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCardsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCardsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCardsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCardsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListCards]($e/Cards/ListCards) endpoint.
//
// Note: if there are errors processing the request, the card field will not be
// present.
type ListCardsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested list of `Card`s.
	Cards []*Card `json:"cards,omitempty" url:"cards,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCardsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCardsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCardsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCardsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCardsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftEventsRequest struct {
	// The ID of the location to list cash drawer shifts for.
	LocationID string `json:"location_id" url:"location_id"`
	// Number of resources to be returned in a page of results (200 by
	// default, 1000 max).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Opaque cursor for fetching the next page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCashDrawerShiftEventsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftEventsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftEventsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftEventsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftEventsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftEventsResponse struct {
	// Opaque cursor for fetching the next page. Cursor is not present in
	// the last page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// All of the events (payments, refunds, etc.) for a cash drawer during
	// the shift.
	CashDrawerShiftEvents []*CashDrawerShiftEvent `json:"cash_drawer_shift_events,omitempty" url:"cash_drawer_shift_events,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCashDrawerShiftEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftEventsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftsRequest struct {
	// The ID of the location to query for a list of cash drawer shifts.
	LocationID string `json:"location_id" url:"location_id"`
	// The order in which cash drawer shifts are listed in the response,
	// based on their opened_at field. Default value: ASC
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// The inclusive start time of the query on opened_at, in ISO 8601 format.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// The exclusive end date of the query on opened_at, in ISO 8601 format.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// Number of cash drawer shift events in a page of results (200 by
	// default, 1000 max).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Opaque cursor for fetching the next page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCashDrawerShiftsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftsResponse struct {
	// Opaque cursor for fetching the next page of results. Cursor is not
	// present in the last page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A collection of CashDrawerShiftSummary objects for shifts that match
	// the query.
	CashDrawerShifts []*CashDrawerShiftSummary `json:"cash_drawer_shifts,omitempty" url:"cash_drawer_shifts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCashDrawerShiftsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCatalogRequest struct {
	// The pagination cursor returned in the previous response. Leave unset for an initial request.
	// The page size is currently set to be 100.
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// An optional case-insensitive, comma-separated list of object types to retrieve.
	//
	// The valid values are defined in the [CatalogObjectType](entity:CatalogObjectType) enum, for example,
	// `ITEM`, `ITEM_VARIATION`, `CATEGORY`, `DISCOUNT`, `TAX`,
	// `MODIFIER`, `MODIFIER_LIST`, `IMAGE`, etc.
	//
	// If this is unspecified, the operation returns objects of all the top level types at the version
	// of the Square API used to make the request. Object types that are nested onto other object types
	// are not included in the defaults.
	//
	// At the current API version the default object types are:
	// ITEM, CATEGORY, TAX, DISCOUNT, MODIFIER_LIST,
	// PRICING_RULE, PRODUCT_SET, TIME_PERIOD, MEASUREMENT_UNIT,
	// SUBSCRIPTION_PLAN, ITEM_OPTION, CUSTOM_ATTRIBUTE_DEFINITION, QUICK_AMOUNT_SETTINGS.
	Types *string `json:"types,omitempty" url:"types,omitempty"`
	// The specific version of the catalog objects to be included in the response.
	// This allows you to retrieve historical versions of objects. The specified version value is matched against
	// the [CatalogObject]($m/CatalogObject)s' `version` attribute. If not included, results will be from the
	// current version of the catalog.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCatalogRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCatalogRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCatalogRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCatalogRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCatalogRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCatalogResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset, this is the final response.
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The CatalogObjects returned.
	Objects []*CatalogObject `json:"objects,omitempty" url:"objects,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCatalogResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCatalogResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCatalogResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCatalogResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCatalogResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListCustomerCustomAttributeDefinitions]($e/CustomerCustomAttributes/ListCustomerCustomAttributeDefinitions) request.
type ListCustomerCustomAttributeDefinitionsRequest struct {
	// The maximum number of results to return in a single paged response. This limit is advisory.
	// The response might contain more or fewer results. The minimum value is 1 and the maximum value is 100.
	// The default value is 20. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// The cursor returned in the paged response from the previous call to this endpoint.
	// Provide this cursor to retrieve the next page of results for your original request.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerCustomAttributeDefinitionsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerCustomAttributeDefinitionsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerCustomAttributeDefinitionsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerCustomAttributeDefinitionsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerCustomAttributeDefinitionsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListCustomerCustomAttributeDefinitions]($e/CustomerCustomAttributes/ListCustomerCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListCustomerCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerCustomAttributeDefinitionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListCustomerCustomAttributes]($e/CustomerCustomAttributes/ListCustomerCustomAttributes) request.
type ListCustomerCustomAttributesRequest struct {
	// The maximum number of results to return in a single paged response. This limit is advisory.
	// The response might contain more or fewer results. The minimum value is 1 and the maximum value is 100.
	// The default value is 20. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// The cursor returned in the paged response from the previous call to this endpoint.
	// Provide this cursor to retrieve the next page of results for your original request. For more
	// information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Indicates whether to return the [custom attribute definition](entity:CustomAttributeDefinition) in the `definition` field of each
	// custom attribute. Set this parameter to `true` to get the name and description of each custom
	// attribute, information about the data type, or other definition details. The default value is `false`.
	WithDefinitions *bool `json:"with_definitions,omitempty" url:"with_definitions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerCustomAttributesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerCustomAttributesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerCustomAttributesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerCustomAttributesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerCustomAttributesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListCustomerCustomAttributes]($e/CustomerCustomAttributes/ListCustomerCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListCustomerCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	//
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerCustomAttributesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the query parameters that can be included in a request to the
// [ListCustomerGroups]($e/CustomerGroups/ListCustomerGroups) endpoint.
type ListCustomerGroupsRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for your original query.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The maximum number of results to return in a single page. This limit is advisory. The response might contain more or fewer results.
	// If the limit is less than 1 or greater than 50, Square returns a `400 VALUE_TOO_LOW` or `400 VALUE_TOO_HIGH` error. The default value is 50.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerGroupsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerGroupsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerGroupsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerGroupsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerGroupsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListCustomerGroups]($e/CustomerGroups/ListCustomerGroups) endpoint.
//
// Either `errors` or `groups` is present in a given response (never both).
type ListCustomerGroupsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A list of customer groups belonging to the current seller.
	Groups []*CustomerGroup `json:"groups,omitempty" url:"groups,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint. This value is present only if the request
	// succeeded and additional results are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerGroupsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerGroupsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerGroupsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerGroupsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerGroupsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the valid parameters for requests to the `ListCustomerSegments` endpoint.
type ListCustomerSegmentsRequest struct {
	// A pagination cursor returned by previous calls to `ListCustomerSegments`.
	// This cursor is used to retrieve the next set of query results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The maximum number of results to return in a single page. This limit is advisory. The response might contain more or fewer results.
	// If the specified limit is less than 1 or greater than 50, Square returns a `400 VALUE_TOO_LOW` or `400 VALUE_TOO_HIGH` error. The default value is 50.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerSegmentsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerSegmentsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerSegmentsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerSegmentsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerSegmentsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body for requests to the `ListCustomerSegments` endpoint.
//
// Either `errors` or `segments` is present in a given response (never both).
type ListCustomerSegmentsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of customer segments belonging to the associated Square account.
	Segments []*CustomerSegment `json:"segments,omitempty" url:"segments,omitempty"`
	// A pagination cursor to be used in subsequent calls to `ListCustomerSegments`
	// to retrieve the next set of query results. The cursor is only present if the request succeeded and
	// additional results are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomerSegmentsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerSegmentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerSegmentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerSegmentsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerSegmentsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the query parameters that can be included in a request to the
// `ListCustomers` endpoint.
type ListCustomersRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for your original query.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The maximum number of results to return in a single page. This limit is advisory. The response might contain more or fewer results.
	// If the specified limit is less than 1 or greater than 100, Square returns a `400 VALUE_TOO_LOW` or `400 VALUE_TOO_HIGH` error. The default value is 100.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Indicates how customers should be sorted.
	//
	// The default value is `DEFAULT`.
	// See [CustomerSortField](#type-customersortfield) for possible values
	SortField *CustomerSortField `json:"sort_field,omitempty" url:"sort_field,omitempty"`
	// Indicates whether customers should be sorted in ascending (`ASC`) or
	// descending (`DESC`) order.
	//
	// The default value is `ASC`.
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// Indicates whether to return the total count of customers in the `count` field of the response.
	//
	// The default value is `false`.
	Count *bool `json:"count,omitempty" url:"count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomersRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomersRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomersRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomersRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomersRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the `ListCustomers` endpoint.
//
// Either `errors` or `customers` is present in a given response (never both).
type ListCustomersResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The customer profiles associated with the Square account or an empty object (`{}`) if none are found.
	// Only customer profiles with public information (`given_name`, `family_name`, `company_name`, `email_address`, or
	// `phone_number`) are included in the response.
	Customers []*Customer `json:"customers,omitempty" url:"customers,omitempty"`
	// A pagination cursor to retrieve the next set of results for the
	// original query. A cursor is only present if the request succeeded and additional results
	// are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The total count of customers associated with the Square account. Only customer profiles with public information
	// (`given_name`, `family_name`, `company_name`, `email_address`, or `phone_number`) are counted. This field is present
	// only if `count` is set to `true` in the request.
	Count *int64 `json:"count,omitempty" url:"count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListCustomersResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomersResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListDeviceCodesRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for your original query.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// If specified, only returns DeviceCodes of the specified location.
	// Returns DeviceCodes of all locations if empty.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// If specified, only returns DeviceCodes targeting the specified product type.
	// Returns DeviceCodes of all product types if empty.
	ProductType *ProductType `json:"product_type,omitempty" url:"product_type,omitempty"`
	// If specified, returns DeviceCodes with the specified statuses.
	// Returns DeviceCodes of status `PAIRED` and `UNPAIRED` if empty.
	// See [DeviceCodeStatus](#type-devicecodestatus) for possible values
	Status []DeviceCodeStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDeviceCodesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDeviceCodesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDeviceCodesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDeviceCodesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDeviceCodesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListDeviceCodesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The queried DeviceCode.
	DeviceCodes []*DeviceCode `json:"device_codes,omitempty" url:"device_codes,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint. This value is present only if the request
	// succeeded and additional results are available.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDeviceCodesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDeviceCodesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDeviceCodesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDeviceCodesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDeviceCodesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListDevicesRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The order in which results are listed.
	//
	//   - `ASC` - Oldest to newest.
	//   - `DESC` - Newest to oldest (default).
	//     See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// The number of results to return in a single page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// If present, only returns devices at the target location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDevicesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDevicesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDevicesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDevicesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDevicesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListDevicesResponse struct {
	// Information about errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested list of `Device` objects.
	Devices []*Device `json:"devices,omitempty" url:"devices,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDevicesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDevicesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDevicesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDevicesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDevicesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the parameters for a `ListDisputeEvidence` request.
type ListDisputeEvidenceRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDisputeEvidenceRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDisputeEvidenceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDisputeEvidenceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDisputeEvidenceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDisputeEvidenceRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields in a `ListDisputeEvidence` response.
type ListDisputeEvidenceResponse struct {
	// The list of evidence previously uploaded to the specified dispute.
	Evidence []*DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The pagination cursor to be used in a subsequent request.
	// If unset, this is the final response. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDisputeEvidenceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDisputeEvidenceResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the request parameters for the `ListDisputes` endpoint.
type ListDisputesRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The dispute states used to filter the result. If not specified, the endpoint returns all disputes.
	// See [DisputeState](#type-disputestate) for possible values
	States []DisputeState `json:"states,omitempty" url:"states,omitempty"`
	// The ID of the location for which to return a list of disputes.
	// If not specified, the endpoint returns disputes associated with all locations.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDisputesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDisputesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDisputesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDisputesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDisputesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines fields in a `ListDisputes` response.
type ListDisputesResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of disputes.
	Disputes []*Dispute `json:"disputes,omitempty" url:"disputes,omitempty"`
	// The pagination cursor to be used in a subsequent request.
	// If unset, this is the final response. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListDisputesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDisputesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDisputesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDisputesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDisputesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request for a set of `EmployeeWage` objects.
type ListEmployeeWagesRequest struct {
	// Filter the returned wages to only those that are associated with the specified employee.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The maximum number of `EmployeeWage` results to return per page. The number can range between
	// 1 and 200. The default is 200.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// A pointer to the next page of `EmployeeWage` results to fetch.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListEmployeeWagesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEmployeeWagesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmployeeWagesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmployeeWagesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmployeeWagesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `EmployeeWage` objects. The response contains
// a set of `EmployeeWage` objects.
type ListEmployeeWagesResponse struct {
	// A page of `EmployeeWage` results.
	EmployeeWages []*EmployeeWage `json:"employee_wages,omitempty" url:"employee_wages,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `EmployeeWage` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListEmployeeWagesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEmployeeWagesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmployeeWagesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmployeeWagesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmployeeWagesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListEmployeesRequest struct {
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Specifies the EmployeeStatus to filter the employee by.
	// See [EmployeeStatus](#type-employeestatus) for possible values
	Status *EmployeeStatus `json:"status,omitempty" url:"status,omitempty"`
	// The number of employees to be returned on each page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// The token required to retrieve the specified page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListEmployeesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEmployeesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmployeesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmployeesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmployeesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListEmployeesResponse struct {
	Employees []*Employee `json:"employees,omitempty" url:"employees,omitempty"`
	// The token to be used to retrieve the next page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListEmployeesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEmployeesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmployeesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmployeesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmployeesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListEventTypes]($e/Events/ListEventTypes) endpoint.
//
// Note: if there are errors processing the request, the event types field will not be
// present.
type ListEventTypesResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of event types.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// Contains the metadata of an event type. For more information, see [EventTypeMetadata](entity:EventTypeMetadata).
	Metadata []*EventTypeMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListEventTypesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEventTypesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEventTypesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEventTypesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEventTypesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Returns a list of gift card activities. You can optionally specify a filter to retrieve a
// subset of activites.
type ListGiftCardActivitiesRequest struct {
	// If a gift card ID is provided, the endpoint returns activities related
	// to the specified gift card. Otherwise, the endpoint returns all gift card activities for
	// the seller.
	GiftCardID *string `json:"gift_card_id,omitempty" url:"gift_card_id,omitempty"`
	// If a [type](entity:GiftCardActivityType) is provided, the endpoint returns gift card activities of the specified type.
	// Otherwise, the endpoint returns all types of gift card activities.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// If a location ID is provided, the endpoint returns gift card activities for the specified location.
	// Otherwise, the endpoint returns gift card activities for all locations.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The timestamp for the beginning of the reporting period, in RFC 3339 format.
	// This start time is inclusive. The default value is the current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// The timestamp for the end of the reporting period, in RFC 3339 format.
	// This end time is inclusive. The default value is the current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// If a limit is provided, the endpoint returns the specified number
	// of results (or fewer) per page. The maximum value is 100. The default value is 50.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// If a cursor is not provided, the endpoint returns the first page of the results.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The order in which the endpoint returns the activities, based on `created_at`.
	//
	// - `ASC` - Oldest to newest.
	// - `DESC` - Newest to oldest (default).
	SortOrder *string `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListGiftCardActivitiesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListGiftCardActivitiesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListGiftCardActivitiesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListGiftCardActivitiesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListGiftCardActivitiesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A response that contains a list of `GiftCardActivity` objects. If the request resulted in errors,
// the response contains a set of `Error` objects.
type ListGiftCardActivitiesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested gift card activities or an empty object if none are found.
	GiftCardActivities []*GiftCardActivity `json:"gift_card_activities,omitempty" url:"gift_card_activities,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a
	// subsequent request to retrieve the next set of activities. If a cursor is not present, this is
	// the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListGiftCardActivitiesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListGiftCardActivitiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListGiftCardActivitiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListGiftCardActivitiesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListGiftCardActivitiesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request to list gift cards. You can optionally specify a filter to retrieve a subset of
// gift cards.
type ListGiftCardsRequest struct {
	// If a [type](entity:GiftCardType) is provided, the endpoint returns gift cards of the specified type.
	// Otherwise, the endpoint returns gift cards of all types.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// If a [state](entity:GiftCardStatus) is provided, the endpoint returns the gift cards in the specified state.
	// Otherwise, the endpoint returns the gift cards of all states.
	State *string `json:"state,omitempty" url:"state,omitempty"`
	// If a limit is provided, the endpoint returns only the specified number of results per page.
	// The maximum value is 200. The default value is 30.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// If a cursor is not provided, the endpoint returns the first page of the results.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// If a customer ID is provided, the endpoint returns only the gift cards linked to the specified customer.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListGiftCardsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListGiftCardsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListGiftCardsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListGiftCardsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListGiftCardsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A response that contains a list of `GiftCard` objects. If the request resulted in errors,
// the response contains a set of `Error` objects.
type ListGiftCardsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested gift cards or an empty object if none are found.
	GiftCards []*GiftCard `json:"gift_cards,omitempty" url:"gift_cards,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a
	// subsequent request to retrieve the next set of gift cards. If a cursor is not present, this is
	// the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListGiftCardsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListGiftCardsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListGiftCardsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListGiftCardsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListGiftCardsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes a `ListInvoice` request.
type ListInvoicesRequest struct {
	// The ID of the location for which to list invoices.
	LocationID string `json:"location_id" url:"location_id"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for your original query.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The maximum number of invoices to return (200 is the maximum `limit`).
	// If not provided, the server uses a default limit of 100 invoices.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListInvoicesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListInvoicesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListInvoicesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListInvoicesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListInvoicesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes a `ListInvoice` response.
type ListInvoicesResponse struct {
	// The invoices retrieved.
	Invoices []*Invoice `json:"invoices,omitempty" url:"invoices,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a
	// subsequent request to retrieve the next set of invoices. If empty, this is the final
	// response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListInvoicesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListInvoicesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListInvoicesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListInvoicesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListInvoicesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListLocationBookingProfilesResponse struct {
	// The list of a seller's location booking profiles.
	LocationBookingProfiles []*LocationBookingProfile `json:"location_booking_profiles,omitempty" url:"location_booking_profiles,omitempty"`
	// The pagination cursor to be used in the subsequent request to get the next page of the results. Stop retrieving the next page of the results when the cursor is not set.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLocationBookingProfilesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationBookingProfilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationBookingProfilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationBookingProfilesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationBookingProfilesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLocationCustomAttributeDefinitions]($e/LocationCustomAttributes/ListLocationCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListLocationCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLocationCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationCustomAttributeDefinitionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationCustomAttributeDefinitionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLocationCustomAttributes]($e/LocationCustomAttributes/ListLocationCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListLocationCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLocationCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationCustomAttributesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in requests to the
// [ListLocations]($e/Locations/ListLocations) endpoint.
type ListLocationsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLocationsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of a request
// to the [ListLocations]($e/Locations/ListLocations) endpoint.
//
// Either `errors` or `locations` is present in a given response (never both).
type ListLocationsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The business locations.
	Locations []*Location `json:"locations,omitempty" url:"locations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLocationsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request to list `LoyaltyProgram`.
type ListLoyaltyProgramsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLoyaltyProgramsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyProgramsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyProgramsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyProgramsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyProgramsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A response that contains all loyalty programs.
type ListLoyaltyProgramsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A list of `LoyaltyProgram` for the merchant.
	Programs []*LoyaltyProgram `json:"programs,omitempty" url:"programs,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLoyaltyProgramsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyProgramsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyProgramsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyProgramsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyProgramsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLoyaltyPromotions]($e/Loyalty/ListLoyaltyPromotions) request.
type ListLoyaltyPromotionsRequest struct {
	// The status to filter the results by. If a status is provided, only loyalty promotions
	// with the specified status are returned. Otherwise, all loyalty promotions associated with
	// the loyalty program are returned.
	// See [LoyaltyPromotionStatus](#type-loyaltypromotionstatus) for possible values
	Status *LoyaltyPromotionStatus `json:"status,omitempty" url:"status,omitempty"`
	// The cursor returned in the paged response from the previous call to this endpoint.
	// Provide this cursor to retrieve the next page of results for your original request.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The maximum number of results to return in a single paged response.
	// The minimum value is 1 and the maximum value is 30. The default value is 30.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLoyaltyPromotionsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyPromotionsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyPromotionsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyPromotionsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyPromotionsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLoyaltyPromotions]($e/Loyalty/ListLoyaltyPromotions) response.
// One of `loyalty_promotions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `loyalty_promotions`.
type ListLoyaltyPromotionsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved loyalty promotions.
	LoyaltyPromotions []*LoyaltyPromotion `json:"loyalty_promotions,omitempty" url:"loyalty_promotions,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLoyaltyPromotionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyPromotionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyPromotionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyPromotionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyPromotionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListMerchantCustomAttributeDefinitions]($e/MerchantCustomAttributes/ListMerchantCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListMerchantCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMerchantCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMerchantCustomAttributeDefinitionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListMerchantCustomAttributes]($e/MerchantCustomAttributes/ListMerchantCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListMerchantCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListMerchantCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMerchantCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMerchantCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMerchantCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMerchantCustomAttributesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Request object for the [ListMerchant]($e/Merchants/ListMerchants) endpoint.
type ListMerchantsRequest struct {
	// The cursor generated by the previous response.
	Cursor *int `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListMerchantsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMerchantsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMerchantsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMerchantsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMerchantsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response object returned by the [ListMerchant]($e/Merchants/ListMerchants) endpoint.
type ListMerchantsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `Merchant` entities.
	Merchant []*Merchant `json:"merchant,omitempty" url:"merchant,omitempty"`
	// If the response is truncated, the cursor to use in next request to fetch next set of objects.
	Cursor *int `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListMerchantsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMerchantsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMerchantsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMerchantsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMerchantsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a response from listing order custom attribute definitions.
type ListOrderCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found, Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of results for your original request.
	// This field is present only if the request succeeded and additional results are available.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListOrderCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListOrderCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListOrderCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListOrderCustomAttributeDefinitionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListOrderCustomAttributeDefinitionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a response from listing order custom attributes.
type ListOrderCustomAttributesResponse struct {
	// The retrieved custom attributes. If no custom attribute are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of results for your original request.
	// This field is present only if the request succeeded and additional results are available.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListOrderCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListOrderCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListOrderCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListOrderCustomAttributesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListOrderCustomAttributesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPaymentLinksRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// If a cursor is not provided, the endpoint returns the first page of the results.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// A limit on the number of results to return per page. The limit is advisory and
	// the implementation might return more or less results. If the supplied limit is negative, zero, or
	// greater than the maximum limit of 1000, it is ignored.
	//
	// Default value: `100`
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentLinksRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentLinksRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentLinksRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentLinksRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentLinksRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPaymentLinksResponse struct {
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of payment links.
	PaymentLinks []*PaymentLink `json:"payment_links,omitempty" url:"payment_links,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a subsequent request
	// to retrieve the next set of gift cards. If a cursor is not present, this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentLinksResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentLinksResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentLinksResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentLinksResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentLinksResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes a request to list refunds using
// [ListPaymentRefunds]($e/Refunds/ListPaymentRefunds).
//
// The maximum results per page is 100.
type ListPaymentRefundsRequest struct {
	// Indicates the start of the time range to retrieve each `PaymentRefund` for, in RFC 3339
	// format. The range is determined using the `created_at` field for each `PaymentRefund`.
	//
	// Default: The current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// Indicates the end of the time range to retrieve each `PaymentRefund` for, in RFC 3339
	// format. The range is determined using the `created_at` field for each `PaymentRefund`.
	//
	// Default: The current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The order in which results are listed by `PaymentRefund.created_at`:
	//
	// - `ASC` - Oldest to newest.
	// - `DESC` - Newest to oldest (default).
	SortOrder *string `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Limit results to the location supplied. By default, results are returned
	// for all locations associated with the seller.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// If provided, only refunds with the given status are returned.
	// For a list of refund status values, see [PaymentRefund](entity:PaymentRefund).
	//
	// Default: If omitted, refunds are returned regardless of their status.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// If provided, only returns refunds whose payments have the indicated source type.
	// Current values include `CARD`, `BANK_ACCOUNT`, `WALLET`, `CASH`, and `EXTERNAL`.
	// For information about these payment source types, see
	// [Take Payments](https://developer.squareup.com/docs/payments-api/take-payments).
	//
	// Default: If omitted, refunds are returned regardless of the source type.
	SourceType *string `json:"source_type,omitempty" url:"source_type,omitempty"`
	// The maximum number of results to be returned in a single page.
	//
	// It is possible to receive fewer results than the specified limit on a given page.
	//
	// If the supplied value is greater than 100, no more than 100 results are returned.
	//
	// Default: 100
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentRefundsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentRefundsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentRefundsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentRefundsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentRefundsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the response returned by [ListPaymentRefunds]($e/Refunds/ListPaymentRefunds).
//
// Either `errors` or `refunds` is present in a given response (never both).
type ListPaymentRefundsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of requested refunds.
	Refunds []*PaymentRefund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentRefundsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentRefundsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes a request to list payments using
// [ListPayments]($e/Payments/ListPayments).
//
// The maximum results per page is 100.
type ListPaymentsRequest struct {
	// Indicates the start of the time range to retrieve payments for, in RFC 3339 format.
	// The range is determined using the `created_at` field for each Payment.
	// Inclusive. Default: The current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// Indicates the end of the time range to retrieve payments for, in RFC 3339 format. The
	// range is determined using the `created_at` field for each Payment.
	//
	// Default: The current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The order in which results are listed by `Payment.created_at`:
	//
	// - `ASC` - Oldest to newest.
	// - `DESC` - Newest to oldest (default).
	SortOrder *string `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Limit results to the location supplied. By default, results are returned
	// for the default (main) location associated with the seller.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The exact amount in the `total_money` for a payment.
	Total *int64 `json:"total,omitempty" url:"total,omitempty"`
	// The last four digits of a payment card.
	Last4 *string `json:"last_4,omitempty" url:"last_4,omitempty"`
	// The brand of the payment card (for example, VISA).
	CardBrand *string `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The maximum number of results to be returned in a single page.
	// It is possible to receive fewer results than the specified limit on a given page.
	//
	// The default value of 100 is also the maximum allowed value. If the provided value is
	// greater than 100, it is ignored and the default value is used instead.
	//
	// Default: `100`
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Whether the payment was taken offline or not.
	IsOfflinePayment *bool `json:"is_offline_payment,omitempty" url:"is_offline_payment,omitempty"`
	// Indicates the start of the time range for which to retrieve offline payments, in RFC 3339
	// format for timestamps. The range is determined using the
	// `offline_payment_details.client_created_at` field for each Payment. If set, payments without a
	// value set in `offline_payment_details.client_created_at` will not be returned.
	//
	// Default: The current time.
	OfflineBeginTime *string `json:"offline_begin_time,omitempty" url:"offline_begin_time,omitempty"`
	// Indicates the end of the time range for which to retrieve offline payments, in RFC 3339
	// format for timestamps. The range is determined using the
	// `offline_payment_details.client_created_at` field for each Payment. If set, payments without a
	// value set in `offline_payment_details.client_created_at` will not be returned.
	//
	// Default: The current time.
	OfflineEndTime *string `json:"offline_end_time,omitempty" url:"offline_end_time,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the response returned by [ListPayments]($e/Payments/ListPayments).
type ListPaymentsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested list of payments.
	Payments []*Payment `json:"payments,omitempty" url:"payments,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPayoutEntriesRequest struct {
	// The order in which payout entries are listed.
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	// If request parameters change between requests, subsequent results may contain duplicates or missing records.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The maximum number of results to be returned in a single page.
	// It is possible to receive fewer results than the specified limit on a given page.
	// The default value of 100 is also the maximum allowed value. If the provided value is
	// greater than 100, it is ignored and the default value is used instead.
	// Default: `100`
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPayoutEntriesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPayoutEntriesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPayoutEntriesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPayoutEntriesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPayoutEntriesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to retrieve payout records entries.
type ListPayoutEntriesResponse struct {
	// The requested list of payout entries, ordered with the given or default sort order.
	PayoutEntries []*PayoutEntry `json:"payout_entries,omitempty" url:"payout_entries,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty, this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPayoutEntriesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPayoutEntriesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPayoutEntriesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPayoutEntriesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPayoutEntriesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request to retrieve payout records.
type ListPayoutsRequest struct {
	// The ID of the location for which to list the payouts.
	// By default, payouts are returned for the default (main) location associated with the seller.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// If provided, only payouts with the given status are returned.
	Status *PayoutStatus `json:"status,omitempty" url:"status,omitempty"`
	// The timestamp for the beginning of the payout creation time, in RFC 3339 format.
	// Inclusive. Default: The current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// The timestamp for the end of the payout creation time, in RFC 3339 format.
	// Default: The current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The order in which payouts are listed.
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this cursor to retrieve the next set of results for the original query.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	// If request parameters change between requests, subsequent results may contain duplicates or missing records.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The maximum number of results to be returned in a single page.
	// It is possible to receive fewer results than the specified limit on a given page.
	// The default value of 100 is also the maximum allowed value. If the provided value is
	// greater than 100, it is ignored and the default value is used instead.
	// Default: `100`
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPayoutsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPayoutsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPayoutsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPayoutsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPayoutsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to retrieve payout records entries.
type ListPayoutsResponse struct {
	// The requested list of payouts.
	Payouts []*Payout `json:"payouts,omitempty" url:"payouts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty, this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPayoutsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPayoutsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPayoutsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPayoutsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPayoutsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the query parameters that can be included in
// a request to the [ListRefunds](api-endpoint:Transactions-ListRefunds) endpoint.
//
// Deprecated - recommend using [SearchOrders](api-endpoint:Orders-SearchOrders)
type ListRefundsRequest struct {
	// The beginning of the requested reporting period, in RFC 3339 format.
	//
	// See [Date ranges](https://developer.squareup.com/docs/build-basics/working-with-dates) for details on date inclusivity/exclusivity.
	//
	// Default value: The current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// The end of the requested reporting period, in RFC 3339 format.
	//
	// See [Date ranges](https://developer.squareup.com/docs/build-basics/working-with-dates) for details on date inclusivity/exclusivity.
	//
	// Default value: The current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The order in which results are listed in the response (`ASC` for
	// oldest first, `DESC` for newest first).
	//
	// Default value: `DESC`
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for your original query.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListRefundsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListRefundsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListRefundsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListRefundsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListRefundsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListRefunds](api-endpoint:Transactions-ListRefunds) endpoint.
//
// One of `errors` or `refunds` is present in a given response (never both).
type ListRefundsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// An array of refunds that match your query.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// A pagination cursor for retrieving the next set of results,
	// if any remain. Provide this value as the `cursor` parameter in a subsequent
	// request to this endpoint.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListRefundsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListRefundsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a `ListSites` request.
type ListSitesRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListSitesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSitesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSitesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSitesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSitesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a `ListSites` response. The response can include either `sites` or `errors`.
type ListSitesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The sites that belong to the seller.
	Sites []*Site `json:"sites,omitempty" url:"sites,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListSitesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSitesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSitesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSitesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSitesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines input parameters in a request to the
// [ListSubscriptionEvents]($e/Subscriptions/ListSubscriptionEvents)
// endpoint.
type ListSubscriptionEventsRequest struct {
	// When the total number of resulting subscription events exceeds the limit of a paged response,
	// specify the cursor returned from a preceding response here to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The upper limit on the number of subscription events to return
	// in a paged response.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListSubscriptionEventsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSubscriptionEventsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSubscriptionEventsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSubscriptionEventsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSubscriptionEventsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines output parameters in a response from the
// [ListSubscriptionEvents]($e/Subscriptions/ListSubscriptionEvents).
type ListSubscriptionEventsResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved subscription events.
	SubscriptionEvents []*SubscriptionEvent `json:"subscription_events,omitempty" url:"subscription_events,omitempty"`
	// When the total number of resulting subscription events exceeds the limit of a paged response,
	// the response includes a cursor for you to use in a subsequent request to fetch the next set of events.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListSubscriptionEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSubscriptionEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSubscriptionEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSubscriptionEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSubscriptionEventsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListTeamMemberBookingProfilesRequest struct {
	// Indicates whether to include only bookable team members in the returned result (`true`) or not (`false`).
	BookableOnly *bool `json:"bookable_only,omitempty" url:"bookable_only,omitempty"`
	// The maximum number of results to return in a paged response.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// The pagination cursor from the preceding response to return the next page of the results. Do not set this when retrieving the first page of the results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Indicates whether to include only team members enabled at the given location in the returned result.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTeamMemberBookingProfilesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberBookingProfilesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberBookingProfilesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberBookingProfilesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberBookingProfilesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListTeamMemberBookingProfilesResponse struct {
	// The list of team member booking profiles. The results are returned in the ascending order of the time
	// when the team member booking profiles were last updated. Multiple booking profiles updated at the same time
	// are further sorted in the ascending order of their IDs.
	TeamMemberBookingProfiles []*TeamMemberBookingProfile `json:"team_member_booking_profiles,omitempty" url:"team_member_booking_profiles,omitempty"`
	// The pagination cursor to be used in the subsequent request to get the next page of the results. Stop retrieving the next page of the results when the cursor is not set.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTeamMemberBookingProfilesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberBookingProfilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberBookingProfilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberBookingProfilesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberBookingProfilesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request for a set of `TeamMemberWage` objects.
type ListTeamMemberWagesRequest struct {
	// Filter the returned wages to only those that are associated with the
	// specified team member.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The maximum number of `TeamMemberWage` results to return per page. The number can range between
	// 1 and 200. The default is 200.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// A pointer to the next page of `EmployeeWage` results to fetch.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTeamMemberWagesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberWagesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberWagesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberWagesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberWagesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `TeamMemberWage` objects. The response contains
// a set of `TeamMemberWage` objects.
type ListTeamMemberWagesResponse struct {
	// A page of `TeamMemberWage` results.
	TeamMemberWages []*TeamMemberWage `json:"team_member_wages,omitempty" url:"team_member_wages,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `TeamMemberWage` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTeamMemberWagesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberWagesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberWagesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberWagesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberWagesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the query parameters that can be included in
// a request to the [ListTransactions](api-endpoint:Transactions-ListTransactions) endpoint.
//
// Deprecated - recommend using [SearchOrders](api-endpoint:Orders-SearchOrders)
type ListTransactionsRequest struct {
	// The beginning of the requested reporting period, in RFC 3339 format.
	//
	// See [Date ranges](https://developer.squareup.com/docs/build-basics/working-with-dates) for details on date inclusivity/exclusivity.
	//
	// Default value: The current time minus one year.
	BeginTime *string `json:"begin_time,omitempty" url:"begin_time,omitempty"`
	// The end of the requested reporting period, in RFC 3339 format.
	//
	// See [Date ranges](https://developer.squareup.com/docs/build-basics/working-with-dates) for details on date inclusivity/exclusivity.
	//
	// Default value: The current time.
	EndTime *string `json:"end_time,omitempty" url:"end_time,omitempty"`
	// The order in which results are listed in the response (`ASC` for
	// oldest first, `DESC` for newest first).
	//
	// Default value: `DESC`
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for your original query.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTransactionsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTransactionsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTransactionsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTransactionsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTransactionsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListTransactions](api-endpoint:Transactions-ListTransactions) endpoint.
//
// One of `errors` or `transactions` is present in a given response (never both).
type ListTransactionsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// An array of transactions that match your query.
	Transactions []*Transaction `json:"transactions,omitempty" url:"transactions,omitempty"`
	// A pagination cursor for retrieving the next set of results,
	// if any remain. Provide this value as the `cursor` parameter in a subsequent
	// request to this endpoint.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListTransactionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTransactionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTransactionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTransactionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTransactionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Lists all webhook event types that can be subscribed to.
type ListWebhookEventTypesRequest struct {
	// The API version for which to list event types. Setting this field overrides the default version used by the application.
	APIVersion *string `json:"api_version,omitempty" url:"api_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWebhookEventTypesRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookEventTypesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookEventTypesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookEventTypesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookEventTypesRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListWebhookEventTypes]($e/WebhookSubscriptions/ListWebhookEventTypes) endpoint.
//
// Note: if there are errors processing the request, the event types field will not be
// present.
type ListWebhookEventTypesResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of event types.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// Contains the metadata of a webhook event type. For more information, see [EventTypeMetadata](entity:EventTypeMetadata).
	Metadata []*EventTypeMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWebhookEventTypesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookEventTypesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookEventTypesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookEventTypesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookEventTypesResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Lists all [Subscription]($m/WebhookSubscription)s owned by your application.
type ListWebhookSubscriptionsRequest struct {
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for your original query.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Includes disabled [Subscription](entity:WebhookSubscription)s.
	// By default, all enabled [Subscription](entity:WebhookSubscription)s are returned.
	IncludeDisabled *bool `json:"include_disabled,omitempty" url:"include_disabled,omitempty"`
	// Sorts the returned list by when the [Subscription](entity:WebhookSubscription) was created with the specified order.
	// This field defaults to ASC.
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`
	// The maximum number of results to be returned in a single page.
	// It is possible to receive fewer results than the specified limit on a given page.
	// The default value of 100 is also the maximum allowed value.
	//
	// Default: 100
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWebhookSubscriptionsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookSubscriptionsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookSubscriptionsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookSubscriptionsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookSubscriptionsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListWebhookSubscriptions]($e/WebhookSubscriptions/ListWebhookSubscriptions) endpoint.
//
// Note: if there are errors processing the request, the subscriptions field will not be
// present.
type ListWebhookSubscriptionsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested list of [Subscription](entity:WebhookSubscription)s.
	Subscriptions []*WebhookSubscription `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWebhookSubscriptionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookSubscriptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookSubscriptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookSubscriptionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookSubscriptionsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A request for a set of `WorkweekConfig` objects.
type ListWorkweekConfigsRequest struct {
	// The maximum number of `WorkweekConfigs` results to return per page.
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// A pointer to the next page of `WorkweekConfig` results to fetch.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWorkweekConfigsRequest) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWorkweekConfigsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWorkweekConfigsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWorkweekConfigsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWorkweekConfigsRequest) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `WorkweekConfig` objects. The response contains
// the requested `WorkweekConfig` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type ListWorkweekConfigsResponse struct {
	// A page of `WorkweekConfig` results.
	WorkweekConfigs []*WorkweekConfig `json:"workweek_configs,omitempty" url:"workweek_configs,omitempty"`
	// The value supplied in the subsequent request to fetch the next page of
	// `WorkweekConfig` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListWorkweekConfigsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWorkweekConfigsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWorkweekConfigsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWorkweekConfigsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWorkweekConfigsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents one of a business' [locations](https://developer.squareup.com/docs/locations-api).
type Location struct {
	// A short generated string of letters and numbers that uniquely identifies this location instance.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the location.
	// This information appears in the Seller Dashboard as the nickname.
	// A location name must be unique within a seller account.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The physical address of the location.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The [IANA time zone](https://www.iana.org/time-zones) identifier for
	// the time zone of the location. For example, `America/Los_Angeles`.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// The Square features that are enabled for the location.
	// See [LocationCapability](entity:LocationCapability) for possible values.
	// See [LocationCapability](#type-locationcapability) for possible values
	Capabilities []LocationCapability `json:"capabilities,omitempty" url:"capabilities,omitempty"`
	// The status of the location.
	// See [LocationStatus](#type-locationstatus) for possible values
	Status *LocationStatus `json:"status,omitempty" url:"status,omitempty"`
	// The time when the location was created, in RFC 3339 format.
	// For more information, see [Working with Dates](https://developer.squareup.com/docs/build-basics/working-with-dates).
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The ID of the merchant that owns the location.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The country of the location, in the two-letter format of ISO 3166. For example, `US` or `JP`.
	//
	// See [Country](entity:Country) for possible values.
	// See [Country](#type-country) for possible values
	Country *Country `json:"country,omitempty" url:"country,omitempty"`
	// The language associated with the location, in
	// [BCP 47 format](https://tools.ietf.org/html/bcp47#appendix-A).
	// For more information, see [Language Preferences](https://developer.squareup.com/docs/build-basics/general-considerations/language-preferences).
	LanguageCode *string `json:"language_code,omitempty" url:"language_code,omitempty"`
	// The currency used for all transactions at this location,
	// in ISO 4217 format. For example, the currency code for US dollars is `USD`.
	// See [Currency](entity:Currency) for possible values.
	// See [Currency](#type-currency) for possible values
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	// The phone number of the location. For example, `+1 855-700-6000`.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The name of the location's overall business. This name is present on receipts and other customer-facing branding, and can be changed no more than three times in a twelve-month period.
	BusinessName *string `json:"business_name,omitempty" url:"business_name,omitempty"`
	// The type of the location.
	// See [LocationType](#type-locationtype) for possible values
	Type *LocationType `json:"type,omitempty" url:"type,omitempty"`
	// The website URL of the location. For example, `https://squareup.com`.
	WebsiteURL *string `json:"website_url,omitempty" url:"website_url,omitempty"`
	// The hours of operation for the location.
	BusinessHours *BusinessHours `json:"business_hours,omitempty" url:"business_hours,omitempty"`
	// The email address of the location. This can be unique to the location and is not always the email address for the business owner or administrator.
	BusinessEmail *string `json:"business_email,omitempty" url:"business_email,omitempty"`
	// The description of the location. For example, `Main Street location`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The Twitter username of the location without the '@' symbol. For example, `Square`.
	TwitterUsername *string `json:"twitter_username,omitempty" url:"twitter_username,omitempty"`
	// The Instagram username of the location without the '@' symbol. For example, `square`.
	InstagramUsername *string `json:"instagram_username,omitempty" url:"instagram_username,omitempty"`
	// The Facebook profile URL of the location. The URL should begin with 'facebook.com/'. For example, `https://www.facebook.com/square`.
	FacebookURL *string `json:"facebook_url,omitempty" url:"facebook_url,omitempty"`
	// The physical coordinates (latitude and longitude) of the location.
	Coordinates *Coordinates `json:"coordinates,omitempty" url:"coordinates,omitempty"`
	// The URL of the logo image for the location. When configured in the Seller
	// Dashboard (Receipts section), the logo appears on transactions (such as receipts and invoices) that Square generates on behalf of the seller.
	// This image should have a roughly square (1:1) aspect ratio and should be at least 200x200 pixels.
	LogoURL *string `json:"logo_url,omitempty" url:"logo_url,omitempty"`
	// The URL of the Point of Sale background image for the location.
	PosBackgroundURL *string `json:"pos_background_url,omitempty" url:"pos_background_url,omitempty"`
	// A four-digit number that describes the kind of goods or services sold at the location.
	// The [merchant category code (MCC)](https://developer.squareup.com/docs/locations-api#initialize-a-merchant-category-code) of the location as standardized by ISO 18245.
	// For example, `5045`, for a location that sells computer goods and software.
	Mcc *string `json:"mcc,omitempty" url:"mcc,omitempty"`
	// The URL of a full-format logo image for the location. When configured in the Seller
	// Dashboard (Receipts section), the logo appears on transactions (such as receipts and invoices) that Square generates on behalf of the seller.
	// This image can be wider than it is tall and should be at least 1280x648 pixels.
	FullFormatLogoURL *string `json:"full_format_logo_url,omitempty" url:"full_format_logo_url,omitempty"`
	// The tax IDs for this location.
	TaxIDs *TaxIDs `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Location) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type unmarshaler Location
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Location(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Location) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The booking profile of a seller's location, including the location's ID and whether the location is enabled for online booking.
type LocationBookingProfile struct {
	// The ID of the [location](entity:Location).
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Url for the online booking site for this location.
	BookingSiteURL *string `json:"booking_site_url,omitempty" url:"booking_site_url,omitempty"`
	// Indicates whether the location is enabled for online booking.
	OnlineBookingEnabled *bool `json:"online_booking_enabled,omitempty" url:"online_booking_enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LocationBookingProfile) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationBookingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationBookingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationBookingProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationBookingProfile) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The capabilities a location might have.
type LocationCapability string

const (
	LocationCapabilityCreditCardProcessing LocationCapability = "CREDIT_CARD_PROCESSING"
	LocationCapabilityAutomaticTransfers   LocationCapability = "AUTOMATIC_TRANSFERS"
	LocationCapabilityUnlinkedRefunds      LocationCapability = "UNLINKED_REFUNDS"
)

func NewLocationCapabilityFromString(s string) (LocationCapability, error) {
	switch s {
	case "CREDIT_CARD_PROCESSING":
		return LocationCapabilityCreditCardProcessing, nil
	case "AUTOMATIC_TRANSFERS":
		return LocationCapabilityAutomaticTransfers, nil
	case "UNLINKED_REFUNDS":
		return LocationCapabilityUnlinkedRefunds, nil
	}
	var t LocationCapability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationCapability) Ptr() *LocationCapability {
	return &l
}

// A location's status.
type LocationStatus string

const (
	LocationStatusActive   LocationStatus = "ACTIVE"
	LocationStatusInactive LocationStatus = "INACTIVE"
)

func NewLocationStatusFromString(s string) (LocationStatus, error) {
	switch s {
	case "ACTIVE":
		return LocationStatusActive, nil
	case "INACTIVE":
		return LocationStatusInactive, nil
	}
	var t LocationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationStatus) Ptr() *LocationStatus {
	return &l
}

// A location's type.
type LocationType string

const (
	LocationTypePhysical LocationType = "PHYSICAL"
	LocationTypeMobile   LocationType = "MOBILE"
)

func NewLocationTypeFromString(s string) (LocationType, error) {
	switch s {
	case "PHYSICAL":
		return LocationTypePhysical, nil
	case "MOBILE":
		return LocationTypeMobile, nil
	}
	var t LocationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationType) Ptr() *LocationType {
	return &l
}

// Describes a loyalty account in a [loyalty program]($m/LoyaltyProgram). For more information, see
// [Create and Retrieve Loyalty Accounts](https://developer.squareup.com/docs/loyalty-api/loyalty-accounts).
type LoyaltyAccount struct {
	// The Square-assigned ID of the loyalty account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram) to which the account belongs.
	ProgramID string `json:"program_id" url:"program_id"`
	// The available point balance in the loyalty account. If points are scheduled to expire, they are listed in the `expiring_point_deadlines` field.
	//
	// Your application should be able to handle loyalty accounts that have a negative point balance (`balance` is less than 0). This might occur if a seller makes a manual adjustment or as a result of a refund or exchange.
	Balance *int `json:"balance,omitempty" url:"balance,omitempty"`
	// The total points accrued during the lifetime of the account.
	LifetimePoints *int `json:"lifetime_points,omitempty" url:"lifetime_points,omitempty"`
	// The Square-assigned ID of the [customer](entity:Customer) that is associated with the account.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The timestamp when the buyer joined the loyalty program, in RFC 3339 format. This field is used to display the **Enrolled On** or **Member Since** date in first-party Square products.
	//
	// If this field is not set in a `CreateLoyaltyAccount` request, Square populates it after the buyer's first action on their account
	// (when `AccumulateLoyaltyPoints` or `CreateLoyaltyReward` is called). In first-party flows, Square populates the field when the buyer agrees to the terms of service in Square Point of Sale.
	//
	// This field is typically specified in a `CreateLoyaltyAccount` request when creating a loyalty account for a buyer who already interacted with their account.
	// For example, you would set this field when migrating accounts from an external system. The timestamp in the request can represent a current or previous date and time, but it cannot be set for the future.
	EnrolledAt *string `json:"enrolled_at,omitempty" url:"enrolled_at,omitempty"`
	// The timestamp when the loyalty account was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the loyalty account was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The mapping that associates the loyalty account with a buyer. Currently,
	// a loyalty account can only be mapped to a buyer by phone number.
	//
	// To create a loyalty account, you must specify the `mapping` field, with the buyer's phone number
	// in the `phone_number` field.
	Mapping *LoyaltyAccountMapping `json:"mapping,omitempty" url:"mapping,omitempty"`
	// The schedule for when points expire in the loyalty account balance. This field is present only if the account has points that are scheduled to expire.
	//
	// The total number of points in this field equals the number of points in the `balance` field.
	ExpiringPointDeadlines []*LoyaltyAccountExpiringPointDeadline `json:"expiring_point_deadlines,omitempty" url:"expiring_point_deadlines,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccount) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccount) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a set of points for a loyalty account that are scheduled to expire on a specific date.
type LoyaltyAccountExpiringPointDeadline struct {
	// The number of points scheduled to expire at the `expires_at` timestamp.
	Points int `json:"points" url:"points"`
	// The timestamp of when the points are scheduled to expire, in RFC 3339 format.
	ExpiresAt string `json:"expires_at" url:"expires_at"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountExpiringPointDeadline) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountExpiringPointDeadline) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountExpiringPointDeadline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountExpiringPointDeadline(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountExpiringPointDeadline) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the mapping that associates a loyalty account with a buyer.
//
// Currently, a loyalty account can only be mapped to a buyer by phone number. For more information, see
// [Loyalty Overview](https://developer.squareup.com/docs/loyalty/overview).
type LoyaltyAccountMapping struct {
	// The Square-assigned ID of the mapping.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The timestamp when the mapping was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The phone number of the buyer, in E.164 format. For example, "+14155551111".
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyAccountMapping) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountMapping) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The type of mapping.
type LoyaltyAccountMappingType = string

// Provides information about a loyalty event.
// For more information, see [Search for Balance-Changing Loyalty Events](https://developer.squareup.com/docs/loyalty-api/loyalty-events).
type LoyaltyEvent struct {
	// The Square-assigned ID of the loyalty event.
	ID string `json:"id" url:"id"`
	// The type of the loyalty event.
	// See [LoyaltyEventType](#type-loyaltyeventtype) for possible values
	Type LoyaltyEventType `json:"type" url:"type"`
	// The timestamp when the event was created, in RFC 3339 format.
	CreatedAt string `json:"created_at" url:"created_at"`
	// Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
	AccumulatePoints *LoyaltyEventAccumulatePoints `json:"accumulate_points,omitempty" url:"accumulate_points,omitempty"`
	// Provides metadata when the event `type` is `CREATE_REWARD`.
	CreateReward *LoyaltyEventCreateReward `json:"create_reward,omitempty" url:"create_reward,omitempty"`
	// Provides metadata when the event `type` is `REDEEM_REWARD`.
	RedeemReward *LoyaltyEventRedeemReward `json:"redeem_reward,omitempty" url:"redeem_reward,omitempty"`
	// Provides metadata when the event `type` is `DELETE_REWARD`.
	DeleteReward *LoyaltyEventDeleteReward `json:"delete_reward,omitempty" url:"delete_reward,omitempty"`
	// Provides metadata when the event `type` is `ADJUST_POINTS`.
	AdjustPoints *LoyaltyEventAdjustPoints `json:"adjust_points,omitempty" url:"adjust_points,omitempty"`
	// The ID of the [loyalty account](entity:LoyaltyAccount) associated with the event.
	LoyaltyAccountID string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The ID of the [location](entity:Location) where the event occurred.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Defines whether the event was generated by the Square Point of Sale.
	// See [LoyaltyEventSource](#type-loyaltyeventsource) for possible values
	Source LoyaltyEventSource `json:"source" url:"source"`
	// Provides metadata when the event `type` is `EXPIRE_POINTS`.
	ExpirePoints *LoyaltyEventExpirePoints `json:"expire_points,omitempty" url:"expire_points,omitempty"`
	// Provides metadata when the event `type` is `OTHER`.
	OtherEvent *LoyaltyEventOther `json:"other_event,omitempty" url:"other_event,omitempty"`
	// Provides metadata when the event `type` is `ACCUMULATE_PROMOTION_POINTS`.
	AccumulatePromotionPoints *LoyaltyEventAccumulatePromotionPoints `json:"accumulate_promotion_points,omitempty" url:"accumulate_promotion_points,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEvent) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
type LoyaltyEventAccumulatePoints struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points accumulated by the event.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The ID of the [order](entity:Order) for which the buyer accumulated the points.
	// This field is returned only if the Orders API is used to process orders.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventAccumulatePoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAccumulatePoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAccumulatePoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAccumulatePoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAccumulatePoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ACCUMULATE_PROMOTION_POINTS`.
type LoyaltyEventAccumulatePromotionPoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The Square-assigned ID of the [loyalty promotion](entity:LoyaltyPromotion).
	LoyaltyPromotionID *string `json:"loyalty_promotion_id,omitempty" url:"loyalty_promotion_id,omitempty"`
	// The number of points earned by the event.
	Points int `json:"points" url:"points"`
	// The ID of the [order](entity:Order) for which the buyer earned the promotion points.
	// Only applications that use the Orders API to process orders can trigger this event.
	OrderID string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventAccumulatePromotionPoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAccumulatePromotionPoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAccumulatePromotionPoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAccumulatePromotionPoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAccumulatePromotionPoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ADJUST_POINTS`.
type LoyaltyEventAdjustPoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points added or removed.
	Points int `json:"points" url:"points"`
	// The reason for the adjustment of points.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventAdjustPoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAdjustPoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAdjustPoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAdjustPoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAdjustPoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `CREATE_REWARD`.
type LoyaltyEventCreateReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The Square-assigned ID of the created [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardID *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The loyalty points used to create the reward.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventCreateReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreateReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreateReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreateReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreateReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by date time range.
type LoyaltyEventDateTimeFilter struct {
	// The `created_at` date time range used to filter the result.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventDateTimeFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventDateTimeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventDateTimeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventDateTimeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventDateTimeFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `DELETE_REWARD`.
type LoyaltyEventDeleteReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The ID of the deleted [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardID *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The number of points returned to the loyalty account.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventDeleteReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventDeleteReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventDeleteReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventDeleteReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventDeleteReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `EXPIRE_POINTS`.
type LoyaltyEventExpirePoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The number of points expired.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventExpirePoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventExpirePoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventExpirePoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventExpirePoints(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventExpirePoints) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The filtering criteria. If the request specifies multiple filters,
// the endpoint uses a logical AND to evaluate them.
type LoyaltyEventFilter struct {
	// Filter events by loyalty account.
	LoyaltyAccountFilter *LoyaltyEventLoyaltyAccountFilter `json:"loyalty_account_filter,omitempty" url:"loyalty_account_filter,omitempty"`
	// Filter events by event type.
	TypeFilter *LoyaltyEventTypeFilter `json:"type_filter,omitempty" url:"type_filter,omitempty"`
	// Filter events by date time range.
	// For each range, the start time is inclusive and the end time
	// is exclusive.
	DateTimeFilter *LoyaltyEventDateTimeFilter `json:"date_time_filter,omitempty" url:"date_time_filter,omitempty"`
	// Filter events by location.
	LocationFilter *LoyaltyEventLocationFilter `json:"location_filter,omitempty" url:"location_filter,omitempty"`
	// Filter events by the order associated with the event.
	OrderFilter *LoyaltyEventOrderFilter `json:"order_filter,omitempty" url:"order_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by location.
type LoyaltyEventLocationFilter struct {
	// The [location](entity:Location) IDs for loyalty events to query.
	// If multiple values are specified, the endpoint uses
	// a logical OR to combine them.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventLocationFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventLocationFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventLocationFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventLocationFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventLocationFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by loyalty account.
type LoyaltyEventLoyaltyAccountFilter struct {
	// The ID of the [loyalty account](entity:LoyaltyAccount) associated with loyalty events.
	LoyaltyAccountID string `json:"loyalty_account_id" url:"loyalty_account_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventLoyaltyAccountFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventLoyaltyAccountFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventLoyaltyAccountFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventLoyaltyAccountFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventLoyaltyAccountFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Filter events by the order associated with the event.
type LoyaltyEventOrderFilter struct {
	// The ID of the [order](entity:Order) associated with the event.
	OrderID string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventOrderFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventOrderFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventOrderFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventOrderFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventOrderFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `OTHER`.
type LoyaltyEventOther struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The number of points added or removed.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventOther) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventOther) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventOther
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventOther(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventOther) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a query used to search for loyalty events.
type LoyaltyEventQuery struct {
	// The query filter criteria.
	Filter *LoyaltyEventFilter `json:"filter,omitempty" url:"filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventQuery) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventQuery) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `REDEEM_REWARD`.
type LoyaltyEventRedeemReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID string `json:"loyalty_program_id" url:"loyalty_program_id"`
	// The ID of the redeemed [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardID *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The ID of the [order](entity:Order) that redeemed the reward.
	// This field is returned only if the Orders API is used to process orders.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventRedeemReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventRedeemReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventRedeemReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventRedeemReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventRedeemReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines whether the event was generated by the Square Point of Sale.
type LoyaltyEventSource string

const (
	LoyaltyEventSourceSquare     LoyaltyEventSource = "SQUARE"
	LoyaltyEventSourceLoyaltyAPI LoyaltyEventSource = "LOYALTY_API"
)

func NewLoyaltyEventSourceFromString(s string) (LoyaltyEventSource, error) {
	switch s {
	case "SQUARE":
		return LoyaltyEventSourceSquare, nil
	case "LOYALTY_API":
		return LoyaltyEventSourceLoyaltyAPI, nil
	}
	var t LoyaltyEventSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyEventSource) Ptr() *LoyaltyEventSource {
	return &l
}

// The type of the loyalty event.
type LoyaltyEventType string

const (
	LoyaltyEventTypeAccumulatePoints          LoyaltyEventType = "ACCUMULATE_POINTS"
	LoyaltyEventTypeCreateReward              LoyaltyEventType = "CREATE_REWARD"
	LoyaltyEventTypeRedeemReward              LoyaltyEventType = "REDEEM_REWARD"
	LoyaltyEventTypeDeleteReward              LoyaltyEventType = "DELETE_REWARD"
	LoyaltyEventTypeAdjustPoints              LoyaltyEventType = "ADJUST_POINTS"
	LoyaltyEventTypeExpirePoints              LoyaltyEventType = "EXPIRE_POINTS"
	LoyaltyEventTypeOther                     LoyaltyEventType = "OTHER"
	LoyaltyEventTypeAccumulatePromotionPoints LoyaltyEventType = "ACCUMULATE_PROMOTION_POINTS"
)

func NewLoyaltyEventTypeFromString(s string) (LoyaltyEventType, error) {
	switch s {
	case "ACCUMULATE_POINTS":
		return LoyaltyEventTypeAccumulatePoints, nil
	case "CREATE_REWARD":
		return LoyaltyEventTypeCreateReward, nil
	case "REDEEM_REWARD":
		return LoyaltyEventTypeRedeemReward, nil
	case "DELETE_REWARD":
		return LoyaltyEventTypeDeleteReward, nil
	case "ADJUST_POINTS":
		return LoyaltyEventTypeAdjustPoints, nil
	case "EXPIRE_POINTS":
		return LoyaltyEventTypeExpirePoints, nil
	case "OTHER":
		return LoyaltyEventTypeOther, nil
	case "ACCUMULATE_PROMOTION_POINTS":
		return LoyaltyEventTypeAccumulatePromotionPoints, nil
	}
	var t LoyaltyEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyEventType) Ptr() *LoyaltyEventType {
	return &l
}

// Filter events by event type.
type LoyaltyEventTypeFilter struct {
	// The loyalty event types used to filter the result.
	// If multiple values are specified, the endpoint uses a
	// logical OR to combine them.
	// See [LoyaltyEventType](#type-loyaltyeventtype) for possible values
	Types []LoyaltyEventType `json:"types,omitempty" url:"types,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyEventTypeFilter) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventTypeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventTypeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventTypeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventTypeFilter) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a Square loyalty program. Loyalty programs define how buyers can earn points and redeem points for rewards.
// Square sellers can have only one loyalty program, which is created and managed from the Seller Dashboard.
// For more information, see [Loyalty Program Overview](https://developer.squareup.com/docs/loyalty/overview).
type LoyaltyProgram struct {
	// The Square-assigned ID of the loyalty program. Updates to
	// the loyalty program do not modify the identifier.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Whether the program is currently active.
	// See [LoyaltyProgramStatus](#type-loyaltyprogramstatus) for possible values
	Status *LoyaltyProgramStatus `json:"status,omitempty" url:"status,omitempty"`
	// The list of rewards for buyers, sorted by ascending points.
	RewardTiers []*LoyaltyProgramRewardTier `json:"reward_tiers,omitempty" url:"reward_tiers,omitempty"`
	// If present, details for how points expire.
	ExpirationPolicy *LoyaltyProgramExpirationPolicy `json:"expiration_policy,omitempty" url:"expiration_policy,omitempty"`
	// A cosmetic name for the “points” currency.
	Terminology *LoyaltyProgramTerminology `json:"terminology,omitempty" url:"terminology,omitempty"`
	// The [locations](entity:Location) at which the program is active.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// The timestamp when the program was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the reward was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Defines how buyers can earn loyalty points from the base loyalty program.
	// To check for associated [loyalty promotions](entity:LoyaltyPromotion) that enable
	// buyers to earn extra points, call [ListLoyaltyPromotions](api-endpoint:Loyalty-ListLoyaltyPromotions).
	AccrualRules []*LoyaltyProgramAccrualRule `json:"accrual_rules,omitempty" url:"accrual_rules,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgram) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgram) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgram(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgram) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents an accrual rule, which defines how buyers can earn points from the base [loyalty program]($m/LoyaltyProgram).
type LoyaltyProgramAccrualRule struct {
	// The type of the accrual rule that defines how buyers can earn points.
	// See [LoyaltyProgramAccrualRuleType](#type-loyaltyprogramaccrualruletype) for possible values
	AccrualType LoyaltyProgramAccrualRuleType `json:"accrual_type" url:"accrual_type"`
	// The number of points that
	// buyers earn based on the `accrual_type`.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// Additional data for rules with the `VISIT` accrual type.
	VisitData *LoyaltyProgramAccrualRuleVisitData `json:"visit_data,omitempty" url:"visit_data,omitempty"`
	// Additional data for rules with the `SPEND` accrual type.
	SpendData *LoyaltyProgramAccrualRuleSpendData `json:"spend_data,omitempty" url:"spend_data,omitempty"`
	// Additional data for rules with the `ITEM_VARIATION` accrual type.
	ItemVariationData *LoyaltyProgramAccrualRuleItemVariationData `json:"item_variation_data,omitempty" url:"item_variation_data,omitempty"`
	// Additional data for rules with the `CATEGORY` accrual type.
	CategoryData *LoyaltyProgramAccrualRuleCategoryData `json:"category_data,omitempty" url:"category_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRule) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRule) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRule) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `CATEGORY` accrual type.
type LoyaltyProgramAccrualRuleCategoryData struct {
	// The ID of the `CATEGORY` [catalog object](entity:CatalogObject) that buyers can purchase to earn
	// points.
	CategoryID string `json:"category_id" url:"category_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleCategoryData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleCategoryData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleCategoryData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleCategoryData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleCategoryData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `ITEM_VARIATION` accrual type.
type LoyaltyProgramAccrualRuleItemVariationData struct {
	// The ID of the `ITEM_VARIATION` [catalog object](entity:CatalogObject) that buyers can purchase to earn
	// points.
	ItemVariationID string `json:"item_variation_id" url:"item_variation_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleItemVariationData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleItemVariationData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `SPEND` accrual type.
type LoyaltyProgramAccrualRuleSpendData struct {
	// The amount that buyers must spend to earn points.
	// For example, given an "Earn 1 point for every $10 spent" accrual rule, a buyer who spends $105 earns 10 points.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The IDs of any `CATEGORY` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded categories.
	ExcludedCategoryIDs []string `json:"excluded_category_ids,omitempty" url:"excluded_category_ids,omitempty"`
	// The IDs of any `ITEM_VARIATION` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded item variations.
	ExcludedItemVariationIDs []string `json:"excluded_item_variation_ids,omitempty" url:"excluded_item_variation_ids,omitempty"`
	// Indicates how taxes should be treated when calculating the purchase amount used for points accrual.
	// See [LoyaltyProgramAccrualRuleTaxMode](#type-loyaltyprogramaccrualruletaxmode) for possible values
	TaxMode LoyaltyProgramAccrualRuleTaxMode `json:"tax_mode" url:"tax_mode"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleSpendData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleSpendData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleSpendData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleSpendData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleSpendData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates how taxes should be treated when calculating the purchase amount used for loyalty points accrual.
// This setting applies only to `SPEND` accrual rules or `VISIT` accrual rules that have a minimum spend requirement.
type LoyaltyProgramAccrualRuleTaxMode string

const (
	LoyaltyProgramAccrualRuleTaxModeBeforeTax LoyaltyProgramAccrualRuleTaxMode = "BEFORE_TAX"
	LoyaltyProgramAccrualRuleTaxModeAfterTax  LoyaltyProgramAccrualRuleTaxMode = "AFTER_TAX"
)

func NewLoyaltyProgramAccrualRuleTaxModeFromString(s string) (LoyaltyProgramAccrualRuleTaxMode, error) {
	switch s {
	case "BEFORE_TAX":
		return LoyaltyProgramAccrualRuleTaxModeBeforeTax, nil
	case "AFTER_TAX":
		return LoyaltyProgramAccrualRuleTaxModeAfterTax, nil
	}
	var t LoyaltyProgramAccrualRuleTaxMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramAccrualRuleTaxMode) Ptr() *LoyaltyProgramAccrualRuleTaxMode {
	return &l
}

// The type of the accrual rule that defines how buyers can earn points.
type LoyaltyProgramAccrualRuleType string

const (
	LoyaltyProgramAccrualRuleTypeVisit         LoyaltyProgramAccrualRuleType = "VISIT"
	LoyaltyProgramAccrualRuleTypeSpend         LoyaltyProgramAccrualRuleType = "SPEND"
	LoyaltyProgramAccrualRuleTypeItemVariation LoyaltyProgramAccrualRuleType = "ITEM_VARIATION"
	LoyaltyProgramAccrualRuleTypeCategory      LoyaltyProgramAccrualRuleType = "CATEGORY"
)

func NewLoyaltyProgramAccrualRuleTypeFromString(s string) (LoyaltyProgramAccrualRuleType, error) {
	switch s {
	case "VISIT":
		return LoyaltyProgramAccrualRuleTypeVisit, nil
	case "SPEND":
		return LoyaltyProgramAccrualRuleTypeSpend, nil
	case "ITEM_VARIATION":
		return LoyaltyProgramAccrualRuleTypeItemVariation, nil
	case "CATEGORY":
		return LoyaltyProgramAccrualRuleTypeCategory, nil
	}
	var t LoyaltyProgramAccrualRuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramAccrualRuleType) Ptr() *LoyaltyProgramAccrualRuleType {
	return &l
}

// Represents additional data for rules with the `VISIT` accrual type.
type LoyaltyProgramAccrualRuleVisitData struct {
	// The minimum purchase required during the visit to quality for points.
	MinimumAmountMoney *Money `json:"minimum_amount_money,omitempty" url:"minimum_amount_money,omitempty"`
	// Indicates how taxes should be treated when calculating the purchase amount to determine whether the visit qualifies for points.
	// This setting applies only if `minimum_amount_money` is specified.
	// See [LoyaltyProgramAccrualRuleTaxMode](#type-loyaltyprogramaccrualruletaxmode) for possible values
	TaxMode LoyaltyProgramAccrualRuleTaxMode `json:"tax_mode" url:"tax_mode"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleVisitData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleVisitData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleVisitData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleVisitData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleVisitData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes when the loyalty program expires.
type LoyaltyProgramExpirationPolicy struct {
	// The number of months before points expire, in `P[n]M` RFC 3339 duration format. For example, a value of `P12M` represents a duration of 12 months.
	// Points are valid through the last day of the month in which they are scheduled to expire. For example, with a `P12M` duration, points earned on July 6, 2020 expire on August 1, 2021.
	ExpirationDuration string `json:"expiration_duration" url:"expiration_duration"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramExpirationPolicy) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramExpirationPolicy) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramExpirationPolicy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramExpirationPolicy(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramExpirationPolicy) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides details about the reward tier discount. DEPRECATED at version 2020-12-16. Discount details
// are now defined using a catalog pricing rule and other catalog objects. For more information, see
// [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
type LoyaltyProgramRewardDefinition struct {
	// Indicates the scope of the reward tier. DEPRECATED at version 2020-12-16. You can find this information in the
	// `product_set_data` field of the `PRODUCT_SET` catalog object referenced by the pricing rule. For `ORDER` scopes,
	// `all_products` is true. For `ITEM_VARIATION` or `CATEGORY` scopes, `product_ids_any` is a list of
	// catalog object IDs of the given type.
	// See [LoyaltyProgramRewardDefinitionScope](#type-loyaltyprogramrewarddefinitionscope) for possible values
	Scope LoyaltyProgramRewardDefinitionScope `json:"scope" url:"scope"`
	// The type of discount the reward tier offers. DEPRECATED at version 2020-12-16. You can find this information
	// in the `discount_data.discount_type` field of the `DISCOUNT` catalog object referenced by the pricing rule.
	// See [LoyaltyProgramRewardDefinitionType](#type-loyaltyprogramrewarddefinitiontype) for possible values
	DiscountType LoyaltyProgramRewardDefinitionType `json:"discount_type" url:"discount_type"`
	// The fixed percentage of the discount. Present if `discount_type` is `FIXED_PERCENTAGE`.
	// For example, a 7.25% off discount will be represented as "7.25". DEPRECATED at version 2020-12-16. You can find this
	// information in the `discount_data.percentage` field of the `DISCOUNT` catalog object referenced by the pricing rule.
	PercentageDiscount *string `json:"percentage_discount,omitempty" url:"percentage_discount,omitempty"`
	// The list of catalog objects to which this reward can be applied. They are either all item-variation ids or category ids, depending on the `type` field.
	// DEPRECATED at version 2020-12-16. You can find this information in the `product_set_data.product_ids_any` field
	// of the `PRODUCT_SET` catalog object referenced by the pricing rule.
	CatalogObjectIDs []string `json:"catalog_object_ids,omitempty" url:"catalog_object_ids,omitempty"`
	// The amount of the discount. Present if `discount_type` is `FIXED_AMOUNT`. For example, $5 off.
	// DEPRECATED at version 2020-12-16. You can find this information in the `discount_data.amount_money` field of the
	// `DISCOUNT` catalog object referenced by the pricing rule.
	FixedDiscountMoney *Money `json:"fixed_discount_money,omitempty" url:"fixed_discount_money,omitempty"`
	// When `discount_type` is `FIXED_PERCENTAGE`, the maximum discount amount that can be applied.
	// DEPRECATED at version 2020-12-16. You can find this information in the `discount_data.maximum_amount_money` field
	// of the `DISCOUNT` catalog object referenced by the the pricing rule.
	MaxDiscountMoney *Money `json:"max_discount_money,omitempty" url:"max_discount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramRewardDefinition) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramRewardDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramRewardDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramRewardDefinition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramRewardDefinition) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the scope of the reward tier. DEPRECATED at version 2020-12-16. Discount details
// are now defined using a catalog pricing rule and other catalog objects. For more information, see
// [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
type LoyaltyProgramRewardDefinitionScope string

const (
	LoyaltyProgramRewardDefinitionScopeOrder         LoyaltyProgramRewardDefinitionScope = "ORDER"
	LoyaltyProgramRewardDefinitionScopeItemVariation LoyaltyProgramRewardDefinitionScope = "ITEM_VARIATION"
	LoyaltyProgramRewardDefinitionScopeCategory      LoyaltyProgramRewardDefinitionScope = "CATEGORY"
)

func NewLoyaltyProgramRewardDefinitionScopeFromString(s string) (LoyaltyProgramRewardDefinitionScope, error) {
	switch s {
	case "ORDER":
		return LoyaltyProgramRewardDefinitionScopeOrder, nil
	case "ITEM_VARIATION":
		return LoyaltyProgramRewardDefinitionScopeItemVariation, nil
	case "CATEGORY":
		return LoyaltyProgramRewardDefinitionScopeCategory, nil
	}
	var t LoyaltyProgramRewardDefinitionScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramRewardDefinitionScope) Ptr() *LoyaltyProgramRewardDefinitionScope {
	return &l
}

// The type of discount the reward tier offers. DEPRECATED at version 2020-12-16. Discount details
// are now defined using a catalog pricing rule and other catalog objects. For more information, see
// [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
type LoyaltyProgramRewardDefinitionType string

const (
	LoyaltyProgramRewardDefinitionTypeFixedAmount     LoyaltyProgramRewardDefinitionType = "FIXED_AMOUNT"
	LoyaltyProgramRewardDefinitionTypeFixedPercentage LoyaltyProgramRewardDefinitionType = "FIXED_PERCENTAGE"
)

func NewLoyaltyProgramRewardDefinitionTypeFromString(s string) (LoyaltyProgramRewardDefinitionType, error) {
	switch s {
	case "FIXED_AMOUNT":
		return LoyaltyProgramRewardDefinitionTypeFixedAmount, nil
	case "FIXED_PERCENTAGE":
		return LoyaltyProgramRewardDefinitionTypeFixedPercentage, nil
	}
	var t LoyaltyProgramRewardDefinitionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramRewardDefinitionType) Ptr() *LoyaltyProgramRewardDefinitionType {
	return &l
}

// Represents a reward tier in a loyalty program. A reward tier defines how buyers can redeem points for a reward, such as the number of points required and the value and scope of the discount. A loyalty program can offer multiple reward tiers.
type LoyaltyProgramRewardTier struct {
	// The Square-assigned ID of the reward tier.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The points exchanged for the reward tier.
	Points int `json:"points" url:"points"`
	// The name of the reward tier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Provides details about the reward tier definition.
	// DEPRECATED at version 2020-12-16. Replaced by the `pricing_rule_reference` field.
	Definition *LoyaltyProgramRewardDefinition `json:"definition,omitempty" url:"definition,omitempty"`
	// The timestamp when the reward tier was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A reference to the specific version of a `PRICING_RULE` catalog object that contains information about the reward tier discount.
	//
	// Use `object_id` and `catalog_version` with the [RetrieveCatalogObject](api-endpoint:Catalog-RetrieveCatalogObject) endpoint
	// to get discount details. Make sure to set `include_related_objects` to true in the request to retrieve all catalog objects
	// that define the discount. For more information, see [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
	PricingRuleReference *CatalogObjectReference `json:"pricing_rule_reference,omitempty" url:"pricing_rule_reference,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramRewardTier) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramRewardTier) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramRewardTier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramRewardTier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramRewardTier) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates whether the program is currently active.
type LoyaltyProgramStatus string

const (
	LoyaltyProgramStatusInactive LoyaltyProgramStatus = "INACTIVE"
	LoyaltyProgramStatusActive   LoyaltyProgramStatus = "ACTIVE"
)

func NewLoyaltyProgramStatusFromString(s string) (LoyaltyProgramStatus, error) {
	switch s {
	case "INACTIVE":
		return LoyaltyProgramStatusInactive, nil
	case "ACTIVE":
		return LoyaltyProgramStatusActive, nil
	}
	var t LoyaltyProgramStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramStatus) Ptr() *LoyaltyProgramStatus {
	return &l
}

// Represents the naming used for loyalty points.
type LoyaltyProgramTerminology struct {
	// A singular unit for a point (for example, 1 point is called 1 star).
	One string `json:"one" url:"one"`
	// A plural unit for point (for example, 10 points is called 10 stars).
	Other string `json:"other" url:"other"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyProgramTerminology) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramTerminology) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramTerminology
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramTerminology(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramTerminology) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a promotion for a [loyalty program]($m/LoyaltyProgram). Loyalty promotions enable buyers
// to earn extra points on top of those earned from the base program.
//
// A loyalty program can have a maximum of 10 loyalty promotions with an `ACTIVE` or `SCHEDULED` status.
type LoyaltyPromotion struct {
	// The Square-assigned ID of the promotion.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the promotion.
	Name string `json:"name" url:"name"`
	// The points incentive for the promotion. This field defines whether promotion points
	// are earned by multiplying base program points or by adding a specified number of points.
	Incentive *LoyaltyPromotionIncentive `json:"incentive,omitempty" url:"incentive,omitempty"`
	// The scheduling information that defines when purchases can qualify to earn points from an `ACTIVE` promotion.
	AvailableTime *LoyaltyPromotionAvailableTimeData `json:"available_time,omitempty" url:"available_time,omitempty"`
	// The number of times a buyer can earn promotion points during a specified interval.
	// If not specified, buyers can trigger the promotion an unlimited number of times.
	TriggerLimit *LoyaltyPromotionTriggerLimit `json:"trigger_limit,omitempty" url:"trigger_limit,omitempty"`
	// The current status of the promotion.
	// See [LoyaltyPromotionStatus](#type-loyaltypromotionstatus) for possible values
	Status *LoyaltyPromotionStatus `json:"status,omitempty" url:"status,omitempty"`
	// The timestamp of when the promotion was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the promotion was canceled, in RFC 3339 format.
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// The timestamp when the promotion was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the [loyalty program](entity:LoyaltyProgram) associated with the promotion.
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The minimum purchase amount required to earn promotion points. If specified, this amount is positive.
	MinimumSpendAmountMoney *Money `json:"minimum_spend_amount_money,omitempty" url:"minimum_spend_amount_money,omitempty"`
	// The IDs of any qualifying `ITEM_VARIATION` [catalog objects](entity:CatalogObject). If specified,
	// the purchase must include at least one of these items to qualify for the promotion.
	//
	// This option is valid only if the base loyalty program uses a `VISIT` or `SPEND` accrual rule.
	// With `SPEND` accrual rules, make sure that qualifying promotional items are not excluded.
	//
	// You can specify `qualifying_item_variation_ids` or `qualifying_category_ids` for a given promotion, but not both.
	QualifyingItemVariationIDs []string `json:"qualifying_item_variation_ids,omitempty" url:"qualifying_item_variation_ids,omitempty"`
	// The IDs of any qualifying `CATEGORY` [catalog objects](entity:CatalogObject). If specified,
	// the purchase must include at least one item from one of these categories to qualify for the promotion.
	//
	// This option is valid only if the base loyalty program uses a `VISIT` or `SPEND` accrual rule.
	// With `SPEND` accrual rules, make sure that qualifying promotional items are not excluded.
	//
	// You can specify `qualifying_category_ids` or `qualifying_item_variation_ids` for a promotion, but not both.
	QualifyingCategoryIDs []string `json:"qualifying_category_ids,omitempty" url:"qualifying_category_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotion) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotion) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotion(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotion) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents scheduling information that determines when purchases can qualify to earn points
// from a [loyalty promotion]($m/LoyaltyPromotion).
type LoyaltyPromotionAvailableTimeData struct {
	// The date that the promotion starts, in `YYYY-MM-DD` format. Square populates this field
	// based on the provided `time_periods`.
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The date that the promotion ends, in `YYYY-MM-DD` format. Square populates this field
	// based on the provided `time_periods`. If an end date is not specified, an `ACTIVE` promotion
	// remains available until it is canceled.
	EndDate *string `json:"end_date,omitempty" url:"end_date,omitempty"`
	// A list of [iCalendar (RFC 5545) events](https://tools.ietf.org/html/rfc5545#section-3.6.1)
	// (`VEVENT`). Each event represents an available time period per day or days of the week.
	// A day can have a maximum of one available time period.
	//
	// Only `DTSTART`, `DURATION`, and `RRULE` are supported. `DTSTART` and `DURATION` are required and
	// timestamps must be in local (unzoned) time format. Include `RRULE` to specify recurring promotions,
	// an end date (using the `UNTIL` keyword), or both. For more information, see
	// [Available time](https://developer.squareup.com/docs/loyalty-api/loyalty-promotions#available-time).
	//
	// Note that `BEGIN:VEVENT` and `END:VEVENT` are optional in a `CreateLoyaltyPromotion` request
	// but are always included in the response.
	TimePeriods []string `json:"time_periods,omitempty" url:"time_periods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionAvailableTimeData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionAvailableTimeData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionAvailableTimeData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionAvailableTimeData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionAvailableTimeData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents how points for a [loyalty promotion]($m/LoyaltyPromotion) are calculated,
// either by multiplying the points earned from the base program or by adding a specified number
// of points to the points earned from the base program.
type LoyaltyPromotionIncentive struct {
	// The type of points incentive.
	// See [LoyaltyPromotionIncentiveType](#type-loyaltypromotionincentivetype) for possible values
	Type LoyaltyPromotionIncentiveType `json:"type" url:"type"`
	// Additional data for a `POINTS_MULTIPLIER` incentive type.
	PointsMultiplierData *LoyaltyPromotionIncentivePointsMultiplierData `json:"points_multiplier_data,omitempty" url:"points_multiplier_data,omitempty"`
	// Additional data for a `POINTS_ADDITION` incentive type.
	PointsAdditionData *LoyaltyPromotionIncentivePointsAdditionData `json:"points_addition_data,omitempty" url:"points_addition_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionIncentive) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentive) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentive(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentive) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the metadata for a `POINTS_ADDITION` type of [loyalty promotion incentive]($m/LoyaltyPromotionIncentive).
type LoyaltyPromotionIncentivePointsAdditionData struct {
	// The number of additional points to earn each time the promotion is triggered. For example,
	// suppose a purchase qualifies for 5 points from the base loyalty program. If the purchase also
	// qualifies for a `POINTS_ADDITION` promotion incentive with a `points_addition` of 3, the buyer
	// earns a total of 8 points (5 program points + 3 promotion points = 8 points).
	PointsAddition int `json:"points_addition" url:"points_addition"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentivePointsAdditionData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentivePointsAdditionData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the metadata for a `POINTS_MULTIPLIER` type of [loyalty promotion incentive]($m/LoyaltyPromotionIncentive).
type LoyaltyPromotionIncentivePointsMultiplierData struct {
	// The multiplier used to calculate the number of points earned each time the promotion
	// is triggered. For example, suppose a purchase qualifies for 5 points from the base loyalty program.
	// If the purchase also qualifies for a `POINTS_MULTIPLIER` promotion incentive with a `points_multiplier`
	// of 3, the buyer earns a total of 15 points (5 program points x 3 promotion multiplier = 15 points).
	//
	// DEPRECATED at version 2023-08-16. Replaced by the `multiplier` field.
	//
	// One of the following is required when specifying a points multiplier:
	//
	//   - (Recommended) The `multiplier` field.
	//   - This deprecated `points_multiplier` field. If provided in the request, Square also returns `multiplier`
	//     with the equivalent value.
	PointsMultiplier *int `json:"points_multiplier,omitempty" url:"points_multiplier,omitempty"`
	// The multiplier used to calculate the number of points earned each time the promotion is triggered,
	// specified as a string representation of a decimal. Square supports multipliers up to 10x, with three
	// point precision for decimal multipliers. For example, suppose a purchase qualifies for 4 points from the
	// base loyalty program. If the purchase also qualifies for a `POINTS_MULTIPLIER` promotion incentive with a
	// `multiplier` of "1.5", the buyer earns a total of 6 points (4 program points x 1.5 promotion multiplier = 6 points).
	// Fractional points are dropped.
	//
	// One of the following is required when specifying a points multiplier:
	//
	//   - (Recommended) This `multiplier` field.
	//   - The deprecated `points_multiplier` field. If provided in the request, Square also returns `multiplier`
	//     with the equivalent value.
	Multiplier *string `json:"multiplier,omitempty" url:"multiplier,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentivePointsMultiplierData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentivePointsMultiplierData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the type of points incentive for a [loyalty promotion]($m/LoyaltyPromotion),
// which is used to determine how buyers can earn points from the promotion.
type LoyaltyPromotionIncentiveType string

const (
	LoyaltyPromotionIncentiveTypePointsMultiplier LoyaltyPromotionIncentiveType = "POINTS_MULTIPLIER"
	LoyaltyPromotionIncentiveTypePointsAddition   LoyaltyPromotionIncentiveType = "POINTS_ADDITION"
)

func NewLoyaltyPromotionIncentiveTypeFromString(s string) (LoyaltyPromotionIncentiveType, error) {
	switch s {
	case "POINTS_MULTIPLIER":
		return LoyaltyPromotionIncentiveTypePointsMultiplier, nil
	case "POINTS_ADDITION":
		return LoyaltyPromotionIncentiveTypePointsAddition, nil
	}
	var t LoyaltyPromotionIncentiveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionIncentiveType) Ptr() *LoyaltyPromotionIncentiveType {
	return &l
}

// Indicates the status of a [loyalty promotion]($m/LoyaltyPromotion).
type LoyaltyPromotionStatus string

const (
	LoyaltyPromotionStatusActive    LoyaltyPromotionStatus = "ACTIVE"
	LoyaltyPromotionStatusEnded     LoyaltyPromotionStatus = "ENDED"
	LoyaltyPromotionStatusCanceled  LoyaltyPromotionStatus = "CANCELED"
	LoyaltyPromotionStatusScheduled LoyaltyPromotionStatus = "SCHEDULED"
)

func NewLoyaltyPromotionStatusFromString(s string) (LoyaltyPromotionStatus, error) {
	switch s {
	case "ACTIVE":
		return LoyaltyPromotionStatusActive, nil
	case "ENDED":
		return LoyaltyPromotionStatusEnded, nil
	case "CANCELED":
		return LoyaltyPromotionStatusCanceled, nil
	case "SCHEDULED":
		return LoyaltyPromotionStatusScheduled, nil
	}
	var t LoyaltyPromotionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionStatus) Ptr() *LoyaltyPromotionStatus {
	return &l
}

// Represents the number of times a buyer can earn points during a [loyalty promotion]($m/LoyaltyPromotion).
// If this field is not set, buyers can trigger the promotion an unlimited number of times to earn points during
// the time that the promotion is available.
//
// A purchase that is disqualified from earning points because of this limit might qualify for another active promotion.
type LoyaltyPromotionTriggerLimit struct {
	// The maximum number of times a buyer can trigger the promotion during the specified `interval`.
	Times int `json:"times" url:"times"`
	// The time period the limit applies to.
	// See [LoyaltyPromotionTriggerLimitInterval](#type-loyaltypromotiontriggerlimitinterval) for possible values
	Interval *LoyaltyPromotionTriggerLimitInterval `json:"interval,omitempty" url:"interval,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyPromotionTriggerLimit) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionTriggerLimit) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionTriggerLimit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionTriggerLimit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionTriggerLimit) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the time period that the [trigger limit]($m/LoyaltyPromotionTriggerLimit) applies to,
// which is used to determine the number of times a buyer can earn points for a [loyalty promotion]($m/LoyaltyPromotion).
type LoyaltyPromotionTriggerLimitInterval string

const (
	LoyaltyPromotionTriggerLimitIntervalAllTime LoyaltyPromotionTriggerLimitInterval = "ALL_TIME"
	LoyaltyPromotionTriggerLimitIntervalDay     LoyaltyPromotionTriggerLimitInterval = "DAY"
)

func NewLoyaltyPromotionTriggerLimitIntervalFromString(s string) (LoyaltyPromotionTriggerLimitInterval, error) {
	switch s {
	case "ALL_TIME":
		return LoyaltyPromotionTriggerLimitIntervalAllTime, nil
	case "DAY":
		return LoyaltyPromotionTriggerLimitIntervalDay, nil
	}
	var t LoyaltyPromotionTriggerLimitInterval
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionTriggerLimitInterval) Ptr() *LoyaltyPromotionTriggerLimitInterval {
	return &l
}

// Represents a contract to redeem loyalty points for a [reward tier]($m/LoyaltyProgramRewardTier) discount. Loyalty rewards can be in an ISSUED, REDEEMED, or DELETED state.
// For more information, see [Manage loyalty rewards](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards).
type LoyaltyReward struct {
	// The Square-assigned ID of the loyalty reward.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The status of a loyalty reward.
	// See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
	Status *LoyaltyRewardStatus `json:"status,omitempty" url:"status,omitempty"`
	// The Square-assigned ID of the [loyalty account](entity:LoyaltyAccount) to which the reward belongs.
	LoyaltyAccountID string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The Square-assigned ID of the [reward tier](entity:LoyaltyProgramRewardTier) used to create the reward.
	RewardTierID string `json:"reward_tier_id" url:"reward_tier_id"`
	// The number of loyalty points used for the reward.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The Square-assigned ID of the [order](entity:Order) to which the reward is attached.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The timestamp when the reward was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the reward was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp when the reward was redeemed, in RFC 3339 format.
	RedeemedAt *string `json:"redeemed_at,omitempty" url:"redeemed_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoyaltyReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyReward) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The status of the loyalty reward.
type LoyaltyRewardStatus string

const (
	LoyaltyRewardStatusIssued   LoyaltyRewardStatus = "ISSUED"
	LoyaltyRewardStatusRedeemed LoyaltyRewardStatus = "REDEEMED"
	LoyaltyRewardStatusDeleted  LoyaltyRewardStatus = "DELETED"
)

func NewLoyaltyRewardStatusFromString(s string) (LoyaltyRewardStatus, error) {
	switch s {
	case "ISSUED":
		return LoyaltyRewardStatusIssued, nil
	case "REDEEMED":
		return LoyaltyRewardStatusRedeemed, nil
	case "DELETED":
		return LoyaltyRewardStatusDeleted, nil
	}
	var t LoyaltyRewardStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyRewardStatus) Ptr() *LoyaltyRewardStatus {
	return &l
}

// Represents a unit of measurement to use with a quantity, such as ounces
// or inches. Exactly one of the following fields are required: `custom_unit`,
// `area_unit`, `length_unit`, `volume_unit`, and `weight_unit`.
type MeasurementUnit struct {
	// A custom unit of measurement defined by the seller using the Point of Sale
	// app or ad-hoc as an order line item.
	CustomUnit *MeasurementUnitCustom `json:"custom_unit,omitempty" url:"custom_unit,omitempty"`
	// Represents a standard area unit.
	// See [MeasurementUnitArea](#type-measurementunitarea) for possible values
	AreaUnit *MeasurementUnitArea `json:"area_unit,omitempty" url:"area_unit,omitempty"`
	// Represents a standard length unit.
	// See [MeasurementUnitLength](#type-measurementunitlength) for possible values
	LengthUnit *MeasurementUnitLength `json:"length_unit,omitempty" url:"length_unit,omitempty"`
	// Represents a standard volume unit.
	// See [MeasurementUnitVolume](#type-measurementunitvolume) for possible values
	VolumeUnit *MeasurementUnitVolume `json:"volume_unit,omitempty" url:"volume_unit,omitempty"`
	// Represents a standard unit of weight or mass.
	// See [MeasurementUnitWeight](#type-measurementunitweight) for possible values
	WeightUnit *MeasurementUnitWeight `json:"weight_unit,omitempty" url:"weight_unit,omitempty"`
	// Reserved for API integrations that lack the ability to specify a real measurement unit
	// See [MeasurementUnitGeneric](#type-measurementunitgeneric) for possible values
	GenericUnit *MeasurementUnitGeneric `json:"generic_unit,omitempty" url:"generic_unit,omitempty"`
	// Represents a standard unit of time.
	// See [MeasurementUnitTime](#type-measurementunittime) for possible values
	TimeUnit *MeasurementUnitTime `json:"time_unit,omitempty" url:"time_unit,omitempty"`
	// Represents the type of the measurement unit.
	// See [MeasurementUnitUnitType](#type-measurementunitunittype) for possible values
	Type *MeasurementUnitUnitType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnit) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnit) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Unit of area used to measure a quantity.
type MeasurementUnitArea string

const (
	MeasurementUnitAreaImperialAcre           MeasurementUnitArea = "IMPERIAL_ACRE"
	MeasurementUnitAreaImperialSquareInch     MeasurementUnitArea = "IMPERIAL_SQUARE_INCH"
	MeasurementUnitAreaImperialSquareFoot     MeasurementUnitArea = "IMPERIAL_SQUARE_FOOT"
	MeasurementUnitAreaImperialSquareYard     MeasurementUnitArea = "IMPERIAL_SQUARE_YARD"
	MeasurementUnitAreaImperialSquareMile     MeasurementUnitArea = "IMPERIAL_SQUARE_MILE"
	MeasurementUnitAreaMetricSquareCentimeter MeasurementUnitArea = "METRIC_SQUARE_CENTIMETER"
	MeasurementUnitAreaMetricSquareMeter      MeasurementUnitArea = "METRIC_SQUARE_METER"
	MeasurementUnitAreaMetricSquareKilometer  MeasurementUnitArea = "METRIC_SQUARE_KILOMETER"
)

func NewMeasurementUnitAreaFromString(s string) (MeasurementUnitArea, error) {
	switch s {
	case "IMPERIAL_ACRE":
		return MeasurementUnitAreaImperialAcre, nil
	case "IMPERIAL_SQUARE_INCH":
		return MeasurementUnitAreaImperialSquareInch, nil
	case "IMPERIAL_SQUARE_FOOT":
		return MeasurementUnitAreaImperialSquareFoot, nil
	case "IMPERIAL_SQUARE_YARD":
		return MeasurementUnitAreaImperialSquareYard, nil
	case "IMPERIAL_SQUARE_MILE":
		return MeasurementUnitAreaImperialSquareMile, nil
	case "METRIC_SQUARE_CENTIMETER":
		return MeasurementUnitAreaMetricSquareCentimeter, nil
	case "METRIC_SQUARE_METER":
		return MeasurementUnitAreaMetricSquareMeter, nil
	case "METRIC_SQUARE_KILOMETER":
		return MeasurementUnitAreaMetricSquareKilometer, nil
	}
	var t MeasurementUnitArea
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitArea) Ptr() *MeasurementUnitArea {
	return &m
}

// The information needed to define a custom unit, provided by the seller.
type MeasurementUnitCustom struct {
	// The name of the custom unit, for example "bushel".
	Name string `json:"name" url:"name"`
	// The abbreviation of the custom unit, such as "bsh" (bushel). This appears
	// in the cart for the Point of Sale app, and in reports.
	Abbreviation string `json:"abbreviation" url:"abbreviation"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnitCustom) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnitCustom) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnitCustom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnitCustom(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnitCustom) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MeasurementUnitGeneric = string

// The unit of length used to measure a quantity.
type MeasurementUnitLength string

const (
	MeasurementUnitLengthImperialInch     MeasurementUnitLength = "IMPERIAL_INCH"
	MeasurementUnitLengthImperialFoot     MeasurementUnitLength = "IMPERIAL_FOOT"
	MeasurementUnitLengthImperialYard     MeasurementUnitLength = "IMPERIAL_YARD"
	MeasurementUnitLengthImperialMile     MeasurementUnitLength = "IMPERIAL_MILE"
	MeasurementUnitLengthMetricMillimeter MeasurementUnitLength = "METRIC_MILLIMETER"
	MeasurementUnitLengthMetricCentimeter MeasurementUnitLength = "METRIC_CENTIMETER"
	MeasurementUnitLengthMetricMeter      MeasurementUnitLength = "METRIC_METER"
	MeasurementUnitLengthMetricKilometer  MeasurementUnitLength = "METRIC_KILOMETER"
)

func NewMeasurementUnitLengthFromString(s string) (MeasurementUnitLength, error) {
	switch s {
	case "IMPERIAL_INCH":
		return MeasurementUnitLengthImperialInch, nil
	case "IMPERIAL_FOOT":
		return MeasurementUnitLengthImperialFoot, nil
	case "IMPERIAL_YARD":
		return MeasurementUnitLengthImperialYard, nil
	case "IMPERIAL_MILE":
		return MeasurementUnitLengthImperialMile, nil
	case "METRIC_MILLIMETER":
		return MeasurementUnitLengthMetricMillimeter, nil
	case "METRIC_CENTIMETER":
		return MeasurementUnitLengthMetricCentimeter, nil
	case "METRIC_METER":
		return MeasurementUnitLengthMetricMeter, nil
	case "METRIC_KILOMETER":
		return MeasurementUnitLengthMetricKilometer, nil
	}
	var t MeasurementUnitLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitLength) Ptr() *MeasurementUnitLength {
	return &m
}

// Unit of time used to measure a quantity (a duration).
type MeasurementUnitTime string

const (
	MeasurementUnitTimeGenericMillisecond MeasurementUnitTime = "GENERIC_MILLISECOND"
	MeasurementUnitTimeGenericSecond      MeasurementUnitTime = "GENERIC_SECOND"
	MeasurementUnitTimeGenericMinute      MeasurementUnitTime = "GENERIC_MINUTE"
	MeasurementUnitTimeGenericHour        MeasurementUnitTime = "GENERIC_HOUR"
	MeasurementUnitTimeGenericDay         MeasurementUnitTime = "GENERIC_DAY"
)

func NewMeasurementUnitTimeFromString(s string) (MeasurementUnitTime, error) {
	switch s {
	case "GENERIC_MILLISECOND":
		return MeasurementUnitTimeGenericMillisecond, nil
	case "GENERIC_SECOND":
		return MeasurementUnitTimeGenericSecond, nil
	case "GENERIC_MINUTE":
		return MeasurementUnitTimeGenericMinute, nil
	case "GENERIC_HOUR":
		return MeasurementUnitTimeGenericHour, nil
	case "GENERIC_DAY":
		return MeasurementUnitTimeGenericDay, nil
	}
	var t MeasurementUnitTime
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitTime) Ptr() *MeasurementUnitTime {
	return &m
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type MeasurementUnitUnitType string

const (
	MeasurementUnitUnitTypeTypeCustom  MeasurementUnitUnitType = "TYPE_CUSTOM"
	MeasurementUnitUnitTypeTypeArea    MeasurementUnitUnitType = "TYPE_AREA"
	MeasurementUnitUnitTypeTypeLength  MeasurementUnitUnitType = "TYPE_LENGTH"
	MeasurementUnitUnitTypeTypeVolume  MeasurementUnitUnitType = "TYPE_VOLUME"
	MeasurementUnitUnitTypeTypeWeight  MeasurementUnitUnitType = "TYPE_WEIGHT"
	MeasurementUnitUnitTypeTypeGeneric MeasurementUnitUnitType = "TYPE_GENERIC"
)

func NewMeasurementUnitUnitTypeFromString(s string) (MeasurementUnitUnitType, error) {
	switch s {
	case "TYPE_CUSTOM":
		return MeasurementUnitUnitTypeTypeCustom, nil
	case "TYPE_AREA":
		return MeasurementUnitUnitTypeTypeArea, nil
	case "TYPE_LENGTH":
		return MeasurementUnitUnitTypeTypeLength, nil
	case "TYPE_VOLUME":
		return MeasurementUnitUnitTypeTypeVolume, nil
	case "TYPE_WEIGHT":
		return MeasurementUnitUnitTypeTypeWeight, nil
	case "TYPE_GENERIC":
		return MeasurementUnitUnitTypeTypeGeneric, nil
	}
	var t MeasurementUnitUnitType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitUnitType) Ptr() *MeasurementUnitUnitType {
	return &m
}

// The unit of volume used to measure a quantity.
type MeasurementUnitVolume string

const (
	MeasurementUnitVolumeGenericFluidOunce MeasurementUnitVolume = "GENERIC_FLUID_OUNCE"
	MeasurementUnitVolumeGenericShot       MeasurementUnitVolume = "GENERIC_SHOT"
	MeasurementUnitVolumeGenericCup        MeasurementUnitVolume = "GENERIC_CUP"
	MeasurementUnitVolumeGenericPint       MeasurementUnitVolume = "GENERIC_PINT"
	MeasurementUnitVolumeGenericQuart      MeasurementUnitVolume = "GENERIC_QUART"
	MeasurementUnitVolumeGenericGallon     MeasurementUnitVolume = "GENERIC_GALLON"
	MeasurementUnitVolumeImperialCubicInch MeasurementUnitVolume = "IMPERIAL_CUBIC_INCH"
	MeasurementUnitVolumeImperialCubicFoot MeasurementUnitVolume = "IMPERIAL_CUBIC_FOOT"
	MeasurementUnitVolumeImperialCubicYard MeasurementUnitVolume = "IMPERIAL_CUBIC_YARD"
	MeasurementUnitVolumeMetricMilliliter  MeasurementUnitVolume = "METRIC_MILLILITER"
	MeasurementUnitVolumeMetricLiter       MeasurementUnitVolume = "METRIC_LITER"
)

func NewMeasurementUnitVolumeFromString(s string) (MeasurementUnitVolume, error) {
	switch s {
	case "GENERIC_FLUID_OUNCE":
		return MeasurementUnitVolumeGenericFluidOunce, nil
	case "GENERIC_SHOT":
		return MeasurementUnitVolumeGenericShot, nil
	case "GENERIC_CUP":
		return MeasurementUnitVolumeGenericCup, nil
	case "GENERIC_PINT":
		return MeasurementUnitVolumeGenericPint, nil
	case "GENERIC_QUART":
		return MeasurementUnitVolumeGenericQuart, nil
	case "GENERIC_GALLON":
		return MeasurementUnitVolumeGenericGallon, nil
	case "IMPERIAL_CUBIC_INCH":
		return MeasurementUnitVolumeImperialCubicInch, nil
	case "IMPERIAL_CUBIC_FOOT":
		return MeasurementUnitVolumeImperialCubicFoot, nil
	case "IMPERIAL_CUBIC_YARD":
		return MeasurementUnitVolumeImperialCubicYard, nil
	case "METRIC_MILLILITER":
		return MeasurementUnitVolumeMetricMilliliter, nil
	case "METRIC_LITER":
		return MeasurementUnitVolumeMetricLiter, nil
	}
	var t MeasurementUnitVolume
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitVolume) Ptr() *MeasurementUnitVolume {
	return &m
}

// Unit of weight used to measure a quantity.
type MeasurementUnitWeight string

const (
	MeasurementUnitWeightImperialWeightOunce MeasurementUnitWeight = "IMPERIAL_WEIGHT_OUNCE"
	MeasurementUnitWeightImperialPound       MeasurementUnitWeight = "IMPERIAL_POUND"
	MeasurementUnitWeightImperialStone       MeasurementUnitWeight = "IMPERIAL_STONE"
	MeasurementUnitWeightMetricMilligram     MeasurementUnitWeight = "METRIC_MILLIGRAM"
	MeasurementUnitWeightMetricGram          MeasurementUnitWeight = "METRIC_GRAM"
	MeasurementUnitWeightMetricKilogram      MeasurementUnitWeight = "METRIC_KILOGRAM"
)

func NewMeasurementUnitWeightFromString(s string) (MeasurementUnitWeight, error) {
	switch s {
	case "IMPERIAL_WEIGHT_OUNCE":
		return MeasurementUnitWeightImperialWeightOunce, nil
	case "IMPERIAL_POUND":
		return MeasurementUnitWeightImperialPound, nil
	case "IMPERIAL_STONE":
		return MeasurementUnitWeightImperialStone, nil
	case "METRIC_MILLIGRAM":
		return MeasurementUnitWeightMetricMilligram, nil
	case "METRIC_GRAM":
		return MeasurementUnitWeightMetricGram, nil
	case "METRIC_KILOGRAM":
		return MeasurementUnitWeightMetricKilogram, nil
	}
	var t MeasurementUnitWeight
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitWeight) Ptr() *MeasurementUnitWeight {
	return &m
}

// Represents a business that sells with Square.
type Merchant struct {
	// The Square-issued ID of the merchant.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the merchant's overall business.
	BusinessName *string `json:"business_name,omitempty" url:"business_name,omitempty"`
	// The country code associated with the merchant, in the two-letter format of ISO 3166. For example, `US` or `JP`.
	// See [Country](#type-country) for possible values
	Country Country `json:"country" url:"country"`
	// The code indicating the [language preferences](https://developer.squareup.com/docs/build-basics/general-considerations/language-preferences) of the merchant, in [BCP 47 format](https://tools.ietf.org/html/bcp47#appendix-A). For example, `en-US` or `fr-CA`.
	LanguageCode *string `json:"language_code,omitempty" url:"language_code,omitempty"`
	// The currency associated with the merchant, in ISO 4217 format. For example, the currency code for US dollars is `USD`.
	// See [Currency](#type-currency) for possible values
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	// The merchant's status.
	// See [MerchantStatus](#type-merchantstatus) for possible values
	Status *MerchantStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the [main `Location`](https://developer.squareup.com/docs/locations-api#about-the-main-location) for this merchant.
	MainLocationID *string `json:"main_location_id,omitempty" url:"main_location_id,omitempty"`
	// The time when the merchant was created, in RFC 3339 format.
	// For more information, see [Working with Dates](https://developer.squareup.com/docs/build-basics/working-with-dates).
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Merchant) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Merchant) UnmarshalJSON(data []byte) error {
	type unmarshaler Merchant
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Merchant(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Merchant) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MerchantStatus string

const (
	MerchantStatusActive   MerchantStatus = "ACTIVE"
	MerchantStatusInactive MerchantStatus = "INACTIVE"
)

func NewMerchantStatusFromString(s string) (MerchantStatus, error) {
	switch s {
	case "ACTIVE":
		return MerchantStatusActive, nil
	case "INACTIVE":
		return MerchantStatusInactive, nil
	}
	var t MerchantStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MerchantStatus) Ptr() *MerchantStatus {
	return &m
}

// Location-specific overrides for specified properties of a `CatalogModifier` object.
type ModifierLocationOverrides struct {
	// The ID of the `Location` object representing the location. This can include a deactivated location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The overridden price at the specified location. If this is unspecified, the modifier price is not overridden.
	// The modifier becomes free of charge at the specified location, when this `price_money` field is set to 0.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Indicates whether the modifier is sold out at the specified location or not. As an example, for cheese (modifier) burger (item), when the modifier is sold out, it is the cheese, but not the burger, that is sold out.
	// The seller can manually set this sold out status. Attempts by an application to set this attribute are ignored.
	SoldOut *bool `json:"sold_out,omitempty" url:"sold_out,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *ModifierLocationOverrides) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModifierLocationOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler ModifierLocationOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModifierLocationOverrides(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModifierLocationOverrides) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Represents an amount of money. `Money` fields can be signed or unsigned.
// Fields that do not explicitly define whether they are signed or unsigned are
// considered unsigned and can only hold positive amounts. For signed fields, the
// sign of the value indicates the purpose of the money transfer. See
// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts)
// for more information.
type Money struct {
	// The amount of money, in the smallest denomination of the currency
	// indicated by `currency`. For example, when `currency` is `USD`, `amount` is
	// in cents. Monetary amounts can be positive or negative. See the specific
	// field description to determine the meaning of the sign in a particular case.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// The type of currency, in **ISO 4217 format**. For example, the currency
	// code for US dollars is `USD`.
	//
	// See [Currency](entity:Currency) for possible values.
	// See [Currency](#type-currency) for possible values
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Money) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Money) UnmarshalJSON(data []byte) error {
	type unmarshaler Money
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Money(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Money) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ObtainTokenResponse struct {
	// A valid OAuth access token.
	// Provide the access token in a header with every request to Connect API
	// endpoints. For more information, see [OAuth API: Walkthrough](https://developer.squareup.com/docs/oauth-api/walkthrough).
	AccessToken *string `json:"access_token,omitempty" url:"access_token,omitempty"`
	// This value is always _bearer_.
	TokenType *string `json:"token_type,omitempty" url:"token_type,omitempty"`
	// The date when the `access_token` expires, in [ISO 8601](http://www.iso.org/iso/home/standards/iso8601.htm) format.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The ID of the authorizing merchant's business.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// **LEGACY FIELD**. The ID of a subscription plan the merchant signed up
	// for. The ID is only present if the merchant signed up for a subscription plan during authorization.
	SubscriptionID *string `json:"subscription_id,omitempty" url:"subscription_id,omitempty"`
	// **LEGACY FIELD**. The ID of the subscription plan the merchant signed
	// up for. The ID is only present if the merchant signed up for a subscription plan during
	// authorization.
	PlanID *string `json:"plan_id,omitempty" url:"plan_id,omitempty"`
	// The OpenID token belonging to this person. This token is only present if the
	// OPENID scope is included in the authorization request.
	IDToken *string `json:"id_token,omitempty" url:"id_token,omitempty"`
	// A refresh token.
	// For more information, see [Refresh, Revoke, and Limit the Scope of OAuth Tokens](https://developer.squareup.com/docs/oauth-api/refresh-revoke-limit-scope).
	RefreshToken *string `json:"refresh_token,omitempty" url:"refresh_token,omitempty"`
	// A Boolean indicating that the access token is a short-lived access token.
	// The short-lived access token returned in the response expires in 24 hours.
	ShortLived *bool `json:"short_lived,omitempty" url:"short_lived,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The date when the `refresh_token` expires, in [ISO 8601](http://www.iso.org/iso/home/standards/iso8601.htm) format.
	RefreshTokenExpiresAt *string `json:"refresh_token_expires_at,omitempty" url:"refresh_token_expires_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *ObtainTokenResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *ObtainTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ObtainTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = ObtainTokenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *ObtainTokenResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Details specific to offline payments.
type OfflinePaymentDetails struct {
	// The client-side timestamp of when the offline payment was created, in RFC 3339 format.
	ClientCreatedAt *string `json:"client_created_at,omitempty" url:"client_created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OfflinePaymentDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OfflinePaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OfflinePaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OfflinePaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OfflinePaymentDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains all information related to a single order to process with Square,
// including line items that specify the products to purchase. `Order` objects also
// include information about any associated tenders, refunds, and returns.
//
// All Connect V2 Transactions have all been converted to Orders including all associated
// itemization data.
type Order struct {
	// The order's unique ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID string `json:"location_id" url:"location_id"`
	// A client-specified ID to associate an entity in another system
	// with this order.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The origination details of the order.
	Source *OrderSource `json:"source,omitempty" url:"source,omitempty"`
	// The ID of the [customer]($m/Customer) associated with the order.
	//
	// You should specify a `customer_id` on the order (or the payment) to ensure that transactions
	// are reliably linked to customers. Omitting this field might result in the creation of new
	// [instant profiles](https://developer.squareup.com/docs/customers-api/what-it-does#instant-profiles).
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The line items included in the order.
	LineItems []*OrderLineItem `json:"line_items,omitempty" url:"line_items,omitempty"`
	// The list of all taxes associated with the order.
	//
	// Taxes can be scoped to either `ORDER` or `LINE_ITEM`. For taxes with `LINE_ITEM` scope, an
	// `OrderLineItemAppliedTax` must be added to each line item that the tax applies to. For taxes
	// with `ORDER` scope, the server generates an `OrderLineItemAppliedTax` for every line item.
	//
	// On reads, each tax in the list includes the total amount of that tax applied to the order.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any taxes in this field, using the deprecated
	// `line_items.taxes` field results in an error. Use `line_items.applied_taxes`
	// instead.
	Taxes []*OrderLineItemTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// The list of all discounts associated with the order.
	//
	// Discounts can be scoped to either `ORDER` or `LINE_ITEM`. For discounts scoped to `LINE_ITEM`,
	// an `OrderLineItemAppliedDiscount` must be added to each line item that the discount applies to.
	// For discounts with `ORDER` scope, the server generates an `OrderLineItemAppliedDiscount`
	// for every line item.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any discounts in this field, using the deprecated
	// `line_items.discounts` field results in an error. Use `line_items.applied_discounts`
	// instead.
	Discounts []*OrderLineItemDiscount `json:"discounts,omitempty" url:"discounts,omitempty"`
	// A list of service charges applied to the order.
	ServiceCharges []*OrderServiceCharge `json:"service_charges,omitempty" url:"service_charges,omitempty"`
	// Details about order fulfillment.
	//
	// Orders can only be created with at most one fulfillment. However, orders returned
	// by the API might contain multiple fulfillments.
	Fulfillments []*Fulfillment `json:"fulfillments,omitempty" url:"fulfillments,omitempty"`
	// A collection of items from sale orders being returned in this one. Normally part of an
	// itemized return or exchange. There is exactly one `Return` object per sale `Order` being
	// referenced.
	Returns []*OrderReturn `json:"returns,omitempty" url:"returns,omitempty"`
	// The rollup of the returned money amounts.
	ReturnAmounts *OrderMoneyAmounts `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`
	// The net money amounts (sale money - return money).
	NetAmounts *OrderMoneyAmounts `json:"net_amounts,omitempty" url:"net_amounts,omitempty"`
	// A positive rounding adjustment to the total of the order. This adjustment is commonly
	// used to apply cash rounding when the minimum unit of account is smaller than the lowest physical
	// denomination of the currency.
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// The tenders that were used to pay for the order.
	Tenders []*Tender `json:"tenders,omitempty" url:"tenders,omitempty"`
	// The refunds that are part of this order.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The timestamp for when the order was created, at server side, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, at server side, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp for when the order reached a terminal [state](entity:OrderState), in RFC 3339 format (for example "2016-09-04T23:59:33.123Z").
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// The current state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The total amount of money to collect for the order.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the order.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to collect for the order.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of tip money to collect for the order.
	TotalTipMoney *Money `json:"total_tip_money,omitempty" url:"total_tip_money,omitempty"`
	// The total amount of money collected in service charges for the order.
	//
	// Note: `total_service_charge_money` is the sum of `applied_money` fields for each individual
	// service charge. Therefore, `total_service_charge_money` only includes inclusive tax amounts,
	// not additive tax amounts.
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`
	// A short-term identifier for the order (such as a customer first name,
	// table number, or auto-generated order number that resets daily).
	TicketName *string `json:"ticket_name,omitempty" url:"ticket_name,omitempty"`
	// Pricing options for an order. The options affect how the order's price is calculated.
	// They can be used, for example, to apply automatic price adjustments that are based on
	// preconfigured [pricing rules](entity:CatalogPricingRule).
	PricingOptions *OrderPricingOptions `json:"pricing_options,omitempty" url:"pricing_options,omitempty"`
	// A set-like list of Rewards that have been added to the Order.
	Rewards []*OrderReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	// The net amount of money due on the order.
	NetAmountDueMoney *Money `json:"net_amount_due_money,omitempty" url:"net_amount_due_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Order) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Order) UnmarshalJSON(data []byte) error {
	type unmarshaler Order
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Order(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Order) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreated struct {
	// The order's unique ID.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderCreated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreated) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreatedObject struct {
	// Information about the created order.
	OrderCreated *OrderCreated `json:"order_created,omitempty" url:"order_created,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderCreatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreatedObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreatedObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A lightweight description of an [order]($m/Order) that is returned when
// `returned_entries` is `true` on a [SearchOrdersRequest]($e/Orders/SearchOrders).
type OrderEntry struct {
	// The ID of the order.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The location ID the order belongs to.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains details about how to fulfill this order.
// Orders can only be created with at most one fulfillment using the API.
// However, orders returned by the Orders API might contain multiple fulfillments because sellers can create multiple fulfillments using Square products such as Square Online.
type OrderFulfillment struct {
	// A unique ID that identifies the fulfillment only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The type of the fulfillment.
	// See [OrderFulfillmentType](#type-orderfulfillmenttype) for possible values
	Type *OrderFulfillmentType `json:"type,omitempty" url:"type,omitempty"`
	// The state of the fulfillment.
	// See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
	State *OrderFulfillmentState `json:"state,omitempty" url:"state,omitempty"`
	// Describes what order line items this fulfillment applies to.
	// It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
	// See [OrderFulfillmentFulfillmentLineItemApplication](#type-orderfulfillmentfulfillmentlineitemapplication) for possible values
	LineItemApplication *OrderFulfillmentFulfillmentLineItemApplication `json:"line_item_application,omitempty" url:"line_item_application,omitempty"`
	// A list of entries pertaining to the fulfillment of an order. Each entry must reference
	// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
	// fulfill.
	// Multiple entries can reference the same line item `uid`, as long as the total quantity among
	// all fulfillment entries referencing a single line item does not exceed the quantity of the
	// order's line item itself.
	// An order cannot be marked as `COMPLETED` before all fulfillments are `COMPLETED`,
	// `CANCELED`, or `FAILED`. Fulfillments can be created and completed independently
	// before order completion.
	Entries []*OrderFulfillmentFulfillmentEntry `json:"entries,omitempty" url:"entries,omitempty"`
	// Application-defined data attached to this fulfillment. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	// Values have a maximum length of 255 characters.
	// An application can have up to 10 entries per metadata field.
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Contains details for a pickup fulfillment. These details are required when the fulfillment
	// type is `PICKUP`.
	PickupDetails *OrderFulfillmentPickupDetails `json:"pickup_details,omitempty" url:"pickup_details,omitempty"`
	// Contains details for a shipment fulfillment. These details are required when the fulfillment type
	// is `SHIPMENT`.
	// A shipment fulfillment's relationship to fulfillment `state`:
	// `PROPOSED`: A shipment is requested.
	// `RESERVED`: Fulfillment in progress. Shipment processing.
	// `PREPARED`: Shipment packaged. Shipping label created.
	// `COMPLETED`: Package has been shipped.
	// `CANCELED`: Shipment has been canceled.
	// `FAILED`: Shipment has failed.
	ShipmentDetails *OrderFulfillmentShipmentDetails `json:"shipment_details,omitempty" url:"shipment_details,omitempty"`
	// Describes delivery details of an order fulfillment.
	DeliveryDetails *OrderFulfillmentDeliveryDetails `json:"delivery_details,omitempty" url:"delivery_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Describes delivery details of an order fulfillment.
type OrderFulfillmentDeliveryDetails struct {
	// The contact information for the person to receive the fulfillment.
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// Indicates the fulfillment delivery schedule type. If `SCHEDULED`, then
	// `deliver_at` is required. If `ASAP`, then `prep_time_duration` is required. The default is `SCHEDULED`.
	// See [OrderFulfillmentDeliveryDetailsScheduleType](#type-orderfulfillmentdeliverydetailsscheduletype) for possible values
	ScheduleType *OrderFulfillmentDeliveryDetailsScheduleType `json:"schedule_type,omitempty" url:"schedule_type,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	// Must be in RFC 3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the delivery period.
	// When the fulfillment `schedule_type` is `ASAP`, the field is automatically
	// set to the current time plus the `prep_time_duration`.
	// Otherwise, the application can set this field while the fulfillment `state` is
	// `PROPOSED`, `RESERVED`, or `PREPARED` (any time before the
	// terminal state such as `COMPLETED`, `CANCELED`, and `FAILED`).
	//
	// The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	DeliverAt *string `json:"deliver_at,omitempty" url:"deliver_at,omitempty"`
	// The duration of time it takes to prepare and deliver this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// The time period after `deliver_at` in which to deliver the order.
	// Applications can set this field when the fulfillment `state` is
	// `PROPOSED`, `RESERVED`, or `PREPARED` (any time before the terminal state
	// such as `COMPLETED`, `CANCELED`, and `FAILED`).
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	DeliveryWindowDuration *string `json:"delivery_window_duration,omitempty" url:"delivery_window_duration,omitempty"`
	// Provides additional instructions about the delivery fulfillment.
	// It is displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicates when the seller completed the fulfillment.
	// This field is automatically set when fulfillment `state` changes to `COMPLETED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CompletedAt *string `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicates when the seller started processing the fulfillment.
	// This field is automatically set when the fulfillment `state` changes to `RESERVED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. This field is
	// automatically set when the fulfillment `state` changes to `FAILED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the seller marked the fulfillment as ready for
	// courier pickup. This field is automatically set when the fulfillment `state` changes
	// to PREPARED.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was delivered to the recipient.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	DeliveredAt *string `json:"delivered_at,omitempty" url:"delivered_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. This field is automatically
	// set when the fulfillment `state` changes to `CANCELED`.
	//
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// The delivery cancellation reason. Max length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when an order can be picked up by the courier for delivery.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CourierPickupAt *string `json:"courier_pickup_at,omitempty" url:"courier_pickup_at,omitempty"`
	// The time period after `courier_pickup_at` in which the courier should pick up the order.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	CourierPickupWindowDuration *string `json:"courier_pickup_window_duration,omitempty" url:"courier_pickup_window_duration,omitempty"`
	// Whether the delivery is preferred to be no contact.
	IsNoContactDelivery *bool `json:"is_no_contact_delivery,omitempty" url:"is_no_contact_delivery,omitempty"`
	// A note to provide additional instructions about how to deliver the order.
	DropoffNotes *string `json:"dropoff_notes,omitempty" url:"dropoff_notes,omitempty"`
	// The name of the courier provider.
	CourierProviderName *string `json:"courier_provider_name,omitempty" url:"courier_provider_name,omitempty"`
	// The support phone number of the courier.
	CourierSupportPhoneNumber *string `json:"courier_support_phone_number,omitempty" url:"courier_support_phone_number,omitempty"`
	// The identifier for the delivery created by Square.
	SquareDeliveryID *string `json:"square_delivery_id,omitempty" url:"square_delivery_id,omitempty"`
	// The identifier for the delivery created by the third-party courier service.
	ExternalDeliveryID *string `json:"external_delivery_id,omitempty" url:"external_delivery_id,omitempty"`
	// The flag to indicate the delivery is managed by a third party (ie DoorDash), which means
	// we may not receive all recipient information for PII purposes.
	ManagedDelivery *bool `json:"managed_delivery,omitempty" url:"managed_delivery,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentDeliveryDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentDeliveryDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentDeliveryDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentDeliveryDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentDeliveryDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The schedule type of the delivery fulfillment.
type OrderFulfillmentDeliveryDetailsScheduleType string

const (
	OrderFulfillmentDeliveryDetailsScheduleTypeScheduled OrderFulfillmentDeliveryDetailsScheduleType = "SCHEDULED"
	OrderFulfillmentDeliveryDetailsScheduleTypeAsap      OrderFulfillmentDeliveryDetailsScheduleType = "ASAP"
)

func NewOrderFulfillmentDeliveryDetailsScheduleTypeFromString(s string) (OrderFulfillmentDeliveryDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return OrderFulfillmentDeliveryDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return OrderFulfillmentDeliveryDetailsScheduleTypeAsap, nil
	}
	var t OrderFulfillmentDeliveryDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentDeliveryDetailsScheduleType) Ptr() *OrderFulfillmentDeliveryDetailsScheduleType {
	return &o
}

// Links an order line item to a fulfillment. Each entry must reference
// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
// fulfill.
type OrderFulfillmentFulfillmentEntry struct {
	// A unique ID that identifies the fulfillment entry only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` from the order line item.
	LineItemUID string `json:"line_item_uid" url:"line_item_uid"`
	// The quantity of the line item being fulfilled, formatted as a decimal number.
	// For example, `"3"`.
	// Fulfillments for line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// Application-defined data attached to this fulfillment entry. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	// Values have a maximum length of 255 characters.
	// An application can have up to 10 entries per metadata field.
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentFulfillmentEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentFulfillmentEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentFulfillmentEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentFulfillmentEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentFulfillmentEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The `line_item_application` describes what order line items this fulfillment applies
// to. It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
type OrderFulfillmentFulfillmentLineItemApplication string

const (
	OrderFulfillmentFulfillmentLineItemApplicationAll       OrderFulfillmentFulfillmentLineItemApplication = "ALL"
	OrderFulfillmentFulfillmentLineItemApplicationEntryList OrderFulfillmentFulfillmentLineItemApplication = "ENTRY_LIST"
)

func NewOrderFulfillmentFulfillmentLineItemApplicationFromString(s string) (OrderFulfillmentFulfillmentLineItemApplication, error) {
	switch s {
	case "ALL":
		return OrderFulfillmentFulfillmentLineItemApplicationAll, nil
	case "ENTRY_LIST":
		return OrderFulfillmentFulfillmentLineItemApplicationEntryList, nil
	}
	var t OrderFulfillmentFulfillmentLineItemApplication
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentFulfillmentLineItemApplication) Ptr() *OrderFulfillmentFulfillmentLineItemApplication {
	return &o
}

// Contains details necessary to fulfill a pickup order.
type OrderFulfillmentPickupDetails struct {
	// Information about the person to pick up this fulfillment from a physical
	// location.
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment expires if it is not marked in progress. The timestamp must be
	// in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z"). The expiration time can only be set
	// up to 7 days in the future. If `expires_at` is not set, any new payments attached to the order
	// are automatically completed.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The duration of time after which an in progress pickup fulfillment is automatically moved
	// to the `COMPLETED` state. The duration must be in RFC 3339 format (for example, "P1W3D").
	//
	// If not set, this pickup fulfillment remains in progress until it is canceled or completed.
	AutoCompleteDuration *string `json:"auto_complete_duration,omitempty" url:"auto_complete_duration,omitempty"`
	// The schedule type of the pickup fulfillment. Defaults to `SCHEDULED`.
	// See [OrderFulfillmentPickupDetailsScheduleType](#type-orderfulfillmentpickupdetailsscheduletype) for possible values
	ScheduleType *OrderFulfillmentPickupDetailsScheduleType `json:"schedule_type,omitempty" url:"schedule_type,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the pickup window. Must be in RFC 3339 timestamp format, e.g.,
	// "2016-09-04T23:59:33.123Z".
	// For fulfillments with the schedule type `ASAP`, this is automatically set
	// to the current time plus the expected duration to prepare the fulfillment.
	PickupAt *string `json:"pickup_at,omitempty" url:"pickup_at,omitempty"`
	// The window of time in which the order should be picked up after the `pickup_at` timestamp.
	// Must be in RFC 3339 duration format, e.g., "P1W3D". Can be used as an
	// informational guideline for merchants.
	PickupWindowDuration *string `json:"pickup_window_duration,omitempty" url:"pickup_window_duration,omitempty"`
	// The duration of time it takes to prepare this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// A note to provide additional instructions about the pickup
	// fulfillment displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was marked in progress. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	AcceptedAt *string `json:"accepted_at,omitempty" url:"accepted_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment is marked as ready for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment expired. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ExpiredAt *string `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was picked up by the recipient. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PickedUpAt *string `json:"picked_up_at,omitempty" url:"picked_up_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the pickup was canceled. The maximum length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// If set to `true`, indicates that this pickup order is for curbside pickup, not in-store pickup.
	IsCurbsidePickup *bool `json:"is_curbside_pickup,omitempty" url:"is_curbside_pickup,omitempty"`
	// Specific details for curbside pickup. These details can only be populated if `is_curbside_pickup` is set to `true`.
	CurbsidePickupDetails *OrderFulfillmentPickupDetailsCurbsidePickupDetails `json:"curbside_pickup_details,omitempty" url:"curbside_pickup_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentPickupDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentPickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentPickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentPickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentPickupDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Specific details for curbside pickup.
type OrderFulfillmentPickupDetailsCurbsidePickupDetails struct {
	// Specific details for curbside pickup, such as parking number and vehicle model.
	CurbsideDetails *string `json:"curbside_details,omitempty" url:"curbside_details,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the buyer arrived and is waiting for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	BuyerArrivedAt *string `json:"buyer_arrived_at,omitempty" url:"buyer_arrived_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentPickupDetailsCurbsidePickupDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentPickupDetailsCurbsidePickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentPickupDetailsCurbsidePickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentPickupDetailsCurbsidePickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentPickupDetailsCurbsidePickupDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The schedule type of the pickup fulfillment.
type OrderFulfillmentPickupDetailsScheduleType string

const (
	OrderFulfillmentPickupDetailsScheduleTypeScheduled OrderFulfillmentPickupDetailsScheduleType = "SCHEDULED"
	OrderFulfillmentPickupDetailsScheduleTypeAsap      OrderFulfillmentPickupDetailsScheduleType = "ASAP"
)

func NewOrderFulfillmentPickupDetailsScheduleTypeFromString(s string) (OrderFulfillmentPickupDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return OrderFulfillmentPickupDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return OrderFulfillmentPickupDetailsScheduleTypeAsap, nil
	}
	var t OrderFulfillmentPickupDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentPickupDetailsScheduleType) Ptr() *OrderFulfillmentPickupDetailsScheduleType {
	return &o
}

// Information about the fulfillment recipient.
type OrderFulfillmentRecipient struct {
	// The ID of the customer associated with the fulfillment.
	// If `customer_id` is provided, the fulfillment recipient's `display_name`,
	// `email_address`, and `phone_number` are automatically populated from the
	// targeted customer profile. If these fields are set in the request, the request
	// values override the information from the customer profile. If the
	// targeted customer profile does not contain the necessary information and
	// these fields are left unset, the request results in an error.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The display name of the fulfillment recipient. This field is required.
	// If provided, the display name overrides the corresponding customer profile value
	// indicated by `customer_id`.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The email address of the fulfillment recipient.
	// If provided, the email address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the fulfillment recipient. This field is required.
	// If provided, the phone number overrides the corresponding customer profile value
	// indicated by `customer_id`.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The address of the fulfillment recipient. This field is required.
	// If provided, the address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentRecipient) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentRecipient) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the details necessary to fulfill a shipment order.
type OrderFulfillmentShipmentDetails struct {
	// Information about the person to receive this shipment fulfillment.
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The shipping carrier being used to ship this fulfillment (such as UPS, FedEx, or USPS).
	Carrier *string `json:"carrier,omitempty" url:"carrier,omitempty"`
	// A note with additional information for the shipping carrier.
	ShippingNote *string `json:"shipping_note,omitempty" url:"shipping_note,omitempty"`
	// A description of the type of shipping product purchased from the carrier
	// (such as First Class, Priority, or Express).
	ShippingType *string `json:"shipping_type,omitempty" url:"shipping_type,omitempty"`
	// The reference number provided by the carrier to track the shipment's progress.
	TrackingNumber *string `json:"tracking_number,omitempty" url:"tracking_number,omitempty"`
	// A link to the tracking webpage on the carrier's website.
	TrackingURL *string `json:"tracking_url,omitempty" url:"tracking_url,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment was requested. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `RESERVED` state, which indicates that preparation
	// of this shipment has begun. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `PREPARED` state, which indicates that the
	// fulfillment is packaged. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	PackagedAt *string `json:"packaged_at,omitempty" url:"packaged_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment is expected to be delivered to the shipping carrier.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ExpectedShippedAt *string `json:"expected_shipped_at,omitempty" url:"expected_shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `COMPLETED` state, which indicates that
	// the fulfillment has been given to the shipping carrier. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ShippedAt *string `json:"shipped_at,omitempty" url:"shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating the shipment was canceled.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the shipment was canceled.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment failed to be completed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	FailedAt *string `json:"failed_at,omitempty" url:"failed_at,omitempty"`
	// A description of why the shipment failed to be completed.
	FailureReason *string `json:"failure_reason,omitempty" url:"failure_reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentShipmentDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentShipmentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentShipmentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentShipmentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentShipmentDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The current state of this fulfillment.
type OrderFulfillmentState string

const (
	OrderFulfillmentStateProposed  OrderFulfillmentState = "PROPOSED"
	OrderFulfillmentStateReserved  OrderFulfillmentState = "RESERVED"
	OrderFulfillmentStatePrepared  OrderFulfillmentState = "PREPARED"
	OrderFulfillmentStateCompleted OrderFulfillmentState = "COMPLETED"
	OrderFulfillmentStateCanceled  OrderFulfillmentState = "CANCELED"
	OrderFulfillmentStateFailed    OrderFulfillmentState = "FAILED"
)

func NewOrderFulfillmentStateFromString(s string) (OrderFulfillmentState, error) {
	switch s {
	case "PROPOSED":
		return OrderFulfillmentStateProposed, nil
	case "RESERVED":
		return OrderFulfillmentStateReserved, nil
	case "PREPARED":
		return OrderFulfillmentStatePrepared, nil
	case "COMPLETED":
		return OrderFulfillmentStateCompleted, nil
	case "CANCELED":
		return OrderFulfillmentStateCanceled, nil
	case "FAILED":
		return OrderFulfillmentStateFailed, nil
	}
	var t OrderFulfillmentState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentState) Ptr() *OrderFulfillmentState {
	return &o
}

// The type of fulfillment.
type OrderFulfillmentType string

const (
	OrderFulfillmentTypePickup   OrderFulfillmentType = "PICKUP"
	OrderFulfillmentTypeShipment OrderFulfillmentType = "SHIPMENT"
	OrderFulfillmentTypeDelivery OrderFulfillmentType = "DELIVERY"
)

func NewOrderFulfillmentTypeFromString(s string) (OrderFulfillmentType, error) {
	switch s {
	case "PICKUP":
		return OrderFulfillmentTypePickup, nil
	case "SHIPMENT":
		return OrderFulfillmentTypeShipment, nil
	case "DELIVERY":
		return OrderFulfillmentTypeDelivery, nil
	}
	var t OrderFulfillmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentType) Ptr() *OrderFulfillmentType {
	return &o
}

type OrderFulfillmentUpdated struct {
	// The order's unique ID.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The fulfillments that were updated with this version change.
	FulfillmentUpdate []*OrderFulfillmentUpdatedUpdate `json:"fulfillment_update,omitempty" url:"fulfillment_update,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdated) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderFulfillmentUpdatedObject struct {
	// Information about the updated order fulfillment.
	OrderFulfillmentUpdated *OrderFulfillmentUpdated `json:"order_fulfillment_updated,omitempty" url:"order_fulfillment_updated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Information about fulfillment updates.
type OrderFulfillmentUpdatedUpdate struct {
	// A unique ID that identifies the fulfillment only within this order.
	FulfillmentUID *string `json:"fulfillment_uid,omitempty" url:"fulfillment_uid,omitempty"`
	// The state of the fulfillment before the change.
	// The state is not populated if the fulfillment is created with this new `Order` version.
	OldState *FulfillmentState `json:"old_state,omitempty" url:"old_state,omitempty"`
	// The state of the fulfillment after the change. The state might be equal to `old_state` if a non-state
	// field was changed on the fulfillment (such as the tracking number).
	NewState *FulfillmentState `json:"new_state,omitempty" url:"new_state,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentUpdatedUpdate) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedUpdate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedUpdate) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a line item in an order. Each line item describes a different
// product to purchase, with its own quantity and price details.
type OrderLineItem struct {
	// A unique ID that identifies the line item only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The count, or measurement, of a line item being purchased:
	//
	// If `quantity` is a whole number, and `quantity_unit` is not specified, then `quantity` denotes an item count. For example: `3` apples.
	//
	// If `quantity` is a whole or decimal number, and `quantity_unit` is also specified, then `quantity` denotes a measurement. For example: `2.25` pounds of broccoli.
	//
	// For more information, see [Specify item quantity and measurement unit](https://developer.squareup.com/docs/orders-api/create-orders#specify-item-quantity-and-measurement-unit).
	//
	// Line items with a quantity of `0` are automatically removed
	// when paying for or otherwise completing the order.
	Quantity string `json:"quantity" url:"quantity"`
	// The measurement unit and decimal precision that this line item's quantity is measured in.
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// An optional note associated with the line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this line item.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this line item.
	VariationName *string `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	// The type of line item: an itemized sale, a non-itemized sale (custom amount), or the
	// activation or reloading of a gift card.
	// See [OrderLineItemItemType](#type-orderlineitemitemtype) for possible values
	ItemType *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// Application-defined data attached to this line item. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	Modifiers []*OrderLineItemModifier `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The list of references to taxes applied to this line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a
	// top-level `OrderLineItemTax` applied to the line item. On reads, the
	// amount applied is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every line
	// item for all `ORDER` scoped taxes added to the order. `OrderLineItemAppliedTax`
	// records for `LINE_ITEM` scoped taxes must be added in requests for the tax
	// to apply to any line items.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to discounts applied to this line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderLineItemDiscounts` applied to the line item. On reads, the amount
	// applied is populated.
	//
	// An `OrderLineItemAppliedDiscount` is automatically created on every line item for all
	// `ORDER` scoped discounts that are added to the order. `OrderLineItemAppliedDiscount` records
	// for `LINE_ITEM` scoped discounts must be added in requests for the discount to apply to any
	// line items.
	//
	// To change the amount of a discount, modify the referenced top-level discount.
	AppliedDiscounts []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	// The list of references to service charges applied to this line item. Each
	// `OrderLineItemAppliedServiceCharge` has a `service_charge_id` that references the `uid` of a
	// top-level `OrderServiceCharge` applied to the line item. On reads, the amount applied is
	// populated.
	//
	// To change the amount of a service charge, modify the referenced top-level service charge.
	AppliedServiceCharges []*OrderLineItemAppliedServiceCharge `json:"applied_service_charges,omitempty" url:"applied_service_charges,omitempty"`
	// The base price for a single unit of the line item.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of all item variations sold in this line item.
	// The price is calculated as `base_price_money` multiplied by `quantity`.
	// It does not include modifiers.
	VariationTotalPriceMoney *Money `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	// The amount of money made in gross sales for this line item.
	// The amount is calculated as the sum of the variation's total price and each modifier's total price.
	// For inclusive tax items in the US, Canada, and Japan, tax is deducted from `gross_sales_money`. For Europe and
	// Australia, inclusive tax remains as part of the gross sale calculation.
	GrossSalesMoney *Money `json:"gross_sales_money,omitempty" url:"gross_sales_money,omitempty"`
	// The total amount of tax money to collect for the line item.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to collect for the line item.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of money to collect for this line item.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// Describes pricing adjustments that are blocked from automatic
	// application to a line item. For more information, see
	// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
	PricingBlocklists *OrderLineItemPricingBlocklists `json:"pricing_blocklists,omitempty" url:"pricing_blocklists,omitempty"`
	// The total amount of apportioned service charge money to collect for the line item.
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a discount to a line item in an order.
//
// Order scoped discounts have automatically applied discounts present for each line item.
// Line-item scoped discounts must have applied discounts added manually for any applicable line
// items. The corresponding applied money is automatically computed based on participating
// line items.
type OrderLineItemAppliedDiscount struct {
	// A unique ID that identifies the applied discount only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that the applied discount represents. It must
	// reference a discount present in the `order.discounts` field.
	//
	// This field is immutable. To change which discounts apply to a line item,
	// you must delete the discount and re-add it as a new `OrderLineItemAppliedDiscount`.
	DiscountUID string `json:"discount_uid" url:"discount_uid"`
	// The amount of money applied by the discount to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderLineItemAppliedServiceCharge struct {
	// A unique ID that identifies the applied service charge only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the service charge that the applied service charge represents. It must
	// reference a service charge present in the `order.service_charges` field.
	//
	// This field is immutable. To change which service charges apply to a line item,
	// delete and add a new `OrderLineItemAppliedServiceCharge`.
	ServiceChargeUID string `json:"service_charge_uid" url:"service_charge_uid"`
	// The amount of money applied by the service charge to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a tax to a line item in an order.
//
// Order-scoped taxes automatically include the applied taxes in each line item.
// Line item taxes must be referenced from any applicable line items.
// The corresponding applied money is automatically computed, based on the
// set of participating line items.
type OrderLineItemAppliedTax struct {
	// A unique ID that identifies the applied tax only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax for which this applied tax represents. It must reference
	// a tax present in the `order.taxes` field.
	//
	// This field is immutable. To change which taxes apply to a line item, delete and add a new
	// `OrderLineItemAppliedTax`.
	TaxUID string `json:"tax_uid" url:"tax_uid"`
	// The amount of money applied by the tax to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount that applies to one or more line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the
// amount contributed by the item to the order subtotal.
type OrderLineItemDiscount struct {
	// A unique ID that identifies the discount only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The type of the discount.
	//
	// Discounts that do not reference a catalog object ID must have a type of
	// `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	// See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the discount, as a string representation of a decimal number.
	// A value of `7.25` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The total declared monetary amount of the discount.
	//
	// `amount_money` is not set for percentage-based discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of discount actually applied to the line item.
	//
	// The amount represents the amount of money applied as a line-item scoped discount.
	// When an amount-based discount is scoped to the entire order, the value
	// of `applied_money` is different than `amount_money` because the total
	// amount of the discount is distributed across all line items.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Application-defined data attached to this discount. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Indicates the level at which the discount applies. For `ORDER` scoped discounts,
	// Square generates references in `applied_discounts` on all order line items that do
	// not have them. For `LINE_ITEM` scoped discounts, the discount only applies to line items
	// with a discount reference in their `applied_discounts` field.
	//
	// This field is immutable. To change the scope of a discount, you must delete
	// the discount and re-add it as a new discount.
	// See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
	Scope *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`
	// The reward IDs corresponding to this discount. The application and
	// specification of discounts that have `reward_ids` are completely controlled by the backing
	// criteria corresponding to the reward tiers of the rewards that are added to the order
	// through the Loyalty API. To manually unapply discounts that are the result of added rewards,
	// the rewards must be removed from the order through the Loyalty API.
	RewardIDs []string `json:"reward_ids,omitempty" url:"reward_ids,omitempty"`
	// The object ID of a [pricing rule](entity:CatalogPricingRule) to be applied
	// automatically to this discount. The specification and application of the discounts, to
	// which a `pricing_rule_id` is assigned, are completely controlled by the corresponding
	// pricing rule.
	PricingRuleID *string `json:"pricing_rule_id,omitempty" url:"pricing_rule_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level discount.
type OrderLineItemDiscountScope string

const (
	OrderLineItemDiscountScopeOtherDiscountScope OrderLineItemDiscountScope = "OTHER_DISCOUNT_SCOPE"
	OrderLineItemDiscountScopeLineItem           OrderLineItemDiscountScope = "LINE_ITEM"
	OrderLineItemDiscountScopeOrder              OrderLineItemDiscountScope = "ORDER"
)

func NewOrderLineItemDiscountScopeFromString(s string) (OrderLineItemDiscountScope, error) {
	switch s {
	case "OTHER_DISCOUNT_SCOPE":
		return OrderLineItemDiscountScopeOtherDiscountScope, nil
	case "LINE_ITEM":
		return OrderLineItemDiscountScopeLineItem, nil
	case "ORDER":
		return OrderLineItemDiscountScopeOrder, nil
	}
	var t OrderLineItemDiscountScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountScope) Ptr() *OrderLineItemDiscountScope {
	return &o
}

// Indicates how the discount is applied to the associated line item or order.
type OrderLineItemDiscountType string

const (
	OrderLineItemDiscountTypeUnknownDiscount    OrderLineItemDiscountType = "UNKNOWN_DISCOUNT"
	OrderLineItemDiscountTypeFixedPercentage    OrderLineItemDiscountType = "FIXED_PERCENTAGE"
	OrderLineItemDiscountTypeFixedAmount        OrderLineItemDiscountType = "FIXED_AMOUNT"
	OrderLineItemDiscountTypeVariablePercentage OrderLineItemDiscountType = "VARIABLE_PERCENTAGE"
	OrderLineItemDiscountTypeVariableAmount     OrderLineItemDiscountType = "VARIABLE_AMOUNT"
)

func NewOrderLineItemDiscountTypeFromString(s string) (OrderLineItemDiscountType, error) {
	switch s {
	case "UNKNOWN_DISCOUNT":
		return OrderLineItemDiscountTypeUnknownDiscount, nil
	case "FIXED_PERCENTAGE":
		return OrderLineItemDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return OrderLineItemDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return OrderLineItemDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return OrderLineItemDiscountTypeVariableAmount, nil
	}
	var t OrderLineItemDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountType) Ptr() *OrderLineItemDiscountType {
	return &o
}

// Represents the line item type.
type OrderLineItemItemType string

const (
	OrderLineItemItemTypeItem         OrderLineItemItemType = "ITEM"
	OrderLineItemItemTypeCustomAmount OrderLineItemItemType = "CUSTOM_AMOUNT"
	OrderLineItemItemTypeGiftCard     OrderLineItemItemType = "GIFT_CARD"
)

func NewOrderLineItemItemTypeFromString(s string) (OrderLineItemItemType, error) {
	switch s {
	case "ITEM":
		return OrderLineItemItemTypeItem, nil
	case "CUSTOM_AMOUNT":
		return OrderLineItemItemTypeCustomAmount, nil
	case "GIFT_CARD":
		return OrderLineItemItemTypeGiftCard, nil
	}
	var t OrderLineItemItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemItemType) Ptr() *OrderLineItemItemType {
	return &o
}

// A [CatalogModifier]($m/CatalogModifier).
type OrderLineItemModifier struct {
	// A unique ID that identifies the modifier only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity of the line item modifier. The modifier quantity can be 0 or more.
	// For example, suppose a restaurant offers a cheeseburger on the menu. When a buyer orders
	// this item, the restaurant records the purchase by creating an `Order` object with a line item
	// for a burger. The line item includes a line item modifier: the name is cheese and the quantity
	// is 1. The buyer has the option to order extra cheese (or no cheese). If the buyer chooses
	// the extra cheese option, the modifier quantity increases to 2. If the buyer does not want
	// any cheese, the modifier quantity is set to 0.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The base price for the modifier.
	//
	// `base_price_money` is required for ad hoc modifiers.
	// If both `catalog_object_id` and `base_price_money` are set, `base_price_money` will
	// override the predefined [CatalogModifier](entity:CatalogModifier) price.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of the item modifier for its line item.
	// This is the modifier's `base_price_money` multiplied by the line item's quantity.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Describes pricing adjustments that are blocked from automatic
// application to a line item. For more information, see
// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
type OrderLineItemPricingBlocklists struct {
	// A list of discounts blocked from applying to the line item.
	// Discounts can be blocked by the `discount_uid` (for ad hoc discounts) or
	// the `discount_catalog_object_id` (for catalog discounts).
	BlockedDiscounts []*OrderLineItemPricingBlocklistsBlockedDiscount `json:"blocked_discounts,omitempty" url:"blocked_discounts,omitempty"`
	// A list of taxes blocked from applying to the line item.
	// Taxes can be blocked by the `tax_uid` (for ad hoc taxes) or
	// the `tax_catalog_object_id` (for catalog taxes).
	BlockedTaxes []*OrderLineItemPricingBlocklistsBlockedTax `json:"blocked_taxes,omitempty" url:"blocked_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklists) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklists) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklists
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklists(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklists) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A discount to block from applying to a line item. The discount must be
// identified by either `discount_uid` or `discount_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedDiscount struct {
	// A unique ID of the `BlockedDiscount` within the order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that should be blocked. Use this field to block
	// ad hoc discounts. For catalog discounts, use the `discount_catalog_object_id` field.
	DiscountUID *string `json:"discount_uid,omitempty" url:"discount_uid,omitempty"`
	// The `catalog_object_id` of the discount that should be blocked.
	// Use this field to block catalog discounts. For ad hoc discounts, use the
	// `discount_uid` field.
	DiscountCatalogObjectID *string `json:"discount_catalog_object_id,omitempty" url:"discount_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A tax to block from applying to a line item. The tax must be
// identified by either `tax_uid` or `tax_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedTax struct {
	// A unique ID of the `BlockedTax` within the order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax that should be blocked. Use this field to block
	// ad hoc taxes. For catalog, taxes use the `tax_catalog_object_id` field.
	TaxUID *string `json:"tax_uid,omitempty" url:"tax_uid,omitempty"`
	// The `catalog_object_id` of the tax that should be blocked.
	// Use this field to block catalog taxes. For ad hoc taxes, use the
	// `tax_uid` field.
	TaxCatalogObjectID *string `json:"tax_catalog_object_id,omitempty" url:"tax_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax that applies to one or more line item in the order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the amount the item
// contributes to the order subtotal.
type OrderLineItemTax struct {
	// A unique ID that identifies the tax only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates the calculation method used to apply the tax.
	// See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal
	// number. For example, a value of `"7.25"` corresponds to a percentage of
	// 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// Application-defined data attached to this tax. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The amount of money applied to the order by the tax.
	//
	//   - For percentage-based taxes, `applied_money` is the money
	//     calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the tax applies. For `ORDER` scoped taxes,
	// Square generates references in `applied_taxes` on all order line items that do
	// not have them. For `LINE_ITEM` scoped taxes, the tax only applies to line items
	// with references in their `applied_taxes` field.
	//
	// This field is immutable. To change the scope, you must delete the tax and
	// re-add it as a new tax.
	// See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
	Scope *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`
	// Determines whether the tax was automatically applied to the order based on
	// the catalog configuration. For an example, see
	// [Automatically Apply Taxes to an Order](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts/auto-apply-taxes).
	AutoApplied *bool `json:"auto_applied,omitempty" url:"auto_applied,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level tax.
type OrderLineItemTaxScope string

const (
	OrderLineItemTaxScopeOtherTaxScope OrderLineItemTaxScope = "OTHER_TAX_SCOPE"
	OrderLineItemTaxScopeLineItem      OrderLineItemTaxScope = "LINE_ITEM"
	OrderLineItemTaxScopeOrder         OrderLineItemTaxScope = "ORDER"
)

func NewOrderLineItemTaxScopeFromString(s string) (OrderLineItemTaxScope, error) {
	switch s {
	case "OTHER_TAX_SCOPE":
		return OrderLineItemTaxScopeOtherTaxScope, nil
	case "LINE_ITEM":
		return OrderLineItemTaxScopeLineItem, nil
	case "ORDER":
		return OrderLineItemTaxScopeOrder, nil
	}
	var t OrderLineItemTaxScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxScope) Ptr() *OrderLineItemTaxScope {
	return &o
}

// Indicates how the tax is applied to the associated line item or order.
type OrderLineItemTaxType string

const (
	OrderLineItemTaxTypeUnknownTax OrderLineItemTaxType = "UNKNOWN_TAX"
	OrderLineItemTaxTypeAdditive   OrderLineItemTaxType = "ADDITIVE"
	OrderLineItemTaxTypeInclusive  OrderLineItemTaxType = "INCLUSIVE"
)

func NewOrderLineItemTaxTypeFromString(s string) (OrderLineItemTaxType, error) {
	switch s {
	case "UNKNOWN_TAX":
		return OrderLineItemTaxTypeUnknownTax, nil
	case "ADDITIVE":
		return OrderLineItemTaxTypeAdditive, nil
	case "INCLUSIVE":
		return OrderLineItemTaxTypeInclusive, nil
	}
	var t OrderLineItemTaxType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxType) Ptr() *OrderLineItemTaxType {
	return &o
}

// A collection of various money amounts.
type OrderMoneyAmounts struct {
	// The total money.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The money associated with taxes.
	TaxMoney *Money `json:"tax_money,omitempty" url:"tax_money,omitempty"`
	// The money associated with discounts.
	DiscountMoney *Money `json:"discount_money,omitempty" url:"discount_money,omitempty"`
	// The money associated with tips.
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The money associated with service charges.
	ServiceChargeMoney *Money `json:"service_charge_money,omitempty" url:"service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderMoneyAmounts) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderMoneyAmounts) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderMoneyAmounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderMoneyAmounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderMoneyAmounts) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Pricing options for an order. The options affect how the order's price is calculated.
// They can be used, for example, to apply automatic price adjustments that are based on preconfigured
// [pricing rules]($m/CatalogPricingRule).
type OrderPricingOptions struct {
	// The option to determine whether pricing rule-based
	// discounts are automatically applied to an order.
	AutoApplyDiscounts *bool `json:"auto_apply_discounts,omitempty" url:"auto_apply_discounts,omitempty"`
	// The option to determine whether rule-based taxes are automatically
	// applied to an order when the criteria of the corresponding rules are met.
	AutoApplyTaxes *bool `json:"auto_apply_taxes,omitempty" url:"auto_apply_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderPricingOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderPricingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderPricingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderPricingOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderPricingOptions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the measurement unit for a quantity and a precision that
// specifies the number of digits after the decimal point for decimal quantities.
type OrderQuantityUnit struct {
	// A [MeasurementUnit](entity:MeasurementUnit) that represents the
	// unit of measure for the quantity.
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// For non-integer quantities, represents the number of digits after the decimal point that are
	// recorded for this quantity.
	//
	// For example, a precision of 1 allows quantities such as `"1.0"` and `"1.1"`, but not `"1.01"`.
	//
	// Min: 0. Max: 5.
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`
	// The catalog object ID referencing the
	// [CatalogMeasurementUnit](entity:CatalogMeasurementUnit).
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this measurement unit references.
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderQuantityUnit) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderQuantityUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderQuantityUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderQuantityUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderQuantityUnit) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The set of line items, service charges, taxes, discounts, tips, and other items being returned in an order.
type OrderReturn struct {
	// A unique ID that identifies the return only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An order that contains the original sale of these return line items. This is unset
	// for unlinked returns.
	SourceOrderID *string `json:"source_order_id,omitempty" url:"source_order_id,omitempty"`
	// A collection of line items that are being returned.
	ReturnLineItems []*OrderReturnLineItem `json:"return_line_items,omitempty" url:"return_line_items,omitempty"`
	// A collection of service charges that are being returned.
	ReturnServiceCharges []*OrderReturnServiceCharge `json:"return_service_charges,omitempty" url:"return_service_charges,omitempty"`
	// A collection of references to taxes being returned for an order, including the total
	// applied tax amount to be returned. The taxes must reference a top-level tax ID from the source
	// order.
	ReturnTaxes []*OrderReturnTax `json:"return_taxes,omitempty" url:"return_taxes,omitempty"`
	// A collection of references to discounts being returned for an order, including the total
	// applied discount amount to be returned. The discounts must reference a top-level discount ID
	// from the source order.
	ReturnDiscounts []*OrderReturnDiscount `json:"return_discounts,omitempty" url:"return_discounts,omitempty"`
	// A collection of references to tips being returned for an order.
	ReturnTips []*OrderReturnTip `json:"return_tips,omitempty" url:"return_tips,omitempty"`
	// A positive or negative rounding adjustment to the total value being returned. Adjustments are commonly
	// used to apply cash rounding when the minimum unit of the account is smaller than the lowest
	// physical denomination of the currency.
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// An aggregate monetary value being returned by this return entry.
	ReturnAmounts *OrderMoneyAmounts `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturn) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturn) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturn(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturn) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount being returned that applies to one or more return line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnDiscount struct {
	// A unique ID that identifies the returned discount only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The discount `uid` from the order that contains the original application of this discount.
	SourceDiscountUID *string `json:"source_discount_uid,omitempty" url:"source_discount_uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The type of the discount. If it is created by the API, it is `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	//
	// Discounts that do not reference a catalog object ID must have a type of
	// `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	// See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// A value of `"7.25"` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The total declared monetary amount of the discount.
	//
	// `amount_money` is not set for percentage-based discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of discount actually applied to this line item. When an amount-based
	// discount is at the order level, this value is different from `amount_money` because the discount
	// is distributed across the line items.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the `OrderReturnDiscount` applies. For `ORDER` scoped
	// discounts, the server generates references in `applied_discounts` on all
	// `OrderReturnLineItem`s. For `LINE_ITEM` scoped discounts, the discount is only applied to
	// `OrderReturnLineItem`s with references in their `applied_discounts` field.
	// See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
	Scope *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The line item being returned in an order.
type OrderReturnLineItem struct {
	// A unique ID for this return line-item entry.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the line item in the original sale order.
	SourceLineItemUID *string `json:"source_line_item_uid,omitempty" url:"source_line_item_uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity returned, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// The unit and precision that this return line item's quantity is measured in.
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the return line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this return line item.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this return line item.
	VariationName *string `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	// The type of line item: an itemized return, a non-itemized return (custom amount),
	// or the return of an unactivated gift card sale.
	// See [OrderLineItemItemType](#type-orderlineitemitemtype) for possible values
	ItemType *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	ReturnModifiers []*OrderReturnLineItemModifier `json:"return_modifiers,omitempty" url:"return_modifiers,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the return line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderReturnTax` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to `OrderReturnDiscount` entities applied to the return line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderReturnDiscount` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedDiscounts []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	// The base price for a single unit of the line item.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of all item variations returned in this line item.
	// The price is calculated as `base_price_money` multiplied by `quantity` and
	// does not include modifiers.
	VariationTotalPriceMoney *Money `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	// The gross return amount of money calculated as (item base price + modifiers price) \* quantity.
	GrossReturnMoney *Money `json:"gross_return_money,omitempty" url:"gross_return_money,omitempty"`
	// The total amount of tax money to return for the line item.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to return for the line item.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of money to return for this line item.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The list of references to `OrderReturnServiceCharge` entities applied to the return
	// line item. Each `OrderLineItemAppliedServiceCharge` has a `service_charge_uid` that
	// references the `uid` of a top-level `OrderReturnServiceCharge` applied to the return line
	// item. On reads, the applied amount is populated.
	AppliedServiceCharges []*OrderLineItemAppliedServiceCharge `json:"applied_service_charges,omitempty" url:"applied_service_charges,omitempty"`
	// The total amount of apportioned service charge money to return for the line item.
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A line item modifier being returned.
type OrderReturnLineItemModifier struct {
	// A unique ID that identifies the return modifier only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The modifier `uid` from the order's line item that contains the
	// original sale of this line item modifier.
	SourceModifierUID *string `json:"source_modifier_uid,omitempty" url:"source_modifier_uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The base price for the modifier.
	//
	// `base_price_money` is required for ad hoc modifiers.
	// If both `catalog_object_id` and `base_price_money` are set, `base_price_money` overrides the predefined [CatalogModifier](entity:CatalogModifier) price.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of the item modifier for its line item.
	// This is the modifier's `base_price_money` multiplied by the line item's quantity.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// The quantity of the line item modifier. The modifier quantity can be 0 or more.
	// For example, suppose a restaurant offers a cheeseburger on the menu. When a buyer orders
	// this item, the restaurant records the purchase by creating an `Order` object with a line item
	// for a burger. The line item includes a line item modifier: the name is cheese and the quantity
	// is 1. The buyer has the option to order extra cheese (or no cheese). If the buyer chooses
	// the extra cheese option, the modifier quantity increases to 2. If the buyer does not want
	// any cheese, the modifier quantity is set to 0.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents the service charge applied to the original order.
type OrderReturnServiceCharge struct {
	// A unique ID that identifies the return service charge only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The service charge `uid` from the order containing the original
	// service charge. `source_service_charge_uid` is `null` for
	// unlinked returns.
	SourceServiceChargeUID *string `json:"source_service_charge_uid,omitempty" url:"source_service_charge_uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID of the associated [OrderServiceCharge](entity:OrderServiceCharge).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The percentage of the service charge, as a string representation of
	// a decimal number. For example, a value of `"7.25"` corresponds to a
	// percentage of 7.25%.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of a non-percentage-based service charge.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money applied to the order by the service charge, including
	// any inclusive tax amounts, as calculated by Square.
	//
	// - For fixed-amount service charges, `applied_money` is equal to `amount_money`.
	// - For percentage-based service charges, `applied_money` is the money calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The total amount of money to collect for the service charge.
	//
	// **NOTE**: If an inclusive tax is applied to the service charge, `total_money`
	// does not equal `applied_money` plus `total_tax_money` because the inclusive
	// tax amount is already included in both `applied_money` and `total_tax_money`.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the service charge.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The calculation phase after which to apply the service charge.
	// See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the surcharge can be taxed. Service charges
	// calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the
	// `OrderReturnServiceCharge`. Each `OrderLineItemAppliedTax` has a `tax_uid`
	// that references the `uid` of a top-level `OrderReturnTax` that is being
	// applied to the `OrderReturnServiceCharge`. On reads, the applied amount is
	// populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The treatment type of the service charge.
	// See [OrderServiceChargeTreatmentType](#type-orderservicechargetreatmenttype) for possible values
	TreatmentType *OrderServiceChargeTreatmentType `json:"treatment_type,omitempty" url:"treatment_type,omitempty"`
	// Indicates the level at which the apportioned service charge applies. For `ORDER`
	// scoped service charges, Square generates references in `applied_service_charges` on
	// all order line items that do not have them. For `LINE_ITEM` scoped service charges,
	// the service charge only applies to line items with a service charge reference in their
	// `applied_service_charges` field.
	//
	// This field is immutable. To change the scope of an apportioned service charge, you must delete
	// the apportioned service charge and re-add it as a new apportioned service charge.
	// See [OrderServiceChargeScope](#type-orderservicechargescope) for possible values
	Scope *OrderServiceChargeScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax being returned that applies to one or more return line items in an order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnTax struct {
	// A unique ID that identifies the returned tax only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The tax `uid` from the order that contains the original tax charge.
	SourceTaxUID *string `json:"source_tax_uid,omitempty" url:"source_tax_uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates the calculation method used to apply the tax.
	// See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// For example, a value of `"7.25"` corresponds to a percentage of 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of money applied by the tax in an order.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the `OrderReturnTax` applies. For `ORDER` scoped
	// taxes, Square generates references in `applied_taxes` on all
	// `OrderReturnLineItem`s. For `LINE_ITEM` scoped taxes, the tax is only applied to
	// `OrderReturnLineItem`s with references in their `applied_discounts` field.
	// See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
	Scope *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A tip being returned.
type OrderReturnTip struct {
	// A unique ID that identifies the tip only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// ## The amount of tip being returned
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The tender `uid` from the order that contains the original application of this tip.
	SourceTenderUID *string `json:"source_tender_uid,omitempty" url:"source_tender_uid,omitempty"`
	// The tender `id` from the order that contains the original application of this tip.
	SourceTenderID *string `json:"source_tender_id,omitempty" url:"source_tender_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnTip) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnTip) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnTip
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnTip(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnTip) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a reward that can be applied to an order if the necessary
// reward tier criteria are met. Rewards are created through the Loyalty API.
type OrderReward struct {
	// The identifier of the reward.
	ID string `json:"id" url:"id"`
	// The identifier of the reward tier corresponding to this reward.
	RewardTierID string `json:"reward_tier_id" url:"reward_tier_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReward) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReward) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReward) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A rounding adjustment of the money being returned. Commonly used to apply cash rounding
// when the minimum unit of the account is smaller than the lowest physical denomination of the currency.
type OrderRoundingAdjustment struct {
	// A unique ID that identifies the rounding adjustment only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the rounding adjustment from the original sale order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The actual rounding adjustment amount.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderRoundingAdjustment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderRoundingAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderRoundingAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderRoundingAdjustment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderRoundingAdjustment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a service charge applied to an order.
type OrderServiceCharge struct {
	// A unique ID that identifies the service charge only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID referencing the service charge [CatalogObject](entity:CatalogObject).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The service charge percentage as a string representation of a
	// decimal number. For example, `"7.25"` indicates a service charge of 7.25%.
	//
	// Exactly 1 of `percentage` or `amount_money` should be set.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of a non-percentage-based service charge.
	//
	// Exactly one of `percentage` or `amount_money` should be set.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money applied to the order by the service charge,
	// including any inclusive tax amounts, as calculated by Square.
	//
	//   - For fixed-amount service charges, `applied_money` is equal to `amount_money`.
	//   - For percentage-based service charges, `applied_money` is the money
	//     calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The total amount of money to collect for the service charge.
	//
	// **Note**: If an inclusive tax is applied to the service charge,
	// `total_money` does not equal `applied_money` plus `total_tax_money`
	// because the inclusive tax amount is already included in both
	// `applied_money` and `total_tax_money`.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the service charge.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The calculation phase at which to apply the service charge.
	// See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the service charge can be taxed. If set to `true`,
	// order-level taxes automatically apply to the service charge. Note that
	// service charges calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to the taxes applied to this service charge. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderLineItemTax` that is being applied to this service charge. On reads, the amount applied
	// is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every taxable service charge
	// for all `ORDER` scoped taxes that are added to the order. `OrderLineItemAppliedTax` records
	// for `LINE_ITEM` scoped taxes must be added in requests for the tax to apply to any taxable
	// service charge. Taxable service charges have the `taxable` field set to `true` and calculated
	// in the `SUBTOTAL_PHASE`.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// Application-defined data attached to this service charge. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The type of the service charge.
	// See [OrderServiceChargeType](#type-orderservicechargetype) for possible values
	Type *OrderServiceChargeType `json:"type,omitempty" url:"type,omitempty"`
	// The treatment type of the service charge.
	// See [OrderServiceChargeTreatmentType](#type-orderservicechargetreatmenttype) for possible values
	TreatmentType *OrderServiceChargeTreatmentType `json:"treatment_type,omitempty" url:"treatment_type,omitempty"`
	// Indicates the level at which the apportioned service charge applies. For `ORDER`
	// scoped service charges, Square generates references in `applied_service_charges` on
	// all order line items that do not have them. For `LINE_ITEM` scoped service charges,
	// the service charge only applies to line items with a service charge reference in their
	// `applied_service_charges` field.
	//
	// This field is immutable. To change the scope of an apportioned service charge, you must delete
	// the apportioned service charge and re-add it as a new apportioned service charge.
	// See [OrderServiceChargeScope](#type-orderservicechargescope) for possible values
	Scope *OrderServiceChargeScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a phase in the process of calculating order totals.
// Service charges are applied after the indicated phase.
//
// [Read more about how order totals are calculated.](https://developer.squareup.com/docs/orders-api/how-it-works#how-totals-are-calculated)
type OrderServiceChargeCalculationPhase string

const (
	OrderServiceChargeCalculationPhaseSubtotalPhase              OrderServiceChargeCalculationPhase = "SUBTOTAL_PHASE"
	OrderServiceChargeCalculationPhaseTotalPhase                 OrderServiceChargeCalculationPhase = "TOTAL_PHASE"
	OrderServiceChargeCalculationPhaseApportionedPercentagePhase OrderServiceChargeCalculationPhase = "APPORTIONED_PERCENTAGE_PHASE"
	OrderServiceChargeCalculationPhaseApportionedAmountPhase     OrderServiceChargeCalculationPhase = "APPORTIONED_AMOUNT_PHASE"
)

func NewOrderServiceChargeCalculationPhaseFromString(s string) (OrderServiceChargeCalculationPhase, error) {
	switch s {
	case "SUBTOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseSubtotalPhase, nil
	case "TOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseTotalPhase, nil
	case "APPORTIONED_PERCENTAGE_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedPercentagePhase, nil
	case "APPORTIONED_AMOUNT_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedAmountPhase, nil
	}
	var t OrderServiceChargeCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeCalculationPhase) Ptr() *OrderServiceChargeCalculationPhase {
	return &o
}

// Indicates whether this is a line-item or order-level apportioned
// service charge.
type OrderServiceChargeScope string

const (
	OrderServiceChargeScopeOtherServiceChargeScope OrderServiceChargeScope = "OTHER_SERVICE_CHARGE_SCOPE"
	OrderServiceChargeScopeLineItem                OrderServiceChargeScope = "LINE_ITEM"
	OrderServiceChargeScopeOrder                   OrderServiceChargeScope = "ORDER"
)

func NewOrderServiceChargeScopeFromString(s string) (OrderServiceChargeScope, error) {
	switch s {
	case "OTHER_SERVICE_CHARGE_SCOPE":
		return OrderServiceChargeScopeOtherServiceChargeScope, nil
	case "LINE_ITEM":
		return OrderServiceChargeScopeLineItem, nil
	case "ORDER":
		return OrderServiceChargeScopeOrder, nil
	}
	var t OrderServiceChargeScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeScope) Ptr() *OrderServiceChargeScope {
	return &o
}

// Indicates whether the service charge will be treated as a value-holding line item or
// apportioned toward a line item.
type OrderServiceChargeTreatmentType string

const (
	OrderServiceChargeTreatmentTypeLineItemTreatment    OrderServiceChargeTreatmentType = "LINE_ITEM_TREATMENT"
	OrderServiceChargeTreatmentTypeApportionedTreatment OrderServiceChargeTreatmentType = "APPORTIONED_TREATMENT"
)

func NewOrderServiceChargeTreatmentTypeFromString(s string) (OrderServiceChargeTreatmentType, error) {
	switch s {
	case "LINE_ITEM_TREATMENT":
		return OrderServiceChargeTreatmentTypeLineItemTreatment, nil
	case "APPORTIONED_TREATMENT":
		return OrderServiceChargeTreatmentTypeApportionedTreatment, nil
	}
	var t OrderServiceChargeTreatmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeTreatmentType) Ptr() *OrderServiceChargeTreatmentType {
	return &o
}

type OrderServiceChargeType string

const (
	OrderServiceChargeTypeAutoGratuity OrderServiceChargeType = "AUTO_GRATUITY"
	OrderServiceChargeTypeCustom       OrderServiceChargeType = "CUSTOM"
)

func NewOrderServiceChargeTypeFromString(s string) (OrderServiceChargeType, error) {
	switch s {
	case "AUTO_GRATUITY":
		return OrderServiceChargeTypeAutoGratuity, nil
	case "CUSTOM":
		return OrderServiceChargeTypeCustom, nil
	}
	var t OrderServiceChargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeType) Ptr() *OrderServiceChargeType {
	return &o
}

// Represents the origination details of an order.
type OrderSource struct {
	// The name used to identify the place (physical or digital) that an order originates.
	// If unset, the name defaults to the name of the application that created the order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderSource) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderSource) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderSource) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The state of the order.
type OrderState string

const (
	OrderStateOpen      OrderState = "OPEN"
	OrderStateCompleted OrderState = "COMPLETED"
	OrderStateCanceled  OrderState = "CANCELED"
	OrderStateDraft     OrderState = "DRAFT"
)

func NewOrderStateFromString(s string) (OrderState, error) {
	switch s {
	case "OPEN":
		return OrderStateOpen, nil
	case "COMPLETED":
		return OrderStateCompleted, nil
	case "CANCELED":
		return OrderStateCanceled, nil
	case "DRAFT":
		return OrderStateDraft, nil
	}
	var t OrderState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderState) Ptr() *OrderState {
	return &o
}

type OrderUpdated struct {
	// The order's unique ID.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderUpdated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdated(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdated) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderUpdatedObject struct {
	// Information about the updated order.
	OrderUpdated *OrderUpdated `json:"order_updated,omitempty" url:"order_updated,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderUpdatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdatedObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdatedObject) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Used _internally_ to encapsulate pagination details. The resulting proto will be base62 encoded
// in order to produce a cursor that can be used externally.
type PaginationCursor struct {
	// The ID of the last resource in the current page. The page can be in an ascending or
	// descending order
	OrderValue *string `json:"order_value,omitempty" url:"order_value,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginationCursor) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginationCursor) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginationCursor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginationCursor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginationCursor) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Defines output parameters in a response from the
// [PauseSubscription]($e/Subscriptions/PauseSubscription) endpoint.
type PauseSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription to be paused by the scheduled `PAUSE` action.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// The list of a `PAUSE` action and a possible `RESUME` action created by the request.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PauseSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PauseSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PauseSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PauseSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PauseSubscriptionResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Defines the fields that are included in the response body of a request to the
// [PayOrder]($e/Orders/PayOrder) endpoint.
type PayOrderResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The paid, updated [order](entity:Order).
	Order *Order `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayOrderResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PayOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayOrderResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a payment processed by the Square API.
type Payment struct {
	// A unique ID for the payment.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The timestamp of when the payment was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the payment was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The amount processed for this payment, not including `tip_money`.
	//
	// The amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount designated as a tip.
	//
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The total amount for the payment, including `amount_money` and `tip_money`.
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The amount the developer is taking as a fee for facilitating the payment on behalf
	// of the seller. This amount is specified in the smallest denomination of the applicable currency
	// (for example, US dollar amounts are specified in cents). For more information,
	// see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// The amount cannot be more than 90% of the `total_money` value.
	//
	// To set this field, `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission is required.
	// For more information, see [Permissions](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees#permissions).
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// The amount of money approved for this payment. This value may change if Square chooses to
	// obtain reauthorization as part of a call to [UpdatePayment](api-endpoint:Payments-UpdatePayment).
	ApprovedMoney *Money `json:"approved_money,omitempty" url:"approved_money,omitempty"`
	// The processing fees and fee adjustments assessed by Square for this payment.
	ProcessingFee []*ProcessingFee `json:"processing_fee,omitempty" url:"processing_fee,omitempty"`
	// The total amount of the payment refunded to date.
	//
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents).
	RefundedMoney *Money `json:"refunded_money,omitempty" url:"refunded_money,omitempty"`
	// Indicates whether the payment is APPROVED, PENDING, COMPLETED, CANCELED, or FAILED.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The duration of time after the payment's creation when Square automatically applies the
	// `delay_action` to the payment. This automatic `delay_action` applies only to payments that
	// do not reach a terminal state (COMPLETED, CANCELED, or FAILED) before the `delay_duration`
	// time period.
	//
	// This field is specified as a time duration, in RFC 3339 format.
	//
	// Notes:
	// This feature is only supported for card payments.
	//
	// Default:
	//
	// - Card-present payments: "PT36H" (36 hours) from the creation time.
	// - Card-not-present payments: "P7D" (7 days) from the creation time.
	DelayDuration *string `json:"delay_duration,omitempty" url:"delay_duration,omitempty"`
	// The action to be applied to the payment when the `delay_duration` has elapsed.
	//
	// Current values include `CANCEL` and `COMPLETE`.
	DelayAction *string `json:"delay_action,omitempty" url:"delay_action,omitempty"`
	// The read-only timestamp of when the `delay_action` is automatically applied,
	// in RFC 3339 format.
	//
	// Note that this field is calculated by summing the payment's `delay_duration` and `created_at`
	// fields. The `created_at` field is generated by Square and might not exactly match the
	// time on your local machine.
	DelayedUntil *string `json:"delayed_until,omitempty" url:"delayed_until,omitempty"`
	// The source type for this payment.
	//
	// Current values include `CARD`, `BANK_ACCOUNT`, `WALLET`, `BUY_NOW_PAY_LATER`, `SQUARE_ACCOUNT`,
	// `CASH` and `EXTERNAL`. For information about these payment source types,
	// see [Take Payments](https://developer.squareup.com/docs/payments-api/take-payments).
	SourceType *string `json:"source_type,omitempty" url:"source_type,omitempty"`
	// Details about a card payment. These details are only populated if the source_type is `CARD`.
	CardDetails *CardPaymentDetails `json:"card_details,omitempty" url:"card_details,omitempty"`
	// Details about a cash payment. These details are only populated if the source_type is `CASH`.
	CashDetails *CashPaymentDetails `json:"cash_details,omitempty" url:"cash_details,omitempty"`
	// Details about a bank account payment. These details are only populated if the source_type is `BANK_ACCOUNT`.
	BankAccountDetails *BankAccountPaymentDetails `json:"bank_account_details,omitempty" url:"bank_account_details,omitempty"`
	// Details about an external payment. The details are only populated
	// if the `source_type` is `EXTERNAL`.
	ExternalDetails *ExternalPaymentDetails `json:"external_details,omitempty" url:"external_details,omitempty"`
	// Details about an wallet payment. The details are only populated
	// if the `source_type` is `WALLET`.
	WalletDetails *DigitalWalletDetails `json:"wallet_details,omitempty" url:"wallet_details,omitempty"`
	// Details about a Buy Now Pay Later payment. The details are only populated
	// if the `source_type` is `BUY_NOW_PAY_LATER`. For more information, see
	// [Afterpay Payments](https://developer.squareup.com/docs/payments-api/take-payments/afterpay-payments).
	BuyNowPayLaterDetails *BuyNowPayLaterDetails `json:"buy_now_pay_later_details,omitempty" url:"buy_now_pay_later_details,omitempty"`
	// Details about a Square Account payment. The details are only populated
	// if the `source_type` is `SQUARE_ACCOUNT`.
	SquareAccountDetails *SquareAccountDetails `json:"square_account_details,omitempty" url:"square_account_details,omitempty"`
	// The ID of the location associated with the payment.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the order associated with the payment.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// An optional ID that associates the payment with an entity in
	// another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The ID of the customer associated with the payment. If the ID is
	// not provided in the `CreatePayment` request that was used to create the `Payment`,
	// Square may use information in the request
	// (such as the billing and shipping address, email address, and payment source)
	// to identify a matching customer profile in the Customer Directory.
	// If found, the profile ID is used. If a profile is not found, the
	// API attempts to create an
	// [instant profile](https://developer.squareup.com/docs/customers-api/what-it-does#instant-profiles).
	// If the API cannot create an
	// instant profile (either because the seller has disabled it or the
	// seller's region prevents creating it), this field remains unset. Note that
	// this process is asynchronous and it may take some time before a
	// customer ID is added to the payment.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// **Deprecated**: Use `Payment.team_member_id` instead.
	//
	// An optional ID of the employee associated with taking the payment.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// An optional ID of the [TeamMember](entity:TeamMember) associated with taking the payment.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// A list of `refund_id`s identifying refunds for the payment.
	RefundIDs []string `json:"refund_ids,omitempty" url:"refund_ids,omitempty"`
	// Provides information about the risk associated with the payment, as determined by Square.
	// This field is present for payments to sellers that have opted in to receive risk
	// evaluations.
	RiskEvaluation *RiskEvaluation `json:"risk_evaluation,omitempty" url:"risk_evaluation,omitempty"`
	// An optional ID for a Terminal checkout that is associated with the payment.
	TerminalCheckoutID *string `json:"terminal_checkout_id,omitempty" url:"terminal_checkout_id,omitempty"`
	// The buyer's email address.
	BuyerEmailAddress *string `json:"buyer_email_address,omitempty" url:"buyer_email_address,omitempty"`
	// The buyer's billing address.
	BillingAddress *Address `json:"billing_address,omitempty" url:"billing_address,omitempty"`
	// The buyer's shipping address.
	ShippingAddress *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// An optional note to include when creating a payment.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// Additional payment information that gets added to the customer's card statement
	// as part of the statement description.
	//
	// Note that the `statement_description_identifier` might get truncated on the statement description
	// to fit the required information including the Square identifier (SQ \*) and the name of the
	// seller taking the payment.
	StatementDescriptionIdentifier *string `json:"statement_description_identifier,omitempty" url:"statement_description_identifier,omitempty"`
	// Actions that can be performed on this payment:
	//
	// - `EDIT_AMOUNT_UP` - The payment amount can be edited up.
	// - `EDIT_AMOUNT_DOWN` - The payment amount can be edited down.
	// - `EDIT_TIP_AMOUNT_UP` - The tip amount can be edited up.
	// - `EDIT_TIP_AMOUNT_DOWN` - The tip amount can be edited down.
	// - `EDIT_DELAY_ACTION` - The delay_action can be edited.
	Capabilities []string `json:"capabilities,omitempty" url:"capabilities,omitempty"`
	// The payment's receipt number.
	// The field is missing if a payment is canceled.
	ReceiptNumber *string `json:"receipt_number,omitempty" url:"receipt_number,omitempty"`
	// The URL for the payment's receipt.
	// The field is only populated for COMPLETED payments.
	ReceiptURL *string `json:"receipt_url,omitempty" url:"receipt_url,omitempty"`
	// Details about the device that took the payment.
	DeviceDetails *DeviceDetails `json:"device_details,omitempty" url:"device_details,omitempty"`
	// Details about the application that took the payment.
	ApplicationDetails *ApplicationDetails `json:"application_details,omitempty" url:"application_details,omitempty"`
	// Whether or not this payment was taken offline.
	IsOfflinePayment *bool `json:"is_offline_payment,omitempty" url:"is_offline_payment,omitempty"`
	// Additional information about the payment if it was taken offline.
	OfflinePaymentDetails *OfflinePaymentDetails `json:"offline_payment_details,omitempty" url:"offline_payment_details,omitempty"`
	// Used for optimistic concurrency. This opaque token identifies a specific version of the
	// `Payment` object.
	VersionToken *string `json:"version_token,omitempty" url:"version_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Payment) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payment) UnmarshalJSON(data []byte) error {
	type unmarshaler Payment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payment) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityAppFeeRefundDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the refund associated with this activity.
	RefundID *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`
	// The ID of the location of the merchant associated with the payment refund activity
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityAppFeeRefundDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityAppFeeRefundDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityAppFeeRefundDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityAppFeeRefundDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityAppFeeRefundDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityAppFeeRevenueDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the location of the merchant associated with the payment activity
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityAppFeeRevenueDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityAppFeeRevenueDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityAppFeeRevenueDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityAppFeeRevenueDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityAppFeeRevenueDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityAutomaticSavingsDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the payout associated with this activity.
	PayoutID *string `json:"payout_id,omitempty" url:"payout_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityAutomaticSavingsDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityAutomaticSavingsDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityAutomaticSavingsDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityAutomaticSavingsDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityAutomaticSavingsDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityAutomaticSavingsReversedDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the payout associated with this activity.
	PayoutID *string `json:"payout_id,omitempty" url:"payout_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityAutomaticSavingsReversedDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityAutomaticSavingsReversedDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityAutomaticSavingsReversedDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityAutomaticSavingsReversedDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityAutomaticSavingsReversedDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityChargeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityChargeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityChargeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityChargeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityChargeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityChargeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityDepositFeeDetail struct {
	// The ID of the payout that triggered this deposit fee activity.
	PayoutID *string `json:"payout_id,omitempty" url:"payout_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityDepositFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityDepositFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityDepositFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityDepositFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityDepositFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityDisputeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the dispute associated with this activity.
	DisputeID *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityDisputeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityDisputeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityDisputeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityDisputeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityDisputeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityFeeDetail struct {
	// The ID of the payment associated with this activity
	// This will only be populated when a principal LedgerEntryToken is also populated.
	// If the fee is independent (there is no principal LedgerEntryToken) then this will likely not
	// be populated.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityFreeProcessingDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityFreeProcessingDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityFreeProcessingDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityFreeProcessingDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityFreeProcessingDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityFreeProcessingDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityHoldAdjustmentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityHoldAdjustmentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityHoldAdjustmentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityHoldAdjustmentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityHoldAdjustmentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityHoldAdjustmentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityOpenDisputeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the dispute associated with this activity.
	DisputeID *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityOpenDisputeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityOpenDisputeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityOpenDisputeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityOpenDisputeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityOpenDisputeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityOtherAdjustmentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityOtherAdjustmentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityOtherAdjustmentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityOtherAdjustmentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityOtherAdjustmentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityOtherAdjustmentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityOtherDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityOtherDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityOtherDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityOtherDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityOtherDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityOtherDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityRefundDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the refund associated with this activity.
	RefundID *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityRefundDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityRefundDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityRefundDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityRefundDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityRefundDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityReleaseAdjustmentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityReleaseAdjustmentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityReleaseAdjustmentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityReleaseAdjustmentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityReleaseAdjustmentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityReleaseAdjustmentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityReserveHoldDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityReserveHoldDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityReserveHoldDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityReserveHoldDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityReserveHoldDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityReserveHoldDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityReserveReleaseDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityReserveReleaseDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityReserveReleaseDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityReserveReleaseDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityReserveReleaseDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityReserveReleaseDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivitySquareCapitalPaymentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivitySquareCapitalPaymentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivitySquareCapitalPaymentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivitySquareCapitalPaymentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivitySquareCapitalPaymentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivitySquareCapitalPaymentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivitySquareCapitalReversedPaymentDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivitySquareCapitalReversedPaymentDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivitySquareCapitalReversedPaymentDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivitySquareCapitalReversedPaymentDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivitySquareCapitalReversedPaymentDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivitySquareCapitalReversedPaymentDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityTaxOnFeeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The description of the tax rate being applied. For example: "GST", "HST".
	TaxRateDescription *string `json:"tax_rate_description,omitempty" url:"tax_rate_description,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityTaxOnFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityTaxOnFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityTaxOnFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityTaxOnFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityTaxOnFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityThirdPartyFeeDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityThirdPartyFeeDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityThirdPartyFeeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityThirdPartyFeeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityThirdPartyFeeDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityThirdPartyFeeDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentBalanceActivityThirdPartyFeeRefundDetail struct {
	// The ID of the payment associated with this activity.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The public refund id associated with this activity.
	RefundID *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentBalanceActivityThirdPartyFeeRefundDetail) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentBalanceActivityThirdPartyFeeRefundDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentBalanceActivityThirdPartyFeeRefundDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentBalanceActivityThirdPartyFeeRefundDetail(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentBalanceActivityThirdPartyFeeRefundDetail) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentLink struct {
	// The Square-assigned ID of the payment link.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The Square-assigned version number, which is incremented each time an update is committed to the payment link.
	Version int `json:"version" url:"version"`
	// The optional description of the `payment_link` object.
	// It is primarily for use by your application and is not used anywhere.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The ID of the order associated with the payment link.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The checkout options configured for the payment link.
	// For more information, see [Optional Checkout Configurations](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations).
	CheckoutOptions *CheckoutOptions `json:"checkout_options,omitempty" url:"checkout_options,omitempty"`
	// Describes buyer data to prepopulate
	// on the checkout page.
	PrePopulatedData *PrePopulatedData `json:"pre_populated_data,omitempty" url:"pre_populated_data,omitempty"`
	// The shortened URL of the payment link.
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// The long URL of the payment link.
	LongURL *string `json:"long_url,omitempty" url:"long_url,omitempty"`
	// The timestamp when the payment link was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the payment link was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// An optional note. After Square processes the payment, this note is added to the
	// resulting `Payment`.
	PaymentNote *string `json:"payment_note,omitempty" url:"payment_note,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentLink) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLink) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLink(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLink) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentLinkRelatedResources struct {
	// The order associated with the payment link.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// The subscription plan associated with the payment link.
	SubscriptionPlans []*CatalogObject `json:"subscription_plans,omitempty" url:"subscription_plans,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentLinkRelatedResources) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLinkRelatedResources) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLinkRelatedResources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLinkRelatedResources(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLinkRelatedResources) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentOptions struct {
	// Indicates whether the `Payment` objects created from this `TerminalCheckout` are automatically
	// `COMPLETED` or left in an `APPROVED` state for later modification.
	Autocomplete *bool `json:"autocomplete,omitempty" url:"autocomplete,omitempty"`
	// The duration of time after the payment's creation when Square automatically cancels the
	// payment. This automatic cancellation applies only to payments that do not reach a terminal state
	// (COMPLETED or CANCELED) before the `delay_duration` time period.
	//
	// This parameter should be specified as a time duration, in RFC 3339 format, with a minimum value
	// of 1 minute.
	//
	// Note: This feature is only supported for card payments. This parameter can only be set for a delayed
	// capture payment (`autocomplete=false`).
	// Default:
	//
	// - Card-present payments: "PT36H" (36 hours) from the creation time.
	// - Card-not-present payments: "P7D" (7 days) from the creation time.
	DelayDuration *string `json:"delay_duration,omitempty" url:"delay_duration,omitempty"`
	// If set to `true` and charging a Square Gift Card, a payment might be returned with
	// `amount_money` equal to less than what was requested. For example, a request for $20 when charging
	// a Square Gift Card with a balance of $5 results in an APPROVED payment of $5. You might choose
	// to prompt the buyer for an additional payment to cover the remainder or cancel the Gift Card
	// payment.
	//
	// This field cannot be `true` when `autocomplete = true`.
	// This field cannot be `true` when an `order_id` isn't specified.
	//
	// For more information, see
	// [Take Partial Payments](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/partial-payments-with-gift-cards).
	//
	// Default: false
	AcceptPartialAuthorization *bool `json:"accept_partial_authorization,omitempty" url:"accept_partial_authorization,omitempty"`
	// The action to be applied to the payment when the delay_duration has elapsed.
	// The action must be CANCEL or COMPLETE.
	//
	// This parameter can only be set for a delayed capture payment (when `autocomplete` is `false`).
	// See [DelayAction](#type-delayaction) for possible values
	DelayAction *PaymentOptionsDelayAction `json:"delay_action,omitempty" url:"delay_action,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentOptions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentOptions) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Describes the action to be applied to a delayed capture payment when the delay_duration
// has elapsed.
type PaymentOptionsDelayAction string

const (
	PaymentOptionsDelayActionCancel   PaymentOptionsDelayAction = "CANCEL"
	PaymentOptionsDelayActionComplete PaymentOptionsDelayAction = "COMPLETE"
)

func NewPaymentOptionsDelayActionFromString(s string) (PaymentOptionsDelayAction, error) {
	switch s {
	case "CANCEL":
		return PaymentOptionsDelayActionCancel, nil
	case "COMPLETE":
		return PaymentOptionsDelayActionComplete, nil
	}
	var t PaymentOptionsDelayAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentOptionsDelayAction) Ptr() *PaymentOptionsDelayAction {
	return &p
}

// Represents a refund of a payment made using Square. Contains information about
// the original payment and the amount of money refunded.
type PaymentRefund struct {
	// The unique ID for this refund, generated by Square.
	ID string `json:"id" url:"id"`
	// The refund's status:
	//
	// - `PENDING` - Awaiting approval.
	// - `COMPLETED` - Successfully completed.
	// - `REJECTED` - The refund was rejected.
	// - `FAILED` - An error occurred.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The location ID associated with the payment this refund is attached to.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Flag indicating whether or not the refund is linked to an existing payment in Square.
	Unlinked *bool `json:"unlinked,omitempty" url:"unlinked,omitempty"`
	// The destination type for this refund.
	//
	// Current values include `CARD`, `BANK_ACCOUNT`, `WALLET`, `BUY_NOW_PAY_LATER`, `CASH`,
	// `EXTERNAL`, and `SQUARE_ACCOUNT`.
	DestinationType *string `json:"destination_type,omitempty" url:"destination_type,omitempty"`
	// Contains information about the refund destination. This field is populated only if
	// `destination_id` is defined in the `RefundPayment` request.
	DestinationDetails *DestinationDetails `json:"destination_details,omitempty" url:"destination_details,omitempty"`
	// The amount of money refunded. This amount is specified in the smallest denomination
	// of the applicable currency (for example, US dollar amounts are specified in cents).
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money the application developer contributed to help cover the refunded amount.
	// This amount is specified in the smallest denomination of the applicable currency (for example,
	// US dollar amounts are specified in cents). For more information, see
	// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// Processing fees and fee adjustments assessed by Square for this refund.
	ProcessingFee []*ProcessingFee `json:"processing_fee,omitempty" url:"processing_fee,omitempty"`
	// The ID of the payment associated with this refund.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the order associated with the refund.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The reason for the refund.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// The timestamp of when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the refund was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// An optional ID of the team member associated with taking the payment.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentRefund) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRefund) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An accounting of the amount owed the seller and record of the actual transfer to their
// external bank account or to the Square balance.
type Payout struct {
	// A unique ID for the payout.
	ID string `json:"id" url:"id"`
	// Indicates the payout status.
	// See [PayoutStatus](#type-payoutstatus) for possible values
	Status *PayoutStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the location associated with the payout.
	LocationID string `json:"location_id" url:"location_id"`
	// The timestamp of when the payout was created and submitted for deposit to the seller's banking destination, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the payout was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The amount of money involved in the payout. A positive amount indicates a deposit, and a negative amount indicates a withdrawal. This amount is never zero.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// Information about the banking destination (such as a bank account, Square checking account, or debit card)
	// against which the payout was made.
	Destination *Destination `json:"destination,omitempty" url:"destination,omitempty"`
	// The version number, which is incremented each time an update is made to this payout record.
	// The version number helps developers receive event notifications or feeds out of order.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// Indicates the payout type.
	// See [PayoutType](#type-payouttype) for possible values
	Type *PayoutType `json:"type,omitempty" url:"type,omitempty"`
	// A list of transfer fees and any taxes on the fees assessed by Square for this payout.
	PayoutFee []*PayoutFee `json:"payout_fee,omitempty" url:"payout_fee,omitempty"`
	// The calendar date, in ISO 8601 format (YYYY-MM-DD), when the payout is due to arrive in the seller’s banking destination.
	ArrivalDate *string `json:"arrival_date,omitempty" url:"arrival_date,omitempty"`
	// A unique ID for each `Payout` object that might also appear on the seller’s bank statement. You can use this ID to automate the process of reconciling each payout with the corresponding line item on the bank statement.
	EndToEndID *string `json:"end_to_end_id,omitempty" url:"end_to_end_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Payout) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payout) UnmarshalJSON(data []byte) error {
	type unmarshaler Payout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payout) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// One or more PayoutEntries that make up a Payout. Each one has a date, amount, and type of activity.
// The total amount of the payout will equal the sum of the payout entries for a batch payout
type PayoutEntry struct {
	// A unique ID for the payout entry.
	ID string `json:"id" url:"id"`
	// The ID of the payout entries’ associated payout.
	PayoutID string `json:"payout_id" url:"payout_id"`
	// The timestamp of when the payout entry affected the balance, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of activity associated with this payout entry.
	// See [ActivityType](#type-activitytype) for possible values
	Type *ActivityType `json:"type,omitempty" url:"type,omitempty"`
	// The amount of money involved in this payout entry.
	GrossAmountMoney *Money `json:"gross_amount_money,omitempty" url:"gross_amount_money,omitempty"`
	// The amount of Square fees associated with this payout entry.
	FeeAmountMoney *Money `json:"fee_amount_money,omitempty" url:"fee_amount_money,omitempty"`
	// The net proceeds from this transaction after any fees.
	NetAmountMoney *Money `json:"net_amount_money,omitempty" url:"net_amount_money,omitempty"`
	// Details of any developer app fee revenue generated on a payment.
	TypeAppFeeRevenueDetails *PaymentBalanceActivityAppFeeRevenueDetail `json:"type_app_fee_revenue_details,omitempty" url:"type_app_fee_revenue_details,omitempty"`
	// Details of a refund for an app fee on a payment.
	TypeAppFeeRefundDetails *PaymentBalanceActivityAppFeeRefundDetail `json:"type_app_fee_refund_details,omitempty" url:"type_app_fee_refund_details,omitempty"`
	// Details of any automatic transfer from the payment processing balance to the Square Savings account. These are, generally, proportional to the merchant's sales.
	TypeAutomaticSavingsDetails *PaymentBalanceActivityAutomaticSavingsDetail `json:"type_automatic_savings_details,omitempty" url:"type_automatic_savings_details,omitempty"`
	// Details of any automatic transfer from the Square Savings account back to the processing balance. These are, generally, proportional to the merchant's refunds.
	TypeAutomaticSavingsReversedDetails *PaymentBalanceActivityAutomaticSavingsReversedDetail `json:"type_automatic_savings_reversed_details,omitempty" url:"type_automatic_savings_reversed_details,omitempty"`
	// Details of credit card payment captures.
	TypeChargeDetails *PaymentBalanceActivityChargeDetail `json:"type_charge_details,omitempty" url:"type_charge_details,omitempty"`
	// Details of any fees involved with deposits such as for instant deposits.
	TypeDepositFeeDetails *PaymentBalanceActivityDepositFeeDetail `json:"type_deposit_fee_details,omitempty" url:"type_deposit_fee_details,omitempty"`
	// Details of any balance change due to a dispute event.
	TypeDisputeDetails *PaymentBalanceActivityDisputeDetail `json:"type_dispute_details,omitempty" url:"type_dispute_details,omitempty"`
	// Details of adjustments due to the Square processing fee.
	TypeFeeDetails *PaymentBalanceActivityFeeDetail `json:"type_fee_details,omitempty" url:"type_fee_details,omitempty"`
	// Square offers Free Payments Processing for a variety of business scenarios including seller referral or when Square wants to apologize for a bug, customer service, repricing complication, and so on. This entry represents details of any credit to the merchant for the purposes of Free Processing.
	TypeFreeProcessingDetails *PaymentBalanceActivityFreeProcessingDetail `json:"type_free_processing_details,omitempty" url:"type_free_processing_details,omitempty"`
	// Details of any adjustment made by Square related to the holding or releasing of a payment.
	TypeHoldAdjustmentDetails *PaymentBalanceActivityHoldAdjustmentDetail `json:"type_hold_adjustment_details,omitempty" url:"type_hold_adjustment_details,omitempty"`
	// Details of any open disputes.
	TypeOpenDisputeDetails *PaymentBalanceActivityOpenDisputeDetail `json:"type_open_dispute_details,omitempty" url:"type_open_dispute_details,omitempty"`
	// Details of any other type that does not belong in the rest of the types.
	TypeOtherDetails *PaymentBalanceActivityOtherDetail `json:"type_other_details,omitempty" url:"type_other_details,omitempty"`
	// Details of any other type of adjustments that don't fall under existing types.
	TypeOtherAdjustmentDetails *PaymentBalanceActivityOtherAdjustmentDetail `json:"type_other_adjustment_details,omitempty" url:"type_other_adjustment_details,omitempty"`
	// Details of a refund for an existing card payment.
	TypeRefundDetails *PaymentBalanceActivityRefundDetail `json:"type_refund_details,omitempty" url:"type_refund_details,omitempty"`
	// Details of fees released for adjustments.
	TypeReleaseAdjustmentDetails *PaymentBalanceActivityReleaseAdjustmentDetail `json:"type_release_adjustment_details,omitempty" url:"type_release_adjustment_details,omitempty"`
	// Details of fees paid for funding risk reserve.
	TypeReserveHoldDetails *PaymentBalanceActivityReserveHoldDetail `json:"type_reserve_hold_details,omitempty" url:"type_reserve_hold_details,omitempty"`
	// Details of fees released from risk reserve.
	TypeReserveReleaseDetails *PaymentBalanceActivityReserveReleaseDetail `json:"type_reserve_release_details,omitempty" url:"type_reserve_release_details,omitempty"`
	// Details of capital merchant cash advance (MCA) assessments. These are, generally, proportional to the merchant's sales but may be issued for other reasons related to the MCA.
	TypeSquareCapitalPaymentDetails *PaymentBalanceActivitySquareCapitalPaymentDetail `json:"type_square_capital_payment_details,omitempty" url:"type_square_capital_payment_details,omitempty"`
	// Details of capital merchant cash advance (MCA) assessment refunds. These are, generally, proportional to the merchant's refunds but may be issued for other reasons related to the MCA.
	TypeSquareCapitalReversedPaymentDetails *PaymentBalanceActivitySquareCapitalReversedPaymentDetail `json:"type_square_capital_reversed_payment_details,omitempty" url:"type_square_capital_reversed_payment_details,omitempty"`
	// Details of tax paid on fee amounts.
	TypeTaxOnFeeDetails *PaymentBalanceActivityTaxOnFeeDetail `json:"type_tax_on_fee_details,omitempty" url:"type_tax_on_fee_details,omitempty"`
	// Details of fees collected by a 3rd party platform.
	TypeThirdPartyFeeDetails *PaymentBalanceActivityThirdPartyFeeDetail `json:"type_third_party_fee_details,omitempty" url:"type_third_party_fee_details,omitempty"`
	// Details of refunded fees from a 3rd party platform.
	TypeThirdPartyFeeRefundDetails *PaymentBalanceActivityThirdPartyFeeRefundDetail `json:"type_third_party_fee_refund_details,omitempty" url:"type_third_party_fee_refund_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutEntry) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutEntry) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a payout fee that can incur as part of a payout.
type PayoutFee struct {
	// The money amount of the payout fee.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of fee assessed as part of the payout.
	// See [PayoutFeeType](#type-payoutfeetype) for possible values
	Type *PayoutFeeType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFee) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the type of payout fee that can incur as part of a payout.
type PayoutFeeType string

const (
	PayoutFeeTypeTransferFee      PayoutFeeType = "TRANSFER_FEE"
	PayoutFeeTypeTaxOnTransferFee PayoutFeeType = "TAX_ON_TRANSFER_FEE"
)

func NewPayoutFeeTypeFromString(s string) (PayoutFeeType, error) {
	switch s {
	case "TRANSFER_FEE":
		return PayoutFeeTypeTransferFee, nil
	case "TAX_ON_TRANSFER_FEE":
		return PayoutFeeTypeTaxOnTransferFee, nil
	}
	var t PayoutFeeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutFeeType) Ptr() *PayoutFeeType {
	return &p
}

// Payout status types
type PayoutStatus string

const (
	PayoutStatusSent   PayoutStatus = "SENT"
	PayoutStatusFailed PayoutStatus = "FAILED"
	PayoutStatusPaid   PayoutStatus = "PAID"
)

func NewPayoutStatusFromString(s string) (PayoutStatus, error) {
	switch s {
	case "SENT":
		return PayoutStatusSent, nil
	case "FAILED":
		return PayoutStatusFailed, nil
	case "PAID":
		return PayoutStatusPaid, nil
	}
	var t PayoutStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutStatus) Ptr() *PayoutStatus {
	return &p
}

// The type of payout: “BATCH” or “SIMPLE”.
// BATCH payouts include a list of payout entries that can be considered settled.
// SIMPLE payouts do not have any payout entries associated with them
// and will show up as one of the payout entries in a future BATCH payout.
type PayoutType string

const (
	PayoutTypeBatch  PayoutType = "BATCH"
	PayoutTypeSimple PayoutType = "SIMPLE"
)

func NewPayoutTypeFromString(s string) (PayoutType, error) {
	switch s {
	case "BATCH":
		return PayoutTypeBatch, nil
	case "SIMPLE":
		return PayoutTypeSimple, nil
	}
	var t PayoutType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutType) Ptr() *PayoutType {
	return &p
}

// Represents a phase, which can override subscription phases as defined by plan_id
type Phase struct {
	// id of subscription phase
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// index of phase in total subscription plan
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// id of order to be used in billing
	OrderTemplateID *string `json:"order_template_id,omitempty" url:"order_template_id,omitempty"`
	// the uid from the plan's phase in catalog
	PlanPhaseUID *string `json:"plan_phase_uid,omitempty" url:"plan_phase_uid,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Phase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Phase) UnmarshalJSON(data []byte) error {
	type unmarshaler Phase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Phase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Phase) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the arguments used to construct a new phase.
type PhaseInput struct {
	// index of phase in total subscription plan
	Ordinal int64 `json:"ordinal" url:"ordinal"`
	// id of order to be used in billing
	OrderTemplateID *string `json:"order_template_id,omitempty" url:"order_template_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PhaseInput) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PhaseInput) UnmarshalJSON(data []byte) error {
	type unmarshaler PhaseInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PhaseInput(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PhaseInput) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Describes buyer data to prepopulate in the payment form.
// For more information,
// see [Optional Checkout Configurations](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations).
type PrePopulatedData struct {
	// The buyer email to prepopulate in the payment form.
	BuyerEmail *string `json:"buyer_email,omitempty" url:"buyer_email,omitempty"`
	// The buyer phone number to prepopulate in the payment form.
	BuyerPhoneNumber *string `json:"buyer_phone_number,omitempty" url:"buyer_phone_number,omitempty"`
	// The buyer address to prepopulate in the payment form.
	BuyerAddress *Address `json:"buyer_address,omitempty" url:"buyer_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PrePopulatedData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrePopulatedData) UnmarshalJSON(data []byte) error {
	type unmarshaler PrePopulatedData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrePopulatedData(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PrePopulatedData) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the Square processing fee.
type ProcessingFee struct {
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of fee assessed or adjusted. The fee type can be `INITIAL` or `ADJUSTMENT`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The fee amount, which might be negative, that is assessed or adjusted by Square.
	//
	// Positive values represent funds being assessed, while negative values represent
	// funds being returned.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProcessingFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the Square product used to generate a change.
type Product string

const (
	ProductSquarePos         Product = "SQUARE_POS"
	ProductExternalAPI       Product = "EXTERNAL_API"
	ProductBilling           Product = "BILLING"
	ProductAppointments      Product = "APPOINTMENTS"
	ProductInvoices          Product = "INVOICES"
	ProductOnlineStore       Product = "ONLINE_STORE"
	ProductPayroll           Product = "PAYROLL"
	ProductDashboard         Product = "DASHBOARD"
	ProductItemLibraryImport Product = "ITEM_LIBRARY_IMPORT"
	ProductOther             Product = "OTHER"
)

func NewProductFromString(s string) (Product, error) {
	switch s {
	case "SQUARE_POS":
		return ProductSquarePos, nil
	case "EXTERNAL_API":
		return ProductExternalAPI, nil
	case "BILLING":
		return ProductBilling, nil
	case "APPOINTMENTS":
		return ProductAppointments, nil
	case "INVOICES":
		return ProductInvoices, nil
	case "ONLINE_STORE":
		return ProductOnlineStore, nil
	case "PAYROLL":
		return ProductPayroll, nil
	case "DASHBOARD":
		return ProductDashboard, nil
	case "ITEM_LIBRARY_IMPORT":
		return ProductItemLibraryImport, nil
	case "OTHER":
		return ProductOther, nil
	}
	var t Product
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Product) Ptr() *Product {
	return &p
}

type ProductType = string

// Describes a `PublishInvoice` response.
type PublishInvoiceResponse struct {
	// The published invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PublishInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PublishInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PublishInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PublishInvoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PublishInvoiceResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Fields to describe the action that displays QR-Codes.
type QrCodeOptions struct {
	// The title text to display in the QR code flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display in the QR code flow on the Terminal.
	Body string `json:"body" url:"body"`
	// The text representation of the data to show in the QR code
	// as UTF8-encoded data.
	BarcodeContents string `json:"barcode_contents" url:"barcode_contents"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QrCodeOptions) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QrCodeOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler QrCodeOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QrCodeOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QrCodeOptions) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// A whole number or unreduced fractional ratio.
type QuantityRatio struct {
	// The whole or fractional quantity as the numerator.
	Quantity *int `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The whole or fractional quantity as the denominator.
	// With fractional quantity this field is the denominator and quantity is the numerator.
	// The default value is `1`. For example, when `quantity=3` and `quantity_denominator` is unspecified,
	// the quantity ratio is `3` or `3/1`.
	QuantityDenominator *int `json:"quantity_denominator,omitempty" url:"quantity_denominator,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QuantityRatio) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QuantityRatio) UnmarshalJSON(data []byte) error {
	type unmarshaler QuantityRatio
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QuantityRatio(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QuantityRatio) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Describes an ad hoc item and price to generate a quick pay checkout link.
// For more information,
// see [Quick Pay Checkout](https://developer.squareup.com/docs/checkout-api/quick-pay-checkout).
type QuickPay struct {
	// The ad hoc item name. In the resulting `Order`, this name appears as the line item name.
	Name string `json:"name" url:"name"`
	// The price of the item.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// The ID of the business location the checkout is associated with.
	LocationID string `json:"location_id" url:"location_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (q *QuickPay) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QuickPay) UnmarshalJSON(data []byte) error {
	type unmarshaler QuickPay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QuickPay(value)

	extraProperties, err := core.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties

	q._rawJSON = json.RawMessage(data)
	return nil
}

func (q *QuickPay) String() string {
	if len(q._rawJSON) > 0 {
		if value, err := core.StringifyJSON(q._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// The range of a number value between the specified lower and upper bounds.
type Range struct {
	// The lower bound of the number range. At least one of `min` or `max` must be specified.
	// If unspecified, the results will have no minimum value.
	Min *string `json:"min,omitempty" url:"min,omitempty"`
	// The upper bound of the number range. At least one of `min` or `max` must be specified.
	// If unspecified, the results will have no maximum value.
	Max *string `json:"max,omitempty" url:"max,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Range) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Range) UnmarshalJSON(data []byte) error {
	type unmarshaler Range
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Range(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Range) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Describes receipt action fields.
type ReceiptOptions struct {
	// The reference to the Square payment ID for the receipt.
	PaymentID string `json:"payment_id" url:"payment_id"`
	// Instructs the device to print the receipt without displaying the receipt selection screen.
	// Requires `printer_enabled` set to true.
	// Defaults to false.
	PrintOnly *bool `json:"print_only,omitempty" url:"print_only,omitempty"`
	// Identify the receipt as a reprint rather than an original receipt.
	// Defaults to false.
	IsDuplicate *bool `json:"is_duplicate,omitempty" url:"is_duplicate,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReceiptOptions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReceiptOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ReceiptOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReceiptOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReceiptOptions) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A response that includes the `LoyaltyEvent` published for redeeming the reward.
type RedeemLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The `LoyaltyEvent` for redeeming the reward.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RedeemLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RedeemLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RedeemLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RedeemLoyaltyRewardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RedeemLoyaltyRewardResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a refund processed for a Square transaction.
type Refund struct {
	// The refund's unique ID.
	ID string `json:"id" url:"id"`
	// The ID of the refund's associated location.
	LocationID string `json:"location_id" url:"location_id"`
	// The ID of the transaction that the refunded tender is part of.
	TransactionID *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The ID of the refunded tender.
	TenderID string `json:"tender_id" url:"tender_id"`
	// The timestamp for when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The reason for the refund being issued.
	Reason string `json:"reason" url:"reason"`
	// The amount of money refunded to the buyer.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The current status of the refund (`PENDING`, `APPROVED`, `REJECTED`,
	// or `FAILED`).
	// See [RefundStatus](#type-refundstatus) for possible values
	Status RefundStatus `json:"status" url:"status"`
	// The amount of Square processing fee money refunded to the _merchant_.
	ProcessingFeeMoney *Money `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this refund.
	// For example, fees assessed on a refund of a purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Refund) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Refund) UnmarshalJSON(data []byte) error {
	type unmarshaler Refund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Refund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Refund) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the response returned by
// [RefundPayment]($e/Refunds/RefundPayment).
//
// If there are errors processing the request, the `refund` field might not be
// present, or it might be present with a status of `FAILED`.
type RefundPaymentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created `PaymentRefund`.
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundPaymentResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundPaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundPaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundPaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundPaymentResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates a refund's current status.
type RefundStatus string

const (
	RefundStatusPending  RefundStatus = "PENDING"
	RefundStatusApproved RefundStatus = "APPROVED"
	RefundStatusRejected RefundStatus = "REJECTED"
	RefundStatusFailed   RefundStatus = "FAILED"
)

func NewRefundStatusFromString(s string) (RefundStatus, error) {
	switch s {
	case "PENDING":
		return RefundStatusPending, nil
	case "APPROVED":
		return RefundStatusApproved, nil
	case "REJECTED":
		return RefundStatusRejected, nil
	case "FAILED":
		return RefundStatusFailed, nil
	}
	var t RefundStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefundStatus) Ptr() *RefundStatus {
	return &r
}

// Defines the fields that are included in the response body of
// a request to the [RegisterDomain]($e/ApplePay/RegisterDomain) endpoint.
//
// Either `errors` or `status` are present in a given response (never both).
type RegisterDomainResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The status of the domain registration.
	//
	// See [RegisterDomainResponseStatus](entity:RegisterDomainResponseStatus) for possible values.
	// See [RegisterDomainResponseStatus](#type-registerdomainresponsestatus) for possible values
	Status *RegisterDomainResponseStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RegisterDomainResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RegisterDomainResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RegisterDomainResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RegisterDomainResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RegisterDomainResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The status of the domain registration.
type RegisterDomainResponseStatus string

const (
	RegisterDomainResponseStatusPending  RegisterDomainResponseStatus = "PENDING"
	RegisterDomainResponseStatusVerified RegisterDomainResponseStatus = "VERIFIED"
)

func NewRegisterDomainResponseStatusFromString(s string) (RegisterDomainResponseStatus, error) {
	switch s {
	case "PENDING":
		return RegisterDomainResponseStatusPending, nil
	case "VERIFIED":
		return RegisterDomainResponseStatusVerified, nil
	}
	var t RegisterDomainResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RegisterDomainResponseStatus) Ptr() *RegisterDomainResponseStatus {
	return &r
}

// Defines the fields that are included in the request body of
// a request to the [RemoveGroupFromCustomer]($e/Customers/RemoveGroupFromCustomer) endpoint.
type RemoveGroupFromCustomerRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoveGroupFromCustomerRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoveGroupFromCustomerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoveGroupFromCustomerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoveGroupFromCustomerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoveGroupFromCustomerRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the fields that are included in the response body of
// a request to the [RemoveGroupFromCustomer]($e/Customers/RemoveGroupFromCustomer)
// endpoint.
type RemoveGroupFromCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RemoveGroupFromCustomerResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoveGroupFromCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoveGroupFromCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoveGroupFromCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoveGroupFromCustomerResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines output parameters in a response from the
// [ResumeSubscription]($e/Subscriptions/ResumeSubscription) endpoint.
type ResumeSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resumed subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of `RESUME` actions created by the request and scheduled for the subscription.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ResumeSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResumeSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ResumeSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResumeSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResumeSubscriptionResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveBookingCustomAttributeDefinition]($e/BookingCustomAttributes/RetrieveBookingCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveBookingCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveBookingCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveBookingCustomAttribute]($e/BookingCustomAttributes/RetrieveBookingCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveBookingCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveBookingCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveBookingCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveBookingCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveBookingCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveBookingCustomAttributeResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveCashDrawerShiftRequest struct {
	// The ID of the location to retrieve cash drawer shifts from.
	LocationID string `json:"location_id" url:"location_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveCashDrawerShiftRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveCashDrawerShiftRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveCashDrawerShiftRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveCashDrawerShiftRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveCashDrawerShiftRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveCatalogObjectRequest struct {
	// If `true`, the response will include additional objects that are related to the
	// requested objects. Related objects are defined as any objects referenced by ID by the results in the `objects` field
	// of the response. These objects are put in the `related_objects` field. Setting this to `true` is
	// helpful when the objects are needed for immediate display to a user.
	// This process only goes one level deep. Objects referenced by the related objects will not be included. For example,
	//
	// if the `objects` field of the response contains a CatalogItem, its associated
	// CatalogCategory objects, CatalogTax objects, CatalogImage objects and
	// CatalogModifierLists will be returned in the `related_objects` field of the
	// response. If the `objects` field of the response contains a CatalogItemVariation,
	// its parent CatalogItem will be returned in the `related_objects` field of
	// the response.
	//
	// Default value: `false`
	IncludeRelatedObjects *bool `json:"include_related_objects,omitempty" url:"include_related_objects,omitempty"`
	// Requests objects as of a specific version of the catalog. This allows you to retrieve historical
	// versions of objects. The value to retrieve a specific version of an object can be found
	// in the version field of [CatalogObject]($m/CatalogObject)s. If not included, results will
	// be from the current version of the catalog.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// Specifies whether or not to include the `path_to_root` list for each returned category instance. The `path_to_root` list consists
	// of `CategoryPathToRootNode` objects and specifies the path that starts with the immediate parent category of the returned category
	// and ends with its root category. If the returned category is a top-level category, the `path_to_root` list is empty and is not returned
	// in the response payload.
	IncludeCategoryPathToRoot *bool `json:"include_category_path_to_root,omitempty" url:"include_category_path_to_root,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveCatalogObjectRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveCatalogObjectRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveCatalogObjectRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveCatalogObjectRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveCatalogObjectRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveCustomerCustomAttributeDefinition]($e/CustomerCustomAttributes/RetrieveCustomerCustomAttributeDefinition) request.
type RetrieveCustomerCustomAttributeDefinitionRequest struct {
	// The current version of the custom attribute definition, which is used for strongly consistent
	// reads to guarantee that you receive the most up-to-date data. When included in the request,
	// Square returns the specified version or a higher version if one exists. If the specified version
	// is higher than the current version, Square returns a `BAD_REQUEST` error.
	Version *int `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveCustomerCustomAttributeDefinitionRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveCustomerCustomAttributeDefinitionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveCustomerCustomAttributeDefinitionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveCustomerCustomAttributeDefinitionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveCustomerCustomAttributeDefinitionRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveCustomerCustomAttribute]($e/CustomerCustomAttributes/RetrieveCustomerCustomAttribute) request.
type RetrieveCustomerCustomAttributeRequest struct {
	// Indicates whether to return the [custom attribute definition](entity:CustomAttributeDefinition) in the `definition` field of
	// the custom attribute. Set this parameter to `true` to get the name and description of the custom
	// attribute, information about the data type, or other definition details. The default value is `false`.
	WithDefinition *bool `json:"with_definition,omitempty" url:"with_definition,omitempty"`
	// The current version of the custom attribute, which is used for strongly consistent reads to
	// guarantee that you receive the most up-to-date data. When included in the request, Square
	// returns the specified version or a higher version if one exists. If the specified version is
	// higher than the current version, Square returns a `BAD_REQUEST` error.
	Version *int `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveCustomerCustomAttributeRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveCustomerCustomAttributeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveCustomerCustomAttributeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveCustomerCustomAttributeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveCustomerCustomAttributeRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveInventoryChangesRequest struct {
	// The [Location](entity:Location) IDs to look up as a comma-separated
	// list. An empty list queries all locations.
	LocationIDs *string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for the original query.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveInventoryChangesRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveInventoryChangesRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveInventoryChangesRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveInventoryChangesRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveInventoryChangesRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveInventoryCountRequest struct {
	// The [Location](entity:Location) IDs to look up as a comma-separated
	// list. An empty list queries all locations.
	LocationIDs *string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// A pagination cursor returned by a previous call to this endpoint.
	// Provide this to retrieve the next set of results for the original query.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveInventoryCountRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveInventoryCountRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveInventoryCountRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveInventoryCountRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveInventoryCountRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveLocationBookingProfileRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveLocationBookingProfileRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationBookingProfileRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationBookingProfileRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationBookingProfileRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationBookingProfileRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveLocationBookingProfileResponse struct {
	// The requested location booking profile.
	LocationBookingProfile *LocationBookingProfile `json:"location_booking_profile,omitempty" url:"location_booking_profile,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveLocationBookingProfileResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationBookingProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationBookingProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationBookingProfileResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationBookingProfileResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveLocationCustomAttributeDefinition]($e/LocationCustomAttributes/RetrieveLocationCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveLocationCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveLocationCustomAttribute]($e/LocationCustomAttributes/RetrieveLocationCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveLocationCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveLocationCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationCustomAttributeResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveLocationSettingsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveLocationSettingsRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationSettingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationSettingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationSettingsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationSettingsRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveLocationSettingsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The location settings.
	LocationSettings *CheckoutLocationSettings `json:"location_settings,omitempty" url:"location_settings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveLocationSettingsResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationSettingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationSettingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationSettingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationSettingsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveMerchantCustomAttributeDefinition]($e/MerchantCustomAttributes/RetrieveMerchantCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveMerchantCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveMerchantCustomAttribute]($e/MerchantCustomAttributes/RetrieveMerchantCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveMerchantCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveMerchantCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantCustomAttributeResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveMerchantSettingsRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveMerchantSettingsRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantSettingsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantSettingsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantSettingsRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantSettingsRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveMerchantSettingsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The merchant settings.
	MerchantSettings *CheckoutMerchantSettings `json:"merchant_settings,omitempty" url:"merchant_settings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveMerchantSettingsResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantSettingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantSettingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantSettingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantSettingsResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a response from getting an order custom attribute definition.
type RetrieveOrderCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveOrderCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a response from getting an order custom attribute.
type RetrieveOrderCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request, the custom attribute definition is returned in the `definition field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveOrderCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveOrderCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveOrderCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveOrderCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveOrderCustomAttributeResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines input parameters in a request to the
// [RetrieveSubscription]($e/Subscriptions/RetrieveSubscription) endpoint.
type RetrieveSubscriptionRequest struct {
	// A query parameter to specify related information to be included in the response.
	//
	// The supported query parameter values are:
	//
	// - `actions`: to include scheduled actions on the targeted subscription.
	Include *string `json:"include,omitempty" url:"include,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveSubscriptionRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveSubscriptionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveSubscriptionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveSubscriptionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveSubscriptionRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Request object for [RetrieveTokenStatus] endpoint.
type RetrieveTokenStatusRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveTokenStatusRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveTokenStatusRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveTokenStatusRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveTokenStatusRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveTokenStatusRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the fields that are included in the response body of
// a request to the `RetrieveTokenStatus` endpoint.
type RetrieveTokenStatusResponse struct {
	// The list of scopes associated with an access token.
	Scopes []string `json:"scopes,omitempty" url:"scopes,omitempty"`
	// The date and time when the `access_token` expires, in RFC 3339 format. Empty if the token never expires.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The Square-issued application ID associated with the access token. This is the same application ID used to obtain the token.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The ID of the authorizing merchant's business.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveTokenStatusResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveTokenStatusResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveTokenStatusResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveTokenStatusResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveTokenStatusResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RevokeTokenResponse struct {
	// If the request is successful, this is `true`.
	Success *bool `json:"success,omitempty" url:"success,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RevokeTokenResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RevokeTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RevokeTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RevokeTokenResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RevokeTokenResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents fraud risk information for the associated payment.
//
// When you take a payment through Square's Payments API (using the `CreatePayment`
// endpoint), Square evaluates it and assigns a risk level to the payment. Sellers
// can use this information to determine the course of action (for example,
// provide the goods/services or refund the payment).
type RiskEvaluation struct {
	// The timestamp when payment risk was evaluated, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The risk level associated with the payment
	// See [RiskEvaluationRiskLevel](#type-riskevaluationrisklevel) for possible values
	RiskLevel *RiskEvaluationRiskLevel `json:"risk_level,omitempty" url:"risk_level,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RiskEvaluation) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RiskEvaluation) UnmarshalJSON(data []byte) error {
	type unmarshaler RiskEvaluation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RiskEvaluation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RiskEvaluation) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RiskEvaluationRiskLevel string

const (
	RiskEvaluationRiskLevelPending  RiskEvaluationRiskLevel = "PENDING"
	RiskEvaluationRiskLevelNormal   RiskEvaluationRiskLevel = "NORMAL"
	RiskEvaluationRiskLevelModerate RiskEvaluationRiskLevel = "MODERATE"
	RiskEvaluationRiskLevelHigh     RiskEvaluationRiskLevel = "HIGH"
)

func NewRiskEvaluationRiskLevelFromString(s string) (RiskEvaluationRiskLevel, error) {
	switch s {
	case "PENDING":
		return RiskEvaluationRiskLevelPending, nil
	case "NORMAL":
		return RiskEvaluationRiskLevelNormal, nil
	case "MODERATE":
		return RiskEvaluationRiskLevelModerate, nil
	case "HIGH":
		return RiskEvaluationRiskLevelHigh, nil
	}
	var t RiskEvaluationRiskLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RiskEvaluationRiskLevel) Ptr() *RiskEvaluationRiskLevel {
	return &r
}

// Describes save-card action fields.
type SaveCardOptions struct {
	// The square-assigned ID of the customer linked to the saved card.
	CustomerID string `json:"customer_id" url:"customer_id"`
	// The id of the created card-on-file.
	CardID *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// An optional user-defined reference ID that can be used to associate
	// this `Card` to another entity in an external system. For example, a customer
	// ID generated by a third-party system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SaveCardOptions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SaveCardOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler SaveCardOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SaveCardOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SaveCardOptions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A query filter to search for buyer-accessible availabilities by.
type SearchAvailabilityFilter struct {
	// The query expression to search for buy-accessible availabilities with their starting times falling within the specified time range.
	// The time range must be at least 24 hours and at most 32 days long.
	// For waitlist availabilities, the time range can be 0 or more up to 367 days long.
	StartAtRange *TimeRange `json:"start_at_range,omitempty" url:"start_at_range,omitempty"`
	// The query expression to search for buyer-accessible availabilities with their location IDs matching the specified location ID.
	// This query expression cannot be set if `booking_id` is set.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The query expression to search for buyer-accessible availabilities matching the specified list of segment filters.
	// If the size of the `segment_filters` list is `n`, the search returns availabilities with `n` segments per availability.
	//
	// This query expression cannot be set if `booking_id` is set.
	SegmentFilters []*SegmentFilter `json:"segment_filters,omitempty" url:"segment_filters,omitempty"`
	// The query expression to search for buyer-accessible availabilities for an existing booking by matching the specified `booking_id` value.
	// This is commonly used to reschedule an appointment.
	// If this expression is set, the `location_id` and `segment_filters` expressions cannot be set.
	BookingID *string `json:"booking_id,omitempty" url:"booking_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchAvailabilityFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchAvailabilityFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchAvailabilityFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchAvailabilityFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchAvailabilityFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The query used to search for buyer-accessible availabilities of bookings.
type SearchAvailabilityQuery struct {
	// The query filter to search for buyer-accessible availabilities of existing bookings.
	Filter *SearchAvailabilityFilter `json:"filter,omitempty" url:"filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchAvailabilityQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchAvailabilityQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchAvailabilityQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchAvailabilityQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchAvailabilityQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchAvailabilityResponse struct {
	// List of appointment slots available for booking.
	Availabilities []*Availability `json:"availabilities,omitempty" url:"availabilities,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchAvailabilityResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchAvailabilityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchAvailabilityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchAvailabilityResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchAvailabilityResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines supported stock levels of the item inventory.
type SearchCatalogItemsRequestStockLevel string

const (
	SearchCatalogItemsRequestStockLevelOut SearchCatalogItemsRequestStockLevel = "OUT"
	SearchCatalogItemsRequestStockLevelLow SearchCatalogItemsRequestStockLevel = "LOW"
)

func NewSearchCatalogItemsRequestStockLevelFromString(s string) (SearchCatalogItemsRequestStockLevel, error) {
	switch s {
	case "OUT":
		return SearchCatalogItemsRequestStockLevelOut, nil
	case "LOW":
		return SearchCatalogItemsRequestStockLevelLow, nil
	}
	var t SearchCatalogItemsRequestStockLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchCatalogItemsRequestStockLevel) Ptr() *SearchCatalogItemsRequestStockLevel {
	return &s
}

// Defines the response body returned from the [SearchCatalogItems]($e/Catalog/SearchCatalogItems) endpoint.
type SearchCatalogItemsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Returned items matching the specified query expressions.
	Items []*CatalogObject `json:"items,omitempty" url:"items,omitempty"`
	// Pagination token used in the next request to return more of the search result.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Ids of returned item variations matching the specified query expression.
	MatchedVariationIDs []string `json:"matched_variation_ids,omitempty" url:"matched_variation_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchCatalogItemsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchCatalogItemsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchCatalogItemsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchCatalogItemsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchCatalogItemsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchCatalogObjectsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset, this is the final response.
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The CatalogObjects returned.
	Objects []*CatalogObject `json:"objects,omitempty" url:"objects,omitempty"`
	// A list of CatalogObjects referenced by the objects in the `objects` field.
	RelatedObjects []*CatalogObject `json:"related_objects,omitempty" url:"related_objects,omitempty"`
	// When the associated product catalog was last updated. Will
	// match the value for `end_time` or `cursor` if either field is included in the `SearchCatalog` request.
	LatestTime *string `json:"latest_time,omitempty" url:"latest_time,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchCatalogObjectsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchCatalogObjectsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchCatalogObjectsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchCatalogObjectsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchCatalogObjectsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the fields that are included in the response body of
// a request to the `SearchCustomers` endpoint.
//
// Either `errors` or `customers` is present in a given response (never both).
type SearchCustomersResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The customer profiles that match the search query. If any search condition is not met, the result is an empty object (`{}`).
	// Only customer profiles with public information (`given_name`, `family_name`, `company_name`, `email_address`, or `phone_number`)
	// are included in the response.
	Customers []*Customer `json:"customers,omitempty" url:"customers,omitempty"`
	// A pagination cursor that can be used during subsequent calls
	// to `SearchCustomers` to retrieve the next set of results associated
	// with the original query. Pagination cursors are only present when
	// a request succeeds and additional results are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The total count of customers associated with the Square account that match the search query. Only customer profiles with
	// public information (`given_name`, `family_name`, `company_name`, `email_address`, or `phone_number`) are counted. This field is
	// present only if `count` is set to `true` in the request.
	Count *int64 `json:"count,omitempty" url:"count,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchCustomersResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchCustomersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchCustomersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchCustomersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchCustomersResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Criteria to filter events by.
type SearchEventsFilter struct {
	// Filter events by event types.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// Filter events by merchant.
	MerchantIDs []string `json:"merchant_ids,omitempty" url:"merchant_ids,omitempty"`
	// Filter events by location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Filter events by when they were created.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchEventsFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchEventsFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchEventsFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchEventsFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchEventsFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Contains query criteria for the search.
type SearchEventsQuery struct {
	// Criteria to filter events by.
	Filter *SearchEventsFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Criteria to sort events by.
	Sort *SearchEventsSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchEventsQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchEventsQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchEventsQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchEventsQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchEventsQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the fields that are included in the response body of
// a request to the [SearchEvents]($e/Events/SearchEvents) endpoint.
//
// Note: if there are errors processing the request, the events field will not be
// present.
type SearchEventsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of [Event](entity:Event)s returned by the search.
	Events []*Event `json:"events,omitempty" url:"events,omitempty"`
	// Contains the metadata of an event. For more information, see [Event](entity:Event).
	Metadata []*EventMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a subsequent request to fetch the next set of events. If empty, this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchEventsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchEventsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Criteria to sort events by.
type SearchEventsSort struct {
	// Sort events by event types.
	// See [SearchEventsSortField](#type-searcheventssortfield) for possible values
	Field *SearchEventsSortField `json:"field,omitempty" url:"field,omitempty"`
	// The order to use for sorting the events.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchEventsSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchEventsSort) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchEventsSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchEventsSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchEventsSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies the sort key for events returned from a search.
type SearchEventsSortField = string

// Describes a `SearchInvoices` response.
type SearchInvoicesResponse struct {
	// The list of invoices returned by the search.
	Invoices []*Invoice `json:"invoices,omitempty" url:"invoices,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a
	// subsequent request to fetch the next set of invoices. If empty, this is the final
	// response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchInvoicesResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchInvoicesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchInvoicesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchInvoicesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchInvoicesResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The search criteria for the loyalty accounts.
type SearchLoyaltyAccountsRequestLoyaltyAccountQuery struct {
	// The set of mappings to use in the loyalty account search.
	//
	// This cannot be combined with `customer_ids`.
	//
	// Max: 30 mappings
	Mappings []*LoyaltyAccountMapping `json:"mappings,omitempty" url:"mappings,omitempty"`
	// The set of customer IDs to use in the loyalty account search.
	//
	// This cannot be combined with `mappings`.
	//
	// Max: 30 customer IDs
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyAccountsRequestLoyaltyAccountQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyAccountsRequestLoyaltyAccountQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A response that includes loyalty accounts that satisfy the search criteria.
type SearchLoyaltyAccountsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty accounts that met the search criteria,
	// in order of creation date.
	LoyaltyAccounts []*LoyaltyAccount `json:"loyalty_accounts,omitempty" url:"loyalty_accounts,omitempty"`
	// The pagination cursor to use in a subsequent
	// request. If empty, this is the final response.
	// For more information,
	// see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyAccountsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyAccountsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyAccountsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyAccountsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyAccountsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A response that contains loyalty events that satisfy the search
// criteria, in order by the `created_at` date.
type SearchLoyaltyEventsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty events that satisfy the search criteria.
	Events []*LoyaltyEvent `json:"events,omitempty" url:"events,omitempty"`
	// The pagination cursor to be used in a subsequent
	// request. If empty, this is the final response.
	// For more information,
	// see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyEventsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyEventsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyEventsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The set of search requirements.
type SearchLoyaltyRewardsRequestLoyaltyRewardQuery struct {
	// The ID of the [loyalty account](entity:LoyaltyAccount) to which the loyalty reward belongs.
	LoyaltyAccountID string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The status of the loyalty reward.
	// See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
	Status *LoyaltyRewardStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyRewardsRequestLoyaltyRewardQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyRewardsRequestLoyaltyRewardQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A response that includes the loyalty rewards satisfying the search criteria.
type SearchLoyaltyRewardsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty rewards that satisfy the search criteria.
	// These are returned in descending order by `updated_at`.
	Rewards []*LoyaltyReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	// The pagination cursor to be used in a subsequent
	// request. If empty, this is the final response.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchLoyaltyRewardsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyRewardsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyRewardsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyRewardsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyRewardsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A filter based on the order `customer_id` and any tender `customer_id`
// associated with the order. It does not filter based on the
// [FulfillmentRecipient]($m/FulfillmentRecipient) `customer_id`.
type SearchOrdersCustomerFilter struct {
	// A list of customer IDs to filter by.
	//
	// Max: 10 customer ids.
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersCustomerFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersCustomerFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersCustomerFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersCustomerFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersCustomerFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter for `Order` objects based on whether their `CREATED_AT`,
// `CLOSED_AT`, or `UPDATED_AT` timestamps fall within a specified time range.
// You can specify the time range and which timestamp to filter for. You can filter
// for only one time range at a time.
//
// For each time range, the start time and end time are inclusive. If the end time
// is absent, it defaults to the time of the first request for the cursor.
//
// **Important:** If you use the `DateTimeFilter` in a `SearchOrders` query,
// you must set the `sort_field` in [OrdersSort]($m/SearchOrdersSort)
// to the same field you filter for. For example, if you set the `CLOSED_AT` field
// in `DateTimeFilter`, you must set the `sort_field` in `SearchOrdersSort` to
// `CLOSED_AT`. Otherwise, `SearchOrders` throws an error.
// [Learn more about filtering orders by time range.](https://developer.squareup.com/docs/orders-api/manage-orders/search-orders#important-note-about-filtering-orders-by-time-range)
type SearchOrdersDateTimeFilter struct {
	// The time range for filtering on the `created_at` timestamp. If you use this
	// value, you must set the `sort_field` in the `OrdersSearchSort` object to
	// `CREATED_AT`.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time range for filtering on the `updated_at` timestamp. If you use this
	// value, you must set the `sort_field` in the `OrdersSearchSort` object to
	// `UPDATED_AT`.
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The time range for filtering on the `closed_at` timestamp. If you use this
	// value, you must set the `sort_field` in the `OrdersSearchSort` object to
	// `CLOSED_AT`.
	ClosedAt *TimeRange `json:"closed_at,omitempty" url:"closed_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersDateTimeFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersDateTimeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersDateTimeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersDateTimeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersDateTimeFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filtering criteria to use for a `SearchOrders` request. Multiple filters
// are ANDed together.
type SearchOrdersFilter struct {
	// Filter by [OrderState](entity:OrderState).
	StateFilter *SearchOrdersStateFilter `json:"state_filter,omitempty" url:"state_filter,omitempty"`
	// Filter for results within a time range.
	//
	// **Important:** If you filter for orders by time range, you must set `SearchOrdersSort`
	// to sort by the same field.
	// [Learn more about filtering orders by time range.](https://developer.squareup.com/docs/orders-api/manage-orders/search-orders#important-note-about-filtering-orders-by-time-range)
	DateTimeFilter *SearchOrdersDateTimeFilter `json:"date_time_filter,omitempty" url:"date_time_filter,omitempty"`
	// Filter by the fulfillment type or state.
	FulfillmentFilter *SearchOrdersFulfillmentFilter `json:"fulfillment_filter,omitempty" url:"fulfillment_filter,omitempty"`
	// Filter by the source of the order.
	SourceFilter *SearchOrdersSourceFilter `json:"source_filter,omitempty" url:"source_filter,omitempty"`
	// Filter by customers associated with the order.
	CustomerFilter *SearchOrdersCustomerFilter `json:"customer_filter,omitempty" url:"customer_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter based on [order fulfillment]($m/Fulfillment) information.
type SearchOrdersFulfillmentFilter struct {
	// A list of [fulfillment types](entity:FulfillmentType) to filter
	// for. The list returns orders if any of its fulfillments match any of the fulfillment types
	// listed in this field.
	// See [FulfillmentType](#type-fulfillmenttype) for possible values
	FulfillmentTypes []FulfillmentType `json:"fulfillment_types,omitempty" url:"fulfillment_types,omitempty"`
	// A list of [fulfillment states](entity:FulfillmentState) to filter
	// for. The list returns orders if any of its fulfillments match any of the
	// fulfillment states listed in this field.
	// See [FulfillmentState](#type-fulfillmentstate) for possible values
	FulfillmentStates []FulfillmentState `json:"fulfillment_states,omitempty" url:"fulfillment_states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFulfillmentFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFulfillmentFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFulfillmentFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFulfillmentFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFulfillmentFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Contains query criteria for the search.
type SearchOrdersQuery struct {
	// Criteria to filter results by.
	Filter *SearchOrdersFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Criteria to sort results by.
	Sort *SearchOrdersSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Either the `order_entries` or `orders` field is set, depending on whether
// `return_entries` is set on the [SearchOrdersRequest]($e/Orders/SearchOrders).
type SearchOrdersResponse struct {
	// A list of [OrderEntries](entity:OrderEntry) that fit the query
	// conditions. The list is populated only if `return_entries` is set to `true` in the request.
	OrderEntries []*OrderEntry `json:"order_entries,omitempty" url:"order_entries,omitempty"`
	// A list of
	// [Order](entity:Order) objects that match the query conditions. The list is populated only if
	// `return_entries` is set to `false` in the request.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// [Errors](entity:Error) encountered during the search.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sorting criteria for a `SearchOrders` request. Results can only be sorted
// by a timestamp field.
type SearchOrdersSort struct {
	// The field to sort by.
	//
	// **Important:** When using a [DateTimeFilter](entity:SearchOrdersFilter),
	// `sort_field` must match the timestamp field that the `DateTimeFilter` uses to
	// filter. For example, if you set your `sort_field` to `CLOSED_AT` and you use a
	// `DateTimeFilter`, your `DateTimeFilter` must filter for orders by their `CLOSED_AT` date.
	// If this field does not match the timestamp field in `DateTimeFilter`,
	// `SearchOrders` returns an error.
	//
	// Default: `CREATED_AT`.
	// See [SearchOrdersSortField](#type-searchorderssortfield) for possible values
	SortField SearchOrdersSortField `json:"sort_field" url:"sort_field"`
	// The chronological order in which results are returned. Defaults to `DESC`.
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSort) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies which timestamp to use to sort `SearchOrder` results.
type SearchOrdersSortField string

const (
	SearchOrdersSortFieldCreatedAt SearchOrdersSortField = "CREATED_AT"
	SearchOrdersSortFieldUpdatedAt SearchOrdersSortField = "UPDATED_AT"
	SearchOrdersSortFieldClosedAt  SearchOrdersSortField = "CLOSED_AT"
)

func NewSearchOrdersSortFieldFromString(s string) (SearchOrdersSortField, error) {
	switch s {
	case "CREATED_AT":
		return SearchOrdersSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return SearchOrdersSortFieldUpdatedAt, nil
	case "CLOSED_AT":
		return SearchOrdersSortFieldClosedAt, nil
	}
	var t SearchOrdersSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchOrdersSortField) Ptr() *SearchOrdersSortField {
	return &s
}

// A filter based on order `source` information.
type SearchOrdersSourceFilter struct {
	// Filters by the [Source](entity:OrderSource) `name`. The filter returns any orders
	// with a `source.name` that matches any of the listed source names.
	//
	// Max: 10 source names.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSourceFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSourceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSourceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSourceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSourceFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter by the current order `state`.
type SearchOrdersStateFilter struct {
	// States to filter for.
	// See [OrderState](#type-orderstate) for possible values
	States []OrderState `json:"states,omitempty" url:"states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersStateFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersStateFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersStateFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersStateFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersStateFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The response to a request for `Shift` objects. The response contains
// the requested `Shift` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type SearchShiftsResponse struct {
	// Shifts.
	Shifts []*Shift `json:"shifts,omitempty" url:"shifts,omitempty"`
	// An opaque cursor for fetching the next page.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchShiftsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchShiftsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchShiftsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a set of query expressions (filters) to narrow the scope of targeted subscriptions returned by
// the [SearchSubscriptions]($e/Subscriptions/SearchSubscriptions) endpoint.
type SearchSubscriptionsFilter struct {
	// A filter to select subscriptions based on the subscribing customer IDs.
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`
	// A filter to select subscriptions based on the location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// A filter to select subscriptions based on the source application.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchSubscriptionsFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a query, consisting of specified query expressions, used to search for subscriptions.
type SearchSubscriptionsQuery struct {
	// A list of query expressions.
	Filter *SearchSubscriptionsFilter `json:"filter,omitempty" url:"filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchSubscriptionsQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines output parameters in a response from the
// [SearchSubscriptions]($e/Subscriptions/SearchSubscriptions) endpoint.
type SearchSubscriptionsResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscriptions matching the specified query expressions.
	Subscriptions []*Subscription `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	// When the total number of resulting subscription exceeds the limit of a paged response,
	// the response includes a cursor for you to use in a subsequent request to fetch the next set of results.
	// If the cursor is unset, the response contains the last page of the results.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchSubscriptionsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchSubscriptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchSubscriptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchSubscriptionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchSubscriptionsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a filter used in a search for `TeamMember` objects. `AND` logic is applied
// between the individual fields, and `OR` logic is applied within list-based fields.
// For example, setting this filter value:
//
// ```
// filter = (locations_ids = ["A", "B"], status = ACTIVE)
// ```
//
// returns only active team members assigned to either location "A" or "B".
type SearchTeamMembersFilter struct {
	// When present, filters by team members assigned to the specified locations.
	// When empty, includes team members assigned to any location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// When present, filters by team members who match the given status.
	// When empty, includes team members of all statuses.
	// See [TeamMemberStatus](#type-teammemberstatus) for possible values
	Status *TeamMemberStatus `json:"status,omitempty" url:"status,omitempty"`
	// When present and set to true, returns the team member who is the owner of the Square account.
	IsOwner *bool `json:"is_owner,omitempty" url:"is_owner,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTeamMembersFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTeamMembersFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTeamMembersFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTeamMembersFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTeamMembersFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents the parameters in a search for `TeamMember` objects.
type SearchTeamMembersQuery struct {
	// The options to filter by.
	Filter *SearchTeamMembersFilter `json:"filter,omitempty" url:"filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTeamMembersQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTeamMembersQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTeamMembersQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTeamMembersQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTeamMembersQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a response from a search request containing a filtered list of `TeamMember` objects.
type SearchTeamMembersResponse struct {
	// The filtered list of `TeamMember` objects.
	TeamMembers []*TeamMember `json:"team_members,omitempty" url:"team_members,omitempty"`
	// The opaque cursor for fetching the next page. For more information, see
	// [pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTeamMembersResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTeamMembersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTeamMembersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTeamMembersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTeamMembersResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalActionsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalAction`s.
	Action []*TerminalAction `json:"action,omitempty" url:"action,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more
	// information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTerminalActionsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalActionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalActionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalActionsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalActionsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalCheckoutsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalCheckout` objects.
	Checkouts []*TerminalCheckout `json:"checkouts,omitempty" url:"checkouts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTerminalCheckoutsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalCheckoutsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalCheckoutsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalCheckoutsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalCheckoutsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalRefundsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalRefund` objects.
	Refunds []*TerminalRefund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchTerminalRefundsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalRefundsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines supported query expressions to search for vendors by.
type SearchVendorsRequestFilter struct {
	// The names of the [Vendor](entity:Vendor) objects to retrieve.
	Name []string `json:"name,omitempty" url:"name,omitempty"`
	// The statuses of the [Vendor](entity:Vendor) objects to retrieve.
	// See [VendorStatus](#type-vendorstatus) for possible values
	Status []VendorStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchVendorsRequestFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchVendorsRequestFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchVendorsRequestFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchVendorsRequestFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchVendorsRequestFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines a sorter used to sort results from [SearchVendors]($e/Vendors/SearchVendors).
type SearchVendorsRequestSort struct {
	// Specifies the sort key to sort the returned vendors.
	// See [Field](#type-field) for possible values
	Field *SearchVendorsRequestSortField `json:"field,omitempty" url:"field,omitempty"`
	// Specifies the sort order for the returned vendors.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchVendorsRequestSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchVendorsRequestSort) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchVendorsRequestSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchVendorsRequestSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchVendorsRequestSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The field to sort the returned [Vendor]($m/Vendor) objects by.
type SearchVendorsRequestSortField string

const (
	SearchVendorsRequestSortFieldName      SearchVendorsRequestSortField = "NAME"
	SearchVendorsRequestSortFieldCreatedAt SearchVendorsRequestSortField = "CREATED_AT"
)

func NewSearchVendorsRequestSortFieldFromString(s string) (SearchVendorsRequestSortField, error) {
	switch s {
	case "NAME":
		return SearchVendorsRequestSortFieldName, nil
	case "CREATED_AT":
		return SearchVendorsRequestSortFieldCreatedAt, nil
	}
	var t SearchVendorsRequestSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchVendorsRequestSortField) Ptr() *SearchVendorsRequestSortField {
	return &s
}

// Represents an output from a call to [SearchVendors]($e/Vendors/SearchVendors).
type SearchVendorsResponse struct {
	// Errors encountered when the request fails.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The [Vendor](entity:Vendor) objects matching the specified search filter.
	Vendors []*Vendor `json:"vendors,omitempty" url:"vendors,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchVendorsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchVendorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchVendorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchVendorsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchVendorsResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A query filter to search for buyer-accessible appointment segments by.
type SegmentFilter struct {
	// The ID of the [CatalogItemVariation](entity:CatalogItemVariation) object representing the service booked in this segment.
	ServiceVariationID string `json:"service_variation_id" url:"service_variation_id"`
	// A query filter to search for buyer-accessible appointment segments with service-providing team members matching the specified list of team member IDs. Supported query expressions are
	//
	// - `ANY`: return the appointment segments with team members whose IDs match any member in this list.
	// - `NONE`: return the appointment segments with team members whose IDs are not in this list.
	// - `ALL`: not supported.
	//
	// When no expression is specified, any service-providing team member is eligible to fulfill the Booking.
	TeamMemberIDFilter *FilterValue `json:"team_member_id_filter,omitempty" url:"team_member_id_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SegmentFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SelectOption struct {
	// The reference id for the option.
	ReferenceID string `json:"reference_id" url:"reference_id"`
	// The title text that displays in the select option button.
	Title string `json:"title" url:"title"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SelectOption) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SelectOption) UnmarshalJSON(data []byte) error {
	type unmarshaler SelectOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SelectOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SelectOption) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SelectOptions struct {
	// The title text to display in the select flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display in the select flow on the Terminal.
	Body string `json:"body" url:"body"`
	// Represents the buttons/options that should be displayed in the select flow on the Terminal.
	Options []*SelectOption `json:"options,omitempty" url:"options,omitempty"`
	// The buyer’s selected option.
	SelectedOption *SelectOption `json:"selected_option,omitempty" url:"selected_option,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SelectOptions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SelectOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler SelectOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SelectOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SelectOptions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A record of the hourly rate, start, and end times for a single work shift
// for an employee. This might include a record of the start and end times for breaks
// taken during the shift.
type Shift struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the employee this shift belongs to. DEPRECATED at version 2020-08-26. Use `team_member_id` instead.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The ID of the location this shift occurred at. The location should be based on
	// where the employee clocked in.
	LocationID string `json:"location_id" url:"location_id"`
	// The read-only convenience value that is calculated from the location based
	// on the `location_id`. Format: the IANA timezone database identifier for the
	// location timezone.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// RFC 3339; shifted to the location timezone + offset. Precision up to the
	// minute is respected; seconds are truncated.
	StartAt string `json:"start_at" url:"start_at"`
	// RFC 3339; shifted to the timezone + offset. Precision up to the minute is
	// respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// Job and pay related information. If the wage is not set on create, it defaults to a wage
	// of zero. If the title is not set on create, it defaults to the name of the role the employee
	// is assigned to, if any.
	Wage *ShiftWage `json:"wage,omitempty" url:"wage,omitempty"`
	// A list of all the paid or unpaid breaks that were taken during this shift.
	Breaks []*Break `json:"breaks,omitempty" url:"breaks,omitempty"`
	// Describes the working state of the current `Shift`.
	// See [ShiftStatus](#type-shiftstatus) for possible values
	Status *ShiftStatus `json:"status,omitempty" url:"status,omitempty"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write; potentially overwriting data from another
	// write.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the team member this shift belongs to. Replaced `employee_id` at version "2020-08-26".
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The tips declared by the team member for the shift.
	DeclaredCashTipMoney *Money `json:"declared_cash_tip_money,omitempty" url:"declared_cash_tip_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Shift) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Shift) UnmarshalJSON(data []byte) error {
	type unmarshaler Shift
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Shift(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Shift) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines a filter used in a search for `Shift` records. `AND` logic is
// used by Square's servers to apply each filter property specified.
type ShiftFilter struct {
	// Fetch shifts for the specified location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Fetch shifts for the specified employees. DEPRECATED at version 2020-08-26. Use `team_member_ids` instead.
	EmployeeIDs []string `json:"employee_ids,omitempty" url:"employee_ids,omitempty"`
	// Fetch a `Shift` instance by `Shift.status`.
	// See [ShiftFilterStatus](#type-shiftfilterstatus) for possible values
	Status *ShiftFilterStatus `json:"status,omitempty" url:"status,omitempty"`
	// Fetch `Shift` instances that start in the time range - Inclusive.
	Start *TimeRange `json:"start,omitempty" url:"start,omitempty"`
	// Fetch the `Shift` instances that end in the time range - Inclusive.
	End *TimeRange `json:"end,omitempty" url:"end,omitempty"`
	// Fetch the `Shift` instances based on the workday date range.
	Workday *ShiftWorkday `json:"workday,omitempty" url:"workday,omitempty"`
	// Fetch shifts for the specified team members. Replaced `employee_ids` at version "2020-08-26".
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies the `status` of `Shift` records to be returned.
type ShiftFilterStatus string

const (
	ShiftFilterStatusOpen   ShiftFilterStatus = "OPEN"
	ShiftFilterStatusClosed ShiftFilterStatus = "CLOSED"
)

func NewShiftFilterStatusFromString(s string) (ShiftFilterStatus, error) {
	switch s {
	case "OPEN":
		return ShiftFilterStatusOpen, nil
	case "CLOSED":
		return ShiftFilterStatusClosed, nil
	}
	var t ShiftFilterStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftFilterStatus) Ptr() *ShiftFilterStatus {
	return &s
}

// The parameters of a `Shift` search query, which includes filter and sort options.
type ShiftQuery struct {
	// Query filter options.
	Filter *ShiftFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Sort order details.
	Sort *ShiftSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sets the sort order of search results.
type ShiftSort struct {
	// The field to sort on.
	// See [ShiftSortField](#type-shiftsortfield) for possible values
	Field *ShiftSortField `json:"field,omitempty" url:"field,omitempty"`
	// The order in which results are returned. Defaults to DESC.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftSort) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Enumerates the `Shift` fields to sort on.
type ShiftSortField string

const (
	ShiftSortFieldStartAt   ShiftSortField = "START_AT"
	ShiftSortFieldEndAt     ShiftSortField = "END_AT"
	ShiftSortFieldCreatedAt ShiftSortField = "CREATED_AT"
	ShiftSortFieldUpdatedAt ShiftSortField = "UPDATED_AT"
)

func NewShiftSortFieldFromString(s string) (ShiftSortField, error) {
	switch s {
	case "START_AT":
		return ShiftSortFieldStartAt, nil
	case "END_AT":
		return ShiftSortFieldEndAt, nil
	case "CREATED_AT":
		return ShiftSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return ShiftSortFieldUpdatedAt, nil
	}
	var t ShiftSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftSortField) Ptr() *ShiftSortField {
	return &s
}

// Enumerates the possible status of a `Shift`.
type ShiftStatus string

const (
	ShiftStatusOpen   ShiftStatus = "OPEN"
	ShiftStatusClosed ShiftStatus = "CLOSED"
)

func NewShiftStatusFromString(s string) (ShiftStatus, error) {
	switch s {
	case "OPEN":
		return ShiftStatusOpen, nil
	case "CLOSED":
		return ShiftStatusClosed, nil
	}
	var t ShiftStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftStatus) Ptr() *ShiftStatus {
	return &s
}

// The hourly wage rate used to compensate an employee for this shift.
type ShiftWage struct {
	// The name of the job performed during this shift.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// The id of the job performed during this shift. Square
	// labor-reporting UIs might group shifts together by id. This cannot be used to retrieve the job.
	JobID *string `json:"job_id,omitempty" url:"job_id,omitempty"`
	// Whether team members are eligible for tips when working this job.
	TipEligible *bool `json:"tip_eligible,omitempty" url:"tip_eligible,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftWage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftWage) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftWage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftWage) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A `Shift` search query filter parameter that sets a range of days that
// a `Shift` must start or end in before passing the filter condition.
type ShiftWorkday struct {
	// Dates for fetching the shifts.
	DateRange *DateRange `json:"date_range,omitempty" url:"date_range,omitempty"`
	// The strategy on which the dates are applied.
	// See [ShiftWorkdayMatcher](#type-shiftworkdaymatcher) for possible values
	MatchShiftsBy *ShiftWorkdayMatcher `json:"match_shifts_by,omitempty" url:"match_shifts_by,omitempty"`
	// Location-specific timezones convert workdays to datetime filters.
	// Every location included in the query must have a timezone or this field
	// must be provided as a fallback. Format: the IANA timezone database
	// identifier for the relevant timezone.
	DefaultTimezone *string `json:"default_timezone,omitempty" url:"default_timezone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShiftWorkday) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftWorkday) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftWorkday
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftWorkday(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftWorkday) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the logic used to apply a workday filter.
type ShiftWorkdayMatcher string

const (
	ShiftWorkdayMatcherStartAt      ShiftWorkdayMatcher = "START_AT"
	ShiftWorkdayMatcherEndAt        ShiftWorkdayMatcher = "END_AT"
	ShiftWorkdayMatcherIntersection ShiftWorkdayMatcher = "INTERSECTION"
)

func NewShiftWorkdayMatcherFromString(s string) (ShiftWorkdayMatcher, error) {
	switch s {
	case "START_AT":
		return ShiftWorkdayMatcherStartAt, nil
	case "END_AT":
		return ShiftWorkdayMatcherEndAt, nil
	case "INTERSECTION":
		return ShiftWorkdayMatcherIntersection, nil
	}
	var t ShiftWorkdayMatcher
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftWorkdayMatcher) Ptr() *ShiftWorkdayMatcher {
	return &s
}

type ShippingFee struct {
	// The name for the shipping fee.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The amount and currency for the shipping fee.
	Charge *Money `json:"charge,omitempty" url:"charge,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *ShippingFee) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShippingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingFee) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SignatureImage struct {
	// The mime/type of the image data.
	// Use `image/png;base64` for png.
	ImageType *string `json:"image_type,omitempty" url:"image_type,omitempty"`
	// The base64 representation of the image.
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SignatureImage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureImage) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureImage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureImage) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SignatureOptions struct {
	// The title text to display in the signature capture flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display in the signature capture flow on the Terminal.
	Body string `json:"body" url:"body"`
	// An image representation of the collected signature.
	Signature []*SignatureImage `json:"signature,omitempty" url:"signature,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SignatureOptions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureOptions) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a Square Online site, which is an online store for a Square seller.
type Site struct {
	// The Square-assigned ID of the site.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The title of the site.
	SiteTitle *string `json:"site_title,omitempty" url:"site_title,omitempty"`
	// The domain of the site (without the protocol). For example, `mysite1.square.site`.
	Domain *string `json:"domain,omitempty" url:"domain,omitempty"`
	// Indicates whether the site is published.
	IsPublished *bool `json:"is_published,omitempty" url:"is_published,omitempty"`
	// The timestamp of when the site was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the site was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Site) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Site) UnmarshalJSON(data []byte) error {
	type unmarshaler Site
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Site(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Site) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents the snippet that is added to a Square Online site. The snippet code is injected into the `head` element of all pages on the site, except for checkout pages.
type Snippet struct {
	// The Square-assigned ID for the snippet.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the site that contains the snippet.
	SiteID *string `json:"site_id,omitempty" url:"site_id,omitempty"`
	// The snippet code, which can contain valid HTML, JavaScript, or both.
	Content string `json:"content" url:"content"`
	// The timestamp of when the snippet was initially added to the site, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the snippet was last updated on the site, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Snippet) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Snippet) UnmarshalJSON(data []byte) error {
	type unmarshaler Snippet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Snippet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Snippet) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SnippetResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The snippet.
	Snippet *Snippet `json:"snippet,omitempty" url:"snippet,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SnippetResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SnippetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SnippetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SnippetResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SnippetResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The order (e.g., chronological or alphabetical) in which results from a request are returned.
type SortOrder string

const (
	SortOrderDesc SortOrder = "DESC"
	SortOrderAsc  SortOrder = "ASC"
)

func NewSortOrderFromString(s string) (SortOrder, error) {
	switch s {
	case "DESC":
		return SortOrderDesc, nil
	case "ASC":
		return SortOrderAsc, nil
	}
	var t SortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortOrder) Ptr() *SortOrder {
	return &s
}

// Represents information about the application used to generate a change.
type SourceApplication struct {
	// **Read only** The [product](entity:Product) type of the application.
	// See [Product](#type-product) for possible values
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// **Read only** The Square-assigned ID of the application. This field is used only if the
	// [product](entity:Product) type is `EXTERNAL_API`.
	ApplicationID *string `json:"application_id,omitempty" url:"application_id,omitempty"`
	// **Read only** The display name of the application
	// (for example, `"Custom Application"` or `"Square POS 4.74 for Android"`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SourceApplication) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceApplication) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceApplication
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceApplication(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceApplication) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Additional details about Square Account payments.
type SquareAccountDetails struct {
	// Unique identifier for the payment source used for this payment.
	PaymentSourceToken *string `json:"payment_source_token,omitempty" url:"payment_source_token,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SquareAccountDetails) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SquareAccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler SquareAccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SquareAccountDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SquareAccountDetails) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Contains the name and abbreviation for standard measurement unit.
type StandardUnitDescription struct {
	// Identifies the measurement unit being described.
	Unit *MeasurementUnit `json:"unit,omitempty" url:"unit,omitempty"`
	// UI display name of the measurement unit. For example, 'Pound'.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// UI display abbreviation for the measurement unit. For example, 'lb'.
	Abbreviation *string `json:"abbreviation,omitempty" url:"abbreviation,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StandardUnitDescription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StandardUnitDescription) UnmarshalJSON(data []byte) error {
	type unmarshaler StandardUnitDescription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StandardUnitDescription(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StandardUnitDescription) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Group of standard measurement units.
type StandardUnitDescriptionGroup struct {
	// List of standard (non-custom) measurement units in this description group.
	StandardUnitDescriptions []*StandardUnitDescription `json:"standard_unit_descriptions,omitempty" url:"standard_unit_descriptions,omitempty"`
	// IETF language tag.
	LanguageCode *string `json:"language_code,omitempty" url:"language_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *StandardUnitDescriptionGroup) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StandardUnitDescriptionGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler StandardUnitDescriptionGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StandardUnitDescriptionGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StandardUnitDescriptionGroup) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the parameters for a `SubmitEvidence` request.
type SubmitEvidenceRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubmitEvidenceRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubmitEvidenceRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SubmitEvidenceRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubmitEvidenceRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubmitEvidenceRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the fields in a `SubmitEvidence` response.
type SubmitEvidenceResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The `Dispute` for which evidence was submitted.
	Dispute *Dispute `json:"dispute,omitempty" url:"dispute,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubmitEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubmitEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SubmitEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubmitEvidenceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubmitEvidenceResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents a subscription purchased by a customer.
//
// For more information, see
// [Manage Subscriptions](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions).
type Subscription struct {
	// The Square-assigned ID of the subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the location associated with the subscription.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the subscribed-to [subscription plan variation](entity:CatalogSubscriptionPlanVariation).
	PlanVariationID *string `json:"plan_variation_id,omitempty" url:"plan_variation_id,omitempty"`
	// The ID of the subscribing [customer](entity:Customer) profile.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) to start the subscription.
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) to cancel the subscription,
	// when the subscription status changes to `CANCELED` and the subscription billing stops.
	//
	// If this field is not set, the subscription ends according its subscription plan.
	//
	// This field cannot be updated, other than being cleared.
	CanceledDate *string `json:"canceled_date,omitempty" url:"canceled_date,omitempty"`
	// The `YYYY-MM-DD`-formatted date up to when the subscriber is invoiced for the
	// subscription.
	//
	// After the invoice is sent for a given billing period,
	// this date will be the last day of the billing period.
	// For example,
	// suppose for the month of May a subscriber gets an invoice
	// (or charged the card) on May 1. For the monthly billing scenario,
	// this date is then set to May 31.
	ChargedThroughDate *string `json:"charged_through_date,omitempty" url:"charged_through_date,omitempty"`
	// The current status of the subscription.
	// See [SubscriptionStatus](#type-subscriptionstatus) for possible values
	Status *SubscriptionStatus `json:"status,omitempty" url:"status,omitempty"`
	// The tax amount applied when billing the subscription. The
	// percentage is expressed in decimal form, using a `'.'` as the decimal
	// separator and without a `'%'` sign. For example, a value of `7.5`
	// corresponds to 7.5%.
	TaxPercentage *string `json:"tax_percentage,omitempty" url:"tax_percentage,omitempty"`
	// The IDs of the [invoices](entity:Invoice) created for the
	// subscription, listed in order when the invoices were created
	// (newest invoices appear first).
	InvoiceIDs []string `json:"invoice_ids,omitempty" url:"invoice_ids,omitempty"`
	// A custom price which overrides the cost of a subscription plan variation with `STATIC` pricing.
	// This field does not affect itemized subscriptions with `RELATIVE` pricing. Instead,
	// you should edit the Subscription's [order template](https://developer.squareup.com/docs/subscriptions-api/manage-subscriptions#phases-and-order-templates).
	PriceOverrideMoney *Money `json:"price_override_money,omitempty" url:"price_override_money,omitempty"`
	// The version of the object. When updating an object, the version
	// supplied must match the version in the database, otherwise the write will
	// be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp when the subscription was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The ID of the [subscriber's](entity:Customer) [card](entity:Card)
	// used to charge for the subscription.
	CardID *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// Timezone that will be used in date calculations for the subscription.
	// Defaults to the timezone of the location based on `location_id`.
	// Format: the IANA Timezone Database identifier for the location timezone (for example, `America/Los_Angeles`).
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// The origination details of the subscription.
	Source *SubscriptionSource `json:"source,omitempty" url:"source,omitempty"`
	// The list of scheduled actions on this subscription. It is set only in the response from
	// [RetrieveSubscription]($e/Subscriptions/RetrieveSubscription) with the query parameter
	// of `include=actions` or from
	// [SearchSubscriptions]($e/Subscriptions/SearchSubscriptions) with the input parameter
	// of `include:["actions"]`.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`
	// The day of the month on which the subscription will issue invoices and publish orders.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// array of phases for this subscription
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *Subscription) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Subscription) UnmarshalJSON(data []byte) error {
	type unmarshaler Subscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Subscription(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Subscription) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents an action as a pending change to a subscription.
type SubscriptionAction struct {
	// The ID of an action scoped to a subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the action.
	// See [SubscriptionActionType](#type-subscriptionactiontype) for possible values
	Type *SubscriptionActionType `json:"type,omitempty" url:"type,omitempty"`
	// The `YYYY-MM-DD`-formatted date when the action occurs on the subscription.
	EffectiveDate *string `json:"effective_date,omitempty" url:"effective_date,omitempty"`
	// The new billing anchor day value, for a `CHANGE_BILLING_ANCHOR_DATE` action.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// A list of Phases, to pass phase-specific information used in the swap.
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`
	// The target subscription plan variation that a subscription switches to, for a `SWAP_PLAN` action.
	NewPlanVariationID *string `json:"new_plan_variation_id,omitempty" url:"new_plan_variation_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionAction) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionAction) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionAction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionAction) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported types of an action as a pending change to a subscription.
type SubscriptionActionType string

const (
	SubscriptionActionTypeCancel                  SubscriptionActionType = "CANCEL"
	SubscriptionActionTypePause                   SubscriptionActionType = "PAUSE"
	SubscriptionActionTypeResume                  SubscriptionActionType = "RESUME"
	SubscriptionActionTypeSwapPlan                SubscriptionActionType = "SWAP_PLAN"
	SubscriptionActionTypeChangeBillingAnchorDate SubscriptionActionType = "CHANGE_BILLING_ANCHOR_DATE"
)

func NewSubscriptionActionTypeFromString(s string) (SubscriptionActionType, error) {
	switch s {
	case "CANCEL":
		return SubscriptionActionTypeCancel, nil
	case "PAUSE":
		return SubscriptionActionTypePause, nil
	case "RESUME":
		return SubscriptionActionTypeResume, nil
	case "SWAP_PLAN":
		return SubscriptionActionTypeSwapPlan, nil
	case "CHANGE_BILLING_ANCHOR_DATE":
		return SubscriptionActionTypeChangeBillingAnchorDate, nil
	}
	var t SubscriptionActionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionActionType) Ptr() *SubscriptionActionType {
	return &s
}

// Determines the billing cadence of a [Subscription]($m/Subscription)
type SubscriptionCadence string

const (
	SubscriptionCadenceDaily           SubscriptionCadence = "DAILY"
	SubscriptionCadenceWeekly          SubscriptionCadence = "WEEKLY"
	SubscriptionCadenceEveryTwoWeeks   SubscriptionCadence = "EVERY_TWO_WEEKS"
	SubscriptionCadenceThirtyDays      SubscriptionCadence = "THIRTY_DAYS"
	SubscriptionCadenceSixtyDays       SubscriptionCadence = "SIXTY_DAYS"
	SubscriptionCadenceNinetyDays      SubscriptionCadence = "NINETY_DAYS"
	SubscriptionCadenceMonthly         SubscriptionCadence = "MONTHLY"
	SubscriptionCadenceEveryTwoMonths  SubscriptionCadence = "EVERY_TWO_MONTHS"
	SubscriptionCadenceQuarterly       SubscriptionCadence = "QUARTERLY"
	SubscriptionCadenceEveryFourMonths SubscriptionCadence = "EVERY_FOUR_MONTHS"
	SubscriptionCadenceEverySixMonths  SubscriptionCadence = "EVERY_SIX_MONTHS"
	SubscriptionCadenceAnnual          SubscriptionCadence = "ANNUAL"
	SubscriptionCadenceEveryTwoYears   SubscriptionCadence = "EVERY_TWO_YEARS"
)

func NewSubscriptionCadenceFromString(s string) (SubscriptionCadence, error) {
	switch s {
	case "DAILY":
		return SubscriptionCadenceDaily, nil
	case "WEEKLY":
		return SubscriptionCadenceWeekly, nil
	case "EVERY_TWO_WEEKS":
		return SubscriptionCadenceEveryTwoWeeks, nil
	case "THIRTY_DAYS":
		return SubscriptionCadenceThirtyDays, nil
	case "SIXTY_DAYS":
		return SubscriptionCadenceSixtyDays, nil
	case "NINETY_DAYS":
		return SubscriptionCadenceNinetyDays, nil
	case "MONTHLY":
		return SubscriptionCadenceMonthly, nil
	case "EVERY_TWO_MONTHS":
		return SubscriptionCadenceEveryTwoMonths, nil
	case "QUARTERLY":
		return SubscriptionCadenceQuarterly, nil
	case "EVERY_FOUR_MONTHS":
		return SubscriptionCadenceEveryFourMonths, nil
	case "EVERY_SIX_MONTHS":
		return SubscriptionCadenceEverySixMonths, nil
	case "ANNUAL":
		return SubscriptionCadenceAnnual, nil
	case "EVERY_TWO_YEARS":
		return SubscriptionCadenceEveryTwoYears, nil
	}
	var t SubscriptionCadence
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionCadence) Ptr() *SubscriptionCadence {
	return &s
}

// Describes changes to a subscription and the subscription status.
type SubscriptionEvent struct {
	// The ID of the subscription event.
	ID string `json:"id" url:"id"`
	// Type of the subscription event.
	// See [SubscriptionEventSubscriptionEventType](#type-subscriptioneventsubscriptioneventtype) for possible values
	SubscriptionEventType SubscriptionEventSubscriptionEventType `json:"subscription_event_type" url:"subscription_event_type"`
	// The `YYYY-MM-DD`-formatted date (for example, 2013-01-15) when the subscription event occurred.
	EffectiveDate string `json:"effective_date" url:"effective_date"`
	// The day-of-the-month the billing anchor date was changed to, if applicable.
	MonthlyBillingAnchorDate *int `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// Additional information about the subscription event.
	Info *SubscriptionEventInfo `json:"info,omitempty" url:"info,omitempty"`
	// A list of Phases, to pass phase-specific information used in the swap.
	Phases []*Phase `json:"phases,omitempty" url:"phases,omitempty"`
	// The ID of the subscription plan variation associated with the subscription.
	PlanVariationID string `json:"plan_variation_id" url:"plan_variation_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEvent(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEvent) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Provides information about the subscription event.
type SubscriptionEventInfo struct {
	// A human-readable explanation for the event.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// An info code indicating the subscription event that occurred.
	// See [InfoCode](#type-infocode) for possible values
	Code *SubscriptionEventInfoCode `json:"code,omitempty" url:"code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionEventInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionEventInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionEventInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionEventInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionEventInfo) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported info codes of a subscription event.
type SubscriptionEventInfoCode string

const (
	SubscriptionEventInfoCodeLocationNotActive           SubscriptionEventInfoCode = "LOCATION_NOT_ACTIVE"
	SubscriptionEventInfoCodeLocationCannotAcceptPayment SubscriptionEventInfoCode = "LOCATION_CANNOT_ACCEPT_PAYMENT"
	SubscriptionEventInfoCodeCustomerDeleted             SubscriptionEventInfoCode = "CUSTOMER_DELETED"
	SubscriptionEventInfoCodeCustomerNoEmail             SubscriptionEventInfoCode = "CUSTOMER_NO_EMAIL"
	SubscriptionEventInfoCodeCustomerNoName              SubscriptionEventInfoCode = "CUSTOMER_NO_NAME"
	SubscriptionEventInfoCodeUserProvided                SubscriptionEventInfoCode = "USER_PROVIDED"
)

func NewSubscriptionEventInfoCodeFromString(s string) (SubscriptionEventInfoCode, error) {
	switch s {
	case "LOCATION_NOT_ACTIVE":
		return SubscriptionEventInfoCodeLocationNotActive, nil
	case "LOCATION_CANNOT_ACCEPT_PAYMENT":
		return SubscriptionEventInfoCodeLocationCannotAcceptPayment, nil
	case "CUSTOMER_DELETED":
		return SubscriptionEventInfoCodeCustomerDeleted, nil
	case "CUSTOMER_NO_EMAIL":
		return SubscriptionEventInfoCodeCustomerNoEmail, nil
	case "CUSTOMER_NO_NAME":
		return SubscriptionEventInfoCodeCustomerNoName, nil
	case "USER_PROVIDED":
		return SubscriptionEventInfoCodeUserProvided, nil
	}
	var t SubscriptionEventInfoCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventInfoCode) Ptr() *SubscriptionEventInfoCode {
	return &s
}

// Supported types of an event occurred to a subscription.
type SubscriptionEventSubscriptionEventType string

const (
	SubscriptionEventSubscriptionEventTypeStartSubscription        SubscriptionEventSubscriptionEventType = "START_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePlanChange               SubscriptionEventSubscriptionEventType = "PLAN_CHANGE"
	SubscriptionEventSubscriptionEventTypeStopSubscription         SubscriptionEventSubscriptionEventType = "STOP_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeDeactivateSubscription   SubscriptionEventSubscriptionEventType = "DEACTIVATE_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeResumeSubscription       SubscriptionEventSubscriptionEventType = "RESUME_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypePauseSubscription        SubscriptionEventSubscriptionEventType = "PAUSE_SUBSCRIPTION"
	SubscriptionEventSubscriptionEventTypeBillingAnchorDateChanged SubscriptionEventSubscriptionEventType = "BILLING_ANCHOR_DATE_CHANGED"
)

func NewSubscriptionEventSubscriptionEventTypeFromString(s string) (SubscriptionEventSubscriptionEventType, error) {
	switch s {
	case "START_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStartSubscription, nil
	case "PLAN_CHANGE":
		return SubscriptionEventSubscriptionEventTypePlanChange, nil
	case "STOP_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeStopSubscription, nil
	case "DEACTIVATE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeDeactivateSubscription, nil
	case "RESUME_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypeResumeSubscription, nil
	case "PAUSE_SUBSCRIPTION":
		return SubscriptionEventSubscriptionEventTypePauseSubscription, nil
	case "BILLING_ANCHOR_DATE_CHANGED":
		return SubscriptionEventSubscriptionEventTypeBillingAnchorDateChanged, nil
	}
	var t SubscriptionEventSubscriptionEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionEventSubscriptionEventType) Ptr() *SubscriptionEventSubscriptionEventType {
	return &s
}

// Describes a phase in a subscription plan variation. For more information, see [Subscription Plans and Variations](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations).
type SubscriptionPhase struct {
	// The Square-assigned ID of the subscription phase. This field cannot be changed after a `SubscriptionPhase` is created.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The billing cadence of the phase. For example, weekly or monthly. This field cannot be changed after a `SubscriptionPhase` is created.
	// See [SubscriptionCadence](#type-subscriptioncadence) for possible values
	Cadence SubscriptionCadence `json:"cadence" url:"cadence"`
	// The number of `cadence`s the phase lasts. If not set, the phase never ends. Only the last phase can be indefinite. This field cannot be changed after a `SubscriptionPhase` is created.
	Periods *int `json:"periods,omitempty" url:"periods,omitempty"`
	// The amount to bill for each `cadence`. Failure to specify this field results in a `MISSING_REQUIRED_PARAMETER` error at runtime.
	RecurringPriceMoney *Money `json:"recurring_price_money,omitempty" url:"recurring_price_money,omitempty"`
	// The position this phase appears in the sequence of phases defined for the plan, indexed from 0. This field cannot be changed after a `SubscriptionPhase` is created.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// The subscription pricing.
	Pricing *SubscriptionPricing `json:"pricing,omitempty" url:"pricing,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionPhase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPhase) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPhase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPhase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPhase) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Describes the pricing for the subscription.
type SubscriptionPricing struct {
	// RELATIVE or STATIC
	// See [SubscriptionPricingType](#type-subscriptionpricingtype) for possible values
	Type *SubscriptionPricingType `json:"type,omitempty" url:"type,omitempty"`
	// The ids of the discount catalog objects
	DiscountIDs []string `json:"discount_ids,omitempty" url:"discount_ids,omitempty"`
	// The price of the subscription, if STATIC
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionPricing) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPricing) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPricing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPricing(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPricing) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Determines the pricing of a [Subscription]($m/Subscription)
type SubscriptionPricingType string

const (
	SubscriptionPricingTypeStatic   SubscriptionPricingType = "STATIC"
	SubscriptionPricingTypeRelative SubscriptionPricingType = "RELATIVE"
)

func NewSubscriptionPricingTypeFromString(s string) (SubscriptionPricingType, error) {
	switch s {
	case "STATIC":
		return SubscriptionPricingTypeStatic, nil
	case "RELATIVE":
		return SubscriptionPricingTypeRelative, nil
	}
	var t SubscriptionPricingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionPricingType) Ptr() *SubscriptionPricingType {
	return &s
}

// The origination details of the subscription.
type SubscriptionSource struct {
	// The name used to identify the place (physical or digital) that
	// a subscription originates. If unset, the name defaults to the name
	// of the application that created the subscription.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionSource) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionSource) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionSource) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Supported subscription statuses.
type SubscriptionStatus string

const (
	SubscriptionStatusPending     SubscriptionStatus = "PENDING"
	SubscriptionStatusActive      SubscriptionStatus = "ACTIVE"
	SubscriptionStatusCanceled    SubscriptionStatus = "CANCELED"
	SubscriptionStatusDeactivated SubscriptionStatus = "DEACTIVATED"
	SubscriptionStatusPaused      SubscriptionStatus = "PAUSED"
)

func NewSubscriptionStatusFromString(s string) (SubscriptionStatus, error) {
	switch s {
	case "PENDING":
		return SubscriptionStatusPending, nil
	case "ACTIVE":
		return SubscriptionStatusActive, nil
	case "CANCELED":
		return SubscriptionStatusCanceled, nil
	case "DEACTIVATED":
		return SubscriptionStatusDeactivated, nil
	case "PAUSED":
		return SubscriptionStatusPaused, nil
	}
	var t SubscriptionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionStatus) Ptr() *SubscriptionStatus {
	return &s
}

// Represents the details of a webhook subscription, including notification URL,
// event types, and signature key.
type SubscriptionTestResult struct {
	// A Square-generated unique ID for the subscription test result.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The status code returned by the subscription notification URL.
	StatusCode *int `json:"status_code,omitempty" url:"status_code,omitempty"`
	// An object containing the payload of the test event. For example, a `payment.created` event.
	Payload *string `json:"payload,omitempty" url:"payload,omitempty"`
	// The timestamp of when the subscription was created, in RFC 3339 format.
	// For example, "2016-09-04T23:59:33.123Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the subscription was updated, in RFC 3339 format. For example, "2016-09-04T23:59:33.123Z".
	// Because a subscription test result is unique, this field is the same as the `created_at` field.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionTestResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionTestResult) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionTestResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionTestResult(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionTestResult) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines output parameters in a response of the
// [SwapPlan]($e/Subscriptions/SwapPlan) endpoint.
type SwapPlanResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The subscription with the updated subscription plan.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`
	// A list of a `SWAP_PLAN` action created by the request.
	Actions []*SubscriptionAction `json:"actions,omitempty" url:"actions,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SwapPlanResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SwapPlanResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SwapPlanResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SwapPlanResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SwapPlanResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// When to calculate the taxes due on a cart.
type TaxCalculationPhase string

const (
	TaxCalculationPhaseTaxSubtotalPhase TaxCalculationPhase = "TAX_SUBTOTAL_PHASE"
	TaxCalculationPhaseTaxTotalPhase    TaxCalculationPhase = "TAX_TOTAL_PHASE"
)

func NewTaxCalculationPhaseFromString(s string) (TaxCalculationPhase, error) {
	switch s {
	case "TAX_SUBTOTAL_PHASE":
		return TaxCalculationPhaseTaxSubtotalPhase, nil
	case "TAX_TOTAL_PHASE":
		return TaxCalculationPhaseTaxTotalPhase, nil
	}
	var t TaxCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxCalculationPhase) Ptr() *TaxCalculationPhase {
	return &t
}

// Identifiers for the location used by various governments for tax purposes.
type TaxIDs struct {
	// The EU VAT number for this location. For example, `IE3426675K`.
	// If the EU VAT number is present, it is well-formed and has been
	// validated with VIES, the VAT Information Exchange System.
	EuVat *string `json:"eu_vat,omitempty" url:"eu_vat,omitempty"`
	// The SIRET (Système d'Identification du Répertoire des Entreprises et de leurs Etablissements)
	// number is a 14-digit code issued by the French INSEE. For example, `39922799000021`.
	FrSiret *string `json:"fr_siret,omitempty" url:"fr_siret,omitempty"`
	// The French government uses the NAF (Nomenclature des Activités Françaises) to display and
	// track economic statistical data. This is also called the APE (Activite Principale de l’Entreprise) code.
	// For example, `6910Z`.
	FrNaf *string `json:"fr_naf,omitempty" url:"fr_naf,omitempty"`
	// The NIF (Numero de Identificacion Fiscal) number is a nine-character tax identifier used in Spain.
	// If it is present, it has been validated. For example, `73628495A`.
	EsNif *string `json:"es_nif,omitempty" url:"es_nif,omitempty"`
	// The QII (Qualified Invoice Issuer) number is a 14-character tax identifier used in Japan.
	// For example, `T1234567890123`.
	JpQii *string `json:"jp_qii,omitempty" url:"jp_qii,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TaxIDs) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxIDs) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxIDs
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxIDs(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxIDs) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Whether to the tax amount should be additional to or included in the CatalogItem price.
type TaxInclusionType string

const (
	TaxInclusionTypeAdditive  TaxInclusionType = "ADDITIVE"
	TaxInclusionTypeInclusive TaxInclusionType = "INCLUSIVE"
)

func NewTaxInclusionTypeFromString(s string) (TaxInclusionType, error) {
	switch s {
	case "ADDITIVE":
		return TaxInclusionTypeAdditive, nil
	case "INCLUSIVE":
		return TaxInclusionTypeInclusive, nil
	}
	var t TaxInclusionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxInclusionType) Ptr() *TaxInclusionType {
	return &t
}

// A record representing an individual team member for a business.
type TeamMember struct {
	// The unique ID for the team member.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// A second ID used to associate the team member with an entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Whether the team member is the owner of the Square account.
	IsOwner *bool `json:"is_owner,omitempty" url:"is_owner,omitempty"`
	// Describes the status of the team member.
	// See [TeamMemberStatus](#type-teammemberstatus) for possible values
	Status *TeamMemberStatus `json:"status,omitempty" url:"status,omitempty"`
	// The given name (that is, the first name) associated with the team member.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The family name (that is, the last name) associated with the team member.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// The email address associated with the team member.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The team member's phone number, in E.164 format. For example:
	// +14155552671 - the country code is 1 for US
	// +551155256325 - the country code is 55 for BR
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the team member was created.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the team member was last updated.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Describes the team member's assigned locations.
	AssignedLocations *TeamMemberAssignedLocations `json:"assigned_locations,omitempty" url:"assigned_locations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMember) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMember) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMember
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMember(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMember) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// An object that represents a team member's assignment to locations.
type TeamMemberAssignedLocations struct {
	// The current assignment type of the team member.
	// See [TeamMemberAssignedLocationsAssignmentType](#type-teammemberassignedlocationsassignmenttype) for possible values
	AssignmentType *TeamMemberAssignedLocationsAssignmentType `json:"assignment_type,omitempty" url:"assignment_type,omitempty"`
	// The explicit locations that the team member is assigned to.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberAssignedLocations) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberAssignedLocations) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberAssignedLocations
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberAssignedLocations(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberAssignedLocations) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Enumerates the possible assignment types that the team member can have.
type TeamMemberAssignedLocationsAssignmentType string

const (
	TeamMemberAssignedLocationsAssignmentTypeAllCurrentAndFutureLocations TeamMemberAssignedLocationsAssignmentType = "ALL_CURRENT_AND_FUTURE_LOCATIONS"
	TeamMemberAssignedLocationsAssignmentTypeExplicitLocations            TeamMemberAssignedLocationsAssignmentType = "EXPLICIT_LOCATIONS"
)

func NewTeamMemberAssignedLocationsAssignmentTypeFromString(s string) (TeamMemberAssignedLocationsAssignmentType, error) {
	switch s {
	case "ALL_CURRENT_AND_FUTURE_LOCATIONS":
		return TeamMemberAssignedLocationsAssignmentTypeAllCurrentAndFutureLocations, nil
	case "EXPLICIT_LOCATIONS":
		return TeamMemberAssignedLocationsAssignmentTypeExplicitLocations, nil
	}
	var t TeamMemberAssignedLocationsAssignmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TeamMemberAssignedLocationsAssignmentType) Ptr() *TeamMemberAssignedLocationsAssignmentType {
	return &t
}

// The booking profile of a seller's team member, including the team member's ID, display name, description and whether the team member can be booked as a service provider.
type TeamMemberBookingProfile struct {
	// The ID of the [TeamMember](entity:TeamMember) object for the team member associated with the booking profile.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The description of the team member.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The display name of the team member.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// Indicates whether the team member can be booked through the Bookings API or the seller's online booking channel or site (`true`) or not (`false`).
	IsBookable *bool `json:"is_bookable,omitempty" url:"is_bookable,omitempty"`
	// The URL of the team member's image for the bookings profile.
	ProfileImageURL *string `json:"profile_image_url,omitempty" url:"profile_image_url,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberBookingProfile) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberBookingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberBookingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberBookingProfile(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberBookingProfile) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Enumerates the possible invitation statuses the team member can have within a business.
type TeamMemberInvitationStatus string

const (
	TeamMemberInvitationStatusUninvited TeamMemberInvitationStatus = "UNINVITED"
	TeamMemberInvitationStatusPending   TeamMemberInvitationStatus = "PENDING"
	TeamMemberInvitationStatusAccepted  TeamMemberInvitationStatus = "ACCEPTED"
)

func NewTeamMemberInvitationStatusFromString(s string) (TeamMemberInvitationStatus, error) {
	switch s {
	case "UNINVITED":
		return TeamMemberInvitationStatusUninvited, nil
	case "PENDING":
		return TeamMemberInvitationStatusPending, nil
	case "ACCEPTED":
		return TeamMemberInvitationStatusAccepted, nil
	}
	var t TeamMemberInvitationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TeamMemberInvitationStatus) Ptr() *TeamMemberInvitationStatus {
	return &t
}

// Enumerates the possible statuses the team member can have within a business.
type TeamMemberStatus string

const (
	TeamMemberStatusActive   TeamMemberStatus = "ACTIVE"
	TeamMemberStatusInactive TeamMemberStatus = "INACTIVE"
)

func NewTeamMemberStatusFromString(s string) (TeamMemberStatus, error) {
	switch s {
	case "ACTIVE":
		return TeamMemberStatusActive, nil
	case "INACTIVE":
		return TeamMemberStatusInactive, nil
	}
	var t TeamMemberStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TeamMemberStatus) Ptr() *TeamMemberStatus {
	return &t
}

// The hourly wage rate that a team member earns on a `Shift` for doing the job
// specified by the `title` property of this object.
type TeamMemberWage struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The `TeamMember` that this wage is assigned to.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The job title that this wage relates to.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// An identifier for the job that this wage relates to. This cannot be
	// used to retrieve the job.
	JobID *string `json:"job_id,omitempty" url:"job_id,omitempty"`
	// Whether team members are eligible for tips when working this job.
	TipEligible *bool `json:"tip_eligible,omitempty" url:"tip_eligible,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TeamMemberWage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWage) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWage) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a tender (i.e., a method of payment) used in a Square transaction.
type Tender struct {
	// The tender's unique ID. It is the associated payment ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the transaction's associated location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the tender's associated transaction.
	TransactionID *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The timestamp for when the tender was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// An optional note associated with the tender at the time of payment.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The total amount of the tender, including `tip_money`. If the tender has a `payment_id`,
	// the `total_money` of the corresponding [Payment](entity:Payment) will be equal to the
	// `amount_money` of the tender.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The tip's amount of the tender.
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The amount of any Square processing fees applied to the tender.
	//
	// This field is not immediately populated when a new transaction is created.
	// It is usually available after about ten seconds.
	ProcessingFeeMoney *Money `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// If the tender is associated with a customer or represents a customer's card on file,
	// this is the ID of the associated customer.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The type of tender, such as `CARD` or `CASH`.
	// See [TenderType](#type-tendertype) for possible values
	Type TenderType `json:"type" url:"type"`
	// The details of the card tender.
	//
	// This value is present only if the value of `type` is `CARD`.
	CardDetails *TenderCardDetails `json:"card_details,omitempty" url:"card_details,omitempty"`
	// The details of the cash tender.
	//
	// This value is present only if the value of `type` is `CASH`.
	CashDetails *TenderCashDetails `json:"cash_details,omitempty" url:"cash_details,omitempty"`
	// The details of the bank account tender.
	//
	// This value is present only if the value of `type` is `BANK_ACCOUNT`.
	BankAccountDetails *TenderBankAccountDetails `json:"bank_account_details,omitempty" url:"bank_account_details,omitempty"`
	// The details of a Buy Now Pay Later tender.
	//
	// This value is present only if the value of `type` is `BUY_NOW_PAY_LATER`.
	BuyNowPayLaterDetails *TenderBuyNowPayLaterDetails `json:"buy_now_pay_later_details,omitempty" url:"buy_now_pay_later_details,omitempty"`
	// The details of a Square Account tender.
	//
	// This value is present only if the value of `type` is `SQUARE_ACCOUNT`.
	SquareAccountDetails *TenderSquareAccountDetails `json:"square_account_details,omitempty" url:"square_account_details,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this tender.
	// For example, fees assessed on the purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`
	// The ID of the [Payment](entity:Payment) that corresponds to this tender.
	// This value is only present for payments created with the v2 Payments API.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Tender) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tender) UnmarshalJSON(data []byte) error {
	type unmarshaler Tender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tender) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents the details of a tender with `type` `BANK_ACCOUNT`.
//
// See [BankAccountPaymentDetails]($m/BankAccountPaymentDetails)
// for more exposed details of a bank account payment.
type TenderBankAccountDetails struct {
	// The bank account payment's current state.
	//
	// See [TenderBankAccountPaymentDetailsStatus](entity:TenderBankAccountDetailsStatus) for possible values.
	// See [TenderBankAccountDetailsStatus](#type-tenderbankaccountdetailsstatus) for possible values
	Status *TenderBankAccountDetailsStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TenderBankAccountDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderBankAccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderBankAccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderBankAccountDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderBankAccountDetails) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the bank account payment's current status.
type TenderBankAccountDetailsStatus string

const (
	TenderBankAccountDetailsStatusPending   TenderBankAccountDetailsStatus = "PENDING"
	TenderBankAccountDetailsStatusCompleted TenderBankAccountDetailsStatus = "COMPLETED"
	TenderBankAccountDetailsStatusFailed    TenderBankAccountDetailsStatus = "FAILED"
)

func NewTenderBankAccountDetailsStatusFromString(s string) (TenderBankAccountDetailsStatus, error) {
	switch s {
	case "PENDING":
		return TenderBankAccountDetailsStatusPending, nil
	case "COMPLETED":
		return TenderBankAccountDetailsStatusCompleted, nil
	case "FAILED":
		return TenderBankAccountDetailsStatusFailed, nil
	}
	var t TenderBankAccountDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderBankAccountDetailsStatus) Ptr() *TenderBankAccountDetailsStatus {
	return &t
}

// Represents the details of a tender with `type` `BUY_NOW_PAY_LATER`.
type TenderBuyNowPayLaterDetails struct {
	// The Buy Now Pay Later brand.
	// See [Brand](#type-brand) for possible values
	BuyNowPayLaterBrand *TenderBuyNowPayLaterDetailsBrand `json:"buy_now_pay_later_brand,omitempty" url:"buy_now_pay_later_brand,omitempty"`
	// The buy now pay later payment's current state (such as `AUTHORIZED` or
	// `CAPTURED`). See [TenderBuyNowPayLaterDetailsStatus](entity:TenderBuyNowPayLaterDetailsStatus)
	// for possible values.
	// See [Status](#type-status) for possible values
	Status *TenderBuyNowPayLaterDetailsStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TenderBuyNowPayLaterDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderBuyNowPayLaterDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderBuyNowPayLaterDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderBuyNowPayLaterDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderBuyNowPayLaterDetails) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TenderBuyNowPayLaterDetailsBrand string

const (
	TenderBuyNowPayLaterDetailsBrandOtherBrand TenderBuyNowPayLaterDetailsBrand = "OTHER_BRAND"
	TenderBuyNowPayLaterDetailsBrandAfterpay   TenderBuyNowPayLaterDetailsBrand = "AFTERPAY"
)

func NewTenderBuyNowPayLaterDetailsBrandFromString(s string) (TenderBuyNowPayLaterDetailsBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return TenderBuyNowPayLaterDetailsBrandOtherBrand, nil
	case "AFTERPAY":
		return TenderBuyNowPayLaterDetailsBrandAfterpay, nil
	}
	var t TenderBuyNowPayLaterDetailsBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderBuyNowPayLaterDetailsBrand) Ptr() *TenderBuyNowPayLaterDetailsBrand {
	return &t
}

type TenderBuyNowPayLaterDetailsStatus string

const (
	TenderBuyNowPayLaterDetailsStatusAuthorized TenderBuyNowPayLaterDetailsStatus = "AUTHORIZED"
	TenderBuyNowPayLaterDetailsStatusCaptured   TenderBuyNowPayLaterDetailsStatus = "CAPTURED"
	TenderBuyNowPayLaterDetailsStatusVoided     TenderBuyNowPayLaterDetailsStatus = "VOIDED"
	TenderBuyNowPayLaterDetailsStatusFailed     TenderBuyNowPayLaterDetailsStatus = "FAILED"
)

func NewTenderBuyNowPayLaterDetailsStatusFromString(s string) (TenderBuyNowPayLaterDetailsStatus, error) {
	switch s {
	case "AUTHORIZED":
		return TenderBuyNowPayLaterDetailsStatusAuthorized, nil
	case "CAPTURED":
		return TenderBuyNowPayLaterDetailsStatusCaptured, nil
	case "VOIDED":
		return TenderBuyNowPayLaterDetailsStatusVoided, nil
	case "FAILED":
		return TenderBuyNowPayLaterDetailsStatusFailed, nil
	}
	var t TenderBuyNowPayLaterDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderBuyNowPayLaterDetailsStatus) Ptr() *TenderBuyNowPayLaterDetailsStatus {
	return &t
}

// Represents additional details of a tender with `type` `CARD` or `SQUARE_GIFT_CARD`
type TenderCardDetails struct {
	// The credit card payment's current state (such as `AUTHORIZED` or
	// `CAPTURED`). See [TenderCardDetailsStatus](entity:TenderCardDetailsStatus)
	// for possible values.
	// See [TenderCardDetailsStatus](#type-tendercarddetailsstatus) for possible values
	Status *TenderCardDetailsStatus `json:"status,omitempty" url:"status,omitempty"`
	// The credit card's non-confidential details.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`
	// The method used to enter the card's details for the transaction.
	// See [TenderCardDetailsEntryMethod](#type-tendercarddetailsentrymethod) for possible values
	EntryMethod *TenderCardDetailsEntryMethod `json:"entry_method,omitempty" url:"entry_method,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TenderCardDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderCardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderCardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderCardDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderCardDetails) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the method used to enter the card's details.
type TenderCardDetailsEntryMethod string

const (
	TenderCardDetailsEntryMethodSwiped      TenderCardDetailsEntryMethod = "SWIPED"
	TenderCardDetailsEntryMethodKeyed       TenderCardDetailsEntryMethod = "KEYED"
	TenderCardDetailsEntryMethodEmv         TenderCardDetailsEntryMethod = "EMV"
	TenderCardDetailsEntryMethodOnFile      TenderCardDetailsEntryMethod = "ON_FILE"
	TenderCardDetailsEntryMethodContactless TenderCardDetailsEntryMethod = "CONTACTLESS"
)

func NewTenderCardDetailsEntryMethodFromString(s string) (TenderCardDetailsEntryMethod, error) {
	switch s {
	case "SWIPED":
		return TenderCardDetailsEntryMethodSwiped, nil
	case "KEYED":
		return TenderCardDetailsEntryMethodKeyed, nil
	case "EMV":
		return TenderCardDetailsEntryMethodEmv, nil
	case "ON_FILE":
		return TenderCardDetailsEntryMethodOnFile, nil
	case "CONTACTLESS":
		return TenderCardDetailsEntryMethodContactless, nil
	}
	var t TenderCardDetailsEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderCardDetailsEntryMethod) Ptr() *TenderCardDetailsEntryMethod {
	return &t
}

// Indicates the card transaction's current status.
type TenderCardDetailsStatus string

const (
	TenderCardDetailsStatusAuthorized TenderCardDetailsStatus = "AUTHORIZED"
	TenderCardDetailsStatusCaptured   TenderCardDetailsStatus = "CAPTURED"
	TenderCardDetailsStatusVoided     TenderCardDetailsStatus = "VOIDED"
	TenderCardDetailsStatusFailed     TenderCardDetailsStatus = "FAILED"
)

func NewTenderCardDetailsStatusFromString(s string) (TenderCardDetailsStatus, error) {
	switch s {
	case "AUTHORIZED":
		return TenderCardDetailsStatusAuthorized, nil
	case "CAPTURED":
		return TenderCardDetailsStatusCaptured, nil
	case "VOIDED":
		return TenderCardDetailsStatusVoided, nil
	case "FAILED":
		return TenderCardDetailsStatusFailed, nil
	}
	var t TenderCardDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderCardDetailsStatus) Ptr() *TenderCardDetailsStatus {
	return &t
}

// Represents the details of a tender with `type` `CASH`.
type TenderCashDetails struct {
	// The total amount of cash provided by the buyer, before change is given.
	BuyerTenderedMoney *Money `json:"buyer_tendered_money,omitempty" url:"buyer_tendered_money,omitempty"`
	// The amount of change returned to the buyer.
	ChangeBackMoney *Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TenderCashDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderCashDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderCashDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderCashDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderCashDetails) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents the details of a tender with `type` `SQUARE_ACCOUNT`.
type TenderSquareAccountDetails struct {
	// The Square Account payment's current state (such as `AUTHORIZED` or
	// `CAPTURED`). See [TenderSquareAccountDetailsStatus](entity:TenderSquareAccountDetailsStatus)
	// for possible values.
	// See [Status](#type-status) for possible values
	Status *TenderSquareAccountDetailsStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TenderSquareAccountDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderSquareAccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderSquareAccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderSquareAccountDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderSquareAccountDetails) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TenderSquareAccountDetailsStatus string

const (
	TenderSquareAccountDetailsStatusAuthorized TenderSquareAccountDetailsStatus = "AUTHORIZED"
	TenderSquareAccountDetailsStatusCaptured   TenderSquareAccountDetailsStatus = "CAPTURED"
	TenderSquareAccountDetailsStatusVoided     TenderSquareAccountDetailsStatus = "VOIDED"
	TenderSquareAccountDetailsStatusFailed     TenderSquareAccountDetailsStatus = "FAILED"
)

func NewTenderSquareAccountDetailsStatusFromString(s string) (TenderSquareAccountDetailsStatus, error) {
	switch s {
	case "AUTHORIZED":
		return TenderSquareAccountDetailsStatusAuthorized, nil
	case "CAPTURED":
		return TenderSquareAccountDetailsStatusCaptured, nil
	case "VOIDED":
		return TenderSquareAccountDetailsStatusVoided, nil
	case "FAILED":
		return TenderSquareAccountDetailsStatusFailed, nil
	}
	var t TenderSquareAccountDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderSquareAccountDetailsStatus) Ptr() *TenderSquareAccountDetailsStatus {
	return &t
}

// Indicates a tender's type.
type TenderType string

const (
	TenderTypeCard           TenderType = "CARD"
	TenderTypeCash           TenderType = "CASH"
	TenderTypeThirdPartyCard TenderType = "THIRD_PARTY_CARD"
	TenderTypeSquareGiftCard TenderType = "SQUARE_GIFT_CARD"
	TenderTypeNoSale         TenderType = "NO_SALE"
	TenderTypeBankAccount    TenderType = "BANK_ACCOUNT"
	TenderTypeWallet         TenderType = "WALLET"
	TenderTypeBuyNowPayLater TenderType = "BUY_NOW_PAY_LATER"
	TenderTypeSquareAccount  TenderType = "SQUARE_ACCOUNT"
	TenderTypeOther          TenderType = "OTHER"
)

func NewTenderTypeFromString(s string) (TenderType, error) {
	switch s {
	case "CARD":
		return TenderTypeCard, nil
	case "CASH":
		return TenderTypeCash, nil
	case "THIRD_PARTY_CARD":
		return TenderTypeThirdPartyCard, nil
	case "SQUARE_GIFT_CARD":
		return TenderTypeSquareGiftCard, nil
	case "NO_SALE":
		return TenderTypeNoSale, nil
	case "BANK_ACCOUNT":
		return TenderTypeBankAccount, nil
	case "WALLET":
		return TenderTypeWallet, nil
	case "BUY_NOW_PAY_LATER":
		return TenderTypeBuyNowPayLater, nil
	case "SQUARE_ACCOUNT":
		return TenderTypeSquareAccount, nil
	case "OTHER":
		return TenderTypeOther, nil
	}
	var t TenderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderType) Ptr() *TenderType {
	return &t
}

// Represents an action processed by the Square Terminal.
type TerminalAction struct {
	// A unique ID for this `TerminalAction`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The unique Id of the device intended for this `TerminalAction`.
	// The Id can be retrieved from /v2/devices api.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The duration as an RFC 3339 duration, after which the action will be automatically canceled.
	// TerminalActions that are `PENDING` will be automatically `CANCELED` and have a cancellation reason
	// of `TIMED_OUT`
	//
	// Default: 5 minutes from creation
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalAction`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The reason why `TerminalAction` is canceled. Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The time when the `TerminalAction` was created as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalAction` was last updated as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the action.
	AppID *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location id the action is attached to, if a link can be made.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Represents the type of the action.
	// See [ActionType](#type-actiontype) for possible values
	Type *TerminalActionActionType `json:"type,omitempty" url:"type,omitempty"`
	// Describes configuration for the QR code action. Requires `QR_CODE` type.
	QrCodeOptions *QrCodeOptions `json:"qr_code_options,omitempty" url:"qr_code_options,omitempty"`
	// Describes configuration for the save-card action. Requires `SAVE_CARD` type.
	SaveCardOptions *SaveCardOptions `json:"save_card_options,omitempty" url:"save_card_options,omitempty"`
	// Describes configuration for the signature capture action. Requires `SIGNATURE` type.
	SignatureOptions *SignatureOptions `json:"signature_options,omitempty" url:"signature_options,omitempty"`
	// Describes configuration for the confirmation action. Requires `CONFIRMATION` type.
	ConfirmationOptions *ConfirmationOptions `json:"confirmation_options,omitempty" url:"confirmation_options,omitempty"`
	// Describes configuration for the receipt action. Requires `RECEIPT` type.
	ReceiptOptions *ReceiptOptions `json:"receipt_options,omitempty" url:"receipt_options,omitempty"`
	// Describes configuration for the data collection action. Requires `DATA_COLLECTION` type.
	DataCollectionOptions *DataCollectionOptions `json:"data_collection_options,omitempty" url:"data_collection_options,omitempty"`
	// Describes configuration for the select action. Requires `SELECT` type.
	SelectOptions *SelectOptions `json:"select_options,omitempty" url:"select_options,omitempty"`
	// Details about the Terminal that received the action request (such as battery level,
	// operating system version, and network connection settings).
	//
	// Only available for `PING` action type.
	DeviceMetadata *DeviceMetadata `json:"device_metadata,omitempty" url:"device_metadata,omitempty"`
	// Indicates the action will be linked to another action and requires a waiting dialog to be
	// displayed instead of returning to the idle screen on completion of the action.
	//
	// Only supported on SIGNATURE, CONFIRMATION, DATA_COLLECTION, and SELECT types.
	AwaitNextAction *bool `json:"await_next_action,omitempty" url:"await_next_action,omitempty"`
	// The timeout duration of the waiting dialog as an RFC 3339 duration, after which the
	// waiting dialog will no longer be displayed and the Terminal will return to the idle screen.
	//
	// Default: 5 minutes from when the waiting dialog is displayed
	//
	// Maximum: 5 minutes
	AwaitNextActionDuration *string `json:"await_next_action_duration,omitempty" url:"await_next_action_duration,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalAction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalAction) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalAction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalAction) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type TerminalActionActionType string

const (
	TerminalActionActionTypeQrCode         TerminalActionActionType = "QR_CODE"
	TerminalActionActionTypePing           TerminalActionActionType = "PING"
	TerminalActionActionTypeSaveCard       TerminalActionActionType = "SAVE_CARD"
	TerminalActionActionTypeSignature      TerminalActionActionType = "SIGNATURE"
	TerminalActionActionTypeConfirmation   TerminalActionActionType = "CONFIRMATION"
	TerminalActionActionTypeReceipt        TerminalActionActionType = "RECEIPT"
	TerminalActionActionTypeDataCollection TerminalActionActionType = "DATA_COLLECTION"
	TerminalActionActionTypeSelect         TerminalActionActionType = "SELECT"
)

func NewTerminalActionActionTypeFromString(s string) (TerminalActionActionType, error) {
	switch s {
	case "QR_CODE":
		return TerminalActionActionTypeQrCode, nil
	case "PING":
		return TerminalActionActionTypePing, nil
	case "SAVE_CARD":
		return TerminalActionActionTypeSaveCard, nil
	case "SIGNATURE":
		return TerminalActionActionTypeSignature, nil
	case "CONFIRMATION":
		return TerminalActionActionTypeConfirmation, nil
	case "RECEIPT":
		return TerminalActionActionTypeReceipt, nil
	case "DATA_COLLECTION":
		return TerminalActionActionTypeDataCollection, nil
	case "SELECT":
		return TerminalActionActionTypeSelect, nil
	}
	var t TerminalActionActionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TerminalActionActionType) Ptr() *TerminalActionActionType {
	return &t
}

type TerminalActionQuery struct {
	// Options for filtering returned `TerminalAction`s
	Filter *TerminalActionQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Option for sorting returned `TerminalAction` objects.
	Sort *TerminalActionQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQuery) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQueryFilter struct {
	// `TerminalAction`s associated with a specific device. If no device is specified then all
	// `TerminalAction`s for the merchant will be displayed.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// Time range for the beginning of the reporting period. Inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalAction`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filter results with the desired status of the `TerminalAction`
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Filter results with the requested ActionType.
	// See [TerminalActionActionType](#type-terminalactionactiontype) for possible values
	Type *TerminalActionActionType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQueryFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQueryFilter) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQuerySort struct {
	// The order in which results are listed.
	//
	//   - `ASC` - Oldest to newest.
	//   - `DESC` - Newest to oldest (default).
	//     See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalActionQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQuerySort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQuerySort) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a checkout processed by the Square Terminal.
type TerminalCheckout struct {
	// A unique ID for this `TerminalCheckout`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The amount of money (including the tax amount) that the Square Terminal device should try to collect.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// An optional user-defined reference ID that can be used to associate
	// this `TerminalCheckout` to another entity in an external system. For example, an order
	// ID generated by a third-party shopping cart. The ID is also associated with any payments
	// used to complete the checkout.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// An optional note to associate with the checkout, as well as with any payments used to complete the checkout.
	// Note: maximum 500 characters
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The reference to the Square order ID for the checkout request. Supported only in the US.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// Payment-specific options for the checkout request. Supported only in the US.
	PaymentOptions *PaymentOptions `json:"payment_options,omitempty" url:"payment_options,omitempty"`
	// Options to control the display and behavior of the Square Terminal device.
	DeviceOptions *DeviceCheckoutOptions `json:"device_options,omitempty" url:"device_options,omitempty"`
	// An RFC 3339 duration, after which the checkout is automatically canceled.
	// A `TerminalCheckout` that is `PENDING` is automatically `CANCELED` and has a cancellation reason
	// of `TIMED_OUT`.
	//
	// Default: 5 minutes from creation
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalCheckout`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The reason why `TerminalCheckout` is canceled. Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// A list of IDs for payments created by this `TerminalCheckout`.
	PaymentIDs []string `json:"payment_ids,omitempty" url:"payment_ids,omitempty"`
	// The time when the `TerminalCheckout` was created, as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalCheckout` was last updated, as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the checkout.
	AppID *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location of the device where the `TerminalCheckout` was directed.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of payment the terminal should attempt to capture from. Defaults to `CARD_PRESENT`.
	// See [CheckoutOptionsPaymentType](#type-checkoutoptionspaymenttype) for possible values
	PaymentType *CheckoutOptionsPaymentType `json:"payment_type,omitempty" url:"payment_type,omitempty"`
	// An optional ID of the team member associated with creating the checkout.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// An optional ID of the customer associated with the checkout.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The amount the developer is taking as a fee for facilitating the payment on behalf
	// of the seller.
	//
	// The amount cannot be more than 90% of the total amount of the payment.
	//
	// The amount must be specified in the smallest denomination of the applicable currency (for example, US dollar amounts are specified in cents). For more information, see [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	//
	// The fee currency code must match the currency associated with the seller that is accepting the payment. The application must be from a developer account in the same country and using the same currency code as the seller.
	//
	// For more information about the application fee scenario, see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// To set this field, PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS OAuth permission is required. For more information, see [Permissions](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees#permissions).
	//
	// Supported only in the US.
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// Optional additional payment information to include on the customer's card statement as
	// part of the statement description. This can be, for example, an invoice number, ticket number,
	// or short description that uniquely identifies the purchase. Supported only in the US.
	StatementDescriptionIdentifier *string `json:"statement_description_identifier,omitempty" url:"statement_description_identifier,omitempty"`
	// The amount designated as a tip, in addition to `amount_money`. This may only be set for a
	// checkout that has tipping disabled (`tip_settings.allow_tipping` is `false`). Supported only in
	// the US.
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckout) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckout) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckout) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQuery struct {
	// Options for filtering returned `TerminalCheckout` objects.
	Filter *TerminalCheckoutQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Option for sorting returned `TerminalCheckout` objects.
	Sort *TerminalCheckoutQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQuery) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQueryFilter struct {
	// The `TerminalCheckout` objects associated with a specific device. If no device is specified, then all
	// `TerminalCheckout` objects for the merchant are displayed.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The time range for the beginning of the reporting period, which is inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalCheckout`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filtered results with the desired status of the `TerminalCheckout`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQueryFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQueryFilter) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQuerySort struct {
	// The order in which results are listed.
	// Default: `DESC`
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalCheckoutQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQuerySort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQuerySort) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a payment refund processed by the Square Terminal. Only supports Interac (Canadian debit network) payment refunds.
type TerminalRefund struct {
	// A unique ID for this `TerminalRefund`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The reference to the payment refund created by completing this `TerminalRefund`.
	RefundID *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`
	// The unique ID of the payment being refunded.
	PaymentID string `json:"payment_id" url:"payment_id"`
	// The reference to the Square order ID for the payment identified by the `payment_id`.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The amount of money, inclusive of `tax_money`, that the `TerminalRefund` should return.
	// This value is limited to the amount taken in the original payment minus any completed or
	// pending refunds.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A description of the reason for the refund.
	Reason string `json:"reason" url:"reason"`
	// The unique ID of the device intended for this `TerminalRefund`.
	// The Id can be retrieved from /v2/devices api.
	DeviceID string `json:"device_id" url:"device_id"`
	// The RFC 3339 duration, after which the refund is automatically canceled.
	// A `TerminalRefund` that is `PENDING` is automatically `CANCELED` and has a cancellation reason
	// of `TIMED_OUT`.
	//
	// Default: 5 minutes from creation.
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalRefund`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, or `COMPLETED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The time when the `TerminalRefund` was created, as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalRefund` was last updated, as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the refund.
	AppID *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location of the device where the `TerminalRefund` was directed.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefund) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefund) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQuery struct {
	// The filter for the Terminal refund query.
	Filter *TerminalRefundQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// The sort order for the Terminal refund query.
	Sort *TerminalRefundQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQuery) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQueryFilter struct {
	// `TerminalRefund` objects associated with a specific device. If no device is specified, then all
	// `TerminalRefund` objects for the signed-in account are displayed.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The timestamp for the beginning of the reporting period, in RFC 3339 format. Inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalRefund`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filtered results with the desired status of the `TerminalRefund`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, or `COMPLETED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQueryFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQueryFilter) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQuerySort struct {
	// The order in which results are listed.
	//
	// - `ASC` - Oldest to newest.
	// - `DESC` - Newest to oldest (default).
	SortOrder *string `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TerminalRefundQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQuerySort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQuerySort) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines the fields that are included in the response body of
// a request to the [TestWebhookSubscription]($e/WebhookSubscriptions/TestWebhookSubscription) endpoint.
//
// Note: If there are errors processing the request, the [SubscriptionTestResult]($m/SubscriptionTestResult) field is not
// present.
type TestWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The [SubscriptionTestResult](entity:SubscriptionTestResult).
	SubscriptionTestResult *SubscriptionTestResult `json:"subscription_test_result,omitempty" url:"subscription_test_result,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TestWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TestWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TestWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestWebhookSubscriptionResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a generic time range. The start and end values are
// represented in RFC 3339 format. Time ranges are customized to be
// inclusive or exclusive based on the needs of a particular endpoint.
// Refer to the relevant endpoint-specific documentation to determine
// how time ranges are handled.
type TimeRange struct {
	// A datetime value in RFC 3339 format indicating when the time range
	// starts.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// A datetime value in RFC 3339 format indicating when the time range
	// ends.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TipSettings struct {
	// Indicates whether tipping is enabled for this checkout. Defaults to false.
	AllowTipping *bool `json:"allow_tipping,omitempty" url:"allow_tipping,omitempty"`
	// Indicates whether tip options should be presented on the screen before presenting
	// the signature screen during card payment. Defaults to false.
	SeparateTipScreen *bool `json:"separate_tip_screen,omitempty" url:"separate_tip_screen,omitempty"`
	// Indicates whether custom tip amounts are allowed during the checkout flow. Defaults to false.
	CustomTipField *bool `json:"custom_tip_field,omitempty" url:"custom_tip_field,omitempty"`
	// A list of tip percentages that should be presented during the checkout flow, specified as
	// up to 3 non-negative integers from 0 to 100 (inclusive). Defaults to 15, 20, and 25.
	TipPercentages []int `json:"tip_percentages,omitempty" url:"tip_percentages,omitempty"`
	// Enables the "Smart Tip Amounts" behavior.
	// Exact tipping options depend on the region in which the Square seller is active.
	//
	// For payments under 10.00, in the Australia, Canada, Ireland, United Kingdom, and United States, tipping options are presented as no tip, .50, 1.00 or 2.00.
	//
	// For payment amounts of 10.00 or greater, tipping options are presented as the following percentages: 0%, 5%, 10%, 15%.
	//
	// If set to true, the `tip_percentages` settings is ignored.
	// Defaults to false.
	//
	// To learn more about smart tipping, see [Accept Tips with the Square App](https://squareup.com/help/us/en/article/5069-accept-tips-with-the-square-app).
	SmartTipping *bool `json:"smart_tipping,omitempty" url:"smart_tipping,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TipSettings) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TipSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler TipSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TipSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TipSettings) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a transaction processed with Square, either with the
// Connect API or with Square Point of Sale.
//
// The `tenders` field of this object lists all methods of payment used to pay in
// the transaction.
type Transaction struct {
	// The transaction's unique ID, issued by Square payments servers.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the transaction's associated location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The timestamp for when the transaction was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The tenders used to pay in the transaction.
	Tenders []*Tender `json:"tenders,omitempty" url:"tenders,omitempty"`
	// Refunds that have been applied to any tender in the transaction.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// If the transaction was created with the [Charge](api-endpoint:Transactions-Charge)
	// endpoint, this value is the same as the value provided for the `reference_id`
	// parameter in the request to that endpoint. Otherwise, it is not set.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The Square product that processed the transaction.
	// See [TransactionProduct](#type-transactionproduct) for possible values
	Product *TransactionProduct `json:"product,omitempty" url:"product,omitempty"`
	// If the transaction was created in the Square Point of Sale app, this value
	// is the ID generated for the transaction by Square Point of Sale.
	//
	// This ID has no relationship to the transaction's canonical `id`, which is
	// generated by Square's backend servers. This value is generated for bookkeeping
	// purposes, in case the transaction cannot immediately be completed (for example,
	// if the transaction is processed in offline mode).
	//
	// It is not currently possible with the Connect API to perform a transaction
	// lookup by this value.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The shipping address provided in the request, if any.
	ShippingAddress *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// The order_id is an identifier for the order associated with this transaction, if any.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Transaction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Transaction) UnmarshalJSON(data []byte) error {
	type unmarshaler Transaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Transaction(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transaction) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the Square product used to process a transaction.
type TransactionProduct string

const (
	TransactionProductRegister     TransactionProduct = "REGISTER"
	TransactionProductExternalAPI  TransactionProduct = "EXTERNAL_API"
	TransactionProductBilling      TransactionProduct = "BILLING"
	TransactionProductAppointments TransactionProduct = "APPOINTMENTS"
	TransactionProductInvoices     TransactionProduct = "INVOICES"
	TransactionProductOnlineStore  TransactionProduct = "ONLINE_STORE"
	TransactionProductPayroll      TransactionProduct = "PAYROLL"
	TransactionProductOther        TransactionProduct = "OTHER"
)

func NewTransactionProductFromString(s string) (TransactionProduct, error) {
	switch s {
	case "REGISTER":
		return TransactionProductRegister, nil
	case "EXTERNAL_API":
		return TransactionProductExternalAPI, nil
	case "BILLING":
		return TransactionProductBilling, nil
	case "APPOINTMENTS":
		return TransactionProductAppointments, nil
	case "INVOICES":
		return TransactionProductInvoices, nil
	case "ONLINE_STORE":
		return TransactionProductOnlineStore, nil
	case "PAYROLL":
		return TransactionProductPayroll, nil
	case "OTHER":
		return TransactionProductOther, nil
	}
	var t TransactionProduct
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionProduct) Ptr() *TransactionProduct {
	return &t
}

// The transaction type used in the disputed payment.
type TransactionType string

const (
	TransactionTypeDebit  TransactionType = "DEBIT"
	TransactionTypeCredit TransactionType = "CREDIT"
)

func NewTransactionTypeFromString(s string) (TransactionType, error) {
	switch s {
	case "DEBIT":
		return TransactionTypeDebit, nil
	case "CREDIT":
		return TransactionTypeCredit, nil
	}
	var t TransactionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionType) Ptr() *TransactionType {
	return &t
}

// A response that contains the unlinked `GiftCard` object. If the request resulted in errors,
// the response contains a set of `Error` objects.
type UnlinkCustomerFromGiftCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The gift card with the ID of the unlinked customer removed from the `customer_ids` field.
	// If no other customers are linked, the `customer_ids` field is also removed.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UnlinkCustomerFromGiftCardResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UnlinkCustomerFromGiftCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UnlinkCustomerFromGiftCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UnlinkCustomerFromGiftCardResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UnlinkCustomerFromGiftCardResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpdateBookingCustomAttributeDefinition]($e/BookingCustomAttributes/UpdateBookingCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateBookingCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBookingCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateBookingResponse struct {
	// The booking that was updated.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateBookingResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBookingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBookingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBookingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBookingResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// A response to a request to update a `BreakType`. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateBreakTypeResponse struct {
	// The response object.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBreakTypeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBreakTypeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCatalogImageRequest struct {
	// A unique string that identifies this UpdateCatalogImage request.
	// Keys can be any valid string but must be unique for every UpdateCatalogImage request.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCatalogImageRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCatalogImageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCatalogImageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCatalogImageRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCatalogImageRequest) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCatalogImageResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly updated `CatalogImage` including a Square-generated
	// URL for the encapsulated image file.
	Image *CatalogObject `json:"image,omitempty" url:"image,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCatalogImageResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCatalogImageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCatalogImageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCatalogImageResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCatalogImageResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpdateCustomerCustomAttributeDefinition]($e/CustomerCustomAttributes/UpdateCustomerCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateCustomerCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomerCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateCustomerGroup]($e/CustomerGroups/UpdateCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type UpdateCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully updated customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomerGroupResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomerGroupResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateCustomer]($e/Customers/UpdateCustomer) or
// [BulkUpdateCustomers]($e/Customers/BulkUpdateCustomers) endpoint.
//
// Either `errors` or `customer` is present in a given response (never both).
type UpdateCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCustomerResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomerResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Describes a `UpdateInvoice` response.
type UpdateInvoiceResponse struct {
	// The updated invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateInvoiceResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateInvoiceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateInvoiceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateInvoiceResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateInvoiceResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateItemModifierListsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/common-data-types/working-with-dates) of this update in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateItemModifierListsResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateItemModifierListsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateItemModifierListsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateItemModifierListsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateItemModifierListsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateItemTaxesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) of this update in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateItemTaxesResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateItemTaxesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateItemTaxesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateItemTaxesResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateItemTaxesResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpdateLocationCustomAttributeDefinition]($e/LocationCustomAttributes/UpdateLocationCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateLocationCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLocationCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response object returned by the [UpdateLocation]($e/Locations/UpdateLocation) endpoint.
type UpdateLocationResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated `Location` object.
	Location *Location `json:"location,omitempty" url:"location,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateLocationResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLocationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLocationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLocationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLocationResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateLocationSettingsResponse struct {
	// Any errors that occurred when updating the location settings.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated location settings.
	LocationSettings *CheckoutLocationSettings `json:"location_settings,omitempty" url:"location_settings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateLocationSettingsResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLocationSettingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLocationSettingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLocationSettingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLocationSettingsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpdateMerchantCustomAttributeDefinition]($e/MerchantCustomAttributes/UpdateMerchantCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateMerchantCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMerchantCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateMerchantSettingsResponse struct {
	// Any errors that occurred when updating the merchant settings.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated merchant settings.
	MerchantSettings *CheckoutMerchantSettings `json:"merchant_settings,omitempty" url:"merchant_settings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateMerchantSettingsResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMerchantSettingsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMerchantSettingsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMerchantSettingsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMerchantSettingsResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from updating an order custom attribute definition.
type UpdateOrderCustomAttributeDefinitionResponse struct {
	// The updated order custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrderCustomAttributeDefinitionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateOrder]($e/Orders/UpdateOrder) endpoint.
type UpdateOrderResponse struct {
	// The updated order.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateOrderResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrderResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePaymentLinkResponse struct {
	// Any errors that occurred when updating the payment link.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated payment link.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdatePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePaymentLinkResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePaymentLinkResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the response returned by
// [UpdatePayment]($e/Payments/UpdatePayment).
type UpdatePaymentResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated payment.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdatePaymentResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePaymentResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response to a request to update a `Shift`. The response contains
// the updated `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateShiftResponse struct {
	// The updated `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateShiftResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateShiftResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateShiftResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines output parameters in a response from the
// [UpdateSubscription]($e/Subscriptions/UpdateSubscription) endpoint.
type UpdateSubscriptionResponse struct {
	// Errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateSubscriptionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an update request for a `TeamMember` object.
type UpdateTeamMemberRequest struct {
	// The data used to update the `TeamMember` object.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateTeamMemberRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTeamMemberRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTeamMemberRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTeamMemberRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTeamMemberRequest) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from an update request containing the updated `TeamMember` object or error messages.
type UpdateTeamMemberResponse struct {
	// The successfully updated `TeamMember` object.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateTeamMemberResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTeamMemberResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTeamMemberResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTeamMemberResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTeamMemberResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an input to a call to [UpdateVendor]($e/Vendors/UpdateVendor).
type UpdateVendorRequest struct {
	// A client-supplied, universally unique identifier (UUID) for the
	// request.
	//
	// See [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) in the
	// [API Development 101](https://developer.squareup.com/docs/buildbasics) section for more
	// information.
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`
	// The specified [Vendor](entity:Vendor) to be updated.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateVendorRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateVendorRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateVendorRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateVendorRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateVendorRequest) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an output from a call to [UpdateVendor]($e/Vendors/UpdateVendor).
type UpdateVendorResponse struct {
	// Errors occurred when the request fails.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The [Vendor](entity:Vendor) that has been updated.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateVendorResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateVendorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateVendorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateVendorResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateVendorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from an update request containing the updated `WageSetting` object
// or error messages.
type UpdateWageSettingResponse struct {
	// The successfully updated `WageSetting` object.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWageSettingResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWageSettingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWageSettingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWageSettingResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWageSettingResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateWebhookSubscription]($e/WebhookSubscriptions/UpdateWebhookSubscription) endpoint.
//
// Note: If there are errors processing the request, the [Subscription]($m/WebhookSubscription) is not
// present.
type UpdateWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWebhookSubscriptionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWebhookSubscriptionResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateWebhookSubscriptionSignatureKey]($e/WebhookSubscriptions/UpdateWebhookSubscriptionSignatureKey) endpoint.
//
// Note: If there are errors processing the request, the [Subscription]($m/WebhookSubscription) is not
// present.
type UpdateWebhookSubscriptionSignatureKeyResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new Square-generated signature key used to validate the origin of the webhook event.
	SignatureKey *string `json:"signature_key,omitempty" url:"signature_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWebhookSubscriptionSignatureKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWebhookSubscriptionSignatureKeyResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response to a request to update a `WorkweekConfig` object. The response contains
// the updated `WorkweekConfig` object and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateWorkweekConfigResponse struct {
	// The response object.
	WorkweekConfig *WorkweekConfig `json:"workweek_config,omitempty" url:"workweek_config,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateWorkweekConfigResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWorkweekConfigResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWorkweekConfigResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWorkweekConfigResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWorkweekConfigResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertBookingCustomAttribute]($e/BookingCustomAttributes/UpsertBookingCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertBookingCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertBookingCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBookingCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBookingCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBookingCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBookingCustomAttributeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created or updated CatalogObject.
	CatalogObject *CatalogObject `json:"catalog_object,omitempty" url:"catalog_object,omitempty"`
	// The mapping between client and server IDs for this upsert.
	IDMappings []*CatalogIDMapping `json:"id_mappings,omitempty" url:"id_mappings,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertCatalogObjectResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertCustomerCustomAttribute]($e/CustomerCustomAttributes/UpsertCustomerCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertCustomerCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertCustomerCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertCustomerCustomAttributeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertLocationCustomAttribute]($e/LocationCustomAttributes/UpsertLocationCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertLocationCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertLocationCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertLocationCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertLocationCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertLocationCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertLocationCustomAttributeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertMerchantCustomAttribute]($e/MerchantCustomAttributes/UpsertMerchantCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertMerchantCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertMerchantCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertMerchantCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertMerchantCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertMerchantCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertMerchantCustomAttributeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from upserting order custom attribute definitions.
type UpsertOrderCustomAttributeResponse struct {
	// The order custom attribute that was created or modified.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertOrderCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertOrderCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertOrderCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertOrderCustomAttributeResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertOrderCustomAttributeResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an `UpsertSnippet` response. The response can include either `snippet` or `errors`.
type UpsertSnippetResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new or updated snippet.
	Snippet *Snippet `json:"snippet,omitempty" url:"snippet,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpsertSnippetResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertSnippetResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertSnippetResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertSnippetResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertSnippetResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type V1Device struct {
	// The device's Square-issued ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The device's merchant-specified name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Device) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Device) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Device
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Device(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Device) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1GetPaymentRequest = interface{}

type V1GetSettlementRequest = interface{}

type V1ListOrdersResponse struct {
	Items []*V1Order `json:"items,omitempty" url:"items,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1ListOrdersResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1ListOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V1ListOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1ListOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1ListOrdersResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1Money struct {
	// Amount in the lowest denominated value of this Currency. E.g. in USD
	// these are cents, in JPY they are Yen (which do not have a 'cent' concept).
	Amount *int `json:"amount,omitempty" url:"amount,omitempty"`
	// See [Currency](#type-currency) for possible values
	CurrencyCode *Currency `json:"currency_code,omitempty" url:"currency_code,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Money) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Money) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Money
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Money(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Money) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1Order
type V1Order struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The order's unique identifier.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The email address of the order's buyer.
	BuyerEmail *string `json:"buyer_email,omitempty" url:"buyer_email,omitempty"`
	// The name of the order's buyer.
	RecipientName *string `json:"recipient_name,omitempty" url:"recipient_name,omitempty"`
	// The phone number to use for the order's delivery.
	RecipientPhoneNumber *string `json:"recipient_phone_number,omitempty" url:"recipient_phone_number,omitempty"`
	// Whether the tax is an ADDITIVE tax or an INCLUSIVE tax.
	// See [V1OrderState](#type-v1orderstate) for possible values
	State *V1OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The address to ship the order to.
	ShippingAddress *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// The amount of all items purchased in the order, before taxes and shipping.
	SubtotalMoney *V1Money `json:"subtotal_money,omitempty" url:"subtotal_money,omitempty"`
	// The shipping cost for the order.
	TotalShippingMoney *V1Money `json:"total_shipping_money,omitempty" url:"total_shipping_money,omitempty"`
	// The total of all taxes applied to the order.
	TotalTaxMoney *V1Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total cost of the order.
	TotalPriceMoney *V1Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// The total of all discounts applied to the order.
	TotalDiscountMoney *V1Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The time when the order was created, in ISO 8601 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the order was last modified, in ISO 8601 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The time when the order expires if no action is taken, in ISO 8601 format.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The unique identifier of the payment associated with the order.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// A note provided by the buyer when the order was created, if any.
	BuyerNote *string `json:"buyer_note,omitempty" url:"buyer_note,omitempty"`
	// A note provided by the merchant when the order's state was set to COMPLETED, if any
	CompletedNote *string `json:"completed_note,omitempty" url:"completed_note,omitempty"`
	// A note provided by the merchant when the order's state was set to REFUNDED, if any.
	RefundedNote *string `json:"refunded_note,omitempty" url:"refunded_note,omitempty"`
	// A note provided by the merchant when the order's state was set to CANCELED, if any.
	CanceledNote *string `json:"canceled_note,omitempty" url:"canceled_note,omitempty"`
	// The tender used to pay for the order.
	Tender *V1Tender `json:"tender,omitempty" url:"tender,omitempty"`
	// The history of actions associated with the order.
	OrderHistory []*V1OrderHistoryEntry `json:"order_history,omitempty" url:"order_history,omitempty"`
	// The promo code provided by the buyer, if any.
	PromoCode *string `json:"promo_code,omitempty" url:"promo_code,omitempty"`
	// For Bitcoin transactions, the address that the buyer sent Bitcoin to.
	BtcReceiveAddress *string `json:"btc_receive_address,omitempty" url:"btc_receive_address,omitempty"`
	// For Bitcoin transactions, the price of the buyer's order in satoshi (100 million satoshi equals 1 BTC).
	BtcPriceSatoshi *float64 `json:"btc_price_satoshi,omitempty" url:"btc_price_satoshi,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Order) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Order) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Order
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Order(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Order) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// V1OrderHistoryEntry
type V1OrderHistoryEntry struct {
	// The type of action performed on the order.
	// See [V1OrderHistoryEntryAction](#type-v1orderhistoryentryaction) for possible values
	Action *V1OrderHistoryEntryAction `json:"action,omitempty" url:"action,omitempty"`
	// The time when the action was performed, in ISO 8601 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1OrderHistoryEntry) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1OrderHistoryEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler V1OrderHistoryEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1OrderHistoryEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1OrderHistoryEntry) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1OrderHistoryEntryAction string

const (
	V1OrderHistoryEntryActionOrderPlaced     V1OrderHistoryEntryAction = "ORDER_PLACED"
	V1OrderHistoryEntryActionDeclined        V1OrderHistoryEntryAction = "DECLINED"
	V1OrderHistoryEntryActionPaymentReceived V1OrderHistoryEntryAction = "PAYMENT_RECEIVED"
	V1OrderHistoryEntryActionCanceled        V1OrderHistoryEntryAction = "CANCELED"
	V1OrderHistoryEntryActionCompleted       V1OrderHistoryEntryAction = "COMPLETED"
	V1OrderHistoryEntryActionRefunded        V1OrderHistoryEntryAction = "REFUNDED"
	V1OrderHistoryEntryActionExpired         V1OrderHistoryEntryAction = "EXPIRED"
)

func NewV1OrderHistoryEntryActionFromString(s string) (V1OrderHistoryEntryAction, error) {
	switch s {
	case "ORDER_PLACED":
		return V1OrderHistoryEntryActionOrderPlaced, nil
	case "DECLINED":
		return V1OrderHistoryEntryActionDeclined, nil
	case "PAYMENT_RECEIVED":
		return V1OrderHistoryEntryActionPaymentReceived, nil
	case "CANCELED":
		return V1OrderHistoryEntryActionCanceled, nil
	case "COMPLETED":
		return V1OrderHistoryEntryActionCompleted, nil
	case "REFUNDED":
		return V1OrderHistoryEntryActionRefunded, nil
	case "EXPIRED":
		return V1OrderHistoryEntryActionExpired, nil
	}
	var t V1OrderHistoryEntryAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1OrderHistoryEntryAction) Ptr() *V1OrderHistoryEntryAction {
	return &v
}

type V1OrderState string

const (
	V1OrderStatePending   V1OrderState = "PENDING"
	V1OrderStateOpen      V1OrderState = "OPEN"
	V1OrderStateCompleted V1OrderState = "COMPLETED"
	V1OrderStateCanceled  V1OrderState = "CANCELED"
	V1OrderStateRefunded  V1OrderState = "REFUNDED"
	V1OrderStateRejected  V1OrderState = "REJECTED"
)

func NewV1OrderStateFromString(s string) (V1OrderState, error) {
	switch s {
	case "PENDING":
		return V1OrderStatePending, nil
	case "OPEN":
		return V1OrderStateOpen, nil
	case "COMPLETED":
		return V1OrderStateCompleted, nil
	case "CANCELED":
		return V1OrderStateCanceled, nil
	case "REFUNDED":
		return V1OrderStateRefunded, nil
	case "REJECTED":
		return V1OrderStateRejected, nil
	}
	var t V1OrderState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1OrderState) Ptr() *V1OrderState {
	return &v
}

// Represents a phone number.
type V1PhoneNumber struct {
	// The phone number's international calling code. For US phone numbers, this value is +1.
	CallingCode string `json:"calling_code" url:"calling_code"`
	// The phone number.
	Number string `json:"number" url:"number"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1PhoneNumber) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1PhoneNumber) UnmarshalJSON(data []byte) error {
	type unmarshaler V1PhoneNumber
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1PhoneNumber(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1PhoneNumber) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V1RetrieveOrderRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1RetrieveOrderRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1RetrieveOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler V1RetrieveOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1RetrieveOrderRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1RetrieveOrderRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// A tender represents a discrete monetary exchange. Square represents this
// exchange as a money object with a specific currency and amount, where the
// amount is given in the smallest denomination of the given currency.
//
// Square POS can accept more than one form of tender for a single payment (such
// as by splitting a bill between a credit card and a gift card). The `tender`
// field of the Payment object lists all forms of tender used for the payment.
//
// Split tender payments behave slightly differently from single tender payments:
//
// The receipt_url for a split tender corresponds only to the first tender listed
// in the tender field. To get the receipt URLs for the remaining tenders, use
// the receipt_url fields of the corresponding Tender objects.
//
// \*A note on gift cards\*\*: when a customer purchases a Square gift card from a
// merchant, the merchant receives the full amount of the gift card in the
// associated payment.
//
// When that gift card is used as a tender, the balance of the gift card is
// reduced and the merchant receives no funds. A `Tender` object with a type of
// `SQUARE_GIFT_CARD` indicates a gift card was used for some or all of the
// associated payment.
type V1Tender struct {
	// The tender's unique ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of tender.
	// See [V1TenderType](#type-v1tendertype) for possible values
	Type *V1TenderType `json:"type,omitempty" url:"type,omitempty"`
	// A human-readable description of the tender.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The ID of the employee that processed the tender.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The URL of the receipt for the tender.
	ReceiptURL *string `json:"receipt_url,omitempty" url:"receipt_url,omitempty"`
	// The brand of credit card provided.
	// See [V1TenderCardBrand](#type-v1tendercardbrand) for possible values
	CardBrand *V1TenderCardBrand `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The last four digits of the provided credit card's account number.
	PanSuffix *string `json:"pan_suffix,omitempty" url:"pan_suffix,omitempty"`
	// The tender's unique ID.
	// See [V1TenderEntryMethod](#type-v1tenderentrymethod) for possible values
	EntryMethod *V1TenderEntryMethod `json:"entry_method,omitempty" url:"entry_method,omitempty"`
	// Notes entered by the merchant about the tender at the time of payment, if any. Typically only present for tender with the type: OTHER.
	PaymentNote *string `json:"payment_note,omitempty" url:"payment_note,omitempty"`
	// The total amount of money provided in this form of tender.
	TotalMoney *V1Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The amount of total_money applied to the payment.
	TenderedMoney *V1Money `json:"tendered_money,omitempty" url:"tendered_money,omitempty"`
	// The time when the tender was created, in ISO 8601 format.
	TenderedAt *string `json:"tendered_at,omitempty" url:"tendered_at,omitempty"`
	// The time when the tender was settled, in ISO 8601 format.
	SettledAt *string `json:"settled_at,omitempty" url:"settled_at,omitempty"`
	// The amount of total_money returned to the buyer as change.
	ChangeBackMoney *V1Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`
	// The total of all refunds applied to this tender. This amount is always negative or zero.
	RefundedMoney *V1Money `json:"refunded_money,omitempty" url:"refunded_money,omitempty"`
	// Indicates whether or not the tender is associated with an exchange. If is_exchange is true, the tender represents the value of goods returned in an exchange not the actual money paid. The exchange value reduces the tender amounts needed to pay for items purchased in the exchange.
	IsExchange *bool `json:"is_exchange,omitempty" url:"is_exchange,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *V1Tender) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *V1Tender) UnmarshalJSON(data []byte) error {
	type unmarshaler V1Tender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V1Tender(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V1Tender) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The brand of a credit card.
type V1TenderCardBrand string

const (
	V1TenderCardBrandOtherBrand      V1TenderCardBrand = "OTHER_BRAND"
	V1TenderCardBrandVisa            V1TenderCardBrand = "VISA"
	V1TenderCardBrandMasterCard      V1TenderCardBrand = "MASTER_CARD"
	V1TenderCardBrandAmericanExpress V1TenderCardBrand = "AMERICAN_EXPRESS"
	V1TenderCardBrandDiscover        V1TenderCardBrand = "DISCOVER"
	V1TenderCardBrandDiscoverDiners  V1TenderCardBrand = "DISCOVER_DINERS"
	V1TenderCardBrandJcb             V1TenderCardBrand = "JCB"
	V1TenderCardBrandChinaUnionpay   V1TenderCardBrand = "CHINA_UNIONPAY"
	V1TenderCardBrandSquareGiftCard  V1TenderCardBrand = "SQUARE_GIFT_CARD"
)

func NewV1TenderCardBrandFromString(s string) (V1TenderCardBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return V1TenderCardBrandOtherBrand, nil
	case "VISA":
		return V1TenderCardBrandVisa, nil
	case "MASTER_CARD":
		return V1TenderCardBrandMasterCard, nil
	case "AMERICAN_EXPRESS":
		return V1TenderCardBrandAmericanExpress, nil
	case "DISCOVER":
		return V1TenderCardBrandDiscover, nil
	case "DISCOVER_DINERS":
		return V1TenderCardBrandDiscoverDiners, nil
	case "JCB":
		return V1TenderCardBrandJcb, nil
	case "CHINA_UNIONPAY":
		return V1TenderCardBrandChinaUnionpay, nil
	case "SQUARE_GIFT_CARD":
		return V1TenderCardBrandSquareGiftCard, nil
	}
	var t V1TenderCardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1TenderCardBrand) Ptr() *V1TenderCardBrand {
	return &v
}

type V1TenderEntryMethod string

const (
	V1TenderEntryMethodManual       V1TenderEntryMethod = "MANUAL"
	V1TenderEntryMethodScanned      V1TenderEntryMethod = "SCANNED"
	V1TenderEntryMethodSquareCash   V1TenderEntryMethod = "SQUARE_CASH"
	V1TenderEntryMethodSquareWallet V1TenderEntryMethod = "SQUARE_WALLET"
	V1TenderEntryMethodSwiped       V1TenderEntryMethod = "SWIPED"
	V1TenderEntryMethodWebForm      V1TenderEntryMethod = "WEB_FORM"
	V1TenderEntryMethodOther        V1TenderEntryMethod = "OTHER"
)

func NewV1TenderEntryMethodFromString(s string) (V1TenderEntryMethod, error) {
	switch s {
	case "MANUAL":
		return V1TenderEntryMethodManual, nil
	case "SCANNED":
		return V1TenderEntryMethodScanned, nil
	case "SQUARE_CASH":
		return V1TenderEntryMethodSquareCash, nil
	case "SQUARE_WALLET":
		return V1TenderEntryMethodSquareWallet, nil
	case "SWIPED":
		return V1TenderEntryMethodSwiped, nil
	case "WEB_FORM":
		return V1TenderEntryMethodWebForm, nil
	case "OTHER":
		return V1TenderEntryMethodOther, nil
	}
	var t V1TenderEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1TenderEntryMethod) Ptr() *V1TenderEntryMethod {
	return &v
}

type V1TenderType string

const (
	V1TenderTypeCreditCard     V1TenderType = "CREDIT_CARD"
	V1TenderTypeCash           V1TenderType = "CASH"
	V1TenderTypeThirdPartyCard V1TenderType = "THIRD_PARTY_CARD"
	V1TenderTypeNoSale         V1TenderType = "NO_SALE"
	V1TenderTypeSquareWallet   V1TenderType = "SQUARE_WALLET"
	V1TenderTypeSquareGiftCard V1TenderType = "SQUARE_GIFT_CARD"
	V1TenderTypeUnknown        V1TenderType = "UNKNOWN"
	V1TenderTypeOther          V1TenderType = "OTHER"
)

func NewV1TenderTypeFromString(s string) (V1TenderType, error) {
	switch s {
	case "CREDIT_CARD":
		return V1TenderTypeCreditCard, nil
	case "CASH":
		return V1TenderTypeCash, nil
	case "THIRD_PARTY_CARD":
		return V1TenderTypeThirdPartyCard, nil
	case "NO_SALE":
		return V1TenderTypeNoSale, nil
	case "SQUARE_WALLET":
		return V1TenderTypeSquareWallet, nil
	case "SQUARE_GIFT_CARD":
		return V1TenderTypeSquareGiftCard, nil
	case "UNKNOWN":
		return V1TenderTypeUnknown, nil
	case "OTHER":
		return V1TenderTypeOther, nil
	}
	var t V1TenderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1TenderType) Ptr() *V1TenderType {
	return &v
}

type V1UpdateOrderRequestAction string

const (
	V1UpdateOrderRequestActionComplete V1UpdateOrderRequestAction = "COMPLETE"
	V1UpdateOrderRequestActionCancel   V1UpdateOrderRequestAction = "CANCEL"
	V1UpdateOrderRequestActionRefund   V1UpdateOrderRequestAction = "REFUND"
)

func NewV1UpdateOrderRequestActionFromString(s string) (V1UpdateOrderRequestAction, error) {
	switch s {
	case "COMPLETE":
		return V1UpdateOrderRequestActionComplete, nil
	case "CANCEL":
		return V1UpdateOrderRequestActionCancel, nil
	case "REFUND":
		return V1UpdateOrderRequestActionRefund, nil
	}
	var t V1UpdateOrderRequestAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V1UpdateOrderRequestAction) Ptr() *V1UpdateOrderRequestAction {
	return &v
}

// Represents a supplier to a seller.
type Vendor struct {
	// A unique Square-generated ID for the [Vendor](entity:Vendor).
	// This field is required when attempting to update a [Vendor](entity:Vendor).
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the
	// [Vendor](entity:Vendor) was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// An RFC 3339-formatted timestamp that indicates when the
	// [Vendor](entity:Vendor) was last updated.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The name of the [Vendor](entity:Vendor).
	// This field is required when attempting to create or update a [Vendor](entity:Vendor).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The address of the [Vendor](entity:Vendor).
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The contacts of the [Vendor](entity:Vendor).
	Contacts []*VendorContact `json:"contacts,omitempty" url:"contacts,omitempty"`
	// The account number of the [Vendor](entity:Vendor).
	AccountNumber *string `json:"account_number,omitempty" url:"account_number,omitempty"`
	// A note detailing information about the [Vendor](entity:Vendor).
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The version of the [Vendor](entity:Vendor).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The status of the [Vendor](entity:Vendor).
	// See [Status](#type-status) for possible values
	Status *VendorStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *Vendor) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *Vendor) UnmarshalJSON(data []byte) error {
	type unmarshaler Vendor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = Vendor(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *Vendor) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Represents a contact of a [Vendor]($m/Vendor).
type VendorContact struct {
	// A unique Square-generated ID for the [VendorContact](entity:VendorContact).
	// This field is required when attempting to update a [VendorContact](entity:VendorContact).
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the [VendorContact](entity:VendorContact).
	// This field is required when attempting to create a [Vendor](entity:Vendor).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The email address of the [VendorContact](entity:VendorContact).
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the [VendorContact](entity:VendorContact).
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The state of the [VendorContact](entity:VendorContact).
	Removed *bool `json:"removed,omitempty" url:"removed,omitempty"`
	// The ordinal of the [VendorContact](entity:VendorContact).
	Ordinal int `json:"ordinal" url:"ordinal"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VendorContact) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorContact) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorContact
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorContact(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorContact) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The status of the [Vendor]($m/Vendor),
// whether a [Vendor]($m/Vendor) is active or inactive.
type VendorStatus string

const (
	VendorStatusActive   VendorStatus = "ACTIVE"
	VendorStatusInactive VendorStatus = "INACTIVE"
)

func NewVendorStatusFromString(s string) (VendorStatus, error) {
	switch s {
	case "ACTIVE":
		return VendorStatusActive, nil
	case "INACTIVE":
		return VendorStatusInactive, nil
	}
	var t VendorStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VendorStatus) Ptr() *VendorStatus {
	return &v
}

// Enumeration of visibility-filter values used to set the ability to view custom attributes or custom attribute definitions.
type VisibilityFilter string

const (
	VisibilityFilterAll       VisibilityFilter = "ALL"
	VisibilityFilterRead      VisibilityFilter = "READ"
	VisibilityFilterReadWrite VisibilityFilter = "READ_WRITE"
)

func NewVisibilityFilterFromString(s string) (VisibilityFilter, error) {
	switch s {
	case "ALL":
		return VisibilityFilterAll, nil
	case "READ":
		return VisibilityFilterRead, nil
	case "READ_WRITE":
		return VisibilityFilterReadWrite, nil
	}
	var t VisibilityFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VisibilityFilter) Ptr() *VisibilityFilter {
	return &v
}

type VoidTransactionRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VoidTransactionRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoidTransactionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VoidTransactionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoidTransactionRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoidTransactionRequest) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Defines the fields that are included in the response body of
// a request to the [VoidTransaction](api-endpoint:Transactions-VoidTransaction) endpoint.
type VoidTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (v *VoidTransactionResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoidTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoidTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoidTransactionResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties

	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoidTransactionResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// An object representing a team member's wage information.
type WageSetting struct {
	// The unique ID of the `TeamMember` whom this wage setting describes.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// Required. The ordered list of jobs that the team member is assigned to.
	// The first job assignment is considered the team member's primary job.
	//
	// The minimum length is 1 and the maximum length is 12.
	JobAssignments []*JobAssignment `json:"job_assignments,omitempty" url:"job_assignments,omitempty"`
	// Whether the team member is exempt from the overtime rules of the seller's country.
	IsOvertimeExempt *bool `json:"is_overtime_exempt,omitempty" url:"is_overtime_exempt,omitempty"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write, potentially overwriting data from another write. For more information,
	// see [optimistic concurrency](https://developer.squareup.com/docs/working-with-apis/optimistic-concurrency).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the wage setting object was created.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp, in RFC 3339 format, describing when the wage setting object was last updated.
	// For example, "2018-10-04T04:00:00-07:00" or "2019-02-05T12:00:00Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WageSetting) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WageSetting) UnmarshalJSON(data []byte) error {
	type unmarshaler WageSetting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WageSetting(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WageSetting) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Represents the details of a webhook subscription, including notification URL,
// event types, and signature key.
type WebhookSubscription struct {
	// A Square-generated unique ID for the subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of this subscription.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether the subscription is enabled (`true`) or not (`false`).
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The event types associated with this subscription.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// The URL to which webhooks are sent.
	NotificationURL *string `json:"notification_url,omitempty" url:"notification_url,omitempty"`
	// The API version of the subscription.
	// This field is optional for `CreateWebhookSubscription`.
	// The value defaults to the API version used by the application.
	APIVersion *string `json:"api_version,omitempty" url:"api_version,omitempty"`
	// The Square-generated signature key used to validate the origin of the webhook event.
	SignatureKey *string `json:"signature_key,omitempty" url:"signature_key,omitempty"`
	// The timestamp of when the subscription was created, in RFC 3339 format. For example, "2016-09-04T23:59:33.123Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the subscription was last updated, in RFC 3339 format.
	// For example, "2016-09-04T23:59:33.123Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WebhookSubscription) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookSubscription) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookSubscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookSubscription(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookSubscription) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// The days of the week.
type Weekday string

const (
	WeekdayMon Weekday = "MON"
	WeekdayTue Weekday = "TUE"
	WeekdayWed Weekday = "WED"
	WeekdayThu Weekday = "THU"
	WeekdayFri Weekday = "FRI"
	WeekdaySat Weekday = "SAT"
	WeekdaySun Weekday = "SUN"
)

func NewWeekdayFromString(s string) (Weekday, error) {
	switch s {
	case "MON":
		return WeekdayMon, nil
	case "TUE":
		return WeekdayTue, nil
	case "WED":
		return WeekdayWed, nil
	case "THU":
		return WeekdayThu, nil
	case "FRI":
		return WeekdayFri, nil
	case "SAT":
		return WeekdaySat, nil
	case "SUN":
		return WeekdaySun, nil
	}
	var t Weekday
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w Weekday) Ptr() *Weekday {
	return &w
}

// Sets the day of the week and hour of the day that a business starts a
// workweek. This is used to calculate overtime pay.
type WorkweekConfig struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The day of the week on which a business week starts for
	// compensation purposes.
	// See [Weekday](#type-weekday) for possible values
	StartOfWeek Weekday `json:"start_of_week" url:"start_of_week"`
	// The local time at which a business week starts. Represented as a
	// string in `HH:MM` format (`HH:MM:SS` is also accepted, but seconds are
	// truncated).
	StartOfDayLocalTime string `json:"start_of_day_local_time" url:"start_of_day_local_time"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write; potentially overwriting data from another
	// write.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (w *WorkweekConfig) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkweekConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkweekConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkweekConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties

	w._rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkweekConfig) String() string {
	if len(w._rawJSON) > 0 {
		if value, err := core.StringifyJSON(w._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
