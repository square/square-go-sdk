// Code generated by Fern. DO NOT EDIT.

package square

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/square/square-go-sdk/v2/internal"
)

type AcceptedPaymentMethods struct {
	// Whether Apple Pay is accepted at checkout.
	ApplePay *bool `json:"apple_pay,omitempty" url:"apple_pay,omitempty"`
	// Whether Google Pay is accepted at checkout.
	GooglePay *bool `json:"google_pay,omitempty" url:"google_pay,omitempty"`
	// Whether Cash App Pay is accepted at checkout.
	CashAppPay *bool `json:"cash_app_pay,omitempty" url:"cash_app_pay,omitempty"`
	// Whether Afterpay/Clearpay is accepted at checkout.
	AfterpayClearpay *bool `json:"afterpay_clearpay,omitempty" url:"afterpay_clearpay,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AcceptedPaymentMethods) GetApplePay() *bool {
	if a == nil {
		return nil
	}
	return a.ApplePay
}

func (a *AcceptedPaymentMethods) GetGooglePay() *bool {
	if a == nil {
		return nil
	}
	return a.GooglePay
}

func (a *AcceptedPaymentMethods) GetCashAppPay() *bool {
	if a == nil {
		return nil
	}
	return a.CashAppPay
}

func (a *AcceptedPaymentMethods) GetAfterpayClearpay() *bool {
	if a == nil {
		return nil
	}
	return a.AfterpayClearpay
}

func (a *AcceptedPaymentMethods) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AcceptedPaymentMethods) UnmarshalJSON(data []byte) error {
	type unmarshaler AcceptedPaymentMethods
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AcceptedPaymentMethods(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AcceptedPaymentMethods) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an [AccumulateLoyaltyPoints](api-endpoint:Loyalty-AccumulateLoyaltyPoints) response.
type AccumulateLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resulting loyalty event. Starting in Square version 2022-08-17, this field is no longer returned.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`
	// The resulting loyalty events. If the purchase qualifies for points, the `ACCUMULATE_POINTS` event
	// is always included. When using the Orders API, the `ACCUMULATE_PROMOTION_POINTS` event is included
	// if the purchase also qualifies for a loyalty promotion.
	Events []*LoyaltyEvent `json:"events,omitempty" url:"events,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AccumulateLoyaltyPointsResponse) GetErrors() []*Error {
	if a == nil {
		return nil
	}
	return a.Errors
}

func (a *AccumulateLoyaltyPointsResponse) GetEvent() *LoyaltyEvent {
	if a == nil {
		return nil
	}
	return a.Event
}

func (a *AccumulateLoyaltyPointsResponse) GetEvents() []*LoyaltyEvent {
	if a == nil {
		return nil
	}
	return a.Events
}

func (a *AccumulateLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AccumulateLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AccumulateLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AccumulateLoyaltyPointsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AccumulateLoyaltyPointsResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionCancelReason string

const (
	ActionCancelReasonBuyerCanceled  ActionCancelReason = "BUYER_CANCELED"
	ActionCancelReasonSellerCanceled ActionCancelReason = "SELLER_CANCELED"
	ActionCancelReasonTimedOut       ActionCancelReason = "TIMED_OUT"
)

func NewActionCancelReasonFromString(s string) (ActionCancelReason, error) {
	switch s {
	case "BUYER_CANCELED":
		return ActionCancelReasonBuyerCanceled, nil
	case "SELLER_CANCELED":
		return ActionCancelReasonSellerCanceled, nil
	case "TIMED_OUT":
		return ActionCancelReasonTimedOut, nil
	}
	var t ActionCancelReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionCancelReason) Ptr() *ActionCancelReason {
	return &a
}

// Defines the fields that are included in the response body of
// a request to the [AddGroupToCustomer](api-endpoint:Customers-AddGroupToCustomer) endpoint.
type AddGroupToCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AddGroupToCustomerResponse) GetErrors() []*Error {
	if a == nil {
		return nil
	}
	return a.Errors
}

func (a *AddGroupToCustomerResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AddGroupToCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AddGroupToCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AddGroupToCustomerResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AddGroupToCustomerResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an additional recipient (other than the merchant) receiving a portion of this tender.
type AdditionalRecipient struct {
	// The location ID for a recipient (other than the merchant) receiving a portion of this tender.
	LocationID string `json:"location_id" url:"location_id"`
	// The description of the additional recipient.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money distributed to the recipient.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// The unique ID for the RETIRED `AdditionalRecipientReceivable` object. This field should be empty for any `AdditionalRecipient` objects created after the retirement.
	ReceivableID *string `json:"receivable_id,omitempty" url:"receivable_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AdditionalRecipient) GetLocationID() string {
	if a == nil {
		return ""
	}
	return a.LocationID
}

func (a *AdditionalRecipient) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *AdditionalRecipient) GetAmountMoney() *Money {
	if a == nil {
		return nil
	}
	return a.AmountMoney
}

func (a *AdditionalRecipient) GetReceivableID() *string {
	if a == nil {
		return nil
	}
	return a.ReceivableID
}

func (a *AdditionalRecipient) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalRecipient(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdditionalRecipient) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents a postal address in a country.
// For more information, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
type Address struct {
	// The first line of the address.
	//
	// Fields that start with `address_line` provide the address's most specific
	// details, like street number, street name, and building name. They do *not*
	// provide less specific details like city, state/province, or country (these
	// details are provided in other fields).
	AddressLine1 *string `json:"address_line_1,omitempty" url:"address_line_1,omitempty"`
	// The second line of the address, if any.
	AddressLine2 *string `json:"address_line_2,omitempty" url:"address_line_2,omitempty"`
	// The third line of the address, if any.
	AddressLine3 *string `json:"address_line_3,omitempty" url:"address_line_3,omitempty"`
	// The city or town of the address. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	Locality *string `json:"locality,omitempty" url:"locality,omitempty"`
	// A civil region within the address's `locality`, if any.
	Sublocality *string `json:"sublocality,omitempty" url:"sublocality,omitempty"`
	// A civil region within the address's `sublocality`, if any.
	Sublocality2 *string `json:"sublocality_2,omitempty" url:"sublocality_2,omitempty"`
	// A civil region within the address's `sublocality_2`, if any.
	Sublocality3 *string `json:"sublocality_3,omitempty" url:"sublocality_3,omitempty"`
	// A civil entity within the address's country. In the US, this
	// is the state. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	AdministrativeDistrictLevel1 *string `json:"administrative_district_level_1,omitempty" url:"administrative_district_level_1,omitempty"`
	// A civil entity within the address's `administrative_district_level_1`.
	// In the US, this is the county.
	AdministrativeDistrictLevel2 *string `json:"administrative_district_level_2,omitempty" url:"administrative_district_level_2,omitempty"`
	// A civil entity within the address's `administrative_district_level_2`,
	// if any.
	AdministrativeDistrictLevel3 *string `json:"administrative_district_level_3,omitempty" url:"administrative_district_level_3,omitempty"`
	// The address's postal code. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	PostalCode *string `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	// The address's country, in the two-letter format of ISO 3166. For example, `US` or `FR`.
	// See [Country](#type-country) for possible values
	Country *Country `json:"country,omitempty" url:"country,omitempty"`
	// Optional first name when it's representing recipient.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// Optional last name when it's representing recipient.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *Address) GetAddressLine1() *string {
	if a == nil {
		return nil
	}
	return a.AddressLine1
}

func (a *Address) GetAddressLine2() *string {
	if a == nil {
		return nil
	}
	return a.AddressLine2
}

func (a *Address) GetAddressLine3() *string {
	if a == nil {
		return nil
	}
	return a.AddressLine3
}

func (a *Address) GetLocality() *string {
	if a == nil {
		return nil
	}
	return a.Locality
}

func (a *Address) GetSublocality() *string {
	if a == nil {
		return nil
	}
	return a.Sublocality
}

func (a *Address) GetSublocality2() *string {
	if a == nil {
		return nil
	}
	return a.Sublocality2
}

func (a *Address) GetSublocality3() *string {
	if a == nil {
		return nil
	}
	return a.Sublocality3
}

func (a *Address) GetAdministrativeDistrictLevel1() *string {
	if a == nil {
		return nil
	}
	return a.AdministrativeDistrictLevel1
}

func (a *Address) GetAdministrativeDistrictLevel2() *string {
	if a == nil {
		return nil
	}
	return a.AdministrativeDistrictLevel2
}

func (a *Address) GetAdministrativeDistrictLevel3() *string {
	if a == nil {
		return nil
	}
	return a.AdministrativeDistrictLevel3
}

func (a *Address) GetPostalCode() *string {
	if a == nil {
		return nil
	}
	return a.PostalCode
}

func (a *Address) GetCountry() *Country {
	if a == nil {
		return nil
	}
	return a.Country
}

func (a *Address) GetFirstName() *string {
	if a == nil {
		return nil
	}
	return a.FirstName
}

func (a *Address) GetLastName() *string {
	if a == nil {
		return nil
	}
	return a.LastName
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an [AdjustLoyaltyPoints](api-endpoint:Loyalty-AdjustLoyaltyPoints) request.
type AdjustLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The resulting event data for the adjustment.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AdjustLoyaltyPointsResponse) GetErrors() []*Error {
	if a == nil {
		return nil
	}
	return a.Errors
}

func (a *AdjustLoyaltyPointsResponse) GetEvent() *LoyaltyEvent {
	if a == nil {
		return nil
	}
	return a.Event
}

func (a *AdjustLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdjustLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AdjustLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdjustLoyaltyPointsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdjustLoyaltyPointsResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Published when you link an external bank account to a Square
// account in the Seller Dashboard. Square sets the initial status to
// `VERIFICATION_IN_PROGRESS` and publishes the event.
type BankAccountCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"bank_account.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *BankAccountCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountCreatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BankAccountCreatedEvent) GetLocationID() *string {
	if b == nil {
		return nil
	}
	return b.LocationID
}

func (b *BankAccountCreatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BankAccountCreatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BankAccountCreatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BankAccountCreatedEvent) GetData() *BankAccountCreatedEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BankAccountCreatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCreatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountCreatedEventData struct {
	// Name of the affected object’s type, `"bank_account"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected bank account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created bank account.
	Object *BankAccountCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountCreatedEventData) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BankAccountCreatedEventData) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BankAccountCreatedEventData) GetObject() *BankAccountCreatedEventObject {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BankAccountCreatedEventData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCreatedEventData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountCreatedEventObject struct {
	// The created bank account.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountCreatedEventObject) GetBankAccount() *BankAccount {
	if b == nil {
		return nil
	}
	return b.BankAccount
}

func (b *BankAccountCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountCreatedEventObject) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when Square sets the status of a
// [BankAccount](entity:BankAccount) to `DISABLED`.
type BankAccountDisabledEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"bank_account.disabled"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was disabled, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *BankAccountDisabledEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountDisabledEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BankAccountDisabledEvent) GetLocationID() *string {
	if b == nil {
		return nil
	}
	return b.LocationID
}

func (b *BankAccountDisabledEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BankAccountDisabledEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BankAccountDisabledEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BankAccountDisabledEvent) GetData() *BankAccountDisabledEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BankAccountDisabledEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountDisabledEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountDisabledEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountDisabledEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountDisabledEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountDisabledEventData struct {
	// Name of the affected object’s type, `"bank_account"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected bank account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the disabled bank account.
	Object *BankAccountDisabledEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountDisabledEventData) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BankAccountDisabledEventData) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BankAccountDisabledEventData) GetObject() *BankAccountDisabledEventObject {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BankAccountDisabledEventData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountDisabledEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountDisabledEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountDisabledEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountDisabledEventData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountDisabledEventObject struct {
	// The disabled bank account.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountDisabledEventObject) GetBankAccount() *BankAccount {
	if b == nil {
		return nil
	}
	return b.BankAccount
}

func (b *BankAccountDisabledEventObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountDisabledEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountDisabledEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountDisabledEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountDisabledEventObject) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when Square sets the status of a
// [BankAccount](entity:BankAccount) to `VERIFIED`.
type BankAccountVerifiedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"bank_account.verified"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *BankAccountVerifiedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountVerifiedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BankAccountVerifiedEvent) GetLocationID() *string {
	if b == nil {
		return nil
	}
	return b.LocationID
}

func (b *BankAccountVerifiedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BankAccountVerifiedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BankAccountVerifiedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BankAccountVerifiedEvent) GetData() *BankAccountVerifiedEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BankAccountVerifiedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountVerifiedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountVerifiedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountVerifiedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountVerifiedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountVerifiedEventData struct {
	// Name of the affected object’s type, `"bank_account"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected bank account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the verified bank account.
	Object *BankAccountVerifiedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountVerifiedEventData) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BankAccountVerifiedEventData) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BankAccountVerifiedEventData) GetObject() *BankAccountVerifiedEventObject {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BankAccountVerifiedEventData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountVerifiedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountVerifiedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountVerifiedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountVerifiedEventData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BankAccountVerifiedEventObject struct {
	// The verified bank account.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccountVerifiedEventObject) GetBankAccount() *BankAccount {
	if b == nil {
		return nil
	}
	return b.BankAccount
}

func (b *BankAccountVerifiedEventObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountVerifiedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountVerifiedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountVerifiedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountVerifiedEventObject) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertCustomerCustomAttributes](api-endpoint:CustomerCustomAttributes-BulkUpsertCustomerCustomAttributes)
// request. An individual request contains a customer ID, the custom attribute to create or update,
// and an optional idempotency key.
type BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest struct {
	// The ID of the target [customer profile](entity:Customer).
	CustomerID string `json:"customer_id" url:"customer_id"`
	// The custom attribute to create or update, with following fields:
	//
	// - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	// account. If the requesting application is not the definition owner, you must provide the qualified key.
	//
	// - `value`. This value must conform to the `schema` specified by the definition.
	// For more information, see [Value data types](https://developer.squareup.com/docs/customer-custom-attributes-api/custom-attributes#value-data-types).
	//
	// - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control for update operations, include this optional field in the request and set the
	// value to the current version of the custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute" url:"custom_attribute"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) GetCustomerID() string {
	if b == nil {
		return ""
	}
	return b.CustomerID
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) GetIdempotencyKey() *string {
	if b == nil {
		return nil
	}
	return b.IdempotencyKey
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCustomerCustomAttributesRequestCustomerCustomAttributeUpsertRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertCustomerCustomAttributes](api-endpoint:CustomerCustomAttributes-BulkUpsertCustomerCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BatchUpsertCustomerCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `customer_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchUpsertCustomerCustomAttributesResponse) GetValues() map[string]*BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BatchUpsertCustomerCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BatchUpsertCustomerCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCustomerCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCustomerCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCustomerCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCustomerCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertCustomerCustomAttributes](api-endpoint:CustomerCustomAttributes-BulkUpsertCustomerCustomAttributes) operation.
type BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse struct {
	// The ID of the customer profile associated with the custom attribute.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) GetCustomerID() *string {
	if b == nil {
		return nil
	}
	return b.CustomerID
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchUpsertCustomerCustomAttributesResponseCustomerCustomAttributeUpsertResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking is created.
//
// To receive this event with buyer-level permissions, you must have `APPOINTMENTS_READ` set for the OAuth scope.
// To receive this event with seller-level permissions, you must have `APPOINTMENTS_ALL_READ` and `APPOINTMENTS_READ` set for the OAuth scope.
type BookingCreatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *BookingCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCreatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCreatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCreatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCreatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCreatedEvent) GetData() *BookingCreatedEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCreatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingCreatedEventData struct {
	// The type of the event data object. The value is `"booking"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created booking.
	Object *BookingCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCreatedEventData) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCreatedEventData) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BookingCreatedEventData) GetObject() *BookingCreatedEventObject {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BookingCreatedEventData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatedEventData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingCreatedEventObject struct {
	// The created booking.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCreatedEventObject) GetBooking() *Booking {
	if b == nil {
		return nil
	}
	return b.Booking
}

func (b *BookingCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCreatedEventObject) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute definition](entity:CustomAttributeDefinition)
// is created by the subscribing application. Subscribe to this event to be notified
// when your application creates a booking custom attribute definition.
type BookingCustomAttributeDefinitionOwnedCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute_definition.owned.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDefinitionOwnedCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDefinitionOwnedCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDefinitionOwnedCreatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute definition](entity:CustomAttributeDefinition)
// is deleted by the subscribing application. Subscribe to this event to be notified
// when your application deletes a booking custom attribute definition.
type BookingCustomAttributeDefinitionOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute_definition.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDefinitionOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDefinitionOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDefinitionOwnedDeletedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute definition](entity:CustomAttributeDefinition)
// is updated by the subscribing application. Subscribe to this event to be notified
// when your application updates a booking custom attribute definition.
type BookingCustomAttributeDefinitionOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute_definition.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDefinitionOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDefinitionOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDefinitionOwnedUpdatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute definition](entity:CustomAttributeDefinition)
// with the `visibility` field set to `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES` is created.
// An application that subscribes to this event is notified when a booking custom attribute definition is created
// by any application for which the subscribing application has read access to the booking custom attribute definition.
type BookingCustomAttributeDefinitionVisibleCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute_definition.visible.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDefinitionVisibleCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDefinitionVisibleCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDefinitionVisibleCreatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute definition](entity:CustomAttributeDefinition)
// with the `visibility` field set to `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES` is deleted.
// An application that subscribes to this event is notified when a booking custom attribute definition is deleted
// by any application for which the subscribing application has read access to the booking custom attribute definition.
type BookingCustomAttributeDefinitionVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute_definition.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDefinitionVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDefinitionVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDefinitionVisibleDeletedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute definition](entity:CustomAttributeDefinition)
// with the `visibility` field set to `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES` is updated.
// An application that subscribes to this event is notified when a booking custom attribute definition is updated
// by any application for which the subscribing application has read access to the booking custom attribute definition.
type BookingCustomAttributeDefinitionVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute_definition.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDefinitionVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDefinitionVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDefinitionVisibleUpdatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete request in a [BulkDeleteBookingCustomAttributes](api-endpoint:BookingCustomAttributes-BulkDeleteBookingCustomAttributes)
// request. An individual request contains a booking ID, the custom attribute to delete, and an optional idempotency key.
type BookingCustomAttributeDeleteRequest struct {
	// The ID of the target [booking](entity:Booking).
	BookingID string `json:"booking_id" url:"booking_id"`
	// The key of the custom attribute to delete. This key must match the `key` of a
	// custom attribute definition in the Square seller account. If the requesting application is not
	// the definition owner, you must use the qualified key.
	Key string `json:"key" url:"key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDeleteRequest) GetBookingID() string {
	if b == nil {
		return ""
	}
	return b.BookingID
}

func (b *BookingCustomAttributeDeleteRequest) GetKey() string {
	if b == nil {
		return ""
	}
	return b.Key
}

func (b *BookingCustomAttributeDeleteRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDeleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDeleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDeleteRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDeleteRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkDeleteBookingCustomAttributes](api-endpoint:BookingCustomAttributes-BulkDeleteBookingCustomAttributes) operation.
type BookingCustomAttributeDeleteResponse struct {
	// The ID of the [booking](entity:Booking) associated with the custom attribute.
	BookingID *string `json:"booking_id,omitempty" url:"booking_id,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeDeleteResponse) GetBookingID() *string {
	if b == nil {
		return nil
	}
	return b.BookingID
}

func (b *BookingCustomAttributeDeleteResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BookingCustomAttributeDeleteResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeDeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeDeleteResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute](entity:CustomAttribute)
// associated with a [custom attribute definition](entity:CustomAttributeDefinition) that is
// owned by the subscribing application is deleted.
// Subscribe to this event to be notified
// when your application deletes a booking custom attribute.
type BookingCustomAttributeOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeOwnedDeletedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeOwnedDeletedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeOwnedDeletedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeOwnedDeletedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeOwnedDeletedEvent) GetData() *CustomAttributeEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeOwnedDeletedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute](entity:CustomAttribute)
// is updated by the subscribing application. Subscribe to this event to be notified
// when your application updates a booking custom attribute.
type BookingCustomAttributeOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) GetData() *CustomAttributeEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeOwnedUpdatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertBookingCustomAttributes](api-endpoint:BookingCustomAttributes-BulkUpsertBookingCustomAttributes)
// request. An individual request contains a booking ID, the custom attribute to create or update,
// and an optional idempotency key.
type BookingCustomAttributeUpsertRequest struct {
	// The ID of the target [booking](entity:Booking).
	BookingID string `json:"booking_id" url:"booking_id"`
	// The custom attribute to create or update, with following fields:
	//
	// - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	// account. If the requesting application is not the definition owner, you must provide the qualified key.
	//
	// - `value`. This value must conform to the `schema` specified by the definition.
	// For more information, see [Value data types](https://developer.squareup.com/docs/booking-custom-attributes-api/custom-attributes#value-data-types).
	//
	// - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control for update operations, include this optional field in the request and set the
	// value to the current version of the custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute" url:"custom_attribute"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeUpsertRequest) GetBookingID() string {
	if b == nil {
		return ""
	}
	return b.BookingID
}

func (b *BookingCustomAttributeUpsertRequest) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BookingCustomAttributeUpsertRequest) GetIdempotencyKey() *string {
	if b == nil {
		return nil
	}
	return b.IdempotencyKey
}

func (b *BookingCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeUpsertRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeUpsertRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertBookingCustomAttributes](api-endpoint:BookingCustomAttributes-BulkUpsertBookingCustomAttributes) operation.
type BookingCustomAttributeUpsertResponse struct {
	// The ID of the [booking](entity:Booking) associated with the custom attribute.
	BookingID *string `json:"booking_id,omitempty" url:"booking_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeUpsertResponse) GetBookingID() *string {
	if b == nil {
		return nil
	}
	return b.BookingID
}

func (b *BookingCustomAttributeUpsertResponse) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BookingCustomAttributeUpsertResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BookingCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeUpsertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeUpsertResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute](entity:CustomAttribute) with
// the `visibility` field set to `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES` is deleted.
// An application that subscribes to this event is notified when a booking custom attribute is deleted
// by any application for which the subscribing application has read access to the booking custom attribute.
type BookingCustomAttributeVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeVisibleDeletedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeVisibleDeletedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeVisibleDeletedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeVisibleDeletedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeVisibleDeletedEvent) GetData() *CustomAttributeEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeVisibleDeletedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking [custom attribute](entity:CustomAttribute)
// with the `visibility` field set to `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES` is updated.
// An application that subscribes to this event is notified when a booking custom attribute is updated
// by any application for which the subscribing application has read access to the booking custom attribute.
type BookingCustomAttributeVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.custom_attribute.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) GetData() *CustomAttributeEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingCustomAttributeVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingCustomAttributeVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingCustomAttributeVisibleUpdatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Published when a booking is updated or cancelled.
//
// To receive this event with buyer-level permissions, you must have `APPOINTMENTS_READ` set for the OAuth scope.
// To receive this event with seller-level permissions, you must have `APPOINTMENTS_ALL_READ` and `APPOINTMENTS_READ` set for the OAuth scope.
type BookingUpdatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"booking.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *BookingUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingUpdatedEvent) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BookingUpdatedEvent) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingUpdatedEvent) GetEventID() *string {
	if b == nil {
		return nil
	}
	return b.EventID
}

func (b *BookingUpdatedEvent) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BookingUpdatedEvent) GetData() *BookingUpdatedEventData {
	if b == nil {
		return nil
	}
	return b.Data
}

func (b *BookingUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingUpdatedEvent) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingUpdatedEventData struct {
	// The type of the event data object. The value is `"booking"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated booking.
	Object *BookingUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingUpdatedEventData) GetType() *string {
	if b == nil {
		return nil
	}
	return b.Type
}

func (b *BookingUpdatedEventData) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BookingUpdatedEventData) GetObject() *BookingUpdatedEventObject {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BookingUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingUpdatedEventData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BookingUpdatedEventObject struct {
	// The updated booking.
	Booking *Booking `json:"booking,omitempty" url:"booking,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BookingUpdatedEventObject) GetBooking() *Booking {
	if b == nil {
		return nil
	}
	return b.Booking
}

func (b *BookingUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BookingUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler BookingUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BookingUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BookingUpdatedEventObject) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A record of a team member's break on a [timecard](entity:Timecard).
type Break struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// RFC 3339; follows the same timezone information as the [timecard](entity:Timecard). Precision up to
	// the minute is respected; seconds are truncated.
	StartAt string `json:"start_at" url:"start_at"`
	// RFC 3339; follows the same timezone information as the [timecard](entity:Timecard). Precision up to
	// the minute is respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// The [BreakType](entity:BreakType) that this break was templated on.
	BreakTypeID string `json:"break_type_id" url:"break_type_id"`
	// A human-readable name.
	Name string `json:"name" url:"name"`
	// Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of
	// the break.
	//
	// Example for break expected duration of 15 minutes: PT15M
	ExpectedDuration string `json:"expected_duration" url:"expected_duration"`
	// Whether this break counts towards time worked for compensation
	// purposes.
	IsPaid bool `json:"is_paid" url:"is_paid"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *Break) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *Break) GetStartAt() string {
	if b == nil {
		return ""
	}
	return b.StartAt
}

func (b *Break) GetEndAt() *string {
	if b == nil {
		return nil
	}
	return b.EndAt
}

func (b *Break) GetBreakTypeID() string {
	if b == nil {
		return ""
	}
	return b.BreakTypeID
}

func (b *Break) GetName() string {
	if b == nil {
		return ""
	}
	return b.Name
}

func (b *Break) GetExpectedDuration() string {
	if b == nil {
		return ""
	}
	return b.ExpectedDuration
}

func (b *Break) GetIsPaid() bool {
	if b == nil {
		return false
	}
	return b.IsPaid
}

func (b *Break) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Break) UnmarshalJSON(data []byte) error {
	type unmarshaler Break
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = Break(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *Break) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A template for a type of [break](entity:Break) that can be added to a
// [timecard](entity:Timecard), including the expected duration and paid status.
type BreakType struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the business location this type of break applies to.
	LocationID string `json:"location_id" url:"location_id"`
	// A human-readable name for this type of break. The name is displayed to
	// team members in Square products.
	BreakName string `json:"break_name" url:"break_name"`
	// Format: RFC-3339 P[n]Y[n]M[n]DT[n]H[n]M[n]S. The expected length of
	// this break. Precision less than minutes is truncated.
	//
	// Example for break expected duration of 15 minutes: PT15M
	ExpectedDuration string `json:"expected_duration" url:"expected_duration"`
	// Whether this break counts towards time worked for compensation
	// purposes.
	IsPaid bool `json:"is_paid" url:"is_paid"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If a value is not
	// provided, Square's servers execute a "blind" write; potentially
	// overwriting another writer's data.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BreakType) GetID() *string {
	if b == nil {
		return nil
	}
	return b.ID
}

func (b *BreakType) GetLocationID() string {
	if b == nil {
		return ""
	}
	return b.LocationID
}

func (b *BreakType) GetBreakName() string {
	if b == nil {
		return ""
	}
	return b.BreakName
}

func (b *BreakType) GetExpectedDuration() string {
	if b == nil {
		return ""
	}
	return b.ExpectedDuration
}

func (b *BreakType) GetIsPaid() bool {
	if b == nil {
		return false
	}
	return b.IsPaid
}

func (b *BreakType) GetVersion() *int {
	if b == nil {
		return nil
	}
	return b.Version
}

func (b *BreakType) GetCreatedAt() *string {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BreakType) GetUpdatedAt() *string {
	if b == nil {
		return nil
	}
	return b.UpdatedAt
}

func (b *BreakType) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BreakType) UnmarshalJSON(data []byte) error {
	type unmarshaler BreakType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BreakType(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BreakType) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkDeleteBookingCustomAttributes](api-endpoint:BookingCustomAttributes-BulkDeleteBookingCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual delete request.
type BulkDeleteBookingCustomAttributesResponse struct {
	// A map of responses that correspond to individual delete requests. Each response has the
	// same ID as the corresponding request and contains `booking_id` and  `errors` field.
	Values map[string]*BookingCustomAttributeDeleteResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteBookingCustomAttributesResponse) GetValues() map[string]*BookingCustomAttributeDeleteResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkDeleteBookingCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkDeleteBookingCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteBookingCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteBookingCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteBookingCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteBookingCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete request in a [BulkDeleteLocationCustomAttributes](api-endpoint:LocationCustomAttributes-BulkDeleteLocationCustomAttributes)
// request. An individual request contains an optional ID of the associated custom attribute definition
// and optional key of the associated custom attribute definition.
type BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest struct {
	// The key of the associated custom attribute definition.
	// Represented as a qualified key if the requesting app is not the definition owner.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest) GetKey() *string {
	if b == nil {
		return nil
	}
	return b.Key
}

func (b *BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteLocationCustomAttributesRequestLocationCustomAttributeDeleteRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkDeleteLocationCustomAttributes](api-endpoint:LocationCustomAttributes-BulkDeleteLocationCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual delete request.
type BulkDeleteLocationCustomAttributesResponse struct {
	// A map of responses that correspond to individual delete requests. Each response has the
	// same key as the corresponding request.
	Values map[string]*BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse `json:"values" url:"values"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteLocationCustomAttributesResponse) GetValues() map[string]*BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkDeleteLocationCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkDeleteLocationCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteLocationCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteLocationCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteLocationCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteLocationCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete response in a [BulkDeleteLocationCustomAttributes](api-endpoint:LocationCustomAttributes-BulkDeleteLocationCustomAttributes)
// request.
type BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse struct {
	// The ID of the location associated with the custom attribute.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Errors that occurred while processing the individual LocationCustomAttributeDeleteRequest request
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) GetLocationID() *string {
	if b == nil {
		return nil
	}
	return b.LocationID
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteLocationCustomAttributesResponseLocationCustomAttributeDeleteResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete request in a [BulkDeleteMerchantCustomAttributes](api-endpoint:MerchantCustomAttributes-BulkDeleteMerchantCustomAttributes)
// request. An individual request contains an optional ID of the associated custom attribute definition
// and optional key of the associated custom attribute definition.
type BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest struct {
	// The key of the associated custom attribute definition.
	// Represented as a qualified key if the requesting app is not the definition owner.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest) GetKey() *string {
	if b == nil {
		return nil
	}
	return b.Key
}

func (b *BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteMerchantCustomAttributesRequestMerchantCustomAttributeDeleteRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkDeleteMerchantCustomAttributes](api-endpoint:MerchantCustomAttributes-BulkDeleteMerchantCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual delete request.
type BulkDeleteMerchantCustomAttributesResponse struct {
	// A map of responses that correspond to individual delete requests. Each response has the
	// same key as the corresponding request.
	Values map[string]*BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse `json:"values" url:"values"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteMerchantCustomAttributesResponse) GetValues() map[string]*BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkDeleteMerchantCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkDeleteMerchantCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteMerchantCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteMerchantCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteMerchantCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteMerchantCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual delete response in a [BulkDeleteMerchantCustomAttributes](api-endpoint:MerchantCustomAttributes-BulkDeleteMerchantCustomAttributes)
// request.
type BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse struct {
	// Errors that occurred while processing the individual MerchantCustomAttributeDeleteRequest request
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteMerchantCustomAttributesResponseMerchantCustomAttributeDeleteResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents one delete within the bulk operation.
type BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute struct {
	// The key of the custom attribute to delete.  This key must match the key
	// of an existing custom attribute definition.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// The ID of the target [order](entity:Order).
	OrderID string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) GetKey() *string {
	if b == nil {
		return nil
	}
	return b.Key
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) GetOrderID() string {
	if b == nil {
		return ""
	}
	return b.OrderID
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteOrderCustomAttributesRequestDeleteCustomAttribute) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response from deleting one or more order custom attributes.
type BulkDeleteOrderCustomAttributesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	//	A map of responses that correspond to individual delete requests. Each response has the same ID
	//
	// as the corresponding request and contains either a `custom_attribute` or an `errors` field.
	Values map[string]*DeleteOrderCustomAttributeResponse `json:"values" url:"values"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkDeleteOrderCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkDeleteOrderCustomAttributesResponse) GetValues() map[string]*DeleteOrderCustomAttributeResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkDeleteOrderCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkDeleteOrderCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkDeleteOrderCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkDeleteOrderCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkDeleteOrderCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertBookingCustomAttributes](api-endpoint:BookingCustomAttributes-BulkUpsertBookingCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BulkUpsertBookingCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `booking_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BookingCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertBookingCustomAttributesResponse) GetValues() map[string]*BookingCustomAttributeUpsertResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkUpsertBookingCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkUpsertBookingCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertBookingCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertBookingCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertBookingCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertBookingCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertLocationCustomAttributes](api-endpoint:LocationCustomAttributes-BulkUpsertLocationCustomAttributes)
// request. An individual request contains a location ID, the custom attribute to create or update,
// and an optional idempotency key.
type BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest struct {
	// The ID of the target [location](entity:Location).
	LocationID string `json:"location_id" url:"location_id"`
	// The custom attribute to create or update, with following fields:
	// - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	// account. If the requesting application is not the definition owner, you must provide the qualified key.
	// - `value`. This value must conform to the `schema` specified by the definition.
	// For more information, see [Supported data types](https://developer.squareup.com/docs/devtools/customattributes/overview#supported-data-types)..
	// - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control, specify the current version of the custom attribute.
	// If this is not important for your application, `version` can be set to -1.
	CustomAttribute *CustomAttribute `json:"custom_attribute" url:"custom_attribute"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) GetLocationID() string {
	if b == nil {
		return ""
	}
	return b.LocationID
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) GetIdempotencyKey() *string {
	if b == nil {
		return nil
	}
	return b.IdempotencyKey
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertLocationCustomAttributesRequestLocationCustomAttributeUpsertRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertLocationCustomAttributes](api-endpoint:LocationCustomAttributes-BulkUpsertLocationCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BulkUpsertLocationCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `location_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertLocationCustomAttributesResponse) GetValues() map[string]*BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkUpsertLocationCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkUpsertLocationCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertLocationCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertLocationCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertLocationCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertLocationCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertLocationCustomAttributes](api-endpoint:LocationCustomAttributes-BulkUpsertLocationCustomAttributes) operation.
type BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse struct {
	// The ID of the location associated with the custom attribute.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) GetLocationID() *string {
	if b == nil {
		return nil
	}
	return b.LocationID
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertLocationCustomAttributesResponseLocationCustomAttributeUpsertResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents an individual upsert request in a [BulkUpsertMerchantCustomAttributes](api-endpoint:MerchantCustomAttributes-BulkUpsertMerchantCustomAttributes)
// request. An individual request contains a merchant ID, the custom attribute to create or update,
// and an optional idempotency key.
type BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest struct {
	// The ID of the target [merchant](entity:Merchant).
	MerchantID string `json:"merchant_id" url:"merchant_id"`
	// The custom attribute to create or update, with following fields:
	// - `key`. This key must match the `key` of a custom attribute definition in the Square seller
	// account. If the requesting application is not the definition owner, you must provide the qualified key.
	// - `value`. This value must conform to the `schema` specified by the definition.
	// For more information, see [Supported data types](https://developer.squareup.com/docs/devtools/customattributes/overview#supported-data-types).
	// - The version field must match the current version of the custom attribute definition to enable
	// [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// If this is not important for your application, version can be set to -1. For any other values, the request fails with a BAD_REQUEST error.
	CustomAttribute *CustomAttribute `json:"custom_attribute" url:"custom_attribute"`
	// A unique identifier for this individual upsert request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) GetMerchantID() string {
	if b == nil {
		return ""
	}
	return b.MerchantID
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) GetIdempotencyKey() *string {
	if b == nil {
		return nil
	}
	return b.IdempotencyKey
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertMerchantCustomAttributesRequestMerchantCustomAttributeUpsertRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkUpsertMerchantCustomAttributes](api-endpoint:MerchantCustomAttributes-BulkUpsertMerchantCustomAttributes) response,
// which contains a map of responses that each corresponds to an individual upsert request.
type BulkUpsertMerchantCustomAttributesResponse struct {
	// A map of responses that correspond to individual upsert requests. Each response has the
	// same ID as the corresponding request and contains either a `merchant_id` and `custom_attribute` or an `errors` field.
	Values map[string]*BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse `json:"values,omitempty" url:"values,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertMerchantCustomAttributesResponse) GetValues() map[string]*BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkUpsertMerchantCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkUpsertMerchantCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertMerchantCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertMerchantCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertMerchantCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertMerchantCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response for an individual upsert request in a [BulkUpsertMerchantCustomAttributes](api-endpoint:MerchantCustomAttributes-BulkUpsertMerchantCustomAttributes) operation.
type BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse struct {
	// The ID of the merchant associated with the custom attribute.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred while processing the individual request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) GetMerchantID() *string {
	if b == nil {
		return nil
	}
	return b.MerchantID
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertMerchantCustomAttributesResponseMerchantCustomAttributeUpsertResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents one upsert within the bulk operation.
type BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute struct {
	// The custom attribute to create or update, with the following fields:
	//
	// - `value`. This value must conform to the `schema` specified by the definition.
	// For more information, see [Value data types](https://developer.squareup.com/docs/customer-custom-attributes-api/custom-attributes#value-data-types).
	//
	// - `version`. To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control, include this optional field and specify the current version of the custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute" url:"custom_attribute"`
	// A unique identifier for this request, used to ensure idempotency.
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`
	// The ID of the target [order](entity:Order).
	OrderID string `json:"order_id" url:"order_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) GetCustomAttribute() *CustomAttribute {
	if b == nil {
		return nil
	}
	return b.CustomAttribute
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) GetIdempotencyKey() *string {
	if b == nil {
		return nil
	}
	return b.IdempotencyKey
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) GetOrderID() string {
	if b == nil {
		return ""
	}
	return b.OrderID
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertOrderCustomAttributesRequestUpsertCustomAttribute) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a response from a bulk upsert of order custom attributes.
type BulkUpsertOrderCustomAttributesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A map of responses that correspond to individual upsert operations for custom attributes.
	Values map[string]*UpsertOrderCustomAttributeResponse `json:"values" url:"values"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkUpsertOrderCustomAttributesResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkUpsertOrderCustomAttributesResponse) GetValues() map[string]*UpsertOrderCustomAttributeResponse {
	if b == nil {
		return nil
	}
	return b.Values
}

func (b *BulkUpsertOrderCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkUpsertOrderCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkUpsertOrderCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkUpsertOrderCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkUpsertOrderCustomAttributesResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [CalculateLoyaltyPoints](api-endpoint:Loyalty-CalculateLoyaltyPoints) response.
type CalculateLoyaltyPointsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The number of points that the buyer can earn from the base loyalty program.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The number of points that the buyer can earn from a loyalty promotion. To be eligible
	// to earn promotion points, the purchase must first qualify for program points. When `order_id`
	// is not provided in the request, this value is always 0.
	PromotionPoints *int `json:"promotion_points,omitempty" url:"promotion_points,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CalculateLoyaltyPointsResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CalculateLoyaltyPointsResponse) GetPoints() *int {
	if c == nil {
		return nil
	}
	return c.Points
}

func (c *CalculateLoyaltyPointsResponse) GetPromotionPoints() *int {
	if c == nil {
		return nil
	}
	return c.PromotionPoints
}

func (c *CalculateLoyaltyPointsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CalculateLoyaltyPointsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CalculateLoyaltyPointsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CalculateLoyaltyPointsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CalculateLoyaltyPointsResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CancelLoyaltyPromotion](api-endpoint:Loyalty-CancelLoyaltyPromotion) response.
// Either `loyalty_promotion` or `errors` is present in the response.
type CancelLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelLoyaltyPromotionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CancelLoyaltyPromotionResponse) GetLoyaltyPromotion() *LoyaltyPromotion {
	if c == nil {
		return nil
	}
	return c.LoyaltyPromotion
}

func (c *CancelLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelLoyaltyPromotionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelLoyaltyPromotionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelTerminalActionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CancelTerminalActionResponse) GetAction() *TerminalAction {
	if c == nil {
		return nil
	}
	return c.Action
}

func (c *CancelTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalActionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalActionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The canceled `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelTerminalCheckoutResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CancelTerminalCheckoutResponse) GetCheckout() *TerminalCheckout {
	if c == nil {
		return nil
	}
	return c.Checkout
}

func (c *CancelTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalCheckoutResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalCheckoutResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated `TerminalRefund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelTerminalRefundResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CancelTerminalRefundResponse) GetRefund() *TerminalRefund {
	if c == nil {
		return nil
	}
	return c.Refund
}

func (c *CancelTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelTerminalRefundResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelTerminalRefundResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CaptureTransaction](api-endpoint:Transactions-CaptureTransaction) endpoint.
type CaptureTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CaptureTransactionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CaptureTransactionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CaptureTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CaptureTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CaptureTransactionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CaptureTransactionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the payment details of a card to be used for payments. These
// details are determined by the payment token generated by Web Payments SDK.
type Card struct {
	// Unique ID for this card. Generated by Square.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The card's brand.
	// See [CardBrand](#type-cardbrand) for possible values
	CardBrand *CardBrand `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The last 4 digits of the card number.
	Last4 *string `json:"last_4,omitempty" url:"last_4,omitempty"`
	// The expiration month of the associated card as an integer between 1 and 12.
	ExpMonth *int64 `json:"exp_month,omitempty" url:"exp_month,omitempty"`
	// The four-digit year of the card's expiration date.
	ExpYear *int64 `json:"exp_year,omitempty" url:"exp_year,omitempty"`
	// The name of the cardholder.
	CardholderName *string `json:"cardholder_name,omitempty" url:"cardholder_name,omitempty"`
	// The billing address for this card. `US` postal codes can be provided as a 5-digit zip code
	// or 9-digit ZIP+4 (example: `12345-6789`). For a full list of field meanings by country, see
	// [Working with Addresses](https://developer.squareup.com/docs/build-basics/common-data-types/working-with-addresses).
	BillingAddress *Address `json:"billing_address,omitempty" url:"billing_address,omitempty"`
	// Intended as a Square-assigned identifier, based
	// on the card number, to identify the card across multiple locations within a
	// single application.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// **Required** The ID of a [customer](entity:Customer) to be associated with the card.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The ID of the merchant associated with the card.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// An optional user-defined reference ID that associates this card with
	// another entity in an external system. For example, a customer ID from an
	// external customer management system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Indicates whether or not a card can be used for payments.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The type of the card.
	// The Card object includes this field only in response to Payments API calls.
	// See [CardType](#type-cardtype) for possible values
	CardType *CardType `json:"card_type,omitempty" url:"card_type,omitempty"`
	// Indicates whether the card is prepaid or not.
	// See [CardPrepaidType](#type-cardprepaidtype) for possible values
	PrepaidType *CardPrepaidType `json:"prepaid_type,omitempty" url:"prepaid_type,omitempty"`
	// The first six digits of the card number, known as the Bank Identification Number (BIN). Only the Payments API
	// returns this field.
	Bin *string `json:"bin,omitempty" url:"bin,omitempty"`
	// Current version number of the card. Increments with each card update. Requests to update an
	// existing Card object will be rejected unless the version in the request matches the current
	// version for the Card.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The card's co-brand if available. For example, an Afterpay virtual card would have a
	// co-brand of AFTERPAY.
	// See [CardCoBrand](#type-cardcobrand) for possible values
	CardCoBrand *CardCoBrand `json:"card_co_brand,omitempty" url:"card_co_brand,omitempty"`
	// An alert from the issuing bank about the card status. Alerts can indicate whether
	// future charges to the card are likely to fail. For more information, see
	// [Manage Card on File Declines](https://developer.squareup.com/docs/cards-api/manage-card-on-file-declines).
	//
	// This field is present only if there's an active issuer alert.
	// See [IssuerAlert](#type-issueralert) for possible values
	IssuerAlert *CardIssuerAlert `json:"issuer_alert,omitempty" url:"issuer_alert,omitempty"`
	// The timestamp of when the current issuer alert was received and processed, in
	// RFC 3339 format.
	//
	// This field is present only if there's an active issuer alert.
	IssuerAlertAt *string `json:"issuer_alert_at,omitempty" url:"issuer_alert_at,omitempty"`
	// Indicates whether the card is linked to a Health Savings Account (HSA) or Flexible
	// Spending Account (FSA), based on the card BIN.
	HsaFsa *bool `json:"hsa_fsa,omitempty" url:"hsa_fsa,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Card) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *Card) GetCardBrand() *CardBrand {
	if c == nil {
		return nil
	}
	return c.CardBrand
}

func (c *Card) GetLast4() *string {
	if c == nil {
		return nil
	}
	return c.Last4
}

func (c *Card) GetExpMonth() *int64 {
	if c == nil {
		return nil
	}
	return c.ExpMonth
}

func (c *Card) GetExpYear() *int64 {
	if c == nil {
		return nil
	}
	return c.ExpYear
}

func (c *Card) GetCardholderName() *string {
	if c == nil {
		return nil
	}
	return c.CardholderName
}

func (c *Card) GetBillingAddress() *Address {
	if c == nil {
		return nil
	}
	return c.BillingAddress
}

func (c *Card) GetFingerprint() *string {
	if c == nil {
		return nil
	}
	return c.Fingerprint
}

func (c *Card) GetCustomerID() *string {
	if c == nil {
		return nil
	}
	return c.CustomerID
}

func (c *Card) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *Card) GetReferenceID() *string {
	if c == nil {
		return nil
	}
	return c.ReferenceID
}

func (c *Card) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *Card) GetCardType() *CardType {
	if c == nil {
		return nil
	}
	return c.CardType
}

func (c *Card) GetPrepaidType() *CardPrepaidType {
	if c == nil {
		return nil
	}
	return c.PrepaidType
}

func (c *Card) GetBin() *string {
	if c == nil {
		return nil
	}
	return c.Bin
}

func (c *Card) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *Card) GetCardCoBrand() *CardCoBrand {
	if c == nil {
		return nil
	}
	return c.CardCoBrand
}

func (c *Card) GetIssuerAlertAt() *string {
	if c == nil {
		return nil
	}
	return c.IssuerAlertAt
}

func (c *Card) GetHsaFsa() *bool {
	if c == nil {
		return nil
	}
	return c.HsaFsa
}

func (c *Card) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Card) UnmarshalJSON(data []byte) error {
	type unmarshaler Card
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Card(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Card) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when Square automatically updates the expiration date or
// primary account number (PAN) of a [card](entity:Card) or adds or removes an issuer alert.
type CardAutomaticallyUpdatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.automatically_updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardAutomaticallyUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardAutomaticallyUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CardAutomaticallyUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardAutomaticallyUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CardAutomaticallyUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CardAutomaticallyUpdatedEvent) GetData() *CardAutomaticallyUpdatedEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CardAutomaticallyUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardAutomaticallyUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CardAutomaticallyUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardAutomaticallyUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardAutomaticallyUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardAutomaticallyUpdatedEventData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the automatically updated card.
	Object *CardAutomaticallyUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardAutomaticallyUpdatedEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardAutomaticallyUpdatedEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CardAutomaticallyUpdatedEventData) GetObject() *CardAutomaticallyUpdatedEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CardAutomaticallyUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardAutomaticallyUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardAutomaticallyUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardAutomaticallyUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardAutomaticallyUpdatedEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardAutomaticallyUpdatedEventObject struct {
	// The automatically updated card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardAutomaticallyUpdatedEventObject) GetCard() *Card {
	if c == nil {
		return nil
	}
	return c.Card
}

func (c *CardAutomaticallyUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardAutomaticallyUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardAutomaticallyUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardAutomaticallyUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardAutomaticallyUpdatedEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates a card's brand, such as `VISA` or `MASTERCARD`.
type CardBrand string

const (
	CardBrandOtherBrand        CardBrand = "OTHER_BRAND"
	CardBrandVisa              CardBrand = "VISA"
	CardBrandMastercard        CardBrand = "MASTERCARD"
	CardBrandAmericanExpress   CardBrand = "AMERICAN_EXPRESS"
	CardBrandDiscover          CardBrand = "DISCOVER"
	CardBrandDiscoverDiners    CardBrand = "DISCOVER_DINERS"
	CardBrandJcb               CardBrand = "JCB"
	CardBrandChinaUnionpay     CardBrand = "CHINA_UNIONPAY"
	CardBrandSquareGiftCard    CardBrand = "SQUARE_GIFT_CARD"
	CardBrandSquareCapitalCard CardBrand = "SQUARE_CAPITAL_CARD"
	CardBrandInterac           CardBrand = "INTERAC"
	CardBrandEftpos            CardBrand = "EFTPOS"
	CardBrandFelica            CardBrand = "FELICA"
	CardBrandEbt               CardBrand = "EBT"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return CardBrandOtherBrand, nil
	case "VISA":
		return CardBrandVisa, nil
	case "MASTERCARD":
		return CardBrandMastercard, nil
	case "AMERICAN_EXPRESS":
		return CardBrandAmericanExpress, nil
	case "DISCOVER":
		return CardBrandDiscover, nil
	case "DISCOVER_DINERS":
		return CardBrandDiscoverDiners, nil
	case "JCB":
		return CardBrandJcb, nil
	case "CHINA_UNIONPAY":
		return CardBrandChinaUnionpay, nil
	case "SQUARE_GIFT_CARD":
		return CardBrandSquareGiftCard, nil
	case "SQUARE_CAPITAL_CARD":
		return CardBrandSquareCapitalCard, nil
	case "INTERAC":
		return CardBrandInterac, nil
	case "EFTPOS":
		return CardBrandEftpos, nil
	case "FELICA":
		return CardBrandFelica, nil
	case "EBT":
		return CardBrandEbt, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

// Indicates the brand for a co-branded card.
type CardCoBrand string

const (
	CardCoBrandUnknown  CardCoBrand = "UNKNOWN"
	CardCoBrandAfterpay CardCoBrand = "AFTERPAY"
	CardCoBrandClearpay CardCoBrand = "CLEARPAY"
)

func NewCardCoBrandFromString(s string) (CardCoBrand, error) {
	switch s {
	case "UNKNOWN":
		return CardCoBrandUnknown, nil
	case "AFTERPAY":
		return CardCoBrandAfterpay, nil
	case "CLEARPAY":
		return CardCoBrandClearpay, nil
	}
	var t CardCoBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardCoBrand) Ptr() *CardCoBrand {
	return &c
}

// Published when a [card](entity:Card) is created or imported.
type CardCreatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardCreatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CardCreatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardCreatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CardCreatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CardCreatedEvent) GetData() *CardCreatedEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CardCreatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CardCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardCreatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardCreatedEventData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created card.
	Object *CardCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardCreatedEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardCreatedEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CardCreatedEventData) GetObject() *CardCreatedEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CardCreatedEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardCreatedEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardCreatedEventObject struct {
	// The created card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardCreatedEventObject) GetCard() *Card {
	if c == nil {
		return nil
	}
	return c.Card
}

func (c *CardCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardCreatedEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [card](entity:Card) is disabled.
type CardDisabledEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.disabled"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardDisabledEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardDisabledEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CardDisabledEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardDisabledEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CardDisabledEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CardDisabledEvent) GetData() *CardDisabledEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CardDisabledEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardDisabledEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CardDisabledEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardDisabledEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardDisabledEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardDisabledEventData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the disabled card.
	Object *CardDisabledEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardDisabledEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardDisabledEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CardDisabledEventData) GetObject() *CardDisabledEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CardDisabledEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardDisabledEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardDisabledEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardDisabledEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardDisabledEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardDisabledEventObject struct {
	// The disabled card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardDisabledEventObject) GetCard() *Card {
	if c == nil {
		return nil
	}
	return c.Card
}

func (c *CardDisabledEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardDisabledEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardDisabledEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardDisabledEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardDisabledEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [card](entity:Card) is GDPR forgotten or vaulted.
type CardForgottenEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.forgotten"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardForgottenEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardForgottenEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CardForgottenEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardForgottenEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CardForgottenEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CardForgottenEvent) GetData() *CardForgottenEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CardForgottenEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardForgottenEventCard struct {
	// Unique ID for this card. Generated by Square.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of a customer created using the Customers API associated with the card.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// Indicates whether or not a card can be used for payments.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// An optional user-defined reference ID that associates this card with
	// another entity in an external system. For example, a customer ID from an
	// external customer management system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Current version number of the card. Increments with each card update. Requests to update an
	// existing Card object will be rejected unless the version in the request matches the current
	// version for the Card.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the merchant associated with the card.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardForgottenEventCard) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CardForgottenEventCard) GetCustomerID() *string {
	if c == nil {
		return nil
	}
	return c.CustomerID
}

func (c *CardForgottenEventCard) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CardForgottenEventCard) GetReferenceID() *string {
	if c == nil {
		return nil
	}
	return c.ReferenceID
}

func (c *CardForgottenEventCard) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CardForgottenEventCard) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CardForgottenEventCard) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenEventCard) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenEventCard
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenEventCard(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenEventCard) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardForgottenEventData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the forgotten card.
	Object *CardForgottenEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardForgottenEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardForgottenEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CardForgottenEventData) GetObject() *CardForgottenEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CardForgottenEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardForgottenEventObject struct {
	// The forgotten card.
	Card *CardForgottenEventCard `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardForgottenEventObject) GetCard() *CardForgottenEventCard {
	if c == nil {
		return nil
	}
	return c.Card
}

func (c *CardForgottenEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardForgottenEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardForgottenEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardForgottenEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardForgottenEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the type of issuer alert for a [card on file](entity:Card).
type CardIssuerAlert = string

// Indicates a card's prepaid type, such as `NOT_PREPAID` or `PREPAID`.
type CardPrepaidType string

const (
	CardPrepaidTypeUnknownPrepaidType CardPrepaidType = "UNKNOWN_PREPAID_TYPE"
	CardPrepaidTypeNotPrepaid         CardPrepaidType = "NOT_PREPAID"
	CardPrepaidTypePrepaid            CardPrepaidType = "PREPAID"
)

func NewCardPrepaidTypeFromString(s string) (CardPrepaidType, error) {
	switch s {
	case "UNKNOWN_PREPAID_TYPE":
		return CardPrepaidTypeUnknownPrepaidType, nil
	case "NOT_PREPAID":
		return CardPrepaidTypeNotPrepaid, nil
	case "PREPAID":
		return CardPrepaidTypePrepaid, nil
	}
	var t CardPrepaidType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardPrepaidType) Ptr() *CardPrepaidType {
	return &c
}

// Indicates a card's type, such as `CREDIT` or `DEBIT`.
type CardType string

const (
	CardTypeUnknownCardType CardType = "UNKNOWN_CARD_TYPE"
	CardTypeCredit          CardType = "CREDIT"
	CardTypeDebit           CardType = "DEBIT"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "UNKNOWN_CARD_TYPE":
		return CardTypeUnknownCardType, nil
	case "CREDIT":
		return CardTypeCredit, nil
	case "DEBIT":
		return CardTypeDebit, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

// Published when a [card](entity:Card) is updated by the seller in the Square Dashboard.
type CardUpdatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"card.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CardUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CardUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CardUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CardUpdatedEvent) GetData() *CardUpdatedEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CardUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CardUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardUpdatedEventData struct {
	// The type of the event data object. The value is `"card"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated card.
	Object *CardUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardUpdatedEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CardUpdatedEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CardUpdatedEventData) GetObject() *CardUpdatedEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CardUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CardUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardUpdatedEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CardUpdatedEventObject struct {
	// The updated card.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CardUpdatedEventObject) GetCard() *Card {
	if c == nil {
		return nil
	}
	return c.Card
}

func (c *CardUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CardUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardUpdatedEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CashDrawerDevice struct {
	// The device Square-issued ID
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The device merchant-specified name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CashDrawerDevice) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CashDrawerDevice) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CashDrawerDevice) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerDevice) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerDevice
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerDevice(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerDevice) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The types of events on a CashDrawerShift.
// Each event type represents an employee action on the actual cash drawer
// represented by a CashDrawerShift.
type CashDrawerEventType string

const (
	CashDrawerEventTypeNoSale                      CashDrawerEventType = "NO_SALE"
	CashDrawerEventTypeCashTenderPayment           CashDrawerEventType = "CASH_TENDER_PAYMENT"
	CashDrawerEventTypeOtherTenderPayment          CashDrawerEventType = "OTHER_TENDER_PAYMENT"
	CashDrawerEventTypeCashTenderCancelledPayment  CashDrawerEventType = "CASH_TENDER_CANCELLED_PAYMENT"
	CashDrawerEventTypeOtherTenderCancelledPayment CashDrawerEventType = "OTHER_TENDER_CANCELLED_PAYMENT"
	CashDrawerEventTypeCashTenderRefund            CashDrawerEventType = "CASH_TENDER_REFUND"
	CashDrawerEventTypeOtherTenderRefund           CashDrawerEventType = "OTHER_TENDER_REFUND"
	CashDrawerEventTypePaidIn                      CashDrawerEventType = "PAID_IN"
	CashDrawerEventTypePaidOut                     CashDrawerEventType = "PAID_OUT"
)

func NewCashDrawerEventTypeFromString(s string) (CashDrawerEventType, error) {
	switch s {
	case "NO_SALE":
		return CashDrawerEventTypeNoSale, nil
	case "CASH_TENDER_PAYMENT":
		return CashDrawerEventTypeCashTenderPayment, nil
	case "OTHER_TENDER_PAYMENT":
		return CashDrawerEventTypeOtherTenderPayment, nil
	case "CASH_TENDER_CANCELLED_PAYMENT":
		return CashDrawerEventTypeCashTenderCancelledPayment, nil
	case "OTHER_TENDER_CANCELLED_PAYMENT":
		return CashDrawerEventTypeOtherTenderCancelledPayment, nil
	case "CASH_TENDER_REFUND":
		return CashDrawerEventTypeCashTenderRefund, nil
	case "OTHER_TENDER_REFUND":
		return CashDrawerEventTypeOtherTenderRefund, nil
	case "PAID_IN":
		return CashDrawerEventTypePaidIn, nil
	case "PAID_OUT":
		return CashDrawerEventTypePaidOut, nil
	}
	var t CashDrawerEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CashDrawerEventType) Ptr() *CashDrawerEventType {
	return &c
}

// This model gives the details of a cash drawer shift.
// The cash_payment_money, cash_refund_money, cash_paid_in_money,
// and cash_paid_out_money fields are all computed by summing their respective
// event types.
type CashDrawerShift struct {
	// The shift unique ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The shift current state.
	// See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
	State *CashDrawerShiftState `json:"state,omitempty" url:"state,omitempty"`
	// The time when the shift began, in ISO 8601 format.
	OpenedAt *string `json:"opened_at,omitempty" url:"opened_at,omitempty"`
	// The time when the shift ended, in ISO 8601 format.
	EndedAt *string `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	// The time when the shift was closed, in ISO 8601 format.
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// The free-form text description of a cash drawer by an employee.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money in the cash drawer at the start of the shift.
	// The amount must be greater than or equal to zero.
	OpenedCashMoney *Money `json:"opened_cash_money,omitempty" url:"opened_cash_money,omitempty"`
	// The amount of money added to the cash drawer from cash payments.
	// This is computed by summing all events with the types CASH_TENDER_PAYMENT and
	// CASH_TENDER_CANCELED_PAYMENT. The amount is always greater than or equal to
	// zero.
	CashPaymentMoney *Money `json:"cash_payment_money,omitempty" url:"cash_payment_money,omitempty"`
	// The amount of money removed from the cash drawer from cash refunds.
	// It is computed by summing the events of type CASH_TENDER_REFUND. The amount
	// is always greater than or equal to zero.
	CashRefundsMoney *Money `json:"cash_refunds_money,omitempty" url:"cash_refunds_money,omitempty"`
	// The amount of money added to the cash drawer for reasons other than cash
	// payments. It is computed by summing the events of type PAID_IN. The amount is
	// always greater than or equal to zero.
	CashPaidInMoney *Money `json:"cash_paid_in_money,omitempty" url:"cash_paid_in_money,omitempty"`
	// The amount of money removed from the cash drawer for reasons other than
	// cash refunds. It is computed by summing the events of type PAID_OUT. The amount
	// is always greater than or equal to zero.
	CashPaidOutMoney *Money `json:"cash_paid_out_money,omitempty" url:"cash_paid_out_money,omitempty"`
	// The amount of money that should be in the cash drawer at the end of the
	// shift, based on the shift's other money amounts.
	// This can be negative if employees have not correctly recorded all the events
	// on the cash drawer.
	// cash_paid_out_money is a summation of amounts from cash_payment_money (zero
	// or positive), cash_refunds_money (zero or negative), cash_paid_in_money (zero
	// or positive), and cash_paid_out_money (zero or negative) event types.
	ExpectedCashMoney *Money `json:"expected_cash_money,omitempty" url:"expected_cash_money,omitempty"`
	// The amount of money found in the cash drawer at the end of the shift
	// by an auditing employee. The amount should be positive.
	ClosedCashMoney *Money `json:"closed_cash_money,omitempty" url:"closed_cash_money,omitempty"`
	// The device running Square Point of Sale that was connected to the cash drawer.
	Device *CashDrawerDevice `json:"device,omitempty" url:"device,omitempty"`
	// The shift start time in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The shift updated at time in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the location the cash drawer shift belongs to.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The IDs of all team members that were logged into Square Point of Sale at any
	// point while the cash drawer shift was open.
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`
	// The ID of the team member that started the cash drawer shift.
	OpeningTeamMemberID *string `json:"opening_team_member_id,omitempty" url:"opening_team_member_id,omitempty"`
	// The ID of the team member that ended the cash drawer shift.
	EndingTeamMemberID *string `json:"ending_team_member_id,omitempty" url:"ending_team_member_id,omitempty"`
	// The ID of the team member that closed the cash drawer shift by auditing
	// the cash drawer contents.
	ClosingTeamMemberID *string `json:"closing_team_member_id,omitempty" url:"closing_team_member_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CashDrawerShift) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CashDrawerShift) GetState() *CashDrawerShiftState {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CashDrawerShift) GetOpenedAt() *string {
	if c == nil {
		return nil
	}
	return c.OpenedAt
}

func (c *CashDrawerShift) GetEndedAt() *string {
	if c == nil {
		return nil
	}
	return c.EndedAt
}

func (c *CashDrawerShift) GetClosedAt() *string {
	if c == nil {
		return nil
	}
	return c.ClosedAt
}

func (c *CashDrawerShift) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CashDrawerShift) GetOpenedCashMoney() *Money {
	if c == nil {
		return nil
	}
	return c.OpenedCashMoney
}

func (c *CashDrawerShift) GetCashPaymentMoney() *Money {
	if c == nil {
		return nil
	}
	return c.CashPaymentMoney
}

func (c *CashDrawerShift) GetCashRefundsMoney() *Money {
	if c == nil {
		return nil
	}
	return c.CashRefundsMoney
}

func (c *CashDrawerShift) GetCashPaidInMoney() *Money {
	if c == nil {
		return nil
	}
	return c.CashPaidInMoney
}

func (c *CashDrawerShift) GetCashPaidOutMoney() *Money {
	if c == nil {
		return nil
	}
	return c.CashPaidOutMoney
}

func (c *CashDrawerShift) GetExpectedCashMoney() *Money {
	if c == nil {
		return nil
	}
	return c.ExpectedCashMoney
}

func (c *CashDrawerShift) GetClosedCashMoney() *Money {
	if c == nil {
		return nil
	}
	return c.ClosedCashMoney
}

func (c *CashDrawerShift) GetDevice() *CashDrawerDevice {
	if c == nil {
		return nil
	}
	return c.Device
}

func (c *CashDrawerShift) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CashDrawerShift) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CashDrawerShift) GetLocationID() *string {
	if c == nil {
		return nil
	}
	return c.LocationID
}

func (c *CashDrawerShift) GetTeamMemberIDs() []string {
	if c == nil {
		return nil
	}
	return c.TeamMemberIDs
}

func (c *CashDrawerShift) GetOpeningTeamMemberID() *string {
	if c == nil {
		return nil
	}
	return c.OpeningTeamMemberID
}

func (c *CashDrawerShift) GetEndingTeamMemberID() *string {
	if c == nil {
		return nil
	}
	return c.EndingTeamMemberID
}

func (c *CashDrawerShift) GetClosingTeamMemberID() *string {
	if c == nil {
		return nil
	}
	return c.ClosingTeamMemberID
}

func (c *CashDrawerShift) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShift) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShift
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShift(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShift) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CashDrawerShiftEvent struct {
	// The unique ID of the event.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of cash drawer shift event.
	// See [CashDrawerEventType](#type-cashdrawereventtype) for possible values
	EventType *CashDrawerEventType `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The amount of money that was added to or removed from the cash drawer
	// in the event. The amount can be positive (for added money)
	// or zero (for other tender type payments). The addition or removal of money can be determined by
	// by the event type.
	EventMoney *Money `json:"event_money,omitempty" url:"event_money,omitempty"`
	// The event time in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// An optional description of the event, entered by the employee that
	// created the event.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The ID of the team member that created the event.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CashDrawerShiftEvent) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CashDrawerShiftEvent) GetEventType() *CashDrawerEventType {
	if c == nil {
		return nil
	}
	return c.EventType
}

func (c *CashDrawerShiftEvent) GetEventMoney() *Money {
	if c == nil {
		return nil
	}
	return c.EventMoney
}

func (c *CashDrawerShiftEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CashDrawerShiftEvent) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CashDrawerShiftEvent) GetTeamMemberID() *string {
	if c == nil {
		return nil
	}
	return c.TeamMemberID
}

func (c *CashDrawerShiftEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShiftEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShiftEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShiftEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShiftEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The current state of a cash drawer shift.
type CashDrawerShiftState string

const (
	CashDrawerShiftStateOpen   CashDrawerShiftState = "OPEN"
	CashDrawerShiftStateEnded  CashDrawerShiftState = "ENDED"
	CashDrawerShiftStateClosed CashDrawerShiftState = "CLOSED"
)

func NewCashDrawerShiftStateFromString(s string) (CashDrawerShiftState, error) {
	switch s {
	case "OPEN":
		return CashDrawerShiftStateOpen, nil
	case "ENDED":
		return CashDrawerShiftStateEnded, nil
	case "CLOSED":
		return CashDrawerShiftStateClosed, nil
	}
	var t CashDrawerShiftState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CashDrawerShiftState) Ptr() *CashDrawerShiftState {
	return &c
}

// The summary of a closed cash drawer shift.
// This model contains only the money counted to start a cash drawer shift, counted
// at the end of the shift, and the amount that should be in the drawer at shift
// end based on summing all cash drawer shift events.
type CashDrawerShiftSummary struct {
	// The shift unique ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The shift current state.
	// See [CashDrawerShiftState](#type-cashdrawershiftstate) for possible values
	State *CashDrawerShiftState `json:"state,omitempty" url:"state,omitempty"`
	// The shift start time in ISO 8601 format.
	OpenedAt *string `json:"opened_at,omitempty" url:"opened_at,omitempty"`
	// The shift end time in ISO 8601 format.
	EndedAt *string `json:"ended_at,omitempty" url:"ended_at,omitempty"`
	// The shift close time in ISO 8601 format.
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// An employee free-text description of a cash drawer shift.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The amount of money in the cash drawer at the start of the shift. This
	// must be a positive amount.
	OpenedCashMoney *Money `json:"opened_cash_money,omitempty" url:"opened_cash_money,omitempty"`
	// The amount of money that should be in the cash drawer at the end of the
	// shift, based on the cash drawer events on the shift.
	// The amount is correct if all shift employees accurately recorded their
	// cash drawer shift events. Unrecorded events and events with the wrong amount
	// result in an incorrect expected_cash_money amount that can be negative.
	ExpectedCashMoney *Money `json:"expected_cash_money,omitempty" url:"expected_cash_money,omitempty"`
	// The amount of money found in the cash drawer at the end of the shift by
	// an auditing employee. The amount must be greater than or equal to zero.
	ClosedCashMoney *Money `json:"closed_cash_money,omitempty" url:"closed_cash_money,omitempty"`
	// The shift start time in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The shift updated at time in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the location the cash drawer shift belongs to.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CashDrawerShiftSummary) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CashDrawerShiftSummary) GetState() *CashDrawerShiftState {
	if c == nil {
		return nil
	}
	return c.State
}

func (c *CashDrawerShiftSummary) GetOpenedAt() *string {
	if c == nil {
		return nil
	}
	return c.OpenedAt
}

func (c *CashDrawerShiftSummary) GetEndedAt() *string {
	if c == nil {
		return nil
	}
	return c.EndedAt
}

func (c *CashDrawerShiftSummary) GetClosedAt() *string {
	if c == nil {
		return nil
	}
	return c.ClosedAt
}

func (c *CashDrawerShiftSummary) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CashDrawerShiftSummary) GetOpenedCashMoney() *Money {
	if c == nil {
		return nil
	}
	return c.OpenedCashMoney
}

func (c *CashDrawerShiftSummary) GetExpectedCashMoney() *Money {
	if c == nil {
		return nil
	}
	return c.ExpectedCashMoney
}

func (c *CashDrawerShiftSummary) GetClosedCashMoney() *Money {
	if c == nil {
		return nil
	}
	return c.ClosedCashMoney
}

func (c *CashDrawerShiftSummary) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CashDrawerShiftSummary) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CashDrawerShiftSummary) GetLocationID() *string {
	if c == nil {
		return nil
	}
	return c.LocationID
}

func (c *CashDrawerShiftSummary) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashDrawerShiftSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler CashDrawerShiftSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashDrawerShiftSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashDrawerShiftSummary) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a time period of availability.
type CatalogAvailabilityPeriod struct {
	// The start time of an availability period, specified in local time using partial-time
	// RFC 3339 format. For example, `8:30:00` for a period starting at 8:30 in the morning.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	StartLocalTime *string `json:"start_local_time,omitempty" url:"start_local_time,omitempty"`
	// The end time of an availability period, specified in local time using partial-time
	// RFC 3339 format. For example, `21:00:00` for a period ending at 9:00 in the evening.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	EndLocalTime *string `json:"end_local_time,omitempty" url:"end_local_time,omitempty"`
	// The day of the week for this availability period.
	// See [DayOfWeek](#type-dayofweek) for possible values
	DayOfWeek *DayOfWeek `json:"day_of_week,omitempty" url:"day_of_week,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogAvailabilityPeriod) GetStartLocalTime() *string {
	if c == nil {
		return nil
	}
	return c.StartLocalTime
}

func (c *CatalogAvailabilityPeriod) GetEndLocalTime() *string {
	if c == nil {
		return nil
	}
	return c.EndLocalTime
}

func (c *CatalogAvailabilityPeriod) GetDayOfWeek() *DayOfWeek {
	if c == nil {
		return nil
	}
	return c.DayOfWeek
}

func (c *CatalogAvailabilityPeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogAvailabilityPeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogAvailabilityPeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogAvailabilityPeriod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogAvailabilityPeriod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A category to which a `CatalogItem` instance belongs.
type CatalogCategory struct {
	// The category name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The IDs of images associated with this `CatalogCategory` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// The type of the category.
	// See [CatalogCategoryType](#type-catalogcategorytype) for possible values
	CategoryType *CatalogCategoryType `json:"category_type,omitempty" url:"category_type,omitempty"`
	// The ID of the parent category of this category instance.
	ParentCategory *CatalogObjectCategory `json:"parent_category,omitempty" url:"parent_category,omitempty"`
	// Indicates whether a category is a top level category, which does not have any parent_category.
	IsTopLevel *bool `json:"is_top_level,omitempty" url:"is_top_level,omitempty"`
	// A list of IDs representing channels, such as a Square Online site, where the category can be made visible.
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	// The IDs of the `CatalogAvailabilityPeriod` objects associated with the category.
	AvailabilityPeriodIDs []string `json:"availability_period_ids,omitempty" url:"availability_period_ids,omitempty"`
	// Indicates whether the category is visible (`true`) or hidden (`false`) on all of the seller's Square Online sites.
	OnlineVisibility *bool `json:"online_visibility,omitempty" url:"online_visibility,omitempty"`
	// The top-level category in a category hierarchy.
	RootCategory *string `json:"root_category,omitempty" url:"root_category,omitempty"`
	// The SEO data for a seller's Square Online store.
	EcomSeoData *CatalogEcomSeoData `json:"ecom_seo_data,omitempty" url:"ecom_seo_data,omitempty"`
	// The path from the category to its root category. The first node of the path is the parent of the category
	// and the last is the root category. The path is empty if the category is a root category.
	PathToRoot []*CategoryPathToRootNode `json:"path_to_root,omitempty" url:"path_to_root,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogCategory) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogCategory) GetImageIDs() []string {
	if c == nil {
		return nil
	}
	return c.ImageIDs
}

func (c *CatalogCategory) GetCategoryType() *CatalogCategoryType {
	if c == nil {
		return nil
	}
	return c.CategoryType
}

func (c *CatalogCategory) GetParentCategory() *CatalogObjectCategory {
	if c == nil {
		return nil
	}
	return c.ParentCategory
}

func (c *CatalogCategory) GetIsTopLevel() *bool {
	if c == nil {
		return nil
	}
	return c.IsTopLevel
}

func (c *CatalogCategory) GetChannels() []string {
	if c == nil {
		return nil
	}
	return c.Channels
}

func (c *CatalogCategory) GetAvailabilityPeriodIDs() []string {
	if c == nil {
		return nil
	}
	return c.AvailabilityPeriodIDs
}

func (c *CatalogCategory) GetOnlineVisibility() *bool {
	if c == nil {
		return nil
	}
	return c.OnlineVisibility
}

func (c *CatalogCategory) GetRootCategory() *string {
	if c == nil {
		return nil
	}
	return c.RootCategory
}

func (c *CatalogCategory) GetEcomSeoData() *CatalogEcomSeoData {
	if c == nil {
		return nil
	}
	return c.EcomSeoData
}

func (c *CatalogCategory) GetPathToRoot() []*CategoryPathToRootNode {
	if c == nil {
		return nil
	}
	return c.PathToRoot
}

func (c *CatalogCategory) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCategory(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCategory) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the type of a category.
type CatalogCategoryType string

const (
	CatalogCategoryTypeRegularCategory CatalogCategoryType = "REGULAR_CATEGORY"
	CatalogCategoryTypeMenuCategory    CatalogCategoryType = "MENU_CATEGORY"
	CatalogCategoryTypeKitchenCategory CatalogCategoryType = "KITCHEN_CATEGORY"
)

func NewCatalogCategoryTypeFromString(s string) (CatalogCategoryType, error) {
	switch s {
	case "REGULAR_CATEGORY":
		return CatalogCategoryTypeRegularCategory, nil
	case "MENU_CATEGORY":
		return CatalogCategoryTypeMenuCategory, nil
	case "KITCHEN_CATEGORY":
		return CatalogCategoryTypeKitchenCategory, nil
	}
	var t CatalogCategoryType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCategoryType) Ptr() *CatalogCategoryType {
	return &c
}

// Contains information defining a custom attribute. Custom attributes are
// intended to store additional information about a catalog object or to associate a
// catalog object with an entity in another system. Do not use custom attributes
// to store any sensitive information (personally identifiable information, card details, etc.).
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes)
type CatalogCustomAttributeDefinition struct {
	// The type of this custom attribute. Cannot be modified after creation.
	// Required.
	// See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
	Type CatalogCustomAttributeDefinitionType `json:"type" url:"type"`
	//	The name of this definition for API and seller-facing UI purposes.
	//
	// The name must be unique within the (merchant, application) pair. Required.
	// May not be empty and may not exceed 255 characters. Can be modified after creation.
	Name string `json:"name" url:"name"`
	// Seller-oriented description of the meaning of this Custom Attribute,
	// any constraints that the seller should observe, etc. May be displayed as a tooltip in Square UIs.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// __Read only.__ Contains information about the application that
	// created this custom attribute definition.
	SourceApplication *SourceApplication `json:"source_application,omitempty" url:"source_application,omitempty"`
	// The set of `CatalogObject` types that this custom atttribute may be applied to.
	// Currently, only `ITEM`, `ITEM_VARIATION`, `MODIFIER`, `MODIFIER_LIST`, and `CATEGORY` are allowed. At least one type must be included.
	// See [CatalogObjectType](#type-catalogobjecttype) for possible values
	AllowedObjectTypes []CatalogObjectType `json:"allowed_object_types" url:"allowed_object_types"`
	// The visibility of a custom attribute in seller-facing UIs (including Square Point
	// of Sale applications and Square Dashboard). May be modified.
	// See [CatalogCustomAttributeDefinitionSellerVisibility](#type-catalogcustomattributedefinitionsellervisibility) for possible values
	SellerVisibility *CatalogCustomAttributeDefinitionSellerVisibility `json:"seller_visibility,omitempty" url:"seller_visibility,omitempty"`
	// The visibility of a custom attribute to applications other than the application
	// that created the attribute.
	// See [CatalogCustomAttributeDefinitionAppVisibility](#type-catalogcustomattributedefinitionappvisibility) for possible values
	AppVisibility *CatalogCustomAttributeDefinitionAppVisibility `json:"app_visibility,omitempty" url:"app_visibility,omitempty"`
	// Optionally, populated when `type` = `STRING`, unset otherwise.
	StringConfig *CatalogCustomAttributeDefinitionStringConfig `json:"string_config,omitempty" url:"string_config,omitempty"`
	// Optionally, populated when `type` = `NUMBER`, unset otherwise.
	NumberConfig *CatalogCustomAttributeDefinitionNumberConfig `json:"number_config,omitempty" url:"number_config,omitempty"`
	// Populated when `type` is set to `SELECTION`, unset otherwise.
	SelectionConfig *CatalogCustomAttributeDefinitionSelectionConfig `json:"selection_config,omitempty" url:"selection_config,omitempty"`
	// The number of custom attributes that reference this
	// custom attribute definition. Set by the server in response to a ListCatalog
	// request with `include_counts` set to `true`.  If the actual count is greater
	// than 100, `custom_attribute_usage_count` will be set to `100`.
	CustomAttributeUsageCount *int `json:"custom_attribute_usage_count,omitempty" url:"custom_attribute_usage_count,omitempty"`
	// The name of the desired custom attribute key that can be used to access
	// the custom attribute value on catalog objects. Cannot be modified after the
	// custom attribute definition has been created.
	// Must be between 1 and 60 characters, and may only contain the characters `[a-zA-Z0-9_-]`.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogCustomAttributeDefinition) GetType() CatalogCustomAttributeDefinitionType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CatalogCustomAttributeDefinition) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CatalogCustomAttributeDefinition) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CatalogCustomAttributeDefinition) GetSourceApplication() *SourceApplication {
	if c == nil {
		return nil
	}
	return c.SourceApplication
}

func (c *CatalogCustomAttributeDefinition) GetAllowedObjectTypes() []CatalogObjectType {
	if c == nil {
		return nil
	}
	return c.AllowedObjectTypes
}

func (c *CatalogCustomAttributeDefinition) GetSellerVisibility() *CatalogCustomAttributeDefinitionSellerVisibility {
	if c == nil {
		return nil
	}
	return c.SellerVisibility
}

func (c *CatalogCustomAttributeDefinition) GetAppVisibility() *CatalogCustomAttributeDefinitionAppVisibility {
	if c == nil {
		return nil
	}
	return c.AppVisibility
}

func (c *CatalogCustomAttributeDefinition) GetStringConfig() *CatalogCustomAttributeDefinitionStringConfig {
	if c == nil {
		return nil
	}
	return c.StringConfig
}

func (c *CatalogCustomAttributeDefinition) GetNumberConfig() *CatalogCustomAttributeDefinitionNumberConfig {
	if c == nil {
		return nil
	}
	return c.NumberConfig
}

func (c *CatalogCustomAttributeDefinition) GetSelectionConfig() *CatalogCustomAttributeDefinitionSelectionConfig {
	if c == nil {
		return nil
	}
	return c.SelectionConfig
}

func (c *CatalogCustomAttributeDefinition) GetCustomAttributeUsageCount() *int {
	if c == nil {
		return nil
	}
	return c.CustomAttributeUsageCount
}

func (c *CatalogCustomAttributeDefinition) GetKey() *string {
	if c == nil {
		return nil
	}
	return c.Key
}

func (c *CatalogCustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to applications other than their
// creating application.
type CatalogCustomAttributeDefinitionAppVisibility string

const (
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden          CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly        CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_ONLY"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionAppVisibilityFromString(s string) (CatalogCustomAttributeDefinitionAppVisibility, error) {
	switch s {
	case "APP_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden, nil
	case "APP_VISIBILITY_READ_ONLY":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly, nil
	case "APP_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionAppVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionAppVisibility) Ptr() *CatalogCustomAttributeDefinitionAppVisibility {
	return &c
}

type CatalogCustomAttributeDefinitionNumberConfig struct {
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in number custom attribute values
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 5
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) GetPrecision() *int {
	if c == nil {
		return nil
	}
	return c.Precision
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionNumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionNumberConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration associated with `SELECTION`-type custom attribute definitions.
type CatalogCustomAttributeDefinitionSelectionConfig struct {
	// The maximum number of selections that can be set. The maximum value for this
	// attribute is 100. The default value is 1. The value can be modified, but changing the value will not
	// affect existing custom attribute values on objects. Clients need to
	// handle custom attributes with more selected values than allowed by this limit.
	MaxAllowedSelections *int `json:"max_allowed_selections,omitempty" url:"max_allowed_selections,omitempty"`
	// The set of valid `CatalogCustomAttributeSelections`. Up to a maximum of 100
	// selections can be defined. Can be modified.
	AllowedSelections []*CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection `json:"allowed_selections,omitempty" url:"allowed_selections,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) GetMaxAllowedSelections() *int {
	if c == nil {
		return nil
	}
	return c.MaxAllowedSelections
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) GetAllowedSelections() []*CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection {
	if c == nil {
		return nil
	}
	return c.AllowedSelections
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A named selection for this `SELECTION`-type custom attribute definition.
type CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection struct {
	// Unique ID set by Square.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Selection name, unique within `allowed_selections`.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) GetUID() *string {
	if c == nil {
		return nil
	}
	return c.UID
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to sellers in Square
// client applications, Square APIs or in Square UIs (including Square Point
// of Sale applications and Square Dashboard).
type CatalogCustomAttributeDefinitionSellerVisibility string

const (
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden          CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionSellerVisibilityFromString(s string) (CatalogCustomAttributeDefinitionSellerVisibility, error) {
	switch s {
	case "SELLER_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden, nil
	case "SELLER_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionSellerVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionSellerVisibility) Ptr() *CatalogCustomAttributeDefinitionSellerVisibility {
	return &c
}

// Configuration associated with Custom Attribute Definitions of type `STRING`.
type CatalogCustomAttributeDefinitionStringConfig struct {
	// If true, each Custom Attribute instance associated with this Custom Attribute
	// Definition must have a unique value within the seller's catalog. For
	// example, this may be used for a value like a SKU that should not be
	// duplicated within a seller's catalog. May not be modified after the
	// definition has been created.
	EnforceUniqueness *bool `json:"enforce_uniqueness,omitempty" url:"enforce_uniqueness,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionStringConfig) GetEnforceUniqueness() *bool {
	if c == nil {
		return nil
	}
	return c.EnforceUniqueness
}

func (c *CatalogCustomAttributeDefinitionStringConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionStringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionStringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionStringConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionStringConfig) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the possible types for a custom attribute.
type CatalogCustomAttributeDefinitionType string

const (
	CatalogCustomAttributeDefinitionTypeString    CatalogCustomAttributeDefinitionType = "STRING"
	CatalogCustomAttributeDefinitionTypeBoolean   CatalogCustomAttributeDefinitionType = "BOOLEAN"
	CatalogCustomAttributeDefinitionTypeNumber    CatalogCustomAttributeDefinitionType = "NUMBER"
	CatalogCustomAttributeDefinitionTypeSelection CatalogCustomAttributeDefinitionType = "SELECTION"
)

func NewCatalogCustomAttributeDefinitionTypeFromString(s string) (CatalogCustomAttributeDefinitionType, error) {
	switch s {
	case "STRING":
		return CatalogCustomAttributeDefinitionTypeString, nil
	case "BOOLEAN":
		return CatalogCustomAttributeDefinitionTypeBoolean, nil
	case "NUMBER":
		return CatalogCustomAttributeDefinitionTypeNumber, nil
	case "SELECTION":
		return CatalogCustomAttributeDefinitionTypeSelection, nil
	}
	var t CatalogCustomAttributeDefinitionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionType) Ptr() *CatalogCustomAttributeDefinitionType {
	return &c
}

// An instance of a custom attribute. Custom attributes can be defined and
// added to `ITEM` and `ITEM_VARIATION` type catalog objects.
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes).
type CatalogCustomAttributeValue struct {
	// The name of the custom attribute.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The string value of the custom attribute.  Populated if `type` = `STRING`.
	StringValue *string `json:"string_value,omitempty" url:"string_value,omitempty"`
	// The id of the [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition) this value belongs to.
	CustomAttributeDefinitionID *string `json:"custom_attribute_definition_id,omitempty" url:"custom_attribute_definition_id,omitempty"`
	// A copy of type from the associated `CatalogCustomAttributeDefinition`.
	// See [CatalogCustomAttributeDefinitionType](#type-catalogcustomattributedefinitiontype) for possible values
	Type *CatalogCustomAttributeDefinitionType `json:"type,omitempty" url:"type,omitempty"`
	// Populated if `type` = `NUMBER`. Contains a string
	// representation of a decimal number, using a `.` as the decimal separator.
	NumberValue *string `json:"number_value,omitempty" url:"number_value,omitempty"`
	// A `true` or `false` value. Populated if `type` = `BOOLEAN`.
	BooleanValue *bool `json:"boolean_value,omitempty" url:"boolean_value,omitempty"`
	// One or more choices from `allowed_selections`. Populated if `type` = `SELECTION`.
	SelectionUIDValues []string `json:"selection_uid_values,omitempty" url:"selection_uid_values,omitempty"`
	// If the associated `CatalogCustomAttributeDefinition` object is defined by another application, this key is prefixed by the defining application ID.
	// For example, if the CatalogCustomAttributeDefinition has a key attribute of "cocoa_brand" and the defining application ID is "abcd1234", this key is "abcd1234:cocoa_brand"
	// when the application making the request is different from the application defining the custom attribute definition. Otherwise, the key is simply "cocoa_brand".
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogCustomAttributeValue) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogCustomAttributeValue) GetStringValue() *string {
	if c == nil {
		return nil
	}
	return c.StringValue
}

func (c *CatalogCustomAttributeValue) GetCustomAttributeDefinitionID() *string {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinitionID
}

func (c *CatalogCustomAttributeValue) GetType() *CatalogCustomAttributeDefinitionType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CatalogCustomAttributeValue) GetNumberValue() *string {
	if c == nil {
		return nil
	}
	return c.NumberValue
}

func (c *CatalogCustomAttributeValue) GetBooleanValue() *bool {
	if c == nil {
		return nil
	}
	return c.BooleanValue
}

func (c *CatalogCustomAttributeValue) GetSelectionUIDValues() []string {
	if c == nil {
		return nil
	}
	return c.SelectionUIDValues
}

func (c *CatalogCustomAttributeValue) GetKey() *string {
	if c == nil {
		return nil
	}
	return c.Key
}

func (c *CatalogCustomAttributeValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeValue) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A discount applicable to items.
type CatalogDiscount struct {
	// The discount name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale.
	// See [CatalogDiscountType](#type-catalogdiscounttype) for possible values
	DiscountType *CatalogDiscountType `json:"discount_type,omitempty" url:"discount_type,omitempty"`
	// The percentage of the discount as a string representation of a decimal number, using a `.` as the decimal
	// separator and without a `%` sign. A value of `7.5` corresponds to `7.5%`. Specify a percentage of `0` if `discount_type`
	// is `VARIABLE_PERCENTAGE`.
	//
	// Do not use this field for amount-based or variable discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of the discount. Specify an amount of `0` if `discount_type` is `VARIABLE_AMOUNT`.
	//
	// Do not use this field for percentage-based or variable discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// Indicates whether a mobile staff member needs to enter their PIN to apply the
	// discount to a payment in the Square Point of Sale app.
	PinRequired *bool `json:"pin_required,omitempty" url:"pin_required,omitempty"`
	// The color of the discount display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor *string `json:"label_color,omitempty" url:"label_color,omitempty"`
	// Indicates whether this discount should reduce the price used to calculate tax.
	//
	// Most discounts should use `MODIFY_TAX_BASIS`. However, in some circumstances taxes must
	// be calculated based on an item's price, ignoring a particular discount. For example,
	// in many US jurisdictions, a manufacturer coupon or instant rebate reduces the price a
	// customer pays but does not reduce the sale price used to calculate how much sales tax is
	// due. In this case, the discount representing that manufacturer coupon should have
	// `DO_NOT_MODIFY_TAX_BASIS` for this field.
	//
	// If you are unsure whether you need to use this field, consult your tax professional.
	// See [CatalogDiscountModifyTaxBasis](#type-catalogdiscountmodifytaxbasis) for possible values
	ModifyTaxBasis *CatalogDiscountModifyTaxBasis `json:"modify_tax_basis,omitempty" url:"modify_tax_basis,omitempty"`
	// For a percentage discount, the maximum absolute value of the discount. For example, if a
	// 50% discount has a `maximum_amount_money` of $20, a $100 purchase will yield a $20 discount,
	// not a $50 discount.
	MaximumAmountMoney *Money `json:"maximum_amount_money,omitempty" url:"maximum_amount_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogDiscount) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogDiscount) GetDiscountType() *CatalogDiscountType {
	if c == nil {
		return nil
	}
	return c.DiscountType
}

func (c *CatalogDiscount) GetPercentage() *string {
	if c == nil {
		return nil
	}
	return c.Percentage
}

func (c *CatalogDiscount) GetAmountMoney() *Money {
	if c == nil {
		return nil
	}
	return c.AmountMoney
}

func (c *CatalogDiscount) GetPinRequired() *bool {
	if c == nil {
		return nil
	}
	return c.PinRequired
}

func (c *CatalogDiscount) GetLabelColor() *string {
	if c == nil {
		return nil
	}
	return c.LabelColor
}

func (c *CatalogDiscount) GetModifyTaxBasis() *CatalogDiscountModifyTaxBasis {
	if c == nil {
		return nil
	}
	return c.ModifyTaxBasis
}

func (c *CatalogDiscount) GetMaximumAmountMoney() *Money {
	if c == nil {
		return nil
	}
	return c.MaximumAmountMoney
}

func (c *CatalogDiscount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogDiscount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogDiscountModifyTaxBasis string

const (
	CatalogDiscountModifyTaxBasisModifyTaxBasis      CatalogDiscountModifyTaxBasis = "MODIFY_TAX_BASIS"
	CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis CatalogDiscountModifyTaxBasis = "DO_NOT_MODIFY_TAX_BASIS"
)

func NewCatalogDiscountModifyTaxBasisFromString(s string) (CatalogDiscountModifyTaxBasis, error) {
	switch s {
	case "MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisModifyTaxBasis, nil
	case "DO_NOT_MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis, nil
	}
	var t CatalogDiscountModifyTaxBasis
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountModifyTaxBasis) Ptr() *CatalogDiscountModifyTaxBasis {
	return &c
}

// How to apply a CatalogDiscount to a CatalogItem.
type CatalogDiscountType string

const (
	CatalogDiscountTypeFixedPercentage    CatalogDiscountType = "FIXED_PERCENTAGE"
	CatalogDiscountTypeFixedAmount        CatalogDiscountType = "FIXED_AMOUNT"
	CatalogDiscountTypeVariablePercentage CatalogDiscountType = "VARIABLE_PERCENTAGE"
	CatalogDiscountTypeVariableAmount     CatalogDiscountType = "VARIABLE_AMOUNT"
)

func NewCatalogDiscountTypeFromString(s string) (CatalogDiscountType, error) {
	switch s {
	case "FIXED_PERCENTAGE":
		return CatalogDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return CatalogDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return CatalogDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return CatalogDiscountTypeVariableAmount, nil
	}
	var t CatalogDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountType) Ptr() *CatalogDiscountType {
	return &c
}

// SEO data for for a seller's Square Online store.
type CatalogEcomSeoData struct {
	// The SEO title used for the Square Online store.
	PageTitle *string `json:"page_title,omitempty" url:"page_title,omitempty"`
	// The SEO description used for the Square Online store.
	PageDescription *string `json:"page_description,omitempty" url:"page_description,omitempty"`
	// The SEO permalink used for the Square Online store.
	Permalink *string `json:"permalink,omitempty" url:"permalink,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogEcomSeoData) GetPageTitle() *string {
	if c == nil {
		return nil
	}
	return c.PageTitle
}

func (c *CatalogEcomSeoData) GetPageDescription() *string {
	if c == nil {
		return nil
	}
	return c.PageDescription
}

func (c *CatalogEcomSeoData) GetPermalink() *string {
	if c == nil {
		return nil
	}
	return c.Permalink
}

func (c *CatalogEcomSeoData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogEcomSeoData) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogEcomSeoData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogEcomSeoData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogEcomSeoData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A mapping between a temporary client-supplied ID and a permanent server-generated ID.
//
// When calling [UpsertCatalogObject](api-endpoint:Catalog-UpsertCatalogObject) or
// [BatchUpsertCatalogObjects](api-endpoint:Catalog-BatchUpsertCatalogObjects) to
// create a [CatalogObject](entity:CatalogObject) instance, you can supply
// a temporary ID for the to-be-created object, especially when the object is to be referenced
// elsewhere in the same request body. This temporary ID can be any string unique within
// the call, but must be prefixed by "#".
//
// After the request is submitted and the object created, a permanent server-generated ID is assigned
// to the new object. The permanent ID is unique across the Square catalog.
type CatalogIDMapping struct {
	// The client-supplied temporary `#`-prefixed ID for a new `CatalogObject`.
	ClientObjectID *string `json:"client_object_id,omitempty" url:"client_object_id,omitempty"`
	// The permanent ID for the CatalogObject created by the server.
	ObjectID *string `json:"object_id,omitempty" url:"object_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogIDMapping) GetClientObjectID() *string {
	if c == nil {
		return nil
	}
	return c.ClientObjectID
}

func (c *CatalogIDMapping) GetObjectID() *string {
	if c == nil {
		return nil
	}
	return c.ObjectID
}

func (c *CatalogIDMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogIDMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogIDMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogIDMapping(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogIDMapping) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An image file to use in Square catalogs. It can be associated with
// `CatalogItem`, `CatalogItemVariation`, `CatalogCategory`, and `CatalogModifierList` objects.
// Only the images on items and item variations are exposed in Dashboard.
// Only the first image on an item is displayed in Square Point of Sale (SPOS).
// Images on items and variations are displayed through Square Online Store.
// Images on other object types are for use by 3rd party application developers.
type CatalogImage struct {
	// The internal name to identify this image in calls to the Square API.
	// This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	// It is not unique and should not be shown in a buyer facing context.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL of this image, generated by Square after an image is uploaded
	// using the [CreateCatalogImage](api-endpoint:Catalog-CreateCatalogImage) endpoint.
	// To modify the image, use the UpdateCatalogImage endpoint. Do not change the URL field.
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// A caption that describes what is shown in the image. Displayed in the
	// Square Online Store. This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	Caption *string `json:"caption,omitempty" url:"caption,omitempty"`
	// The immutable order ID for this image object created by the Photo Studio service in Square Online Store.
	PhotoStudioOrderID *string `json:"photo_studio_order_id,omitempty" url:"photo_studio_order_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogImage) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogImage) GetURL() *string {
	if c == nil {
		return nil
	}
	return c.URL
}

func (c *CatalogImage) GetCaption() *string {
	if c == nil {
		return nil
	}
	return c.Caption
}

func (c *CatalogImage) GetPhotoStudioOrderID() *string {
	if c == nil {
		return nil
	}
	return c.PhotoStudioOrderID
}

func (c *CatalogImage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogImage) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogImage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogImage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A [CatalogObject](entity:CatalogObject) instance of the `ITEM` type, also referred to as an item, in the catalog.
type CatalogItem struct {
	// The item's name. This is a searchable attribute for use in applicable query filters, its value must not be empty, and the length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item's description. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	//
	// Deprecated at 2022-07-20, this field is planned to retire in 6 months. You should migrate to use `description_html` to set the description
	// of the [CatalogItem](entity:CatalogItem) instance.  The `description` and `description_html` field values are kept in sync. If you try to
	// set the both fields, the `description_html` text value overwrites the `description` value. Updates in one field are also reflected in the other,
	// except for when you use an early version before Square API 2022-07-20 and `description_html` is set to blank, setting the `description` value to null
	// does not nullify `description_html`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The text of the item's display label in the Square Point of Sale app. Only up to the first five characters of the string are used.
	// This attribute is searchable, and its value length is of Unicode code points.
	Abbreviation *string `json:"abbreviation,omitempty" url:"abbreviation,omitempty"`
	// The color of the item's display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor *string `json:"label_color,omitempty" url:"label_color,omitempty"`
	// Indicates whether the item is taxable (`true`) or non-taxable (`false`). Default is `true`.
	IsTaxable *bool `json:"is_taxable,omitempty" url:"is_taxable,omitempty"`
	// The ID of the item's category, if any. Deprecated since 2023-12-13. Use `CatalogItem.categories`, instead.
	CategoryID *string `json:"category_id,omitempty" url:"category_id,omitempty"`
	// A set of IDs indicating the taxes enabled for
	// this item. When updating an item, any taxes listed here will be added to the item.
	// Taxes may also be added to or deleted from an item using `UpdateItemTaxes`.
	TaxIDs []string `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`
	// A set of `CatalogItemModifierListInfo` objects
	// representing the modifier lists that apply to this item, along with the overrides and min
	// and max limits that are specific to this item. Modifier lists
	// may also be added to or deleted from an item using `UpdateItemModifierLists`.
	ModifierListInfo []*CatalogItemModifierListInfo `json:"modifier_list_info,omitempty" url:"modifier_list_info,omitempty"`
	// A list of [CatalogItemVariation](entity:CatalogItemVariation) objects for this item. An item must have
	// at least one variation.
	Variations []*CatalogObject `json:"variations,omitempty" url:"variations,omitempty"`
	// The product type of the item. Once set, the `product_type` value cannot be modified.
	//
	// Items of the `LEGACY_SQUARE_ONLINE_SERVICE` and `LEGACY_SQUARE_ONLINE_MEMBERSHIP` product types can be updated
	// but cannot be created using the API.
	// See [CatalogItemProductType](#type-catalogitemproducttype) for possible values
	ProductType *CatalogItemProductType `json:"product_type,omitempty" url:"product_type,omitempty"`
	// If `false`, the Square Point of Sale app will present the `CatalogItem`'s
	// details screen immediately, allowing the merchant to choose `CatalogModifier`s
	// before adding the item to the cart.  This is the default behavior.
	//
	// If `true`, the Square Point of Sale app will immediately add the item to the cart with the pre-selected
	// modifiers, and merchants can edit modifiers by drilling down onto the item's details.
	//
	// Third-party clients are encouraged to implement similar behaviors.
	SkipModifierScreen *bool `json:"skip_modifier_screen,omitempty" url:"skip_modifier_screen,omitempty"`
	// List of item options IDs for this item. Used to manage and group item
	// variations in a specified order.
	//
	// Maximum: 6 item options.
	ItemOptions []*CatalogItemOptionForItem `json:"item_options,omitempty" url:"item_options,omitempty"`
	// Deprecated. A URI pointing to a published e-commerce product page for the Item.
	EcomURI *string `json:"ecom_uri,omitempty" url:"ecom_uri,omitempty"`
	// Deprecated. A comma-separated list of encoded URIs pointing to a set of published e-commerce images for the Item.
	EcomImageURIs []string `json:"ecom_image_uris,omitempty" url:"ecom_image_uris,omitempty"`
	// The IDs of images associated with this `CatalogItem` instance.
	// These images will be shown to customers in Square Online Store.
	// The first image will show up as the icon for this item in POS.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// A name to sort the item by. If this name is unspecified, namely, the `sort_name` field is absent, the regular `name` field is used for sorting.
	// Its value must not be empty.
	//
	// It is currently supported for sellers of the Japanese locale only.
	SortName *string `json:"sort_name,omitempty" url:"sort_name,omitempty"`
	// The list of categories.
	Categories []*CatalogObjectCategory `json:"categories,omitempty" url:"categories,omitempty"`
	// The item's description as expressed in valid HTML elements. The length of this field value, including those of HTML tags,
	// is of Unicode points. With application query filters, the text values of the HTML elements and attributes are searchable. Invalid or
	// unsupported HTML elements or attributes are ignored.
	//
	// Supported HTML elements include:
	// - `a`: Link. Supports linking to website URLs, email address, and telephone numbers.
	// - `b`, `strong`:  Bold text
	// - `br`: Line break
	// - `code`: Computer code
	// - `div`: Section
	// - `h1-h6`: Headings
	// - `i`, `em`: Italics
	// - `li`: List element
	// - `ol`: Numbered list
	// - `p`: Paragraph
	// - `ul`: Bullet list
	// - `u`: Underline
	//
	// Supported HTML attributes include:
	// - `align`: Alignment of the text content
	// - `href`: Link destination
	// - `rel`: Relationship between link's target and source
	// - `target`: Place to open the linked document
	DescriptionHTML *string `json:"description_html,omitempty" url:"description_html,omitempty"`
	// A server-generated plaintext version of the `description_html` field, without formatting tags.
	DescriptionPlaintext *string `json:"description_plaintext,omitempty" url:"description_plaintext,omitempty"`
	// A list of IDs representing channels, such as a Square Online site, where the item can be made visible or available.
	// This field is read only and cannot be edited.
	Channels []string `json:"channels,omitempty" url:"channels,omitempty"`
	// Indicates whether this item is archived (`true`) or not (`false`).
	IsArchived *bool `json:"is_archived,omitempty" url:"is_archived,omitempty"`
	// The SEO data for a seller's Square Online store.
	EcomSeoData *CatalogEcomSeoData `json:"ecom_seo_data,omitempty" url:"ecom_seo_data,omitempty"`
	// The food and beverage-specific details for the `FOOD_AND_BEV` item.
	FoodAndBeverageDetails *CatalogItemFoodAndBeverageDetails `json:"food_and_beverage_details,omitempty" url:"food_and_beverage_details,omitempty"`
	// The item's reporting category.
	ReportingCategory *CatalogObjectCategory `json:"reporting_category,omitempty" url:"reporting_category,omitempty"`
	// Indicates whether this item is alcoholic (`true`) or not (`false`).
	IsAlcoholic *bool `json:"is_alcoholic,omitempty" url:"is_alcoholic,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItem) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogItem) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CatalogItem) GetAbbreviation() *string {
	if c == nil {
		return nil
	}
	return c.Abbreviation
}

func (c *CatalogItem) GetLabelColor() *string {
	if c == nil {
		return nil
	}
	return c.LabelColor
}

func (c *CatalogItem) GetIsTaxable() *bool {
	if c == nil {
		return nil
	}
	return c.IsTaxable
}

func (c *CatalogItem) GetCategoryID() *string {
	if c == nil {
		return nil
	}
	return c.CategoryID
}

func (c *CatalogItem) GetTaxIDs() []string {
	if c == nil {
		return nil
	}
	return c.TaxIDs
}

func (c *CatalogItem) GetModifierListInfo() []*CatalogItemModifierListInfo {
	if c == nil {
		return nil
	}
	return c.ModifierListInfo
}

func (c *CatalogItem) GetVariations() []*CatalogObject {
	if c == nil {
		return nil
	}
	return c.Variations
}

func (c *CatalogItem) GetProductType() *CatalogItemProductType {
	if c == nil {
		return nil
	}
	return c.ProductType
}

func (c *CatalogItem) GetSkipModifierScreen() *bool {
	if c == nil {
		return nil
	}
	return c.SkipModifierScreen
}

func (c *CatalogItem) GetItemOptions() []*CatalogItemOptionForItem {
	if c == nil {
		return nil
	}
	return c.ItemOptions
}

func (c *CatalogItem) GetEcomURI() *string {
	if c == nil {
		return nil
	}
	return c.EcomURI
}

func (c *CatalogItem) GetEcomImageURIs() []string {
	if c == nil {
		return nil
	}
	return c.EcomImageURIs
}

func (c *CatalogItem) GetImageIDs() []string {
	if c == nil {
		return nil
	}
	return c.ImageIDs
}

func (c *CatalogItem) GetSortName() *string {
	if c == nil {
		return nil
	}
	return c.SortName
}

func (c *CatalogItem) GetCategories() []*CatalogObjectCategory {
	if c == nil {
		return nil
	}
	return c.Categories
}

func (c *CatalogItem) GetDescriptionHTML() *string {
	if c == nil {
		return nil
	}
	return c.DescriptionHTML
}

func (c *CatalogItem) GetDescriptionPlaintext() *string {
	if c == nil {
		return nil
	}
	return c.DescriptionPlaintext
}

func (c *CatalogItem) GetChannels() []string {
	if c == nil {
		return nil
	}
	return c.Channels
}

func (c *CatalogItem) GetIsArchived() *bool {
	if c == nil {
		return nil
	}
	return c.IsArchived
}

func (c *CatalogItem) GetEcomSeoData() *CatalogEcomSeoData {
	if c == nil {
		return nil
	}
	return c.EcomSeoData
}

func (c *CatalogItem) GetFoodAndBeverageDetails() *CatalogItemFoodAndBeverageDetails {
	if c == nil {
		return nil
	}
	return c.FoodAndBeverageDetails
}

func (c *CatalogItem) GetReportingCategory() *CatalogObjectCategory {
	if c == nil {
		return nil
	}
	return c.ReportingCategory
}

func (c *CatalogItem) GetIsAlcoholic() *bool {
	if c == nil {
		return nil
	}
	return c.IsAlcoholic
}

func (c *CatalogItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItem) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The food and beverage-specific details of a `FOOD_AND_BEV` item.
type CatalogItemFoodAndBeverageDetails struct {
	// The calorie count (in the unit of kcal) for the `FOOD_AND_BEV` type of items.
	CalorieCount *int `json:"calorie_count,omitempty" url:"calorie_count,omitempty"`
	// The dietary preferences for the `FOOD_AND_BEV` item.
	DietaryPreferences []*CatalogItemFoodAndBeverageDetailsDietaryPreference `json:"dietary_preferences,omitempty" url:"dietary_preferences,omitempty"`
	// The ingredients for the `FOOD_AND_BEV` type item.
	Ingredients []*CatalogItemFoodAndBeverageDetailsIngredient `json:"ingredients,omitempty" url:"ingredients,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemFoodAndBeverageDetails) GetCalorieCount() *int {
	if c == nil {
		return nil
	}
	return c.CalorieCount
}

func (c *CatalogItemFoodAndBeverageDetails) GetDietaryPreferences() []*CatalogItemFoodAndBeverageDetailsDietaryPreference {
	if c == nil {
		return nil
	}
	return c.DietaryPreferences
}

func (c *CatalogItemFoodAndBeverageDetails) GetIngredients() []*CatalogItemFoodAndBeverageDetailsIngredient {
	if c == nil {
		return nil
	}
	return c.Ingredients
}

func (c *CatalogItemFoodAndBeverageDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemFoodAndBeverageDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemFoodAndBeverageDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemFoodAndBeverageDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemFoodAndBeverageDetails) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Dietary preferences that can be assigned to an `FOOD_AND_BEV` item and its ingredients.
type CatalogItemFoodAndBeverageDetailsDietaryPreference struct {
	// The dietary preference type. Supported values include `STANDARD` and `CUSTOM` as specified in `FoodAndBeverageDetails.DietaryPreferenceType`.
	// See [DietaryPreferenceType](#type-dietarypreferencetype) for possible values
	Type *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType `json:"type,omitempty" url:"type,omitempty"`
	// The name of the dietary preference from a standard pre-defined list. This should be null if it's a custom dietary preference.
	// See [StandardDietaryPreference](#type-standarddietarypreference) for possible values
	StandardName *CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference `json:"standard_name,omitempty" url:"standard_name,omitempty"`
	// The name of a user-defined custom dietary preference. This should be null if it's a standard dietary preference.
	CustomName *string `json:"custom_name,omitempty" url:"custom_name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) GetType() *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) GetStandardName() *CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference {
	if c == nil {
		return nil
	}
	return c.StandardName
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) GetCustomName() *string {
	if c == nil {
		return nil
	}
	return c.CustomName
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemFoodAndBeverageDetailsDietaryPreference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemFoodAndBeverageDetailsDietaryPreference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemFoodAndBeverageDetailsDietaryPreference) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Standard dietary preferences for food and beverage items that are recommended on item creation.
type CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference string

const (
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceDairyFree  CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "DAIRY_FREE"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceGlutenFree CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "GLUTEN_FREE"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceHalal      CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "HALAL"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceKosher     CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "KOSHER"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceNutFree    CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "NUT_FREE"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegan      CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "VEGAN"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegetarian CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference = "VEGETARIAN"
)

func NewCatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceFromString(s string) (CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference, error) {
	switch s {
	case "DAIRY_FREE":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceDairyFree, nil
	case "GLUTEN_FREE":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceGlutenFree, nil
	case "HALAL":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceHalal, nil
	case "KOSHER":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceKosher, nil
	case "NUT_FREE":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceNutFree, nil
	case "VEGAN":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegan, nil
	case "VEGETARIAN":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreferenceVegetarian, nil
	}
	var t CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference) Ptr() *CatalogItemFoodAndBeverageDetailsDietaryPreferenceStandardDietaryPreference {
	return &c
}

// The type of dietary preference for the `FOOD_AND_BEV` type of items and integredients.
type CatalogItemFoodAndBeverageDetailsDietaryPreferenceType string

const (
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeStandard CatalogItemFoodAndBeverageDetailsDietaryPreferenceType = "STANDARD"
	CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeCustom   CatalogItemFoodAndBeverageDetailsDietaryPreferenceType = "CUSTOM"
)

func NewCatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeFromString(s string) (CatalogItemFoodAndBeverageDetailsDietaryPreferenceType, error) {
	switch s {
	case "STANDARD":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeStandard, nil
	case "CUSTOM":
		return CatalogItemFoodAndBeverageDetailsDietaryPreferenceTypeCustom, nil
	}
	var t CatalogItemFoodAndBeverageDetailsDietaryPreferenceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemFoodAndBeverageDetailsDietaryPreferenceType) Ptr() *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType {
	return &c
}

// Describes the ingredient used in a `FOOD_AND_BEV` item.
type CatalogItemFoodAndBeverageDetailsIngredient struct {
	// The dietary preference type of the ingredient. Supported values include `STANDARD` and `CUSTOM` as specified in `FoodAndBeverageDetails.DietaryPreferenceType`.
	// See [DietaryPreferenceType](#type-dietarypreferencetype) for possible values
	Type *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType `json:"type,omitempty" url:"type,omitempty"`
	// The name of the ingredient from a standard pre-defined list. This should be null if it's a custom dietary preference.
	// See [StandardIngredient](#type-standardingredient) for possible values
	StandardName *CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient `json:"standard_name,omitempty" url:"standard_name,omitempty"`
	// The name of a custom user-defined ingredient. This should be null if it's a standard dietary preference.
	CustomName *string `json:"custom_name,omitempty" url:"custom_name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) GetType() *CatalogItemFoodAndBeverageDetailsDietaryPreferenceType {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) GetStandardName() *CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient {
	if c == nil {
		return nil
	}
	return c.StandardName
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) GetCustomName() *string {
	if c == nil {
		return nil
	}
	return c.CustomName
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemFoodAndBeverageDetailsIngredient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemFoodAndBeverageDetailsIngredient(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemFoodAndBeverageDetailsIngredient) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Standard ingredients for food and beverage items that are recommended on item creation.
type CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient string

const (
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCelery      CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "CELERY"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCrustaceans CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "CRUSTACEANS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientEggs        CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "EGGS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientFish        CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "FISH"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientGluten      CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "GLUTEN"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientLupin       CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "LUPIN"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMilk        CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "MILK"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMolluscs    CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "MOLLUSCS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMustard     CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "MUSTARD"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientPeanuts     CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "PEANUTS"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSesame      CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "SESAME"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSoy         CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "SOY"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSulphites   CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "SULPHITES"
	CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientTreeNuts    CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient = "TREE_NUTS"
)

func NewCatalogItemFoodAndBeverageDetailsIngredientStandardIngredientFromString(s string) (CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient, error) {
	switch s {
	case "CELERY":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCelery, nil
	case "CRUSTACEANS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientCrustaceans, nil
	case "EGGS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientEggs, nil
	case "FISH":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientFish, nil
	case "GLUTEN":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientGluten, nil
	case "LUPIN":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientLupin, nil
	case "MILK":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMilk, nil
	case "MOLLUSCS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMolluscs, nil
	case "MUSTARD":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientMustard, nil
	case "PEANUTS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientPeanuts, nil
	case "SESAME":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSesame, nil
	case "SOY":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSoy, nil
	case "SULPHITES":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientSulphites, nil
	case "TREE_NUTS":
		return CatalogItemFoodAndBeverageDetailsIngredientStandardIngredientTreeNuts, nil
	}
	var t CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient) Ptr() *CatalogItemFoodAndBeverageDetailsIngredientStandardIngredient {
	return &c
}

// Controls how a modifier list is applied to a specific item. This object allows for item-specific customization of modifier list behavior
// and provides the ability to override global modifier list settings.
type CatalogItemModifierListInfo struct {
	// The ID of the `CatalogModifierList` controlled by this `CatalogModifierListInfo`.
	ModifierListID string `json:"modifier_list_id" url:"modifier_list_id"`
	// A set of `CatalogModifierOverride` objects that override default modifier settings for this item.
	ModifierOverrides []*CatalogModifierOverride `json:"modifier_overrides,omitempty" url:"modifier_overrides,omitempty"`
	// The minimum number of modifiers that must be selected from this modifier list.
	// Values:
	//
	// - 0: No selection is required.
	// - -1: Default value, the attribute was not set by the client. When `max_selected_modifiers` is
	// also -1, use the minimum and maximum selection values set on the `CatalogItemModifierList`.
	// - &gt;0: The required minimum modifier selections. This can be larger than the total `CatalogModifiers` when `allow_quantities` is enabled.
	// - &lt; -1: Invalid. Treated as no selection required.
	MinSelectedModifiers *int `json:"min_selected_modifiers,omitempty" url:"min_selected_modifiers,omitempty"`
	// The maximum number of modifiers that can be selected.
	// Values:
	//
	// - 0: No maximum limit.
	// - -1: Default value, the attribute was not set by the client. When `min_selected_modifiers` is
	// also -1, use the minimum and maximum selection values set on the `CatalogItemModifierList`.
	// - &gt;0: The maximum total modifier selections. This can be larger than the total `CatalogModifiers` when `allow_quantities` is enabled.
	// - &lt; -1: Invalid. Treated as no maximum limit.
	MaxSelectedModifiers *int `json:"max_selected_modifiers,omitempty" url:"max_selected_modifiers,omitempty"`
	// If `true`, enable this `CatalogModifierList`. The default value is `true`.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The position of this `CatalogItemModifierListInfo` object within the `modifier_list_info` list applied
	// to a `CatalogItem` instance.
	Ordinal                    *int        `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	AllowQuantities            interface{} `json:"allow_quantities,omitempty" url:"allow_quantities,omitempty"`
	IsConversational           interface{} `json:"is_conversational,omitempty" url:"is_conversational,omitempty"`
	HiddenFromCustomerOverride interface{} `json:"hidden_from_customer_override,omitempty" url:"hidden_from_customer_override,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemModifierListInfo) GetModifierListID() string {
	if c == nil {
		return ""
	}
	return c.ModifierListID
}

func (c *CatalogItemModifierListInfo) GetModifierOverrides() []*CatalogModifierOverride {
	if c == nil {
		return nil
	}
	return c.ModifierOverrides
}

func (c *CatalogItemModifierListInfo) GetMinSelectedModifiers() *int {
	if c == nil {
		return nil
	}
	return c.MinSelectedModifiers
}

func (c *CatalogItemModifierListInfo) GetMaxSelectedModifiers() *int {
	if c == nil {
		return nil
	}
	return c.MaxSelectedModifiers
}

func (c *CatalogItemModifierListInfo) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CatalogItemModifierListInfo) GetOrdinal() *int {
	if c == nil {
		return nil
	}
	return c.Ordinal
}

func (c *CatalogItemModifierListInfo) GetAllowQuantities() interface{} {
	if c == nil {
		return nil
	}
	return c.AllowQuantities
}

func (c *CatalogItemModifierListInfo) GetIsConversational() interface{} {
	if c == nil {
		return nil
	}
	return c.IsConversational
}

func (c *CatalogItemModifierListInfo) GetHiddenFromCustomerOverride() interface{} {
	if c == nil {
		return nil
	}
	return c.HiddenFromCustomerOverride
}

func (c *CatalogItemModifierListInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemModifierListInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemModifierListInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemModifierListInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemModifierListInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A group of variations for a `CatalogItem`.
type CatalogItemOption struct {
	// The item option's display name for the seller. Must be unique across
	// all item options. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item option's display name for the customer. This is a searchable attribute for use in applicable query filters.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The item option's human-readable description. Displayed in the Square
	// Point of Sale app for the seller and in the Online Store or on receipts for
	// the buyer. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// If true, display colors for entries in `values` when present.
	ShowColors *bool `json:"show_colors,omitempty" url:"show_colors,omitempty"`
	// A list of CatalogObjects containing the
	// `CatalogItemOptionValue`s for this item.
	Values []*CatalogObject `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemOption) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogItemOption) GetDisplayName() *string {
	if c == nil {
		return nil
	}
	return c.DisplayName
}

func (c *CatalogItemOption) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CatalogItemOption) GetShowColors() *bool {
	if c == nil {
		return nil
	}
	return c.ShowColors
}

func (c *CatalogItemOption) GetValues() []*CatalogObject {
	if c == nil {
		return nil
	}
	return c.Values
}

func (c *CatalogItemOption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOption) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

//	An option that can be assigned to an item.
//
// For example, a t-shirt item may offer a color option or a size option.
type CatalogItemOptionForItem struct {
	// The unique id of the item option, used to form the dimensions of the item option matrix in a specified order.
	ItemOptionID *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemOptionForItem) GetItemOptionID() *string {
	if c == nil {
		return nil
	}
	return c.ItemOptionID
}

func (c *CatalogItemOptionForItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionForItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionForItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionForItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionForItem) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An enumerated value that can link a
// `CatalogItemVariation` to an item option as one of
// its item option values.
type CatalogItemOptionValue struct {
	// Unique ID of the associated item option.
	ItemOptionID *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// Name of this item option value. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A human-readable description for the option value. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The HTML-supported hex color for the item option (e.g., "#ff8d4e85").
	// Only displayed if `show_colors` is enabled on the parent `ItemOption`. When
	// left unset, `color` defaults to white ("#ffffff") when `show_colors` is
	// enabled on the parent `ItemOption`.
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// Determines where this option value appears in a list of option values.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemOptionValue) GetItemOptionID() *string {
	if c == nil {
		return nil
	}
	return c.ItemOptionID
}

func (c *CatalogItemOptionValue) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogItemOptionValue) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CatalogItemOptionValue) GetColor() *string {
	if c == nil {
		return nil
	}
	return c.Color
}

func (c *CatalogItemOptionValue) GetOrdinal() *int {
	if c == nil {
		return nil
	}
	return c.Ordinal
}

func (c *CatalogItemOptionValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValue) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A `CatalogItemOptionValue` links an item variation to an item option as
// an item option value. For example, a t-shirt item may offer a color option and
// a size option. An item option value would represent each variation of t-shirt:
// For example, "Color:Red, Size:Small" or "Color:Blue, Size:Medium".
type CatalogItemOptionValueForItemVariation struct {
	// The unique id of an item option.
	ItemOptionID *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// The unique id of the selected value for the item option.
	ItemOptionValueID *string `json:"item_option_value_id,omitempty" url:"item_option_value_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemOptionValueForItemVariation) GetItemOptionID() *string {
	if c == nil {
		return nil
	}
	return c.ItemOptionID
}

func (c *CatalogItemOptionValueForItemVariation) GetItemOptionValueID() *string {
	if c == nil {
		return nil
	}
	return c.ItemOptionValueID
}

func (c *CatalogItemOptionValueForItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValueForItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValueForItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValueForItemVariation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValueForItemVariation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of a CatalogItem. Connect V2 only allows the creation of `REGULAR` or `APPOINTMENTS_SERVICE` items.
type CatalogItemProductType string

const (
	CatalogItemProductTypeRegular                      CatalogItemProductType = "REGULAR"
	CatalogItemProductTypeGiftCard                     CatalogItemProductType = "GIFT_CARD"
	CatalogItemProductTypeAppointmentsService          CatalogItemProductType = "APPOINTMENTS_SERVICE"
	CatalogItemProductTypeFoodAndBev                   CatalogItemProductType = "FOOD_AND_BEV"
	CatalogItemProductTypeEvent                        CatalogItemProductType = "EVENT"
	CatalogItemProductTypeDigital                      CatalogItemProductType = "DIGITAL"
	CatalogItemProductTypeDonation                     CatalogItemProductType = "DONATION"
	CatalogItemProductTypeLegacySquareOnlineService    CatalogItemProductType = "LEGACY_SQUARE_ONLINE_SERVICE"
	CatalogItemProductTypeLegacySquareOnlineMembership CatalogItemProductType = "LEGACY_SQUARE_ONLINE_MEMBERSHIP"
)

func NewCatalogItemProductTypeFromString(s string) (CatalogItemProductType, error) {
	switch s {
	case "REGULAR":
		return CatalogItemProductTypeRegular, nil
	case "GIFT_CARD":
		return CatalogItemProductTypeGiftCard, nil
	case "APPOINTMENTS_SERVICE":
		return CatalogItemProductTypeAppointmentsService, nil
	case "FOOD_AND_BEV":
		return CatalogItemProductTypeFoodAndBev, nil
	case "EVENT":
		return CatalogItemProductTypeEvent, nil
	case "DIGITAL":
		return CatalogItemProductTypeDigital, nil
	case "DONATION":
		return CatalogItemProductTypeDonation, nil
	case "LEGACY_SQUARE_ONLINE_SERVICE":
		return CatalogItemProductTypeLegacySquareOnlineService, nil
	case "LEGACY_SQUARE_ONLINE_MEMBERSHIP":
		return CatalogItemProductTypeLegacySquareOnlineMembership, nil
	}
	var t CatalogItemProductType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemProductType) Ptr() *CatalogItemProductType {
	return &c
}

// An item variation, representing a product for sale, in the Catalog object model. Each [item](entity:CatalogItem) must have at least one
// item variation and can have at most 250 item variations.
//
// An item variation can be sellable, stockable, or both if it has a unit of measure for its count for the sold number of the variation, the stocked
// number of the variation, or both. For example, when a variation representing wine is stocked and sold by the bottle, the variation is both
// stockable and sellable. But when a variation of the wine is sold by the glass, the sold units cannot be used as a measure of the stocked units. This by-the-glass
// variation is sellable, but not stockable. To accurately keep track of the wine's inventory count at any time, the sellable count must be
// converted to stockable count. Typically, the seller defines this unit conversion. For example, 1 bottle equals 5 glasses. The Square API exposes
// the `stockable_conversion` property on the variation to specify the conversion. Thus, when two glasses of the wine are sold, the sellable count
// decreases by 2, and the stockable count automatically decreases by 0.4 bottle according to the conversion.
type CatalogItemVariation struct {
	// The ID of the `CatalogItem` associated with this item variation.
	ItemID *string `json:"item_id,omitempty" url:"item_id,omitempty"`
	// The item variation's name. This is a searchable attribute for use in applicable query filters.
	//
	// Its value has a maximum length of 255 Unicode code points. However, when the parent [item](entity:CatalogItem)
	// uses [item options](entity:CatalogItemOption), this attribute is auto-generated, read-only, and can be
	// longer than 255 Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item variation's SKU, if any. This is a searchable attribute for use in applicable query filters.
	Sku *string `json:"sku,omitempty" url:"sku,omitempty"`
	// The universal product code (UPC) of the item variation, if any. This is a searchable attribute for use in applicable query filters.
	//
	// The value of this attribute should be a number of 12-14 digits long.  This restriction is enforced on the Square Seller Dashboard,
	// Square Point of Sale or Retail Point of Sale apps, where this attribute shows in the GTIN field. If a non-compliant UPC value is assigned
	// to this attribute using the API, the value is not editable on the Seller Dashboard, Square Point of Sale or Retail Point of Sale apps
	// unless it is updated to fit the expected format.
	Upc *string `json:"upc,omitempty" url:"upc,omitempty"`
	// The order in which this item variation should be displayed. This value is read-only. On writes, the ordinal
	// for each item variation within a parent `CatalogItem` is set according to the item variations's
	// position. On reads, the value is not guaranteed to be sequential or unique.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// Indicates whether the item variation's price is fixed or determined at the time
	// of sale.
	// See [CatalogPricingType](#type-catalogpricingtype) for possible values
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	// The item variation's price, if fixed pricing is used.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Per-location price and inventory overrides.
	LocationOverrides []*ItemVariationLocationOverrides `json:"location_overrides,omitempty" url:"location_overrides,omitempty"`
	// If `true`, inventory tracking is active for the variation.
	TrackInventory *bool `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	// Indicates whether the item variation displays an alert when its inventory quantity is less than or equal
	// to its `inventory_alert_threshold`.
	// See [InventoryAlertType](#type-inventoryalerttype) for possible values
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Arbitrary user metadata to associate with the item variation. This attribute value length is of Unicode code points.
	UserData *string `json:"user_data,omitempty" url:"user_data,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, then this is the duration of the service in milliseconds. For
	// example, a 30 minute appointment would have the value `1800000`, which is equal to
	// 30 (minutes) * 60 (seconds per minute) * 1000 (milliseconds per second).
	ServiceDuration *int64 `json:"service_duration,omitempty" url:"service_duration,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, a bool representing whether this service is available for booking.
	AvailableForBooking *bool `json:"available_for_booking,omitempty" url:"available_for_booking,omitempty"`
	// List of item option values associated with this item variation. Listed
	// in the same order as the item options of the parent item.
	ItemOptionValues []*CatalogItemOptionValueForItemVariation `json:"item_option_values,omitempty" url:"item_option_values,omitempty"`
	// ID of the ‘CatalogMeasurementUnit’ that is used to measure the quantity
	// sold of this item variation. If left unset, the item will be sold in
	// whole quantities.
	MeasurementUnitID *string `json:"measurement_unit_id,omitempty" url:"measurement_unit_id,omitempty"`
	// Whether this variation can be sold. The inventory count of a sellable variation indicates
	// the number of units available for sale. When a variation is both stockable and sellable,
	// its sellable inventory count can be smaller than or equal to its stockable count.
	Sellable *bool `json:"sellable,omitempty" url:"sellable,omitempty"`
	// Whether stock is counted directly on this variation (TRUE) or only on its components (FALSE).
	// When a variation is both stockable and sellable, the inventory count of a stockable variation keeps track of the number of units of this variation in stock
	// and is not an indicator of the number of units of the variation that can be sold.
	Stockable *bool `json:"stockable,omitempty" url:"stockable,omitempty"`
	// The IDs of images associated with this `CatalogItemVariation` instance.
	// These images will be shown to customers in Square Online Store.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// Tokens of employees that can perform the service represented by this variation. Only valid for
	// variations of type `APPOINTMENTS_SERVICE`.
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`
	// The unit conversion rule, as prescribed by the [CatalogStockConversion](entity:CatalogStockConversion) type,
	// that describes how this non-stockable (i.e., sellable/receivable) item variation is converted
	// to/from the stockable item variation sharing the same parent item. With the stock conversion,
	// you can accurately track inventory when an item variation is sold in one unit, but stocked in
	// another unit.
	StockableConversion *CatalogStockConversion `json:"stockable_conversion,omitempty" url:"stockable_conversion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogItemVariation) GetItemID() *string {
	if c == nil {
		return nil
	}
	return c.ItemID
}

func (c *CatalogItemVariation) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogItemVariation) GetSku() *string {
	if c == nil {
		return nil
	}
	return c.Sku
}

func (c *CatalogItemVariation) GetUpc() *string {
	if c == nil {
		return nil
	}
	return c.Upc
}

func (c *CatalogItemVariation) GetOrdinal() *int {
	if c == nil {
		return nil
	}
	return c.Ordinal
}

func (c *CatalogItemVariation) GetPricingType() *CatalogPricingType {
	if c == nil {
		return nil
	}
	return c.PricingType
}

func (c *CatalogItemVariation) GetPriceMoney() *Money {
	if c == nil {
		return nil
	}
	return c.PriceMoney
}

func (c *CatalogItemVariation) GetLocationOverrides() []*ItemVariationLocationOverrides {
	if c == nil {
		return nil
	}
	return c.LocationOverrides
}

func (c *CatalogItemVariation) GetTrackInventory() *bool {
	if c == nil {
		return nil
	}
	return c.TrackInventory
}

func (c *CatalogItemVariation) GetInventoryAlertType() *InventoryAlertType {
	if c == nil {
		return nil
	}
	return c.InventoryAlertType
}

func (c *CatalogItemVariation) GetInventoryAlertThreshold() *int64 {
	if c == nil {
		return nil
	}
	return c.InventoryAlertThreshold
}

func (c *CatalogItemVariation) GetUserData() *string {
	if c == nil {
		return nil
	}
	return c.UserData
}

func (c *CatalogItemVariation) GetServiceDuration() *int64 {
	if c == nil {
		return nil
	}
	return c.ServiceDuration
}

func (c *CatalogItemVariation) GetAvailableForBooking() *bool {
	if c == nil {
		return nil
	}
	return c.AvailableForBooking
}

func (c *CatalogItemVariation) GetItemOptionValues() []*CatalogItemOptionValueForItemVariation {
	if c == nil {
		return nil
	}
	return c.ItemOptionValues
}

func (c *CatalogItemVariation) GetMeasurementUnitID() *string {
	if c == nil {
		return nil
	}
	return c.MeasurementUnitID
}

func (c *CatalogItemVariation) GetSellable() *bool {
	if c == nil {
		return nil
	}
	return c.Sellable
}

func (c *CatalogItemVariation) GetStockable() *bool {
	if c == nil {
		return nil
	}
	return c.Stockable
}

func (c *CatalogItemVariation) GetImageIDs() []string {
	if c == nil {
		return nil
	}
	return c.ImageIDs
}

func (c *CatalogItemVariation) GetTeamMemberIDs() []string {
	if c == nil {
		return nil
	}
	return c.TeamMemberIDs
}

func (c *CatalogItemVariation) GetStockableConversion() *CatalogStockConversion {
	if c == nil {
		return nil
	}
	return c.StockableConversion
}

func (c *CatalogItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemVariation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemVariation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the unit used to measure a `CatalogItemVariation` and
// specifies the precision for decimal quantities.
type CatalogMeasurementUnit struct {
	// Indicates the unit used to measure the quantity of a catalog item variation.
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in quantities measured with this unit.
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 3
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogMeasurementUnit) GetMeasurementUnit() *MeasurementUnit {
	if c == nil {
		return nil
	}
	return c.MeasurementUnit
}

func (c *CatalogMeasurementUnit) GetPrecision() *int {
	if c == nil {
		return nil
	}
	return c.Precision
}

func (c *CatalogMeasurementUnit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogMeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogMeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogMeasurementUnit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogMeasurementUnit) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A modifier that can be applied to items at the time of sale. For example, a cheese modifier for a burger, or a flavor modifier for a serving of ice cream.
type CatalogModifier struct {
	// The modifier name.  This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The modifier price.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// When `true`, this modifier is selected by default when displaying the modifier list.
	// This setting can be overridden at the item level using `CatalogModifierListInfo.modifier_overrides`.
	OnByDefault *bool `json:"on_by_default,omitempty" url:"on_by_default,omitempty"`
	// Determines where this `CatalogModifier` appears in the `CatalogModifierList`.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// The ID of the `CatalogModifierList` associated with this modifier.
	ModifierListID *string `json:"modifier_list_id,omitempty" url:"modifier_list_id,omitempty"`
	// Location-specific price overrides.
	LocationOverrides []*ModifierLocationOverrides `json:"location_overrides,omitempty" url:"location_overrides,omitempty"`
	// The ID of the image associated with this `CatalogModifier` instance.
	// Currently this image is not displayed by Square, but is free to be displayed in 3rd party applications.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// When `true`, this modifier is hidden from online ordering channels. This setting can be overridden at the item level using `CatalogModifierListInfo.modifier_overrides`.
	HiddenOnline *bool `json:"hidden_online,omitempty" url:"hidden_online,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogModifier) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogModifier) GetPriceMoney() *Money {
	if c == nil {
		return nil
	}
	return c.PriceMoney
}

func (c *CatalogModifier) GetOnByDefault() *bool {
	if c == nil {
		return nil
	}
	return c.OnByDefault
}

func (c *CatalogModifier) GetOrdinal() *int {
	if c == nil {
		return nil
	}
	return c.Ordinal
}

func (c *CatalogModifier) GetModifierListID() *string {
	if c == nil {
		return nil
	}
	return c.ModifierListID
}

func (c *CatalogModifier) GetLocationOverrides() []*ModifierLocationOverrides {
	if c == nil {
		return nil
	}
	return c.LocationOverrides
}

func (c *CatalogModifier) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogModifier) GetHiddenOnline() *bool {
	if c == nil {
		return nil
	}
	return c.HiddenOnline
}

func (c *CatalogModifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifier) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A container for a list of modifiers, or a text-based modifier.
// For text-based modifiers, this represents text configuration for an item. (For example, custom text to print on a t-shirt).
// For non text-based modifiers, this represents a list of modifiers that can be applied to items at the time of sale.
// (For example, a list of condiments for a hot dog, or a list of ice cream flavors).
// Each element of the modifier list is a `CatalogObject` instance of the `MODIFIER` type.
type CatalogModifierList struct {
	// The name of the `CatalogModifierList` instance. This is a searchable attribute for use in applicable query filters, and its value length is of
	// Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The position of this `CatalogModifierList` within a list of `CatalogModifierList` instances.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// __Deprecated__: Indicates whether a single (`SINGLE`) modifier or multiple (`MULTIPLE`) modifiers can be selected. Use
	// `min_selected_modifiers` and `max_selected_modifiers` instead.
	// See [CatalogModifierListSelectionType](#type-catalogmodifierlistselectiontype) for possible values
	SelectionType *CatalogModifierListSelectionType `json:"selection_type,omitempty" url:"selection_type,omitempty"`
	// A non-empty list of `CatalogModifier` objects to be included in the `CatalogModifierList`,
	// for non text-based modifiers when the `modifier_type` attribute is `LIST`. Each element of this list
	// is a `CatalogObject` instance of the `MODIFIER` type, containing the following attributes:
	// ```
	// {
	// "id": "{{catalog_modifier_id}}",
	// "type": "MODIFIER",
	// "modifier_data": {{a CatalogModifier instance>}}
	// }
	// ```
	Modifiers []*CatalogObject `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The IDs of images associated with this `CatalogModifierList` instance.
	// Currently these images are not displayed on Square products, but may be displayed in 3rd-party applications.
	ImageIDs []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// When `true`, allows multiple quantities of the same modifier to be selected.
	AllowQuantities *bool `json:"allow_quantities,omitempty" url:"allow_quantities,omitempty"`
	// True if modifiers belonging to this list can be used conversationally.
	IsConversational *bool `json:"is_conversational,omitempty" url:"is_conversational,omitempty"`
	// The type of the modifier.
	//
	// When this `modifier_type` value is `TEXT`,  the `CatalogModifierList` represents a text-based modifier.
	// When this `modifier_type` value is `LIST`, the `CatalogModifierList` contains a list of `CatalogModifier` objects.
	// See [CatalogModifierListModifierType](#type-catalogmodifierlistmodifiertype) for possible values
	ModifierType *CatalogModifierListModifierType `json:"modifier_type,omitempty" url:"modifier_type,omitempty"`
	// The maximum length, in Unicode points, of the text string of the text-based modifier as represented by
	// this `CatalogModifierList` object with the `modifier_type` set to `TEXT`.
	MaxLength *int `json:"max_length,omitempty" url:"max_length,omitempty"`
	// Whether the text string must be a non-empty string (`true`) or not (`false`) for a text-based modifier
	// as represented by this `CatalogModifierList` object with the `modifier_type` set to `TEXT`.
	TextRequired *bool `json:"text_required,omitempty" url:"text_required,omitempty"`
	// A note for internal use by the business.
	//
	// For example, for a text-based modifier applied to a T-shirt item, if the buyer-supplied text of "Hello, Kitty!"
	// is to be printed on the T-shirt, this `internal_name` attribute can be "Use italic face" as
	// an instruction for the business to follow.
	//
	// For non text-based modifiers, this `internal_name` attribute can be
	// used to include SKUs, internal codes, or supplemental descriptions for internal use.
	InternalName *string `json:"internal_name,omitempty" url:"internal_name,omitempty"`
	// The minimum number of modifiers that must be selected from this list. The value can be overridden with `CatalogItemModifierListInfo`.
	//
	// Values:
	//
	// - 0: No selection is required.
	// - -1: Default value, the attribute was not set by the client. Treated as no selection required.
	// - &gt;0: The required minimum modifier selections. This can be larger than the total `CatalogModifiers` when `allow_quantities` is enabled.
	// - &lt; -1: Invalid. Treated as no selection required.
	MinSelectedModifiers *int64 `json:"min_selected_modifiers,omitempty" url:"min_selected_modifiers,omitempty"`
	// The maximum number of modifiers that must be selected from this list. The value can be overridden with `CatalogItemModifierListInfo`.
	//
	// Values:
	//
	// - 0: No maximum limit.
	// - -1: Default value, the attribute was not set by the client. Treated as no maximum limit.
	// - &gt;0: The maximum total modifier selections. This can be larger than the total `CatalogModifiers` when `allow_quantities` is enabled.
	// - &lt; -1: Invalid. Treated as no maximum limit.
	MaxSelectedModifiers *int64 `json:"max_selected_modifiers,omitempty" url:"max_selected_modifiers,omitempty"`
	// If `true`, modifiers from this list are hidden from customer receipts. The default value is `false`.
	// This setting can be overridden with `CatalogItemModifierListInfo.hidden_from_customer_override`.
	HiddenFromCustomer *bool `json:"hidden_from_customer,omitempty" url:"hidden_from_customer,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogModifierList) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogModifierList) GetOrdinal() *int {
	if c == nil {
		return nil
	}
	return c.Ordinal
}

func (c *CatalogModifierList) GetSelectionType() *CatalogModifierListSelectionType {
	if c == nil {
		return nil
	}
	return c.SelectionType
}

func (c *CatalogModifierList) GetModifiers() []*CatalogObject {
	if c == nil {
		return nil
	}
	return c.Modifiers
}

func (c *CatalogModifierList) GetImageIDs() []string {
	if c == nil {
		return nil
	}
	return c.ImageIDs
}

func (c *CatalogModifierList) GetAllowQuantities() *bool {
	if c == nil {
		return nil
	}
	return c.AllowQuantities
}

func (c *CatalogModifierList) GetIsConversational() *bool {
	if c == nil {
		return nil
	}
	return c.IsConversational
}

func (c *CatalogModifierList) GetModifierType() *CatalogModifierListModifierType {
	if c == nil {
		return nil
	}
	return c.ModifierType
}

func (c *CatalogModifierList) GetMaxLength() *int {
	if c == nil {
		return nil
	}
	return c.MaxLength
}

func (c *CatalogModifierList) GetTextRequired() *bool {
	if c == nil {
		return nil
	}
	return c.TextRequired
}

func (c *CatalogModifierList) GetInternalName() *string {
	if c == nil {
		return nil
	}
	return c.InternalName
}

func (c *CatalogModifierList) GetMinSelectedModifiers() *int64 {
	if c == nil {
		return nil
	}
	return c.MinSelectedModifiers
}

func (c *CatalogModifierList) GetMaxSelectedModifiers() *int64 {
	if c == nil {
		return nil
	}
	return c.MaxSelectedModifiers
}

func (c *CatalogModifierList) GetHiddenFromCustomer() *bool {
	if c == nil {
		return nil
	}
	return c.HiddenFromCustomer
}

func (c *CatalogModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierList) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the type of `CatalogModifierList`.
type CatalogModifierListModifierType string

const (
	CatalogModifierListModifierTypeList CatalogModifierListModifierType = "LIST"
	CatalogModifierListModifierTypeText CatalogModifierListModifierType = "TEXT"
)

func NewCatalogModifierListModifierTypeFromString(s string) (CatalogModifierListModifierType, error) {
	switch s {
	case "LIST":
		return CatalogModifierListModifierTypeList, nil
	case "TEXT":
		return CatalogModifierListModifierTypeText, nil
	}
	var t CatalogModifierListModifierType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogModifierListModifierType) Ptr() *CatalogModifierListModifierType {
	return &c
}

// Indicates whether a CatalogModifierList supports multiple selections.
type CatalogModifierListSelectionType string

const (
	CatalogModifierListSelectionTypeSingle   CatalogModifierListSelectionType = "SINGLE"
	CatalogModifierListSelectionTypeMultiple CatalogModifierListSelectionType = "MULTIPLE"
)

func NewCatalogModifierListSelectionTypeFromString(s string) (CatalogModifierListSelectionType, error) {
	switch s {
	case "SINGLE":
		return CatalogModifierListSelectionTypeSingle, nil
	case "MULTIPLE":
		return CatalogModifierListSelectionTypeMultiple, nil
	}
	var t CatalogModifierListSelectionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogModifierListSelectionType) Ptr() *CatalogModifierListSelectionType {
	return &c
}

// Options to control how to override the default behavior of the specified modifier.
type CatalogModifierOverride struct {
	// The ID of the `CatalogModifier` whose default behavior is being overridden.
	ModifierID string `json:"modifier_id" url:"modifier_id"`
	// __Deprecated__: Use `on_by_default_override` instead.
	OnByDefault          *bool       `json:"on_by_default,omitempty" url:"on_by_default,omitempty"`
	HiddenOnlineOverride interface{} `json:"hidden_online_override,omitempty" url:"hidden_online_override,omitempty"`
	OnByDefaultOverride  interface{} `json:"on_by_default_override,omitempty" url:"on_by_default_override,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogModifierOverride) GetModifierID() string {
	if c == nil {
		return ""
	}
	return c.ModifierID
}

func (c *CatalogModifierOverride) GetOnByDefault() *bool {
	if c == nil {
		return nil
	}
	return c.OnByDefault
}

func (c *CatalogModifierOverride) GetHiddenOnlineOverride() interface{} {
	if c == nil {
		return nil
	}
	return c.HiddenOnlineOverride
}

func (c *CatalogModifierOverride) GetOnByDefaultOverride() interface{} {
	if c == nil {
		return nil
	}
	return c.OnByDefaultOverride
}

func (c *CatalogModifierOverride) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierOverride(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierOverride) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The wrapper object for the catalog entries of a given object type.
//
// Depending on the `type` attribute value, a `CatalogObject` instance assumes a type-specific data to yield the corresponding type of catalog object.
//
// For example, if `type=ITEM`, the `CatalogObject` instance must have the ITEM-specific data set on the `item_data` attribute. The resulting `CatalogObject` instance is also a `CatalogItem` instance.
//
// In general, if `type=<OBJECT_TYPE>`, the `CatalogObject` instance must have the `<OBJECT_TYPE>`-specific data set on the `<object_type>_data` attribute. The resulting `CatalogObject` instance is also a `Catalog<ObjectType>` instance.
//
// For a more detailed discussion of the Catalog data model, please see the
// [Design a Catalog](https://developer.squareup.com/docs/catalog-api/design-a-catalog) guide.
type CatalogObject struct {
	Type                      string
	Item                      *CatalogObjectItem
	Image                     *CatalogObjectImage
	Category                  *CatalogObjectCategory
	ItemVariation             *CatalogObjectItemVariation
	Tax                       *CatalogObjectTax
	Discount                  *CatalogObjectDiscount
	ModifierList              *CatalogObjectModifierList
	Modifier                  *CatalogObjectModifier
	PricingRule               *CatalogObjectPricingRule
	ProductSet                *CatalogObjectProductSet
	TimePeriod                *CatalogObjectTimePeriod
	MeasurementUnit           *CatalogObjectMeasurementUnit
	SubscriptionPlanVariation *CatalogObjectSubscriptionPlanVariation
	ItemOption                *CatalogObjectItemOption
	ItemOptionVal             *CatalogObjectItemOptionValue
	CustomAttributeDefinition *CatalogObjectCustomAttributeDefinition
	QuickAmountsSettings      *CatalogObjectQuickAmountsSettings
	SubscriptionPlan          *CatalogObjectSubscriptionPlan
	AvailabilityPeriod        *CatalogObjectAvailabilityPeriod
}

func (c *CatalogObject) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CatalogObject) GetItem() *CatalogObjectItem {
	if c == nil {
		return nil
	}
	return c.Item
}

func (c *CatalogObject) GetImage() *CatalogObjectImage {
	if c == nil {
		return nil
	}
	return c.Image
}

func (c *CatalogObject) GetCategory() *CatalogObjectCategory {
	if c == nil {
		return nil
	}
	return c.Category
}

func (c *CatalogObject) GetItemVariation() *CatalogObjectItemVariation {
	if c == nil {
		return nil
	}
	return c.ItemVariation
}

func (c *CatalogObject) GetTax() *CatalogObjectTax {
	if c == nil {
		return nil
	}
	return c.Tax
}

func (c *CatalogObject) GetDiscount() *CatalogObjectDiscount {
	if c == nil {
		return nil
	}
	return c.Discount
}

func (c *CatalogObject) GetModifierList() *CatalogObjectModifierList {
	if c == nil {
		return nil
	}
	return c.ModifierList
}

func (c *CatalogObject) GetModifier() *CatalogObjectModifier {
	if c == nil {
		return nil
	}
	return c.Modifier
}

func (c *CatalogObject) GetPricingRule() *CatalogObjectPricingRule {
	if c == nil {
		return nil
	}
	return c.PricingRule
}

func (c *CatalogObject) GetProductSet() *CatalogObjectProductSet {
	if c == nil {
		return nil
	}
	return c.ProductSet
}

func (c *CatalogObject) GetTimePeriod() *CatalogObjectTimePeriod {
	if c == nil {
		return nil
	}
	return c.TimePeriod
}

func (c *CatalogObject) GetMeasurementUnit() *CatalogObjectMeasurementUnit {
	if c == nil {
		return nil
	}
	return c.MeasurementUnit
}

func (c *CatalogObject) GetSubscriptionPlanVariation() *CatalogObjectSubscriptionPlanVariation {
	if c == nil {
		return nil
	}
	return c.SubscriptionPlanVariation
}

func (c *CatalogObject) GetItemOption() *CatalogObjectItemOption {
	if c == nil {
		return nil
	}
	return c.ItemOption
}

func (c *CatalogObject) GetItemOptionVal() *CatalogObjectItemOptionValue {
	if c == nil {
		return nil
	}
	return c.ItemOptionVal
}

func (c *CatalogObject) GetCustomAttributeDefinition() *CatalogObjectCustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinition
}

func (c *CatalogObject) GetQuickAmountsSettings() *CatalogObjectQuickAmountsSettings {
	if c == nil {
		return nil
	}
	return c.QuickAmountsSettings
}

func (c *CatalogObject) GetSubscriptionPlan() *CatalogObjectSubscriptionPlan {
	if c == nil {
		return nil
	}
	return c.SubscriptionPlan
}

func (c *CatalogObject) GetAvailabilityPeriod() *CatalogObjectAvailabilityPeriod {
	if c == nil {
		return nil
	}
	return c.AvailabilityPeriod
}

func (c *CatalogObject) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "ITEM":
		value := new(CatalogObjectItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Item = value
	case "IMAGE":
		value := new(CatalogObjectImage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Image = value
	case "CATEGORY":
		value := new(CatalogObjectCategory)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Category = value
	case "ITEM_VARIATION":
		value := new(CatalogObjectItemVariation)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ItemVariation = value
	case "TAX":
		value := new(CatalogObjectTax)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Tax = value
	case "DISCOUNT":
		value := new(CatalogObjectDiscount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Discount = value
	case "MODIFIER_LIST":
		value := new(CatalogObjectModifierList)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ModifierList = value
	case "MODIFIER":
		value := new(CatalogObjectModifier)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Modifier = value
	case "PRICING_RULE":
		value := new(CatalogObjectPricingRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.PricingRule = value
	case "PRODUCT_SET":
		value := new(CatalogObjectProductSet)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ProductSet = value
	case "TIME_PERIOD":
		value := new(CatalogObjectTimePeriod)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.TimePeriod = value
	case "MEASUREMENT_UNIT":
		value := new(CatalogObjectMeasurementUnit)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.MeasurementUnit = value
	case "SUBSCRIPTION_PLAN_VARIATION":
		value := new(CatalogObjectSubscriptionPlanVariation)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.SubscriptionPlanVariation = value
	case "ITEM_OPTION":
		value := new(CatalogObjectItemOption)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ItemOption = value
	case "ITEM_OPTION_VAL":
		value := new(CatalogObjectItemOptionValue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ItemOptionVal = value
	case "CUSTOM_ATTRIBUTE_DEFINITION":
		value := new(CatalogObjectCustomAttributeDefinition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.CustomAttributeDefinition = value
	case "QUICK_AMOUNTS_SETTINGS":
		value := new(CatalogObjectQuickAmountsSettings)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.QuickAmountsSettings = value
	case "SUBSCRIPTION_PLAN":
		value := new(CatalogObjectSubscriptionPlan)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.SubscriptionPlan = value
	case "AVAILABILITY_PERIOD":
		value := new(CatalogObjectAvailabilityPeriod)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.AvailabilityPeriod = value
	}
	return nil
}

func (c CatalogObject) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Item != nil {
		return internal.MarshalJSONWithExtraProperty(c.Item, "type", "ITEM")
	}
	if c.Image != nil {
		return internal.MarshalJSONWithExtraProperty(c.Image, "type", "IMAGE")
	}
	if c.Category != nil {
		return internal.MarshalJSONWithExtraProperty(c.Category, "type", "CATEGORY")
	}
	if c.ItemVariation != nil {
		return internal.MarshalJSONWithExtraProperty(c.ItemVariation, "type", "ITEM_VARIATION")
	}
	if c.Tax != nil {
		return internal.MarshalJSONWithExtraProperty(c.Tax, "type", "TAX")
	}
	if c.Discount != nil {
		return internal.MarshalJSONWithExtraProperty(c.Discount, "type", "DISCOUNT")
	}
	if c.ModifierList != nil {
		return internal.MarshalJSONWithExtraProperty(c.ModifierList, "type", "MODIFIER_LIST")
	}
	if c.Modifier != nil {
		return internal.MarshalJSONWithExtraProperty(c.Modifier, "type", "MODIFIER")
	}
	if c.PricingRule != nil {
		return internal.MarshalJSONWithExtraProperty(c.PricingRule, "type", "PRICING_RULE")
	}
	if c.ProductSet != nil {
		return internal.MarshalJSONWithExtraProperty(c.ProductSet, "type", "PRODUCT_SET")
	}
	if c.TimePeriod != nil {
		return internal.MarshalJSONWithExtraProperty(c.TimePeriod, "type", "TIME_PERIOD")
	}
	if c.MeasurementUnit != nil {
		return internal.MarshalJSONWithExtraProperty(c.MeasurementUnit, "type", "MEASUREMENT_UNIT")
	}
	if c.SubscriptionPlanVariation != nil {
		return internal.MarshalJSONWithExtraProperty(c.SubscriptionPlanVariation, "type", "SUBSCRIPTION_PLAN_VARIATION")
	}
	if c.ItemOption != nil {
		return internal.MarshalJSONWithExtraProperty(c.ItemOption, "type", "ITEM_OPTION")
	}
	if c.ItemOptionVal != nil {
		return internal.MarshalJSONWithExtraProperty(c.ItemOptionVal, "type", "ITEM_OPTION_VAL")
	}
	if c.CustomAttributeDefinition != nil {
		return internal.MarshalJSONWithExtraProperty(c.CustomAttributeDefinition, "type", "CUSTOM_ATTRIBUTE_DEFINITION")
	}
	if c.QuickAmountsSettings != nil {
		return internal.MarshalJSONWithExtraProperty(c.QuickAmountsSettings, "type", "QUICK_AMOUNTS_SETTINGS")
	}
	if c.SubscriptionPlan != nil {
		return internal.MarshalJSONWithExtraProperty(c.SubscriptionPlan, "type", "SUBSCRIPTION_PLAN")
	}
	if c.AvailabilityPeriod != nil {
		return internal.MarshalJSONWithExtraProperty(c.AvailabilityPeriod, "type", "AVAILABILITY_PERIOD")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CatalogObjectVisitor interface {
	VisitItem(*CatalogObjectItem) error
	VisitImage(*CatalogObjectImage) error
	VisitCategory(*CatalogObjectCategory) error
	VisitItemVariation(*CatalogObjectItemVariation) error
	VisitTax(*CatalogObjectTax) error
	VisitDiscount(*CatalogObjectDiscount) error
	VisitModifierList(*CatalogObjectModifierList) error
	VisitModifier(*CatalogObjectModifier) error
	VisitPricingRule(*CatalogObjectPricingRule) error
	VisitProductSet(*CatalogObjectProductSet) error
	VisitTimePeriod(*CatalogObjectTimePeriod) error
	VisitMeasurementUnit(*CatalogObjectMeasurementUnit) error
	VisitSubscriptionPlanVariation(*CatalogObjectSubscriptionPlanVariation) error
	VisitItemOption(*CatalogObjectItemOption) error
	VisitItemOptionVal(*CatalogObjectItemOptionValue) error
	VisitCustomAttributeDefinition(*CatalogObjectCustomAttributeDefinition) error
	VisitQuickAmountsSettings(*CatalogObjectQuickAmountsSettings) error
	VisitSubscriptionPlan(*CatalogObjectSubscriptionPlan) error
	VisitAvailabilityPeriod(*CatalogObjectAvailabilityPeriod) error
}

func (c *CatalogObject) Accept(visitor CatalogObjectVisitor) error {
	if c.Item != nil {
		return visitor.VisitItem(c.Item)
	}
	if c.Image != nil {
		return visitor.VisitImage(c.Image)
	}
	if c.Category != nil {
		return visitor.VisitCategory(c.Category)
	}
	if c.ItemVariation != nil {
		return visitor.VisitItemVariation(c.ItemVariation)
	}
	if c.Tax != nil {
		return visitor.VisitTax(c.Tax)
	}
	if c.Discount != nil {
		return visitor.VisitDiscount(c.Discount)
	}
	if c.ModifierList != nil {
		return visitor.VisitModifierList(c.ModifierList)
	}
	if c.Modifier != nil {
		return visitor.VisitModifier(c.Modifier)
	}
	if c.PricingRule != nil {
		return visitor.VisitPricingRule(c.PricingRule)
	}
	if c.ProductSet != nil {
		return visitor.VisitProductSet(c.ProductSet)
	}
	if c.TimePeriod != nil {
		return visitor.VisitTimePeriod(c.TimePeriod)
	}
	if c.MeasurementUnit != nil {
		return visitor.VisitMeasurementUnit(c.MeasurementUnit)
	}
	if c.SubscriptionPlanVariation != nil {
		return visitor.VisitSubscriptionPlanVariation(c.SubscriptionPlanVariation)
	}
	if c.ItemOption != nil {
		return visitor.VisitItemOption(c.ItemOption)
	}
	if c.ItemOptionVal != nil {
		return visitor.VisitItemOptionVal(c.ItemOptionVal)
	}
	if c.CustomAttributeDefinition != nil {
		return visitor.VisitCustomAttributeDefinition(c.CustomAttributeDefinition)
	}
	if c.QuickAmountsSettings != nil {
		return visitor.VisitQuickAmountsSettings(c.QuickAmountsSettings)
	}
	if c.SubscriptionPlan != nil {
		return visitor.VisitSubscriptionPlan(c.SubscriptionPlan)
	}
	if c.AvailabilityPeriod != nil {
		return visitor.VisitAvailabilityPeriod(c.AvailabilityPeriod)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *CatalogObject) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Item != nil {
		fields = append(fields, "ITEM")
	}
	if c.Image != nil {
		fields = append(fields, "IMAGE")
	}
	if c.Category != nil {
		fields = append(fields, "CATEGORY")
	}
	if c.ItemVariation != nil {
		fields = append(fields, "ITEM_VARIATION")
	}
	if c.Tax != nil {
		fields = append(fields, "TAX")
	}
	if c.Discount != nil {
		fields = append(fields, "DISCOUNT")
	}
	if c.ModifierList != nil {
		fields = append(fields, "MODIFIER_LIST")
	}
	if c.Modifier != nil {
		fields = append(fields, "MODIFIER")
	}
	if c.PricingRule != nil {
		fields = append(fields, "PRICING_RULE")
	}
	if c.ProductSet != nil {
		fields = append(fields, "PRODUCT_SET")
	}
	if c.TimePeriod != nil {
		fields = append(fields, "TIME_PERIOD")
	}
	if c.MeasurementUnit != nil {
		fields = append(fields, "MEASUREMENT_UNIT")
	}
	if c.SubscriptionPlanVariation != nil {
		fields = append(fields, "SUBSCRIPTION_PLAN_VARIATION")
	}
	if c.ItemOption != nil {
		fields = append(fields, "ITEM_OPTION")
	}
	if c.ItemOptionVal != nil {
		fields = append(fields, "ITEM_OPTION_VAL")
	}
	if c.CustomAttributeDefinition != nil {
		fields = append(fields, "CUSTOM_ATTRIBUTE_DEFINITION")
	}
	if c.QuickAmountsSettings != nil {
		fields = append(fields, "QUICK_AMOUNTS_SETTINGS")
	}
	if c.SubscriptionPlan != nil {
		fields = append(fields, "SUBSCRIPTION_PLAN")
	}
	if c.AvailabilityPeriod != nil {
		fields = append(fields, "AVAILABILITY_PERIOD")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type CatalogObjectAvailabilityPeriod struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogAvailabilityPeriod`, set for CatalogObjects of type `AVAILABILITY_PERIOD`.
	AvailabilityPeriodData *CatalogAvailabilityPeriod `json:"availability_period_data,omitempty" url:"availability_period_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectAvailabilityPeriod) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectAvailabilityPeriod) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectAvailabilityPeriod) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectAvailabilityPeriod) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectAvailabilityPeriod) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectAvailabilityPeriod) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectAvailabilityPeriod) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectAvailabilityPeriod) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectAvailabilityPeriod) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectAvailabilityPeriod) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectAvailabilityPeriod) GetAvailabilityPeriodData() *CatalogAvailabilityPeriod {
	if c == nil {
		return nil
	}
	return c.AvailabilityPeriodData
}

func (c *CatalogObjectAvailabilityPeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectAvailabilityPeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectAvailabilityPeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectAvailabilityPeriod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectAvailabilityPeriod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectBase struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectBase) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectBase) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectBase) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectBase) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectBase) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectBase) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectBase) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectBase) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectBase) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectBase) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectBase) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectBase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A category that can be assigned to an item or a parent category that can be assigned
// to another category. For example, a clothing category can be assigned to a t-shirt item or
// be made as the parent category to the pants category.
type CatalogObjectCategory struct {
	// The ID of the object's category.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The order of the object within the context of the category.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// Structured data for a `CatalogCategory`, set for CatalogObjects of type `CATEGORY`.
	CategoryData *CatalogCategory `json:"category_data,omitempty" url:"category_data,omitempty"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectCategory) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CatalogObjectCategory) GetOrdinal() *int64 {
	if c == nil {
		return nil
	}
	return c.Ordinal
}

func (c *CatalogObjectCategory) GetCategoryData() *CatalogCategory {
	if c == nil {
		return nil
	}
	return c.CategoryData
}

func (c *CatalogObjectCategory) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectCategory) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectCategory) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectCategory) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectCategory) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectCategory) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectCategory) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectCategory) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectCategory) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectCategory) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectCategory(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectCategory) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectCustomAttributeDefinition struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogCustomAttributeDefinition`, set for CatalogObjects of type `CUSTOM_ATTRIBUTE_DEFINITION`.
	CustomAttributeDefinitionData *CatalogCustomAttributeDefinition `json:"custom_attribute_definition_data,omitempty" url:"custom_attribute_definition_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectCustomAttributeDefinition) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectCustomAttributeDefinition) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectCustomAttributeDefinition) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectCustomAttributeDefinition) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectCustomAttributeDefinition) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectCustomAttributeDefinition) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectCustomAttributeDefinition) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectCustomAttributeDefinition) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectCustomAttributeDefinition) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectCustomAttributeDefinition) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectCustomAttributeDefinition) GetCustomAttributeDefinitionData() *CatalogCustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinitionData
}

func (c *CatalogObjectCustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectCustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectCustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectCustomAttributeDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectCustomAttributeDefinition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectDiscount struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogDiscount`, set for CatalogObjects of type `DISCOUNT`.
	DiscountData *CatalogDiscount `json:"discount_data,omitempty" url:"discount_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectDiscount) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectDiscount) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectDiscount) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectDiscount) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectDiscount) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectDiscount) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectDiscount) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectDiscount) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectDiscount) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectDiscount) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectDiscount) GetDiscountData() *CatalogDiscount {
	if c == nil {
		return nil
	}
	return c.DiscountData
}

func (c *CatalogObjectDiscount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectDiscount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectImage struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogImage`, set for CatalogObjects of type `IMAGE`.
	ImageData *CatalogImage `json:"image_data,omitempty" url:"image_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectImage) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectImage) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectImage) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectImage) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectImage) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectImage) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectImage) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectImage) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectImage) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectImage) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectImage) GetImageData() *CatalogImage {
	if c == nil {
		return nil
	}
	return c.ImageData
}

func (c *CatalogObjectImage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectImage) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectImage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectImage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItem struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItem`, set for CatalogObjects of type `ITEM`.
	ItemData *CatalogItem `json:"item_data,omitempty" url:"item_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectItem) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectItem) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectItem) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectItem) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectItem) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectItem) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectItem) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectItem) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectItem) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectItem) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectItem) GetItemData() *CatalogItem {
	if c == nil {
		return nil
	}
	return c.ItemData
}

func (c *CatalogObjectItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItem) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItemOption struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItemOption`, set for CatalogObjects of type `ITEM_OPTION`.
	ItemOptionData *CatalogItemOption `json:"item_option_data,omitempty" url:"item_option_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectItemOption) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectItemOption) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectItemOption) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectItemOption) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectItemOption) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectItemOption) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectItemOption) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectItemOption) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectItemOption) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectItemOption) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectItemOption) GetItemOptionData() *CatalogItemOption {
	if c == nil {
		return nil
	}
	return c.ItemOptionData
}

func (c *CatalogObjectItemOption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItemOption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItemOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItemOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItemOption) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItemOptionValue struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItemOptionValue`, set for CatalogObjects of type `ITEM_OPTION_VAL`.
	ItemOptionValueData *CatalogItemOptionValue `json:"item_option_value_data,omitempty" url:"item_option_value_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectItemOptionValue) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectItemOptionValue) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectItemOptionValue) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectItemOptionValue) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectItemOptionValue) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectItemOptionValue) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectItemOptionValue) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectItemOptionValue) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectItemOptionValue) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectItemOptionValue) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectItemOptionValue) GetItemOptionValueData() *CatalogItemOptionValue {
	if c == nil {
		return nil
	}
	return c.ItemOptionValueData
}

func (c *CatalogObjectItemOptionValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItemOptionValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItemOptionValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItemOptionValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItemOptionValue) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectItemVariation struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogItemVariation`, set for CatalogObjects of type `ITEM_VARIATION`.
	ItemVariationData *CatalogItemVariation `json:"item_variation_data,omitempty" url:"item_variation_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectItemVariation) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectItemVariation) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectItemVariation) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectItemVariation) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectItemVariation) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectItemVariation) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectItemVariation) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectItemVariation) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectItemVariation) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectItemVariation) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectItemVariation) GetItemVariationData() *CatalogItemVariation {
	if c == nil {
		return nil
	}
	return c.ItemVariationData
}

func (c *CatalogObjectItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectItemVariation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectItemVariation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectMeasurementUnit struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogMeasurementUnit`, set for CatalogObjects of type `MEASUREMENT_UNIT`.
	MeasurementUnitData *CatalogMeasurementUnit `json:"measurement_unit_data,omitempty" url:"measurement_unit_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectMeasurementUnit) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectMeasurementUnit) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectMeasurementUnit) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectMeasurementUnit) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectMeasurementUnit) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectMeasurementUnit) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectMeasurementUnit) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectMeasurementUnit) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectMeasurementUnit) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectMeasurementUnit) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectMeasurementUnit) GetMeasurementUnitData() *CatalogMeasurementUnit {
	if c == nil {
		return nil
	}
	return c.MeasurementUnitData
}

func (c *CatalogObjectMeasurementUnit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectMeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectMeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectMeasurementUnit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectMeasurementUnit) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectModifier struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogModifier`, set for CatalogObjects of type `MODIFIER`.
	ModifierData *CatalogModifier `json:"modifier_data,omitempty" url:"modifier_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectModifier) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectModifier) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectModifier) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectModifier) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectModifier) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectModifier) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectModifier) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectModifier) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectModifier) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectModifier) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectModifier) GetModifierData() *CatalogModifier {
	if c == nil {
		return nil
	}
	return c.ModifierData
}

func (c *CatalogObjectModifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectModifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectModifier) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectModifierList struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogModifierList`, set for CatalogObjects of type `MODIFIER_LIST`.
	ModifierListData *CatalogModifierList `json:"modifier_list_data,omitempty" url:"modifier_list_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectModifierList) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectModifierList) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectModifierList) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectModifierList) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectModifierList) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectModifierList) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectModifierList) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectModifierList) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectModifierList) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectModifierList) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectModifierList) GetModifierListData() *CatalogModifierList {
	if c == nil {
		return nil
	}
	return c.ModifierListData
}

func (c *CatalogObjectModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectModifierList(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectModifierList) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectPricingRule struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogPricingRule`, set for CatalogObjects of type `PRICING_RULE`.
	// A `CatalogPricingRule` object often works with a `CatalogProductSet` object or a `CatalogTimePeriod` object.
	PricingRuleData *CatalogPricingRule `json:"pricing_rule_data,omitempty" url:"pricing_rule_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectPricingRule) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectPricingRule) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectPricingRule) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectPricingRule) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectPricingRule) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectPricingRule) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectPricingRule) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectPricingRule) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectPricingRule) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectPricingRule) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectPricingRule) GetPricingRuleData() *CatalogPricingRule {
	if c == nil {
		return nil
	}
	return c.PricingRuleData
}

func (c *CatalogObjectPricingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectPricingRule) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectPricingRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectPricingRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectPricingRule) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectProductSet struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogProductSet`, set for CatalogObjects of type `PRODUCT_SET`.
	ProductSetData *CatalogProductSet `json:"product_set_data,omitempty" url:"product_set_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectProductSet) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectProductSet) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectProductSet) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectProductSet) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectProductSet) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectProductSet) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectProductSet) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectProductSet) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectProductSet) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectProductSet) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectProductSet) GetProductSetData() *CatalogProductSet {
	if c == nil {
		return nil
	}
	return c.ProductSetData
}

func (c *CatalogObjectProductSet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectProductSet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectProductSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectProductSet(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectProductSet) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectQuickAmountsSettings struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogQuickAmountsSettings`, set for CatalogObjects of type `QUICK_AMOUNTS_SETTINGS`.
	QuickAmountsSettingsData *CatalogQuickAmountsSettings `json:"quick_amounts_settings_data,omitempty" url:"quick_amounts_settings_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectQuickAmountsSettings) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectQuickAmountsSettings) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectQuickAmountsSettings) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectQuickAmountsSettings) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectQuickAmountsSettings) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectQuickAmountsSettings) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectQuickAmountsSettings) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectQuickAmountsSettings) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectQuickAmountsSettings) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectQuickAmountsSettings) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectQuickAmountsSettings) GetQuickAmountsSettingsData() *CatalogQuickAmountsSettings {
	if c == nil {
		return nil
	}
	return c.QuickAmountsSettingsData
}

func (c *CatalogObjectQuickAmountsSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectQuickAmountsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectQuickAmountsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectQuickAmountsSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectQuickAmountsSettings) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A reference to a Catalog object at a specific version. In general this is
// used as an entry point into a graph of catalog objects, where the objects exist
// at a specific version.
type CatalogObjectReference struct {
	// The ID of the referenced object.
	ObjectID *string `json:"object_id,omitempty" url:"object_id,omitempty"`
	// The version of the object.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectReference) GetObjectID() *string {
	if c == nil {
		return nil
	}
	return c.ObjectID
}

func (c *CatalogObjectReference) GetCatalogVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.CatalogVersion
}

func (c *CatalogObjectReference) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectReference) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectReference) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectSubscriptionPlan struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogSubscriptionPlan`, set for CatalogObjects of type `SUBSCRIPTION_PLAN`.
	SubscriptionPlanData *CatalogSubscriptionPlan `json:"subscription_plan_data,omitempty" url:"subscription_plan_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectSubscriptionPlan) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectSubscriptionPlan) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectSubscriptionPlan) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectSubscriptionPlan) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectSubscriptionPlan) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectSubscriptionPlan) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectSubscriptionPlan) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectSubscriptionPlan) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectSubscriptionPlan) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectSubscriptionPlan) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectSubscriptionPlan) GetSubscriptionPlanData() *CatalogSubscriptionPlan {
	if c == nil {
		return nil
	}
	return c.SubscriptionPlanData
}

func (c *CatalogObjectSubscriptionPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectSubscriptionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectSubscriptionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectSubscriptionPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectSubscriptionPlan) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectSubscriptionPlanVariation struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogSubscriptionPlanVariation`, set for CatalogObjects of type `SUBSCRIPTION_PLAN_VARIATION`.
	SubscriptionPlanVariationData *CatalogSubscriptionPlanVariation `json:"subscription_plan_variation_data,omitempty" url:"subscription_plan_variation_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectSubscriptionPlanVariation) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectSubscriptionPlanVariation) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectSubscriptionPlanVariation) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectSubscriptionPlanVariation) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectSubscriptionPlanVariation) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectSubscriptionPlanVariation) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectSubscriptionPlanVariation) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectSubscriptionPlanVariation) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectSubscriptionPlanVariation) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectSubscriptionPlanVariation) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectSubscriptionPlanVariation) GetSubscriptionPlanVariationData() *CatalogSubscriptionPlanVariation {
	if c == nil {
		return nil
	}
	return c.SubscriptionPlanVariationData
}

func (c *CatalogObjectSubscriptionPlanVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectSubscriptionPlanVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectSubscriptionPlanVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectSubscriptionPlanVariation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectSubscriptionPlanVariation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectTax struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogTax`, set for CatalogObjects of type `TAX`.
	TaxData *CatalogTax `json:"tax_data,omitempty" url:"tax_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectTax) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectTax) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectTax) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectTax) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectTax) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectTax) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectTax) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectTax) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectTax) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectTax) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectTax) GetTaxData() *CatalogTax {
	if c == nil {
		return nil
	}
	return c.TaxData
}

func (c *CatalogObjectTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectTax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectTax) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogObjectTimePeriod struct {
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	ID string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1IDs []*CatalogV1ID `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIDs []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIDs []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageID *string `json:"image_id,omitempty" url:"image_id,omitempty"`
	// Structured data for a `CatalogTimePeriod`, set for CatalogObjects of type `TIME_PERIOD`.
	TimePeriodData *CatalogTimePeriod `json:"time_period_data,omitempty" url:"time_period_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogObjectTimePeriod) GetID() string {
	if c == nil {
		return ""
	}
	return c.ID
}

func (c *CatalogObjectTimePeriod) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogObjectTimePeriod) GetVersion() *int64 {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CatalogObjectTimePeriod) GetIsDeleted() *bool {
	if c == nil {
		return nil
	}
	return c.IsDeleted
}

func (c *CatalogObjectTimePeriod) GetCustomAttributeValues() map[string]*CatalogCustomAttributeValue {
	if c == nil {
		return nil
	}
	return c.CustomAttributeValues
}

func (c *CatalogObjectTimePeriod) GetCatalogV1IDs() []*CatalogV1ID {
	if c == nil {
		return nil
	}
	return c.CatalogV1IDs
}

func (c *CatalogObjectTimePeriod) GetPresentAtAllLocations() *bool {
	if c == nil {
		return nil
	}
	return c.PresentAtAllLocations
}

func (c *CatalogObjectTimePeriod) GetPresentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.PresentAtLocationIDs
}

func (c *CatalogObjectTimePeriod) GetAbsentAtLocationIDs() []string {
	if c == nil {
		return nil
	}
	return c.AbsentAtLocationIDs
}

func (c *CatalogObjectTimePeriod) GetImageID() *string {
	if c == nil {
		return nil
	}
	return c.ImageID
}

func (c *CatalogObjectTimePeriod) GetTimePeriodData() *CatalogTimePeriod {
	if c == nil {
		return nil
	}
	return c.TimePeriodData
}

func (c *CatalogObjectTimePeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObjectTimePeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObjectTimePeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObjectTimePeriod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObjectTimePeriod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Possible types of CatalogObjects returned from the catalog, each
// containing type-specific properties in the `*_data` field corresponding to the specified object type.
type CatalogObjectType string

const (
	CatalogObjectTypeItem                      CatalogObjectType = "ITEM"
	CatalogObjectTypeImage                     CatalogObjectType = "IMAGE"
	CatalogObjectTypeCategory                  CatalogObjectType = "CATEGORY"
	CatalogObjectTypeItemVariation             CatalogObjectType = "ITEM_VARIATION"
	CatalogObjectTypeTax                       CatalogObjectType = "TAX"
	CatalogObjectTypeDiscount                  CatalogObjectType = "DISCOUNT"
	CatalogObjectTypeModifierList              CatalogObjectType = "MODIFIER_LIST"
	CatalogObjectTypeModifier                  CatalogObjectType = "MODIFIER"
	CatalogObjectTypePricingRule               CatalogObjectType = "PRICING_RULE"
	CatalogObjectTypeProductSet                CatalogObjectType = "PRODUCT_SET"
	CatalogObjectTypeTimePeriod                CatalogObjectType = "TIME_PERIOD"
	CatalogObjectTypeMeasurementUnit           CatalogObjectType = "MEASUREMENT_UNIT"
	CatalogObjectTypeSubscriptionPlanVariation CatalogObjectType = "SUBSCRIPTION_PLAN_VARIATION"
	CatalogObjectTypeItemOption                CatalogObjectType = "ITEM_OPTION"
	CatalogObjectTypeItemOptionVal             CatalogObjectType = "ITEM_OPTION_VAL"
	CatalogObjectTypeCustomAttributeDefinition CatalogObjectType = "CUSTOM_ATTRIBUTE_DEFINITION"
	CatalogObjectTypeQuickAmountsSettings      CatalogObjectType = "QUICK_AMOUNTS_SETTINGS"
	CatalogObjectTypeSubscriptionPlan          CatalogObjectType = "SUBSCRIPTION_PLAN"
	CatalogObjectTypeAvailabilityPeriod        CatalogObjectType = "AVAILABILITY_PERIOD"
)

func NewCatalogObjectTypeFromString(s string) (CatalogObjectType, error) {
	switch s {
	case "ITEM":
		return CatalogObjectTypeItem, nil
	case "IMAGE":
		return CatalogObjectTypeImage, nil
	case "CATEGORY":
		return CatalogObjectTypeCategory, nil
	case "ITEM_VARIATION":
		return CatalogObjectTypeItemVariation, nil
	case "TAX":
		return CatalogObjectTypeTax, nil
	case "DISCOUNT":
		return CatalogObjectTypeDiscount, nil
	case "MODIFIER_LIST":
		return CatalogObjectTypeModifierList, nil
	case "MODIFIER":
		return CatalogObjectTypeModifier, nil
	case "PRICING_RULE":
		return CatalogObjectTypePricingRule, nil
	case "PRODUCT_SET":
		return CatalogObjectTypeProductSet, nil
	case "TIME_PERIOD":
		return CatalogObjectTypeTimePeriod, nil
	case "MEASUREMENT_UNIT":
		return CatalogObjectTypeMeasurementUnit, nil
	case "SUBSCRIPTION_PLAN_VARIATION":
		return CatalogObjectTypeSubscriptionPlanVariation, nil
	case "ITEM_OPTION":
		return CatalogObjectTypeItemOption, nil
	case "ITEM_OPTION_VAL":
		return CatalogObjectTypeItemOptionVal, nil
	case "CUSTOM_ATTRIBUTE_DEFINITION":
		return CatalogObjectTypeCustomAttributeDefinition, nil
	case "QUICK_AMOUNTS_SETTINGS":
		return CatalogObjectTypeQuickAmountsSettings, nil
	case "SUBSCRIPTION_PLAN":
		return CatalogObjectTypeSubscriptionPlan, nil
	case "AVAILABILITY_PERIOD":
		return CatalogObjectTypeAvailabilityPeriod, nil
	}
	var t CatalogObjectType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogObjectType) Ptr() *CatalogObjectType {
	return &c
}

// Defines how discounts are automatically applied to a set of items that match the pricing rule
// during the active time period.
type CatalogPricingRule struct {
	// User-defined name for the pricing rule. For example, "Buy one get one
	// free" or "10% off".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A list of unique IDs for the catalog time periods when
	// this pricing rule is in effect. If left unset, the pricing rule is always
	// in effect.
	TimePeriodIDs []string `json:"time_period_ids,omitempty" url:"time_period_ids,omitempty"`
	// Unique ID for the `CatalogDiscount` to take off
	// the price of all matched items.
	DiscountID *string `json:"discount_id,omitempty" url:"discount_id,omitempty"`
	// Unique ID for the `CatalogProductSet` that will be matched by this rule. A match rule
	// matches within the entire cart, and can match multiple times. This field will always be set.
	MatchProductsID *string `json:"match_products_id,omitempty" url:"match_products_id,omitempty"`
	// __Deprecated__: Please use the `exclude_products_id` field to apply
	// an exclude set instead. Exclude sets allow better control over quantity
	// ranges and offer more flexibility for which matched items receive a discount.
	//
	// `CatalogProductSet` to apply the pricing to.
	// An apply rule matches within the subset of the cart that fits the match rules (the match set).
	// An apply rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ApplyProductsID *string `json:"apply_products_id,omitempty" url:"apply_products_id,omitempty"`
	// `CatalogProductSet` to exclude from the pricing rule.
	// An exclude rule matches within the subset of the cart that fits the match rules (the match set).
	// An exclude rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ExcludeProductsID *string `json:"exclude_products_id,omitempty" url:"exclude_products_id,omitempty"`
	// Represents the date the Pricing Rule is valid from. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidFromDate *string `json:"valid_from_date,omitempty" url:"valid_from_date,omitempty"`
	// Represents the local time the pricing rule should be valid from. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidFromLocalTime *string `json:"valid_from_local_time,omitempty" url:"valid_from_local_time,omitempty"`
	// Represents the date the Pricing Rule is valid until. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidUntilDate *string `json:"valid_until_date,omitempty" url:"valid_until_date,omitempty"`
	// Represents the local time the pricing rule should be valid until. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidUntilLocalTime *string `json:"valid_until_local_time,omitempty" url:"valid_until_local_time,omitempty"`
	// If an `exclude_products_id` was given, controls which subset of matched
	// products is excluded from any discounts.
	//
	// Default value: `LEAST_EXPENSIVE`
	// See [ExcludeStrategy](#type-excludestrategy) for possible values
	ExcludeStrategy *ExcludeStrategy `json:"exclude_strategy,omitempty" url:"exclude_strategy,omitempty"`
	// The minimum order subtotal (before discounts or taxes are applied)
	// that must be met before this rule may be applied.
	MinimumOrderSubtotalMoney *Money `json:"minimum_order_subtotal_money,omitempty" url:"minimum_order_subtotal_money,omitempty"`
	// A list of IDs of customer groups, the members of which are eligible for discounts specified in this pricing rule.
	// Notice that a group ID is generated by the Customers API.
	// If this field is not set, the specified discount applies to matched products sold to anyone whether the buyer
	// has a customer profile created or not. If this `customer_group_ids_any` field is set, the specified discount
	// applies only to matched products sold to customers belonging to the specified customer groups.
	CustomerGroupIDsAny []string `json:"customer_group_ids_any,omitempty" url:"customer_group_ids_any,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogPricingRule) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogPricingRule) GetTimePeriodIDs() []string {
	if c == nil {
		return nil
	}
	return c.TimePeriodIDs
}

func (c *CatalogPricingRule) GetDiscountID() *string {
	if c == nil {
		return nil
	}
	return c.DiscountID
}

func (c *CatalogPricingRule) GetMatchProductsID() *string {
	if c == nil {
		return nil
	}
	return c.MatchProductsID
}

func (c *CatalogPricingRule) GetApplyProductsID() *string {
	if c == nil {
		return nil
	}
	return c.ApplyProductsID
}

func (c *CatalogPricingRule) GetExcludeProductsID() *string {
	if c == nil {
		return nil
	}
	return c.ExcludeProductsID
}

func (c *CatalogPricingRule) GetValidFromDate() *string {
	if c == nil {
		return nil
	}
	return c.ValidFromDate
}

func (c *CatalogPricingRule) GetValidFromLocalTime() *string {
	if c == nil {
		return nil
	}
	return c.ValidFromLocalTime
}

func (c *CatalogPricingRule) GetValidUntilDate() *string {
	if c == nil {
		return nil
	}
	return c.ValidUntilDate
}

func (c *CatalogPricingRule) GetValidUntilLocalTime() *string {
	if c == nil {
		return nil
	}
	return c.ValidUntilLocalTime
}

func (c *CatalogPricingRule) GetExcludeStrategy() *ExcludeStrategy {
	if c == nil {
		return nil
	}
	return c.ExcludeStrategy
}

func (c *CatalogPricingRule) GetMinimumOrderSubtotalMoney() *Money {
	if c == nil {
		return nil
	}
	return c.MinimumOrderSubtotalMoney
}

func (c *CatalogPricingRule) GetCustomerGroupIDsAny() []string {
	if c == nil {
		return nil
	}
	return c.CustomerGroupIDsAny
}

func (c *CatalogPricingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogPricingRule) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogPricingRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogPricingRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogPricingRule) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether the price of a CatalogItemVariation should be entered manually at the time of sale.
type CatalogPricingType string

const (
	CatalogPricingTypeFixedPricing    CatalogPricingType = "FIXED_PRICING"
	CatalogPricingTypeVariablePricing CatalogPricingType = "VARIABLE_PRICING"
)

func NewCatalogPricingTypeFromString(s string) (CatalogPricingType, error) {
	switch s {
	case "FIXED_PRICING":
		return CatalogPricingTypeFixedPricing, nil
	case "VARIABLE_PRICING":
		return CatalogPricingTypeVariablePricing, nil
	}
	var t CatalogPricingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogPricingType) Ptr() *CatalogPricingType {
	return &c
}

// Represents a collection of catalog objects for the purpose of applying a
// `PricingRule`. Including a catalog object will include all of its subtypes.
// For example, including a category in a product set will include all of its
// items and associated item variations in the product set. Including an item in
// a product set will also include its item variations.
type CatalogProductSet struct {
	// User-defined name for the product set. For example, "Clearance Items"
	// or "Winter Sale Items".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	//	Unique IDs for any `CatalogObject` included in this product set. Any
	//
	// number of these catalog objects can be in an order for a pricing rule to apply.
	//
	// This can be used with `product_ids_all` in a parent `CatalogProductSet` to
	// match groups of products for a bulk discount, such as a discount for an
	// entree and side combo.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIDsAny []string `json:"product_ids_any,omitempty" url:"product_ids_any,omitempty"`
	// Unique IDs for any `CatalogObject` included in this product set.
	// All objects in this set must be included in an order for a pricing rule to apply.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIDsAll []string `json:"product_ids_all,omitempty" url:"product_ids_all,omitempty"`
	// If set, there must be exactly this many items from `products_any` or `products_all`
	// in the cart for the discount to apply.
	//
	// Cannot be combined with either `quantity_min` or `quantity_max`.
	QuantityExact *int64 `json:"quantity_exact,omitempty" url:"quantity_exact,omitempty"`
	// If set, there must be at least this many items from `products_any` or `products_all`
	// in a cart for the discount to apply. See `quantity_exact`. Defaults to 0 if
	// `quantity_exact`, `quantity_min` and `quantity_max` are all unspecified.
	QuantityMin *int64 `json:"quantity_min,omitempty" url:"quantity_min,omitempty"`
	// If set, the pricing rule will apply to a maximum of this many items from
	// `products_any` or `products_all`.
	QuantityMax *int64 `json:"quantity_max,omitempty" url:"quantity_max,omitempty"`
	// If set to `true`, the product set will include every item in the catalog.
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	AllProducts *bool `json:"all_products,omitempty" url:"all_products,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogProductSet) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogProductSet) GetProductIDsAny() []string {
	if c == nil {
		return nil
	}
	return c.ProductIDsAny
}

func (c *CatalogProductSet) GetProductIDsAll() []string {
	if c == nil {
		return nil
	}
	return c.ProductIDsAll
}

func (c *CatalogProductSet) GetQuantityExact() *int64 {
	if c == nil {
		return nil
	}
	return c.QuantityExact
}

func (c *CatalogProductSet) GetQuantityMin() *int64 {
	if c == nil {
		return nil
	}
	return c.QuantityMin
}

func (c *CatalogProductSet) GetQuantityMax() *int64 {
	if c == nil {
		return nil
	}
	return c.QuantityMax
}

func (c *CatalogProductSet) GetAllProducts() *bool {
	if c == nil {
		return nil
	}
	return c.AllProducts
}

func (c *CatalogProductSet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogProductSet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogProductSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogProductSet(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogProductSet) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a Quick Amount in the Catalog.
type CatalogQuickAmount struct {
	// Represents the type of the Quick Amount.
	// See [CatalogQuickAmountType](#type-catalogquickamounttype) for possible values
	Type CatalogQuickAmountType `json:"type" url:"type"`
	// Represents the actual amount of the Quick Amount with Money type.
	Amount *Money `json:"amount" url:"amount"`
	// Describes the ranking of the Quick Amount provided by machine learning model, in the range [0, 100].
	// MANUAL type amount will always have score = 100.
	Score *int64 `json:"score,omitempty" url:"score,omitempty"`
	// The order in which this Quick Amount should be displayed.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogQuickAmount) GetType() CatalogQuickAmountType {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CatalogQuickAmount) GetAmount() *Money {
	if c == nil {
		return nil
	}
	return c.Amount
}

func (c *CatalogQuickAmount) GetScore() *int64 {
	if c == nil {
		return nil
	}
	return c.Score
}

func (c *CatalogQuickAmount) GetOrdinal() *int64 {
	if c == nil {
		return nil
	}
	return c.Ordinal
}

func (c *CatalogQuickAmount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines the type of a specific Quick Amount.
type CatalogQuickAmountType string

const (
	CatalogQuickAmountTypeQuickAmountTypeManual CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_MANUAL"
	CatalogQuickAmountTypeQuickAmountTypeAuto   CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_AUTO"
)

func NewCatalogQuickAmountTypeFromString(s string) (CatalogQuickAmountType, error) {
	switch s {
	case "QUICK_AMOUNT_TYPE_MANUAL":
		return CatalogQuickAmountTypeQuickAmountTypeManual, nil
	case "QUICK_AMOUNT_TYPE_AUTO":
		return CatalogQuickAmountTypeQuickAmountTypeAuto, nil
	}
	var t CatalogQuickAmountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountType) Ptr() *CatalogQuickAmountType {
	return &c
}

// A parent Catalog Object model represents a set of Quick Amounts and the settings control the amounts.
type CatalogQuickAmountsSettings struct {
	// Represents the option seller currently uses on Quick Amounts.
	// See [CatalogQuickAmountsSettingsOption](#type-catalogquickamountssettingsoption) for possible values
	Option CatalogQuickAmountsSettingsOption `json:"option" url:"option"`
	// Represents location's eligibility for auto amounts
	// The boolean should be consistent with whether there are AUTO amounts in the `amounts`.
	EligibleForAutoAmounts *bool `json:"eligible_for_auto_amounts,omitempty" url:"eligible_for_auto_amounts,omitempty"`
	// Represents a set of Quick Amounts at this location.
	Amounts []*CatalogQuickAmount `json:"amounts,omitempty" url:"amounts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogQuickAmountsSettings) GetOption() CatalogQuickAmountsSettingsOption {
	if c == nil {
		return ""
	}
	return c.Option
}

func (c *CatalogQuickAmountsSettings) GetEligibleForAutoAmounts() *bool {
	if c == nil {
		return nil
	}
	return c.EligibleForAutoAmounts
}

func (c *CatalogQuickAmountsSettings) GetAmounts() []*CatalogQuickAmount {
	if c == nil {
		return nil
	}
	return c.Amounts
}

func (c *CatalogQuickAmountsSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmountsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmountsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmountsSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmountsSettings) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines a seller's option on Quick Amounts feature.
type CatalogQuickAmountsSettingsOption string

const (
	CatalogQuickAmountsSettingsOptionDisabled CatalogQuickAmountsSettingsOption = "DISABLED"
	CatalogQuickAmountsSettingsOptionManual   CatalogQuickAmountsSettingsOption = "MANUAL"
	CatalogQuickAmountsSettingsOptionAuto     CatalogQuickAmountsSettingsOption = "AUTO"
)

func NewCatalogQuickAmountsSettingsOptionFromString(s string) (CatalogQuickAmountsSettingsOption, error) {
	switch s {
	case "DISABLED":
		return CatalogQuickAmountsSettingsOptionDisabled, nil
	case "MANUAL":
		return CatalogQuickAmountsSettingsOptionManual, nil
	case "AUTO":
		return CatalogQuickAmountsSettingsOptionAuto, nil
	}
	var t CatalogQuickAmountsSettingsOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountsSettingsOption) Ptr() *CatalogQuickAmountsSettingsOption {
	return &c
}

// Represents the rule of conversion between a stockable [CatalogItemVariation](entity:CatalogItemVariation)
// and a non-stockable sell-by or receive-by `CatalogItemVariation` that
// share the same underlying stock.
type CatalogStockConversion struct {
	// References to the stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// for this stock conversion. Selling, receiving or recounting the non-stockable `CatalogItemVariation`
	// defined with a stock conversion results in adjustments of this stockable `CatalogItemVariation`.
	// This immutable field must reference a stockable `CatalogItemVariation`
	// that shares the parent [CatalogItem](entity:CatalogItem) of the converted `CatalogItemVariation.`
	StockableItemVariationID string `json:"stockable_item_variation_id" url:"stockable_item_variation_id"`
	// The quantity of the stockable item variation (as identified by `stockable_item_variation_id`)
	// equivalent to the non-stockable item variation quantity (as specified in `nonstockable_quantity`)
	// as defined by this stock conversion.  It accepts a decimal number in a string format that can take
	// up to 10 digits before the decimal point and up to 5 digits after the decimal point.
	StockableQuantity string `json:"stockable_quantity" url:"stockable_quantity"`
	// The converted equivalent quantity of the non-stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// in its measurement unit. The `stockable_quantity` value and this `nonstockable_quantity` value together
	// define the conversion ratio between stockable item variation and the non-stockable item variation.
	// It accepts a decimal number in a string format that can take up to 10 digits before the decimal point
	// and up to 5 digits after the decimal point.
	NonstockableQuantity string `json:"nonstockable_quantity" url:"nonstockable_quantity"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogStockConversion) GetStockableItemVariationID() string {
	if c == nil {
		return ""
	}
	return c.StockableItemVariationID
}

func (c *CatalogStockConversion) GetStockableQuantity() string {
	if c == nil {
		return ""
	}
	return c.StockableQuantity
}

func (c *CatalogStockConversion) GetNonstockableQuantity() string {
	if c == nil {
		return ""
	}
	return c.NonstockableQuantity
}

func (c *CatalogStockConversion) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogStockConversion) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogStockConversion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogStockConversion(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogStockConversion) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a subscription plan. A subscription plan represents what you want to sell in a subscription model, and includes references to each of the associated subscription plan variations.
// For more information, see [Subscription Plans and Variations](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations).
type CatalogSubscriptionPlan struct {
	// The name of the plan.
	Name string `json:"name" url:"name"`
	// A list of SubscriptionPhase containing the [SubscriptionPhase](entity:SubscriptionPhase) for this plan.
	// This field it required. Not including this field will throw a REQUIRED_FIELD_MISSING error
	Phases []*SubscriptionPhase `json:"phases,omitempty" url:"phases,omitempty"`
	// The list of subscription plan variations available for this product
	SubscriptionPlanVariations []*CatalogObject `json:"subscription_plan_variations,omitempty" url:"subscription_plan_variations,omitempty"`
	// The list of IDs of `CatalogItems` that are eligible for subscription by this SubscriptionPlan's variations.
	EligibleItemIDs []string `json:"eligible_item_ids,omitempty" url:"eligible_item_ids,omitempty"`
	// The list of IDs of `CatalogCategory` that are eligible for subscription by this SubscriptionPlan's variations.
	EligibleCategoryIDs []string `json:"eligible_category_ids,omitempty" url:"eligible_category_ids,omitempty"`
	// If true, all items in the merchant's catalog are subscribable by this SubscriptionPlan.
	AllItems *bool `json:"all_items,omitempty" url:"all_items,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogSubscriptionPlan) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CatalogSubscriptionPlan) GetPhases() []*SubscriptionPhase {
	if c == nil {
		return nil
	}
	return c.Phases
}

func (c *CatalogSubscriptionPlan) GetSubscriptionPlanVariations() []*CatalogObject {
	if c == nil {
		return nil
	}
	return c.SubscriptionPlanVariations
}

func (c *CatalogSubscriptionPlan) GetEligibleItemIDs() []string {
	if c == nil {
		return nil
	}
	return c.EligibleItemIDs
}

func (c *CatalogSubscriptionPlan) GetEligibleCategoryIDs() []string {
	if c == nil {
		return nil
	}
	return c.EligibleCategoryIDs
}

func (c *CatalogSubscriptionPlan) GetAllItems() *bool {
	if c == nil {
		return nil
	}
	return c.AllItems
}

func (c *CatalogSubscriptionPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogSubscriptionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogSubscriptionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogSubscriptionPlan(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogSubscriptionPlan) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a subscription plan variation. A subscription plan variation represents how the subscription for a product or service is sold.
// For more information, see [Subscription Plans and Variations](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations).
type CatalogSubscriptionPlanVariation struct {
	// The name of the plan variation.
	Name string `json:"name" url:"name"`
	// A list containing each [SubscriptionPhase](entity:SubscriptionPhase) for this plan variation.
	Phases []*SubscriptionPhase `json:"phases" url:"phases"`
	// The id of the subscription plan, if there is one.
	SubscriptionPlanID *string `json:"subscription_plan_id,omitempty" url:"subscription_plan_id,omitempty"`
	// The day of the month the billing period starts.
	MonthlyBillingAnchorDate *int64 `json:"monthly_billing_anchor_date,omitempty" url:"monthly_billing_anchor_date,omitempty"`
	// Whether bills for this plan variation can be split for proration.
	CanProrate *bool `json:"can_prorate,omitempty" url:"can_prorate,omitempty"`
	// The ID of a "successor" plan variation to this one. If the field is set, and this object is disabled at all
	// locations, it indicates that this variation is deprecated and the object identified by the successor ID be used in
	// its stead.
	SuccessorPlanVariationID *string `json:"successor_plan_variation_id,omitempty" url:"successor_plan_variation_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogSubscriptionPlanVariation) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CatalogSubscriptionPlanVariation) GetPhases() []*SubscriptionPhase {
	if c == nil {
		return nil
	}
	return c.Phases
}

func (c *CatalogSubscriptionPlanVariation) GetSubscriptionPlanID() *string {
	if c == nil {
		return nil
	}
	return c.SubscriptionPlanID
}

func (c *CatalogSubscriptionPlanVariation) GetMonthlyBillingAnchorDate() *int64 {
	if c == nil {
		return nil
	}
	return c.MonthlyBillingAnchorDate
}

func (c *CatalogSubscriptionPlanVariation) GetCanProrate() *bool {
	if c == nil {
		return nil
	}
	return c.CanProrate
}

func (c *CatalogSubscriptionPlanVariation) GetSuccessorPlanVariationID() *string {
	if c == nil {
		return nil
	}
	return c.SuccessorPlanVariationID
}

func (c *CatalogSubscriptionPlanVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogSubscriptionPlanVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogSubscriptionPlanVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogSubscriptionPlanVariation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogSubscriptionPlanVariation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A tax applicable to an item.
type CatalogTax struct {
	// The tax's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Whether the tax is calculated based on a payment's subtotal or total.
	// See [TaxCalculationPhase](#type-taxcalculationphase) for possible values
	CalculationPhase *TaxCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Whether the tax is `ADDITIVE` or `INCLUSIVE`.
	// See [TaxInclusionType](#type-taxinclusiontype) for possible values
	InclusionType *TaxInclusionType `json:"inclusion_type,omitempty" url:"inclusion_type,omitempty"`
	// The percentage of the tax in decimal form, using a `'.'` as the decimal separator and without a `'%'` sign.
	// A value of `7.5` corresponds to 7.5%. For a location-specific tax rate, contact the tax authority of the location or a tax consultant.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// If `true`, the fee applies to custom amounts entered into the Square Point of Sale
	// app that are not associated with a particular `CatalogItem`.
	AppliesToCustomAmounts *bool `json:"applies_to_custom_amounts,omitempty" url:"applies_to_custom_amounts,omitempty"`
	// A Boolean flag to indicate whether the tax is displayed as enabled (`true`) in the Square Point of Sale app or not (`false`).
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The ID of a `CatalogProductSet` object. If set, the tax is applicable to all products in the product set.
	AppliesToProductSetID *string `json:"applies_to_product_set_id,omitempty" url:"applies_to_product_set_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogTax) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CatalogTax) GetCalculationPhase() *TaxCalculationPhase {
	if c == nil {
		return nil
	}
	return c.CalculationPhase
}

func (c *CatalogTax) GetInclusionType() *TaxInclusionType {
	if c == nil {
		return nil
	}
	return c.InclusionType
}

func (c *CatalogTax) GetPercentage() *string {
	if c == nil {
		return nil
	}
	return c.Percentage
}

func (c *CatalogTax) GetAppliesToCustomAmounts() *bool {
	if c == nil {
		return nil
	}
	return c.AppliesToCustomAmounts
}

func (c *CatalogTax) GetEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.Enabled
}

func (c *CatalogTax) GetAppliesToProductSetID() *string {
	if c == nil {
		return nil
	}
	return c.AppliesToProductSetID
}

func (c *CatalogTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTax) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a time period - either a single period or a repeating period.
type CatalogTimePeriod struct {
	// An iCalendar (RFC 5545) [event](https://tools.ietf.org/html/rfc5545#section-3.6.1), which
	// specifies the name, timing, duration and recurrence of this time period.
	//
	// Example:
	//
	// ```
	// DTSTART:20190707T180000
	// DURATION:P2H
	// RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR
	// ```
	//
	// Only `SUMMARY`, `DTSTART`, `DURATION` and `RRULE` fields are supported.
	// `DTSTART` must be in local (unzoned) time format. Note that while `BEGIN:VEVENT`
	// and `END:VEVENT` is not required in the request. The response will always
	// include them.
	Event *string `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogTimePeriod) GetEvent() *string {
	if c == nil {
		return nil
	}
	return c.Event
}

func (c *CatalogTimePeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTimePeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTimePeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTimePeriod(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTimePeriod) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A Square API V1 identifier of an item, including the object ID and its associated location ID.
type CatalogV1ID struct {
	// The ID for an object used in the Square API V1, if the object ID differs from the Square API V2 object ID.
	CatalogV1ID *string `json:"catalog_v1_id,omitempty" url:"catalog_v1_id,omitempty"`
	// The ID of the `Location` this Connect V1 ID is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogV1ID) GetCatalogV1ID() *string {
	if c == nil {
		return nil
	}
	return c.CatalogV1ID
}

func (c *CatalogV1ID) GetLocationID() *string {
	if c == nil {
		return nil
	}
	return c.LocationID
}

func (c *CatalogV1ID) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogV1ID) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogV1ID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogV1ID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogV1ID) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when the catalog is updated.
type CatalogVersionUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *CatalogVersionUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogVersionUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CatalogVersionUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CatalogVersionUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CatalogVersionUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CatalogVersionUpdatedEvent) GetData() *CatalogVersionUpdatedEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CatalogVersionUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogVersionUpdatedEventCatalogVersion struct {
	// Last modification timestamp in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogVersionUpdatedEventCatalogVersion) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CatalogVersionUpdatedEventCatalogVersion) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedEventCatalogVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedEventCatalogVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedEventCatalogVersion(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedEventCatalogVersion) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogVersionUpdatedEventData struct {
	// Name of the affected object’s type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// An object containing fields and values relevant to the event. Is absent if affected object was deleted.
	Object *CatalogVersionUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogVersionUpdatedEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CatalogVersionUpdatedEventData) GetObject() *CatalogVersionUpdatedEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CatalogVersionUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogVersionUpdatedEventObject struct {
	// The version of the object.
	CatalogVersion *CatalogVersionUpdatedEventCatalogVersion `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CatalogVersionUpdatedEventObject) GetCatalogVersion() *CatalogVersionUpdatedEventCatalogVersion {
	if c == nil {
		return nil
	}
	return c.CatalogVersion
}

func (c *CatalogVersionUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogVersionUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogVersionUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogVersionUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogVersionUpdatedEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A node in the path from a retrieved category to its root node.
type CategoryPathToRootNode struct {
	// The category's ID.
	CategoryID *string `json:"category_id,omitempty" url:"category_id,omitempty"`
	// The category's name.
	CategoryName *string `json:"category_name,omitempty" url:"category_name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CategoryPathToRootNode) GetCategoryID() *string {
	if c == nil {
		return nil
	}
	return c.CategoryID
}

func (c *CategoryPathToRootNode) GetCategoryName() *string {
	if c == nil {
		return nil
	}
	return c.CategoryName
}

func (c *CategoryPathToRootNode) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CategoryPathToRootNode) UnmarshalJSON(data []byte) error {
	type unmarshaler CategoryPathToRootNode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CategoryPathToRootNode(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CategoryPathToRootNode) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutOptions struct {
	// Indicates whether the payment allows tipping.
	AllowTipping *bool `json:"allow_tipping,omitempty" url:"allow_tipping,omitempty"`
	// The custom fields requesting information from the buyer.
	CustomFields []*CustomField `json:"custom_fields,omitempty" url:"custom_fields,omitempty"`
	// The ID of the subscription plan for the buyer to pay and subscribe.
	// For more information, see [Subscription Plan Checkout](https://developer.squareup.com/docs/checkout-api/subscription-plan-checkout).
	SubscriptionPlanID *string `json:"subscription_plan_id,omitempty" url:"subscription_plan_id,omitempty"`
	// The confirmation page URL to redirect the buyer to after Square processes the payment.
	RedirectURL *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	// The email address that buyers can use to contact the seller.
	MerchantSupportEmail *string `json:"merchant_support_email,omitempty" url:"merchant_support_email,omitempty"`
	// Indicates whether to include the address fields in the payment form.
	AskForShippingAddress *bool `json:"ask_for_shipping_address,omitempty" url:"ask_for_shipping_address,omitempty"`
	// The methods allowed for buyers during checkout.
	AcceptedPaymentMethods *AcceptedPaymentMethods `json:"accepted_payment_methods,omitempty" url:"accepted_payment_methods,omitempty"`
	// The amount of money that the developer is taking as a fee for facilitating the payment on behalf of the seller.
	//
	// The amount cannot be more than 90% of the total amount of the payment.
	//
	// The amount must be specified in the smallest denomination of the applicable currency (for example, US dollar amounts are specified in cents). For more information, see [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/common-data-types/working-with-monetary-amounts).
	//
	// The fee currency code must match the currency associated with the seller that is accepting the payment. The application must be from a developer account in the same country and using the same currency code as the seller. For more information about the application fee scenario, see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// To set this field, `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission is required. For more information, see [Permissions](https://developer.squareup.com/docs/payments-api/collect-fees/additional-considerations#permissions).
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// The fee associated with shipping to be applied to the `Order` as a service charge.
	ShippingFee *ShippingFee `json:"shipping_fee,omitempty" url:"shipping_fee,omitempty"`
	// Indicates whether to include the `Add coupon` section for the buyer to provide a Square marketing coupon in the payment form.
	EnableCoupon *bool `json:"enable_coupon,omitempty" url:"enable_coupon,omitempty"`
	// Indicates whether to include the `REWARDS` section for the buyer to opt in to loyalty, redeem rewards in the payment form, or both.
	EnableLoyalty *bool `json:"enable_loyalty,omitempty" url:"enable_loyalty,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CheckoutOptions) GetAllowTipping() *bool {
	if c == nil {
		return nil
	}
	return c.AllowTipping
}

func (c *CheckoutOptions) GetCustomFields() []*CustomField {
	if c == nil {
		return nil
	}
	return c.CustomFields
}

func (c *CheckoutOptions) GetSubscriptionPlanID() *string {
	if c == nil {
		return nil
	}
	return c.SubscriptionPlanID
}

func (c *CheckoutOptions) GetRedirectURL() *string {
	if c == nil {
		return nil
	}
	return c.RedirectURL
}

func (c *CheckoutOptions) GetMerchantSupportEmail() *string {
	if c == nil {
		return nil
	}
	return c.MerchantSupportEmail
}

func (c *CheckoutOptions) GetAskForShippingAddress() *bool {
	if c == nil {
		return nil
	}
	return c.AskForShippingAddress
}

func (c *CheckoutOptions) GetAcceptedPaymentMethods() *AcceptedPaymentMethods {
	if c == nil {
		return nil
	}
	return c.AcceptedPaymentMethods
}

func (c *CheckoutOptions) GetAppFeeMoney() *Money {
	if c == nil {
		return nil
	}
	return c.AppFeeMoney
}

func (c *CheckoutOptions) GetShippingFee() *ShippingFee {
	if c == nil {
		return nil
	}
	return c.ShippingFee
}

func (c *CheckoutOptions) GetEnableCoupon() *bool {
	if c == nil {
		return nil
	}
	return c.EnableCoupon
}

func (c *CheckoutOptions) GetEnableLoyalty() *bool {
	if c == nil {
		return nil
	}
	return c.EnableLoyalty
}

func (c *CheckoutOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckoutOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckoutOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckoutOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckoutOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CheckoutOptionsPaymentType string

const (
	CheckoutOptionsPaymentTypeCardPresent               CheckoutOptionsPaymentType = "CARD_PRESENT"
	CheckoutOptionsPaymentTypeManualCardEntry           CheckoutOptionsPaymentType = "MANUAL_CARD_ENTRY"
	CheckoutOptionsPaymentTypeFelicaID                  CheckoutOptionsPaymentType = "FELICA_ID"
	CheckoutOptionsPaymentTypeFelicaQuicpay             CheckoutOptionsPaymentType = "FELICA_QUICPAY"
	CheckoutOptionsPaymentTypeFelicaTransportationGroup CheckoutOptionsPaymentType = "FELICA_TRANSPORTATION_GROUP"
	CheckoutOptionsPaymentTypeFelicaAll                 CheckoutOptionsPaymentType = "FELICA_ALL"
	CheckoutOptionsPaymentTypePaypay                    CheckoutOptionsPaymentType = "PAYPAY"
	CheckoutOptionsPaymentTypeQrCode                    CheckoutOptionsPaymentType = "QR_CODE"
)

func NewCheckoutOptionsPaymentTypeFromString(s string) (CheckoutOptionsPaymentType, error) {
	switch s {
	case "CARD_PRESENT":
		return CheckoutOptionsPaymentTypeCardPresent, nil
	case "MANUAL_CARD_ENTRY":
		return CheckoutOptionsPaymentTypeManualCardEntry, nil
	case "FELICA_ID":
		return CheckoutOptionsPaymentTypeFelicaID, nil
	case "FELICA_QUICPAY":
		return CheckoutOptionsPaymentTypeFelicaQuicpay, nil
	case "FELICA_TRANSPORTATION_GROUP":
		return CheckoutOptionsPaymentTypeFelicaTransportationGroup, nil
	case "FELICA_ALL":
		return CheckoutOptionsPaymentTypeFelicaAll, nil
	case "PAYPAY":
		return CheckoutOptionsPaymentTypePaypay, nil
	case "QR_CODE":
		return CheckoutOptionsPaymentTypeQrCode, nil
	}
	var t CheckoutOptionsPaymentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CheckoutOptionsPaymentType) Ptr() *CheckoutOptionsPaymentType {
	return &c
}

type CollectedData struct {
	// The buyer's input text.
	InputText *string `json:"input_text,omitempty" url:"input_text,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CollectedData) GetInputText() *string {
	if c == nil {
		return nil
	}
	return c.InputText
}

func (c *CollectedData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CollectedData) UnmarshalJSON(data []byte) error {
	type unmarshaler CollectedData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CollectedData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CollectedData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConfirmationDecision struct {
	// The buyer's decision to the displayed terms.
	HasAgreed *bool `json:"has_agreed,omitempty" url:"has_agreed,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConfirmationDecision) GetHasAgreed() *bool {
	if c == nil {
		return nil
	}
	return c.HasAgreed
}

func (c *ConfirmationDecision) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConfirmationDecision) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfirmationDecision
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfirmationDecision(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfirmationDecision) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConfirmationOptions struct {
	// The title text to display in the confirmation screen flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The agreement details to display in the confirmation flow on the Terminal.
	Body string `json:"body" url:"body"`
	// The button text to display indicating the customer agrees to the displayed terms.
	AgreeButtonText string `json:"agree_button_text" url:"agree_button_text"`
	// The button text to display indicating the customer does not agree to the displayed terms.
	DisagreeButtonText *string `json:"disagree_button_text,omitempty" url:"disagree_button_text,omitempty"`
	// The result of the buyer’s actions when presented with the confirmation screen.
	Decision *ConfirmationDecision `json:"decision,omitempty" url:"decision,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConfirmationOptions) GetTitle() string {
	if c == nil {
		return ""
	}
	return c.Title
}

func (c *ConfirmationOptions) GetBody() string {
	if c == nil {
		return ""
	}
	return c.Body
}

func (c *ConfirmationOptions) GetAgreeButtonText() string {
	if c == nil {
		return ""
	}
	return c.AgreeButtonText
}

func (c *ConfirmationOptions) GetDisagreeButtonText() *string {
	if c == nil {
		return nil
	}
	return c.DisagreeButtonText
}

func (c *ConfirmationOptions) GetDecision() *ConfirmationDecision {
	if c == nil {
		return nil
	}
	return c.Decision
}

func (c *ConfirmationOptions) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConfirmationOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfirmationOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfirmationOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfirmationOptions) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the country associated with another entity, such as a business.
// Values are in [ISO 3166-1-alpha-2 format](http://www.iso.org/iso/home/standards/country_codes.htm).
type Country string

const (
	CountryZz Country = "ZZ"
	CountryAd Country = "AD"
	CountryAe Country = "AE"
	CountryAf Country = "AF"
	CountryAg Country = "AG"
	CountryAi Country = "AI"
	CountryAl Country = "AL"
	CountryAm Country = "AM"
	CountryAo Country = "AO"
	CountryAq Country = "AQ"
	CountryAr Country = "AR"
	CountryAs Country = "AS"
	CountryAt Country = "AT"
	CountryAu Country = "AU"
	CountryAw Country = "AW"
	CountryAx Country = "AX"
	CountryAz Country = "AZ"
	CountryBa Country = "BA"
	CountryBb Country = "BB"
	CountryBd Country = "BD"
	CountryBe Country = "BE"
	CountryBf Country = "BF"
	CountryBg Country = "BG"
	CountryBh Country = "BH"
	CountryBi Country = "BI"
	CountryBj Country = "BJ"
	CountryBl Country = "BL"
	CountryBm Country = "BM"
	CountryBn Country = "BN"
	CountryBo Country = "BO"
	CountryBq Country = "BQ"
	CountryBr Country = "BR"
	CountryBs Country = "BS"
	CountryBt Country = "BT"
	CountryBv Country = "BV"
	CountryBw Country = "BW"
	CountryBy Country = "BY"
	CountryBz Country = "BZ"
	CountryCa Country = "CA"
	CountryCc Country = "CC"
	CountryCd Country = "CD"
	CountryCf Country = "CF"
	CountryCg Country = "CG"
	CountryCh Country = "CH"
	CountryCi Country = "CI"
	CountryCk Country = "CK"
	CountryCl Country = "CL"
	CountryCm Country = "CM"
	CountryCn Country = "CN"
	CountryCo Country = "CO"
	CountryCr Country = "CR"
	CountryCu Country = "CU"
	CountryCv Country = "CV"
	CountryCw Country = "CW"
	CountryCx Country = "CX"
	CountryCy Country = "CY"
	CountryCz Country = "CZ"
	CountryDe Country = "DE"
	CountryDj Country = "DJ"
	CountryDk Country = "DK"
	CountryDm Country = "DM"
	CountryDo Country = "DO"
	CountryDz Country = "DZ"
	CountryEc Country = "EC"
	CountryEe Country = "EE"
	CountryEg Country = "EG"
	CountryEh Country = "EH"
	CountryEr Country = "ER"
	CountryEs Country = "ES"
	CountryEt Country = "ET"
	CountryFi Country = "FI"
	CountryFj Country = "FJ"
	CountryFk Country = "FK"
	CountryFm Country = "FM"
	CountryFo Country = "FO"
	CountryFr Country = "FR"
	CountryGa Country = "GA"
	CountryGb Country = "GB"
	CountryGd Country = "GD"
	CountryGe Country = "GE"
	CountryGf Country = "GF"
	CountryGg Country = "GG"
	CountryGh Country = "GH"
	CountryGi Country = "GI"
	CountryGl Country = "GL"
	CountryGm Country = "GM"
	CountryGn Country = "GN"
	CountryGp Country = "GP"
	CountryGq Country = "GQ"
	CountryGr Country = "GR"
	CountryGs Country = "GS"
	CountryGt Country = "GT"
	CountryGu Country = "GU"
	CountryGw Country = "GW"
	CountryGy Country = "GY"
	CountryHk Country = "HK"
	CountryHm Country = "HM"
	CountryHn Country = "HN"
	CountryHr Country = "HR"
	CountryHt Country = "HT"
	CountryHu Country = "HU"
	CountryID Country = "ID"
	CountryIe Country = "IE"
	CountryIl Country = "IL"
	CountryIm Country = "IM"
	CountryIn Country = "IN"
	CountryIo Country = "IO"
	CountryIq Country = "IQ"
	CountryIr Country = "IR"
	CountryIs Country = "IS"
	CountryIt Country = "IT"
	CountryJe Country = "JE"
	CountryJm Country = "JM"
	CountryJo Country = "JO"
	CountryJp Country = "JP"
	CountryKe Country = "KE"
	CountryKg Country = "KG"
	CountryKh Country = "KH"
	CountryKi Country = "KI"
	CountryKm Country = "KM"
	CountryKn Country = "KN"
	CountryKp Country = "KP"
	CountryKr Country = "KR"
	CountryKw Country = "KW"
	CountryKy Country = "KY"
	CountryKz Country = "KZ"
	CountryLa Country = "LA"
	CountryLb Country = "LB"
	CountryLc Country = "LC"
	CountryLi Country = "LI"
	CountryLk Country = "LK"
	CountryLr Country = "LR"
	CountryLs Country = "LS"
	CountryLt Country = "LT"
	CountryLu Country = "LU"
	CountryLv Country = "LV"
	CountryLy Country = "LY"
	CountryMa Country = "MA"
	CountryMc Country = "MC"
	CountryMd Country = "MD"
	CountryMe Country = "ME"
	CountryMf Country = "MF"
	CountryMg Country = "MG"
	CountryMh Country = "MH"
	CountryMk Country = "MK"
	CountryMl Country = "ML"
	CountryMm Country = "MM"
	CountryMn Country = "MN"
	CountryMo Country = "MO"
	CountryMp Country = "MP"
	CountryMq Country = "MQ"
	CountryMr Country = "MR"
	CountryMs Country = "MS"
	CountryMt Country = "MT"
	CountryMu Country = "MU"
	CountryMv Country = "MV"
	CountryMw Country = "MW"
	CountryMx Country = "MX"
	CountryMy Country = "MY"
	CountryMz Country = "MZ"
	CountryNa Country = "NA"
	CountryNc Country = "NC"
	CountryNe Country = "NE"
	CountryNf Country = "NF"
	CountryNg Country = "NG"
	CountryNi Country = "NI"
	CountryNl Country = "NL"
	CountryNo Country = "NO"
	CountryNp Country = "NP"
	CountryNr Country = "NR"
	CountryNu Country = "NU"
	CountryNz Country = "NZ"
	CountryOm Country = "OM"
	CountryPa Country = "PA"
	CountryPe Country = "PE"
	CountryPf Country = "PF"
	CountryPg Country = "PG"
	CountryPh Country = "PH"
	CountryPk Country = "PK"
	CountryPl Country = "PL"
	CountryPm Country = "PM"
	CountryPn Country = "PN"
	CountryPr Country = "PR"
	CountryPs Country = "PS"
	CountryPt Country = "PT"
	CountryPw Country = "PW"
	CountryPy Country = "PY"
	CountryQa Country = "QA"
	CountryRe Country = "RE"
	CountryRo Country = "RO"
	CountryRs Country = "RS"
	CountryRu Country = "RU"
	CountryRw Country = "RW"
	CountrySa Country = "SA"
	CountrySb Country = "SB"
	CountrySc Country = "SC"
	CountrySd Country = "SD"
	CountrySe Country = "SE"
	CountrySg Country = "SG"
	CountrySh Country = "SH"
	CountrySi Country = "SI"
	CountrySj Country = "SJ"
	CountrySk Country = "SK"
	CountrySl Country = "SL"
	CountrySm Country = "SM"
	CountrySn Country = "SN"
	CountrySo Country = "SO"
	CountrySr Country = "SR"
	CountrySs Country = "SS"
	CountrySt Country = "ST"
	CountrySv Country = "SV"
	CountrySx Country = "SX"
	CountrySy Country = "SY"
	CountrySz Country = "SZ"
	CountryTc Country = "TC"
	CountryTd Country = "TD"
	CountryTf Country = "TF"
	CountryTg Country = "TG"
	CountryTh Country = "TH"
	CountryTj Country = "TJ"
	CountryTk Country = "TK"
	CountryTl Country = "TL"
	CountryTm Country = "TM"
	CountryTn Country = "TN"
	CountryTo Country = "TO"
	CountryTr Country = "TR"
	CountryTt Country = "TT"
	CountryTv Country = "TV"
	CountryTw Country = "TW"
	CountryTz Country = "TZ"
	CountryUa Country = "UA"
	CountryUg Country = "UG"
	CountryUm Country = "UM"
	CountryUs Country = "US"
	CountryUy Country = "UY"
	CountryUz Country = "UZ"
	CountryVa Country = "VA"
	CountryVc Country = "VC"
	CountryVe Country = "VE"
	CountryVg Country = "VG"
	CountryVi Country = "VI"
	CountryVn Country = "VN"
	CountryVu Country = "VU"
	CountryWf Country = "WF"
	CountryWs Country = "WS"
	CountryYe Country = "YE"
	CountryYt Country = "YT"
	CountryZa Country = "ZA"
	CountryZm Country = "ZM"
	CountryZw Country = "ZW"
)

func NewCountryFromString(s string) (Country, error) {
	switch s {
	case "ZZ":
		return CountryZz, nil
	case "AD":
		return CountryAd, nil
	case "AE":
		return CountryAe, nil
	case "AF":
		return CountryAf, nil
	case "AG":
		return CountryAg, nil
	case "AI":
		return CountryAi, nil
	case "AL":
		return CountryAl, nil
	case "AM":
		return CountryAm, nil
	case "AO":
		return CountryAo, nil
	case "AQ":
		return CountryAq, nil
	case "AR":
		return CountryAr, nil
	case "AS":
		return CountryAs, nil
	case "AT":
		return CountryAt, nil
	case "AU":
		return CountryAu, nil
	case "AW":
		return CountryAw, nil
	case "AX":
		return CountryAx, nil
	case "AZ":
		return CountryAz, nil
	case "BA":
		return CountryBa, nil
	case "BB":
		return CountryBb, nil
	case "BD":
		return CountryBd, nil
	case "BE":
		return CountryBe, nil
	case "BF":
		return CountryBf, nil
	case "BG":
		return CountryBg, nil
	case "BH":
		return CountryBh, nil
	case "BI":
		return CountryBi, nil
	case "BJ":
		return CountryBj, nil
	case "BL":
		return CountryBl, nil
	case "BM":
		return CountryBm, nil
	case "BN":
		return CountryBn, nil
	case "BO":
		return CountryBo, nil
	case "BQ":
		return CountryBq, nil
	case "BR":
		return CountryBr, nil
	case "BS":
		return CountryBs, nil
	case "BT":
		return CountryBt, nil
	case "BV":
		return CountryBv, nil
	case "BW":
		return CountryBw, nil
	case "BY":
		return CountryBy, nil
	case "BZ":
		return CountryBz, nil
	case "CA":
		return CountryCa, nil
	case "CC":
		return CountryCc, nil
	case "CD":
		return CountryCd, nil
	case "CF":
		return CountryCf, nil
	case "CG":
		return CountryCg, nil
	case "CH":
		return CountryCh, nil
	case "CI":
		return CountryCi, nil
	case "CK":
		return CountryCk, nil
	case "CL":
		return CountryCl, nil
	case "CM":
		return CountryCm, nil
	case "CN":
		return CountryCn, nil
	case "CO":
		return CountryCo, nil
	case "CR":
		return CountryCr, nil
	case "CU":
		return CountryCu, nil
	case "CV":
		return CountryCv, nil
	case "CW":
		return CountryCw, nil
	case "CX":
		return CountryCx, nil
	case "CY":
		return CountryCy, nil
	case "CZ":
		return CountryCz, nil
	case "DE":
		return CountryDe, nil
	case "DJ":
		return CountryDj, nil
	case "DK":
		return CountryDk, nil
	case "DM":
		return CountryDm, nil
	case "DO":
		return CountryDo, nil
	case "DZ":
		return CountryDz, nil
	case "EC":
		return CountryEc, nil
	case "EE":
		return CountryEe, nil
	case "EG":
		return CountryEg, nil
	case "EH":
		return CountryEh, nil
	case "ER":
		return CountryEr, nil
	case "ES":
		return CountryEs, nil
	case "ET":
		return CountryEt, nil
	case "FI":
		return CountryFi, nil
	case "FJ":
		return CountryFj, nil
	case "FK":
		return CountryFk, nil
	case "FM":
		return CountryFm, nil
	case "FO":
		return CountryFo, nil
	case "FR":
		return CountryFr, nil
	case "GA":
		return CountryGa, nil
	case "GB":
		return CountryGb, nil
	case "GD":
		return CountryGd, nil
	case "GE":
		return CountryGe, nil
	case "GF":
		return CountryGf, nil
	case "GG":
		return CountryGg, nil
	case "GH":
		return CountryGh, nil
	case "GI":
		return CountryGi, nil
	case "GL":
		return CountryGl, nil
	case "GM":
		return CountryGm, nil
	case "GN":
		return CountryGn, nil
	case "GP":
		return CountryGp, nil
	case "GQ":
		return CountryGq, nil
	case "GR":
		return CountryGr, nil
	case "GS":
		return CountryGs, nil
	case "GT":
		return CountryGt, nil
	case "GU":
		return CountryGu, nil
	case "GW":
		return CountryGw, nil
	case "GY":
		return CountryGy, nil
	case "HK":
		return CountryHk, nil
	case "HM":
		return CountryHm, nil
	case "HN":
		return CountryHn, nil
	case "HR":
		return CountryHr, nil
	case "HT":
		return CountryHt, nil
	case "HU":
		return CountryHu, nil
	case "ID":
		return CountryID, nil
	case "IE":
		return CountryIe, nil
	case "IL":
		return CountryIl, nil
	case "IM":
		return CountryIm, nil
	case "IN":
		return CountryIn, nil
	case "IO":
		return CountryIo, nil
	case "IQ":
		return CountryIq, nil
	case "IR":
		return CountryIr, nil
	case "IS":
		return CountryIs, nil
	case "IT":
		return CountryIt, nil
	case "JE":
		return CountryJe, nil
	case "JM":
		return CountryJm, nil
	case "JO":
		return CountryJo, nil
	case "JP":
		return CountryJp, nil
	case "KE":
		return CountryKe, nil
	case "KG":
		return CountryKg, nil
	case "KH":
		return CountryKh, nil
	case "KI":
		return CountryKi, nil
	case "KM":
		return CountryKm, nil
	case "KN":
		return CountryKn, nil
	case "KP":
		return CountryKp, nil
	case "KR":
		return CountryKr, nil
	case "KW":
		return CountryKw, nil
	case "KY":
		return CountryKy, nil
	case "KZ":
		return CountryKz, nil
	case "LA":
		return CountryLa, nil
	case "LB":
		return CountryLb, nil
	case "LC":
		return CountryLc, nil
	case "LI":
		return CountryLi, nil
	case "LK":
		return CountryLk, nil
	case "LR":
		return CountryLr, nil
	case "LS":
		return CountryLs, nil
	case "LT":
		return CountryLt, nil
	case "LU":
		return CountryLu, nil
	case "LV":
		return CountryLv, nil
	case "LY":
		return CountryLy, nil
	case "MA":
		return CountryMa, nil
	case "MC":
		return CountryMc, nil
	case "MD":
		return CountryMd, nil
	case "ME":
		return CountryMe, nil
	case "MF":
		return CountryMf, nil
	case "MG":
		return CountryMg, nil
	case "MH":
		return CountryMh, nil
	case "MK":
		return CountryMk, nil
	case "ML":
		return CountryMl, nil
	case "MM":
		return CountryMm, nil
	case "MN":
		return CountryMn, nil
	case "MO":
		return CountryMo, nil
	case "MP":
		return CountryMp, nil
	case "MQ":
		return CountryMq, nil
	case "MR":
		return CountryMr, nil
	case "MS":
		return CountryMs, nil
	case "MT":
		return CountryMt, nil
	case "MU":
		return CountryMu, nil
	case "MV":
		return CountryMv, nil
	case "MW":
		return CountryMw, nil
	case "MX":
		return CountryMx, nil
	case "MY":
		return CountryMy, nil
	case "MZ":
		return CountryMz, nil
	case "NA":
		return CountryNa, nil
	case "NC":
		return CountryNc, nil
	case "NE":
		return CountryNe, nil
	case "NF":
		return CountryNf, nil
	case "NG":
		return CountryNg, nil
	case "NI":
		return CountryNi, nil
	case "NL":
		return CountryNl, nil
	case "NO":
		return CountryNo, nil
	case "NP":
		return CountryNp, nil
	case "NR":
		return CountryNr, nil
	case "NU":
		return CountryNu, nil
	case "NZ":
		return CountryNz, nil
	case "OM":
		return CountryOm, nil
	case "PA":
		return CountryPa, nil
	case "PE":
		return CountryPe, nil
	case "PF":
		return CountryPf, nil
	case "PG":
		return CountryPg, nil
	case "PH":
		return CountryPh, nil
	case "PK":
		return CountryPk, nil
	case "PL":
		return CountryPl, nil
	case "PM":
		return CountryPm, nil
	case "PN":
		return CountryPn, nil
	case "PR":
		return CountryPr, nil
	case "PS":
		return CountryPs, nil
	case "PT":
		return CountryPt, nil
	case "PW":
		return CountryPw, nil
	case "PY":
		return CountryPy, nil
	case "QA":
		return CountryQa, nil
	case "RE":
		return CountryRe, nil
	case "RO":
		return CountryRo, nil
	case "RS":
		return CountryRs, nil
	case "RU":
		return CountryRu, nil
	case "RW":
		return CountryRw, nil
	case "SA":
		return CountrySa, nil
	case "SB":
		return CountrySb, nil
	case "SC":
		return CountrySc, nil
	case "SD":
		return CountrySd, nil
	case "SE":
		return CountrySe, nil
	case "SG":
		return CountrySg, nil
	case "SH":
		return CountrySh, nil
	case "SI":
		return CountrySi, nil
	case "SJ":
		return CountrySj, nil
	case "SK":
		return CountrySk, nil
	case "SL":
		return CountrySl, nil
	case "SM":
		return CountrySm, nil
	case "SN":
		return CountrySn, nil
	case "SO":
		return CountrySo, nil
	case "SR":
		return CountrySr, nil
	case "SS":
		return CountrySs, nil
	case "ST":
		return CountrySt, nil
	case "SV":
		return CountrySv, nil
	case "SX":
		return CountrySx, nil
	case "SY":
		return CountrySy, nil
	case "SZ":
		return CountrySz, nil
	case "TC":
		return CountryTc, nil
	case "TD":
		return CountryTd, nil
	case "TF":
		return CountryTf, nil
	case "TG":
		return CountryTg, nil
	case "TH":
		return CountryTh, nil
	case "TJ":
		return CountryTj, nil
	case "TK":
		return CountryTk, nil
	case "TL":
		return CountryTl, nil
	case "TM":
		return CountryTm, nil
	case "TN":
		return CountryTn, nil
	case "TO":
		return CountryTo, nil
	case "TR":
		return CountryTr, nil
	case "TT":
		return CountryTt, nil
	case "TV":
		return CountryTv, nil
	case "TW":
		return CountryTw, nil
	case "TZ":
		return CountryTz, nil
	case "UA":
		return CountryUa, nil
	case "UG":
		return CountryUg, nil
	case "UM":
		return CountryUm, nil
	case "US":
		return CountryUs, nil
	case "UY":
		return CountryUy, nil
	case "UZ":
		return CountryUz, nil
	case "VA":
		return CountryVa, nil
	case "VC":
		return CountryVc, nil
	case "VE":
		return CountryVe, nil
	case "VG":
		return CountryVg, nil
	case "VI":
		return CountryVi, nil
	case "VN":
		return CountryVn, nil
	case "VU":
		return CountryVu, nil
	case "WF":
		return CountryWf, nil
	case "WS":
		return CountryWs, nil
	case "YE":
		return CountryYe, nil
	case "YT":
		return CountryYt, nil
	case "ZA":
		return CountryZa, nil
	case "ZM":
		return CountryZm, nil
	case "ZW":
		return CountryZw, nil
	}
	var t Country
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Country) Ptr() *Country {
	return &c
}

// Represents a [CreateBookingCustomAttributeDefinition](api-endpoint:BookingCustomAttributes-CreateBookingCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateBookingCustomAttributeDefinitionResponse struct {
	// The newly created custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateBookingCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinition
}

func (c *CreateBookingCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBookingCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBookingCustomAttributeDefinitionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response to the request to create a `BreakType`. The response contains
// the created `BreakType` object and might contain a set of `Error` objects if
// the request resulted in errors.
type CreateBreakTypeResponse struct {
	// The `BreakType` that was created by the request.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateBreakTypeResponse) GetBreakType() *BreakType {
	if c == nil {
		return nil
	}
	return c.BreakType
}

func (c *CreateBreakTypeResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateBreakTypeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateBreakTypeResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCatalogImageRequest struct {
	// A unique string that identifies this CreateCatalogImage request.
	// Keys can be any valid string but must be unique for every CreateCatalogImage request.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`
	// Unique ID of the `CatalogObject` to attach this `CatalogImage` object to. Leave this
	// field empty to create unattached images, for example if you are building an integration
	// where an image can be attached to catalog items at a later time.
	ObjectID *string `json:"object_id,omitempty" url:"object_id,omitempty"`
	// The new `CatalogObject` of the `IMAGE` type, namely, a `CatalogImage` object, to encapsulate the specified image file.
	Image *CatalogObject `json:"image" url:"image"`
	// If this is set to `true`, the image created will be the primary, or first image of the object referenced by `object_id`.
	// If the `CatalogObject` already has a primary `CatalogImage`, setting this field to `true` will replace the primary image.
	// If this is set to `false` and you use the Square API version 2021-12-15 or later, the image id will be appended to the list of `image_ids` on the object.
	//
	// With Square API version 2021-12-15 or later, the default value is `false`. Otherwise, the effective default value is `true`.
	IsPrimary *bool `json:"is_primary,omitempty" url:"is_primary,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCatalogImageRequest) GetIdempotencyKey() string {
	if c == nil {
		return ""
	}
	return c.IdempotencyKey
}

func (c *CreateCatalogImageRequest) GetObjectID() *string {
	if c == nil {
		return nil
	}
	return c.ObjectID
}

func (c *CreateCatalogImageRequest) GetImage() *CatalogObject {
	if c == nil {
		return nil
	}
	return c.Image
}

func (c *CreateCatalogImageRequest) GetIsPrimary() *bool {
	if c == nil {
		return nil
	}
	return c.IsPrimary
}

func (c *CreateCatalogImageRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCatalogImageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCatalogImageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCatalogImageRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCatalogImageRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateCatalogImageResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created `CatalogImage` including a Square-generated
	// URL for the encapsulated image file.
	Image *CatalogObject `json:"image,omitempty" url:"image,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCatalogImageResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateCatalogImageResponse) GetImage() *CatalogObject {
	if c == nil {
		return nil
	}
	return c.Image
}

func (c *CreateCatalogImageResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCatalogImageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCatalogImageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCatalogImageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCatalogImageResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the `CreateCustomerCard` endpoint.
//
// Either `errors` or `card` is present in a given response (never both).
type CreateCustomerCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created card on file.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCustomerCardResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateCustomerCardResponse) GetCard() *Card {
	if c == nil {
		return nil
	}
	return c.Card
}

func (c *CreateCustomerCardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerCardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerCardResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateCustomerCustomAttributeDefinition](api-endpoint:CustomerCustomAttributes-CreateCustomerCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateCustomerCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinition
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerCustomAttributeDefinitionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateCustomerGroup](api-endpoint:CustomerGroups-CreateCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type CreateCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateCustomerGroupResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateCustomerGroupResponse) GetGroup() *CustomerGroup {
	if c == nil {
		return nil
	}
	return c.Group
}

func (c *CreateCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateCustomerGroupResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateCustomerGroupResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateDeviceCodeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created DeviceCode object containing the device code string.
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateDeviceCodeResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateDeviceCodeResponse) GetDeviceCode() *DeviceCode {
	if c == nil {
		return nil
	}
	return c.DeviceCode
}

func (c *CreateDeviceCodeResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateDeviceCodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateDeviceCodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateDeviceCodeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateDeviceCodeResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that contains a `GiftCardActivity` that was created.
// The response might contain a set of `Error` objects if the request resulted in errors.
type CreateGiftCardActivityResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The gift card activity that was created.
	GiftCardActivity *GiftCardActivity `json:"gift_card_activity,omitempty" url:"gift_card_activity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateGiftCardActivityResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateGiftCardActivityResponse) GetGiftCardActivity() *GiftCardActivity {
	if c == nil {
		return nil
	}
	return c.GiftCardActivity
}

func (c *CreateGiftCardActivityResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateGiftCardActivityResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateGiftCardActivityResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateGiftCardActivityResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateGiftCardActivityResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateLocationCustomAttributeDefinition](api-endpoint:LocationCustomAttributes-CreateLocationCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateLocationCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLocationCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinition
}

func (c *CreateLocationCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLocationCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLocationCustomAttributeDefinitionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that includes loyalty account created.
type CreateLoyaltyAccountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly created loyalty account.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLoyaltyAccountResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateLoyaltyAccountResponse) GetLoyaltyAccount() *LoyaltyAccount {
	if c == nil {
		return nil
	}
	return c.LoyaltyAccount
}

func (c *CreateLoyaltyAccountResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyAccountResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyAccountResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateLoyaltyPromotion](api-endpoint:Loyalty-CreateLoyaltyPromotion) response.
// Either `loyalty_promotion` or `errors` is present in the response.
type CreateLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLoyaltyPromotionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateLoyaltyPromotionResponse) GetLoyaltyPromotion() *LoyaltyPromotion {
	if c == nil {
		return nil
	}
	return c.LoyaltyPromotion
}

func (c *CreateLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyPromotionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyPromotionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A response that includes the loyalty reward created.
type CreateLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty reward created.
	Reward *LoyaltyReward `json:"reward,omitempty" url:"reward,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateLoyaltyRewardResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateLoyaltyRewardResponse) GetReward() *LoyaltyReward {
	if c == nil {
		return nil
	}
	return c.Reward
}

func (c *CreateLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLoyaltyRewardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLoyaltyRewardResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a [CreateMerchantCustomAttributeDefinition](api-endpoint:MerchantCustomAttributes-CreateMerchantCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type CreateMerchantCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinition
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateMerchantCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateMerchantCustomAttributeDefinitionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a response from creating an order custom attribute definition.
type CreateOrderCustomAttributeDefinitionResponse struct {
	// The new custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOrderCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinition
}

func (c *CreateOrderCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderCustomAttributeDefinitionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateOrderRequest struct {
	// The order to create. If this field is set, the only other top-level field that can be
	// set is the `idempotency_key`.
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// A value you specify that uniquely identifies this
	// order among orders you have created.
	//
	// If you are unsure whether a particular order was created successfully,
	// you can try it again with the same idempotency key without
	// worrying about creating duplicate orders.
	//
	// For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"idempotency_key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateOrderRequest) GetOrder() *Order {
	if c == nil {
		return nil
	}
	return c.Order
}

func (c *CreateOrderRequest) GetIdempotencyKey() *string {
	if c == nil {
		return nil
	}
	return c.IdempotencyKey
}

func (c *CreateOrderRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreatePaymentLinkResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created payment link.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`
	// The list of related objects.
	RelatedResources *PaymentLinkRelatedResources `json:"related_resources,omitempty" url:"related_resources,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreatePaymentLinkResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreatePaymentLinkResponse) GetPaymentLink() *PaymentLink {
	if c == nil {
		return nil
	}
	return c.PaymentLink
}

func (c *CreatePaymentLinkResponse) GetRelatedResources() *PaymentLinkRelatedResources {
	if c == nil {
		return nil
	}
	return c.RelatedResources
}

func (c *CreatePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreatePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreatePaymentLinkResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePaymentLinkResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response to a request to create a `Shift`. The response contains
// the created `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type CreateShiftResponse struct {
	// The `Shift` that was created on the request.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateShiftResponse) GetShift() *Shift {
	if c == nil {
		return nil
	}
	return c.Shift
}

func (c *CreateShiftResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateShiftResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateShiftResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTerminalActionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateTerminalActionResponse) GetAction() *TerminalAction {
	if c == nil {
		return nil
	}
	return c.Action
}

func (c *CreateTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalActionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalActionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTerminalCheckoutResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateTerminalCheckoutResponse) GetCheckout() *TerminalCheckout {
	if c == nil {
		return nil
	}
	return c.Checkout
}

func (c *CreateTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalCheckoutResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalCheckoutResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The created `TerminalRefund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTerminalRefundResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateTerminalRefundResponse) GetRefund() *TerminalRefund {
	if c == nil {
		return nil
	}
	return c.Refund
}

func (c *CreateTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTerminalRefundResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTerminalRefundResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the [CreateWebhookSubscription](api-endpoint:WebhookSubscriptions-CreateWebhookSubscription) endpoint.
//
// Note: if there are errors processing the request, the [Subscription](entity:WebhookSubscription) will not be
// present.
type CreateWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateWebhookSubscriptionResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateWebhookSubscriptionResponse) GetSubscription() *WebhookSubscription {
	if c == nil {
		return nil
	}
	return c.Subscription
}

func (c *CreateWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateWebhookSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateWebhookSubscriptionResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the associated currency for an amount of money. Values correspond
// to [ISO 4217](https://wikipedia.org/wiki/ISO_4217).
type Currency string

const (
	CurrencyUnknownCurrency Currency = "UNKNOWN_CURRENCY"
	CurrencyAed             Currency = "AED"
	CurrencyAfn             Currency = "AFN"
	CurrencyAll             Currency = "ALL"
	CurrencyAmd             Currency = "AMD"
	CurrencyAng             Currency = "ANG"
	CurrencyAoa             Currency = "AOA"
	CurrencyArs             Currency = "ARS"
	CurrencyAud             Currency = "AUD"
	CurrencyAwg             Currency = "AWG"
	CurrencyAzn             Currency = "AZN"
	CurrencyBam             Currency = "BAM"
	CurrencyBbd             Currency = "BBD"
	CurrencyBdt             Currency = "BDT"
	CurrencyBgn             Currency = "BGN"
	CurrencyBhd             Currency = "BHD"
	CurrencyBif             Currency = "BIF"
	CurrencyBmd             Currency = "BMD"
	CurrencyBnd             Currency = "BND"
	CurrencyBob             Currency = "BOB"
	CurrencyBov             Currency = "BOV"
	CurrencyBrl             Currency = "BRL"
	CurrencyBsd             Currency = "BSD"
	CurrencyBtn             Currency = "BTN"
	CurrencyBwp             Currency = "BWP"
	CurrencyByr             Currency = "BYR"
	CurrencyBzd             Currency = "BZD"
	CurrencyCad             Currency = "CAD"
	CurrencyCdf             Currency = "CDF"
	CurrencyChe             Currency = "CHE"
	CurrencyChf             Currency = "CHF"
	CurrencyChw             Currency = "CHW"
	CurrencyClf             Currency = "CLF"
	CurrencyClp             Currency = "CLP"
	CurrencyCny             Currency = "CNY"
	CurrencyCop             Currency = "COP"
	CurrencyCou             Currency = "COU"
	CurrencyCrc             Currency = "CRC"
	CurrencyCuc             Currency = "CUC"
	CurrencyCup             Currency = "CUP"
	CurrencyCve             Currency = "CVE"
	CurrencyCzk             Currency = "CZK"
	CurrencyDjf             Currency = "DJF"
	CurrencyDkk             Currency = "DKK"
	CurrencyDop             Currency = "DOP"
	CurrencyDzd             Currency = "DZD"
	CurrencyEgp             Currency = "EGP"
	CurrencyErn             Currency = "ERN"
	CurrencyEtb             Currency = "ETB"
	CurrencyEur             Currency = "EUR"
	CurrencyFjd             Currency = "FJD"
	CurrencyFkp             Currency = "FKP"
	CurrencyGbp             Currency = "GBP"
	CurrencyGel             Currency = "GEL"
	CurrencyGhs             Currency = "GHS"
	CurrencyGip             Currency = "GIP"
	CurrencyGmd             Currency = "GMD"
	CurrencyGnf             Currency = "GNF"
	CurrencyGtq             Currency = "GTQ"
	CurrencyGyd             Currency = "GYD"
	CurrencyHkd             Currency = "HKD"
	CurrencyHnl             Currency = "HNL"
	CurrencyHrk             Currency = "HRK"
	CurrencyHtg             Currency = "HTG"
	CurrencyHuf             Currency = "HUF"
	CurrencyIdr             Currency = "IDR"
	CurrencyIls             Currency = "ILS"
	CurrencyInr             Currency = "INR"
	CurrencyIqd             Currency = "IQD"
	CurrencyIrr             Currency = "IRR"
	CurrencyIsk             Currency = "ISK"
	CurrencyJmd             Currency = "JMD"
	CurrencyJod             Currency = "JOD"
	CurrencyJpy             Currency = "JPY"
	CurrencyKes             Currency = "KES"
	CurrencyKgs             Currency = "KGS"
	CurrencyKhr             Currency = "KHR"
	CurrencyKmf             Currency = "KMF"
	CurrencyKpw             Currency = "KPW"
	CurrencyKrw             Currency = "KRW"
	CurrencyKwd             Currency = "KWD"
	CurrencyKyd             Currency = "KYD"
	CurrencyKzt             Currency = "KZT"
	CurrencyLak             Currency = "LAK"
	CurrencyLbp             Currency = "LBP"
	CurrencyLkr             Currency = "LKR"
	CurrencyLrd             Currency = "LRD"
	CurrencyLsl             Currency = "LSL"
	CurrencyLtl             Currency = "LTL"
	CurrencyLvl             Currency = "LVL"
	CurrencyLyd             Currency = "LYD"
	CurrencyMad             Currency = "MAD"
	CurrencyMdl             Currency = "MDL"
	CurrencyMga             Currency = "MGA"
	CurrencyMkd             Currency = "MKD"
	CurrencyMmk             Currency = "MMK"
	CurrencyMnt             Currency = "MNT"
	CurrencyMop             Currency = "MOP"
	CurrencyMro             Currency = "MRO"
	CurrencyMur             Currency = "MUR"
	CurrencyMvr             Currency = "MVR"
	CurrencyMwk             Currency = "MWK"
	CurrencyMxn             Currency = "MXN"
	CurrencyMxv             Currency = "MXV"
	CurrencyMyr             Currency = "MYR"
	CurrencyMzn             Currency = "MZN"
	CurrencyNad             Currency = "NAD"
	CurrencyNgn             Currency = "NGN"
	CurrencyNio             Currency = "NIO"
	CurrencyNok             Currency = "NOK"
	CurrencyNpr             Currency = "NPR"
	CurrencyNzd             Currency = "NZD"
	CurrencyOmr             Currency = "OMR"
	CurrencyPab             Currency = "PAB"
	CurrencyPen             Currency = "PEN"
	CurrencyPgk             Currency = "PGK"
	CurrencyPhp             Currency = "PHP"
	CurrencyPkr             Currency = "PKR"
	CurrencyPln             Currency = "PLN"
	CurrencyPyg             Currency = "PYG"
	CurrencyQar             Currency = "QAR"
	CurrencyRon             Currency = "RON"
	CurrencyRsd             Currency = "RSD"
	CurrencyRub             Currency = "RUB"
	CurrencyRwf             Currency = "RWF"
	CurrencySar             Currency = "SAR"
	CurrencySbd             Currency = "SBD"
	CurrencyScr             Currency = "SCR"
	CurrencySdg             Currency = "SDG"
	CurrencySek             Currency = "SEK"
	CurrencySgd             Currency = "SGD"
	CurrencyShp             Currency = "SHP"
	CurrencySll             Currency = "SLL"
	CurrencySle             Currency = "SLE"
	CurrencySos             Currency = "SOS"
	CurrencySrd             Currency = "SRD"
	CurrencySsp             Currency = "SSP"
	CurrencyStd             Currency = "STD"
	CurrencySvc             Currency = "SVC"
	CurrencySyp             Currency = "SYP"
	CurrencySzl             Currency = "SZL"
	CurrencyThb             Currency = "THB"
	CurrencyTjs             Currency = "TJS"
	CurrencyTmt             Currency = "TMT"
	CurrencyTnd             Currency = "TND"
	CurrencyTop             Currency = "TOP"
	CurrencyTry             Currency = "TRY"
	CurrencyTtd             Currency = "TTD"
	CurrencyTwd             Currency = "TWD"
	CurrencyTzs             Currency = "TZS"
	CurrencyUah             Currency = "UAH"
	CurrencyUgx             Currency = "UGX"
	CurrencyUsd             Currency = "USD"
	CurrencyUsn             Currency = "USN"
	CurrencyUss             Currency = "USS"
	CurrencyUyi             Currency = "UYI"
	CurrencyUyu             Currency = "UYU"
	CurrencyUzs             Currency = "UZS"
	CurrencyVef             Currency = "VEF"
	CurrencyVnd             Currency = "VND"
	CurrencyVuv             Currency = "VUV"
	CurrencyWst             Currency = "WST"
	CurrencyXaf             Currency = "XAF"
	CurrencyXag             Currency = "XAG"
	CurrencyXau             Currency = "XAU"
	CurrencyXba             Currency = "XBA"
	CurrencyXbb             Currency = "XBB"
	CurrencyXbc             Currency = "XBC"
	CurrencyXbd             Currency = "XBD"
	CurrencyXcd             Currency = "XCD"
	CurrencyXdr             Currency = "XDR"
	CurrencyXof             Currency = "XOF"
	CurrencyXpd             Currency = "XPD"
	CurrencyXpf             Currency = "XPF"
	CurrencyXpt             Currency = "XPT"
	CurrencyXts             Currency = "XTS"
	CurrencyXxx             Currency = "XXX"
	CurrencyYer             Currency = "YER"
	CurrencyZar             Currency = "ZAR"
	CurrencyZmk             Currency = "ZMK"
	CurrencyZmw             Currency = "ZMW"
	CurrencyBtc             Currency = "BTC"
	CurrencyXus             Currency = "XUS"
)

func NewCurrencyFromString(s string) (Currency, error) {
	switch s {
	case "UNKNOWN_CURRENCY":
		return CurrencyUnknownCurrency, nil
	case "AED":
		return CurrencyAed, nil
	case "AFN":
		return CurrencyAfn, nil
	case "ALL":
		return CurrencyAll, nil
	case "AMD":
		return CurrencyAmd, nil
	case "ANG":
		return CurrencyAng, nil
	case "AOA":
		return CurrencyAoa, nil
	case "ARS":
		return CurrencyArs, nil
	case "AUD":
		return CurrencyAud, nil
	case "AWG":
		return CurrencyAwg, nil
	case "AZN":
		return CurrencyAzn, nil
	case "BAM":
		return CurrencyBam, nil
	case "BBD":
		return CurrencyBbd, nil
	case "BDT":
		return CurrencyBdt, nil
	case "BGN":
		return CurrencyBgn, nil
	case "BHD":
		return CurrencyBhd, nil
	case "BIF":
		return CurrencyBif, nil
	case "BMD":
		return CurrencyBmd, nil
	case "BND":
		return CurrencyBnd, nil
	case "BOB":
		return CurrencyBob, nil
	case "BOV":
		return CurrencyBov, nil
	case "BRL":
		return CurrencyBrl, nil
	case "BSD":
		return CurrencyBsd, nil
	case "BTN":
		return CurrencyBtn, nil
	case "BWP":
		return CurrencyBwp, nil
	case "BYR":
		return CurrencyByr, nil
	case "BZD":
		return CurrencyBzd, nil
	case "CAD":
		return CurrencyCad, nil
	case "CDF":
		return CurrencyCdf, nil
	case "CHE":
		return CurrencyChe, nil
	case "CHF":
		return CurrencyChf, nil
	case "CHW":
		return CurrencyChw, nil
	case "CLF":
		return CurrencyClf, nil
	case "CLP":
		return CurrencyClp, nil
	case "CNY":
		return CurrencyCny, nil
	case "COP":
		return CurrencyCop, nil
	case "COU":
		return CurrencyCou, nil
	case "CRC":
		return CurrencyCrc, nil
	case "CUC":
		return CurrencyCuc, nil
	case "CUP":
		return CurrencyCup, nil
	case "CVE":
		return CurrencyCve, nil
	case "CZK":
		return CurrencyCzk, nil
	case "DJF":
		return CurrencyDjf, nil
	case "DKK":
		return CurrencyDkk, nil
	case "DOP":
		return CurrencyDop, nil
	case "DZD":
		return CurrencyDzd, nil
	case "EGP":
		return CurrencyEgp, nil
	case "ERN":
		return CurrencyErn, nil
	case "ETB":
		return CurrencyEtb, nil
	case "EUR":
		return CurrencyEur, nil
	case "FJD":
		return CurrencyFjd, nil
	case "FKP":
		return CurrencyFkp, nil
	case "GBP":
		return CurrencyGbp, nil
	case "GEL":
		return CurrencyGel, nil
	case "GHS":
		return CurrencyGhs, nil
	case "GIP":
		return CurrencyGip, nil
	case "GMD":
		return CurrencyGmd, nil
	case "GNF":
		return CurrencyGnf, nil
	case "GTQ":
		return CurrencyGtq, nil
	case "GYD":
		return CurrencyGyd, nil
	case "HKD":
		return CurrencyHkd, nil
	case "HNL":
		return CurrencyHnl, nil
	case "HRK":
		return CurrencyHrk, nil
	case "HTG":
		return CurrencyHtg, nil
	case "HUF":
		return CurrencyHuf, nil
	case "IDR":
		return CurrencyIdr, nil
	case "ILS":
		return CurrencyIls, nil
	case "INR":
		return CurrencyInr, nil
	case "IQD":
		return CurrencyIqd, nil
	case "IRR":
		return CurrencyIrr, nil
	case "ISK":
		return CurrencyIsk, nil
	case "JMD":
		return CurrencyJmd, nil
	case "JOD":
		return CurrencyJod, nil
	case "JPY":
		return CurrencyJpy, nil
	case "KES":
		return CurrencyKes, nil
	case "KGS":
		return CurrencyKgs, nil
	case "KHR":
		return CurrencyKhr, nil
	case "KMF":
		return CurrencyKmf, nil
	case "KPW":
		return CurrencyKpw, nil
	case "KRW":
		return CurrencyKrw, nil
	case "KWD":
		return CurrencyKwd, nil
	case "KYD":
		return CurrencyKyd, nil
	case "KZT":
		return CurrencyKzt, nil
	case "LAK":
		return CurrencyLak, nil
	case "LBP":
		return CurrencyLbp, nil
	case "LKR":
		return CurrencyLkr, nil
	case "LRD":
		return CurrencyLrd, nil
	case "LSL":
		return CurrencyLsl, nil
	case "LTL":
		return CurrencyLtl, nil
	case "LVL":
		return CurrencyLvl, nil
	case "LYD":
		return CurrencyLyd, nil
	case "MAD":
		return CurrencyMad, nil
	case "MDL":
		return CurrencyMdl, nil
	case "MGA":
		return CurrencyMga, nil
	case "MKD":
		return CurrencyMkd, nil
	case "MMK":
		return CurrencyMmk, nil
	case "MNT":
		return CurrencyMnt, nil
	case "MOP":
		return CurrencyMop, nil
	case "MRO":
		return CurrencyMro, nil
	case "MUR":
		return CurrencyMur, nil
	case "MVR":
		return CurrencyMvr, nil
	case "MWK":
		return CurrencyMwk, nil
	case "MXN":
		return CurrencyMxn, nil
	case "MXV":
		return CurrencyMxv, nil
	case "MYR":
		return CurrencyMyr, nil
	case "MZN":
		return CurrencyMzn, nil
	case "NAD":
		return CurrencyNad, nil
	case "NGN":
		return CurrencyNgn, nil
	case "NIO":
		return CurrencyNio, nil
	case "NOK":
		return CurrencyNok, nil
	case "NPR":
		return CurrencyNpr, nil
	case "NZD":
		return CurrencyNzd, nil
	case "OMR":
		return CurrencyOmr, nil
	case "PAB":
		return CurrencyPab, nil
	case "PEN":
		return CurrencyPen, nil
	case "PGK":
		return CurrencyPgk, nil
	case "PHP":
		return CurrencyPhp, nil
	case "PKR":
		return CurrencyPkr, nil
	case "PLN":
		return CurrencyPln, nil
	case "PYG":
		return CurrencyPyg, nil
	case "QAR":
		return CurrencyQar, nil
	case "RON":
		return CurrencyRon, nil
	case "RSD":
		return CurrencyRsd, nil
	case "RUB":
		return CurrencyRub, nil
	case "RWF":
		return CurrencyRwf, nil
	case "SAR":
		return CurrencySar, nil
	case "SBD":
		return CurrencySbd, nil
	case "SCR":
		return CurrencyScr, nil
	case "SDG":
		return CurrencySdg, nil
	case "SEK":
		return CurrencySek, nil
	case "SGD":
		return CurrencySgd, nil
	case "SHP":
		return CurrencyShp, nil
	case "SLL":
		return CurrencySll, nil
	case "SLE":
		return CurrencySle, nil
	case "SOS":
		return CurrencySos, nil
	case "SRD":
		return CurrencySrd, nil
	case "SSP":
		return CurrencySsp, nil
	case "STD":
		return CurrencyStd, nil
	case "SVC":
		return CurrencySvc, nil
	case "SYP":
		return CurrencySyp, nil
	case "SZL":
		return CurrencySzl, nil
	case "THB":
		return CurrencyThb, nil
	case "TJS":
		return CurrencyTjs, nil
	case "TMT":
		return CurrencyTmt, nil
	case "TND":
		return CurrencyTnd, nil
	case "TOP":
		return CurrencyTop, nil
	case "TRY":
		return CurrencyTry, nil
	case "TTD":
		return CurrencyTtd, nil
	case "TWD":
		return CurrencyTwd, nil
	case "TZS":
		return CurrencyTzs, nil
	case "UAH":
		return CurrencyUah, nil
	case "UGX":
		return CurrencyUgx, nil
	case "USD":
		return CurrencyUsd, nil
	case "USN":
		return CurrencyUsn, nil
	case "USS":
		return CurrencyUss, nil
	case "UYI":
		return CurrencyUyi, nil
	case "UYU":
		return CurrencyUyu, nil
	case "UZS":
		return CurrencyUzs, nil
	case "VEF":
		return CurrencyVef, nil
	case "VND":
		return CurrencyVnd, nil
	case "VUV":
		return CurrencyVuv, nil
	case "WST":
		return CurrencyWst, nil
	case "XAF":
		return CurrencyXaf, nil
	case "XAG":
		return CurrencyXag, nil
	case "XAU":
		return CurrencyXau, nil
	case "XBA":
		return CurrencyXba, nil
	case "XBB":
		return CurrencyXbb, nil
	case "XBC":
		return CurrencyXbc, nil
	case "XBD":
		return CurrencyXbd, nil
	case "XCD":
		return CurrencyXcd, nil
	case "XDR":
		return CurrencyXdr, nil
	case "XOF":
		return CurrencyXof, nil
	case "XPD":
		return CurrencyXpd, nil
	case "XPF":
		return CurrencyXpf, nil
	case "XPT":
		return CurrencyXpt, nil
	case "XTS":
		return CurrencyXts, nil
	case "XXX":
		return CurrencyXxx, nil
	case "YER":
		return CurrencyYer, nil
	case "ZAR":
		return CurrencyZar, nil
	case "ZMK":
		return CurrencyZmk, nil
	case "ZMW":
		return CurrencyZmw, nil
	case "BTC":
		return CurrencyBtc, nil
	case "XUS":
		return CurrencyXus, nil
	}
	var t Currency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Currency) Ptr() *Currency {
	return &c
}

// A custom attribute value. Each custom attribute value has a corresponding
// `CustomAttributeDefinition` object.
type CustomAttribute struct {
	// The identifier
	// of the custom attribute definition and its corresponding custom attributes. This value
	// can be a simple key, which is the key that is provided when the custom attribute definition
	// is created, or a qualified key, if the requesting
	// application is not the definition owner. The qualified key consists of the application ID
	// of the custom attribute definition owner
	// followed by the simple key that was provided when the definition was created. It has the
	// format application_id:simple key.
	//
	// The value for a simple key can contain up to 60 alphanumeric characters, periods (.),
	// underscores (_), and hyphens (-).
	Key   *string     `json:"key,omitempty" url:"key,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Read only. The current version of the custom attribute. This field is incremented when the custom attribute is changed.
	// When updating an existing custom attribute value, you can provide this field
	// and specify the current version of the custom attribute to enable
	// [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency).
	// This field can also be used to enforce strong consistency for reads. For more information about strong consistency for reads,
	// see [Custom Attributes Overview](https://developer.squareup.com/docs/devtools/customattributes/overview).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A copy of the `visibility` field value for the associated custom attribute definition.
	// See [CustomAttributeDefinitionVisibility](#type-customattributedefinitionvisibility) for possible values
	Visibility *CustomAttributeDefinitionVisibility `json:"visibility,omitempty" url:"visibility,omitempty"`
	// A copy of the associated custom attribute definition object. This field is only set when
	// the optional field is specified on the request.
	Definition *CustomAttributeDefinition `json:"definition,omitempty" url:"definition,omitempty"`
	// The timestamp that indicates when the custom attribute was created or was most recently
	// updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp that indicates when the custom attribute was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomAttribute) GetKey() *string {
	if c == nil {
		return nil
	}
	return c.Key
}

func (c *CustomAttribute) GetValue() interface{} {
	if c == nil {
		return nil
	}
	return c.Value
}

func (c *CustomAttribute) GetVersion() *int {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CustomAttribute) GetVisibility() *CustomAttributeDefinitionVisibility {
	if c == nil {
		return nil
	}
	return c.Visibility
}

func (c *CustomAttribute) GetDefinition() *CustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.Definition
}

func (c *CustomAttribute) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CustomAttribute) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomAttribute) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttribute) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttribute
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttribute(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttribute) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a definition for custom attribute values. A custom attribute definition
// specifies the key, visibility, schema, and other properties for a custom attribute.
type CustomAttributeDefinition struct {
	// The identifier
	// of the custom attribute definition and its corresponding custom attributes. This value
	// can be a simple key, which is the key that is provided when the custom attribute definition
	// is created, or a qualified key, if the requesting
	// application is not the definition owner. The qualified key consists of the application ID
	// of the custom attribute definition owner
	// followed by the simple key that was provided when the definition was created. It has the
	// format application_id:simple key.
	//
	// The value for a simple key can contain up to 60 alphanumeric characters, periods (.),
	// underscores (_), and hyphens (-).
	//
	// This field can not be changed
	// after the custom attribute definition is created. This field is required when creating
	// a definition and must be unique per application, seller, and resource type.
	Key *string `json:"key,omitempty" url:"key,omitempty"`
	// The JSON schema for the custom attribute definition, which determines the data type of the corresponding custom attributes. For more information,
	// see [Custom Attributes Overview](https://developer.squareup.com/docs/devtools/customattributes/overview). This field is required when creating a definition.
	Schema map[string]interface{} `json:"schema,omitempty" url:"schema,omitempty"`
	// The name of the custom attribute definition for API and seller-facing UI purposes. The name must
	// be unique within the seller and application pair. This field is required if the
	// `visibility` field is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Seller-oriented description of the custom attribute definition, including any constraints
	// that the seller should observe. May be displayed as a tooltip in Square UIs. This field is
	// required if the `visibility` field is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// Specifies how the custom attribute definition and its values should be shared with
	// the seller and other applications. If no value is specified, the value defaults to `VISIBILITY_HIDDEN`.
	// See [Visibility](#type-visibility) for possible values
	Visibility *CustomAttributeDefinitionVisibility `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Read only. The current version of the custom attribute definition.
	// The value is incremented each time the custom attribute definition is updated.
	// When updating a custom attribute definition, you can provide this field
	// and specify the current version of the custom attribute definition to enable
	// [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency).
	//
	// On writes, this field must be set to the latest version. Stale writes are rejected.
	//
	// This field can also be used to enforce strong consistency for reads. For more information about strong consistency for reads,
	// see [Custom Attributes Overview](https://developer.squareup.com/docs/devtools/customattributes/overview).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp that indicates when the custom attribute definition was created or most recently updated,
	// in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp that indicates when the custom attribute definition was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomAttributeDefinition) GetKey() *string {
	if c == nil {
		return nil
	}
	return c.Key
}

func (c *CustomAttributeDefinition) GetSchema() map[string]interface{} {
	if c == nil {
		return nil
	}
	return c.Schema
}

func (c *CustomAttributeDefinition) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CustomAttributeDefinition) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CustomAttributeDefinition) GetVisibility() *CustomAttributeDefinitionVisibility {
	if c == nil {
		return nil
	}
	return c.Visibility
}

func (c *CustomAttributeDefinition) GetVersion() *int {
	if c == nil {
		return nil
	}
	return c.Version
}

func (c *CustomAttributeDefinition) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CustomAttributeDefinition) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeDefinition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents an object in the CustomAttributeDefinition event notification
// payload that contains the affected custom attribute definition.
type CustomAttributeDefinitionEventData struct {
	// The type of the event data object. The value is `"custom_attribute_definition"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the custom attribute definition.
	Object *CustomAttributeDefinitionEventDataObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomAttributeDefinitionEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomAttributeDefinitionEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CustomAttributeDefinitionEventData) GetObject() *CustomAttributeDefinitionEventDataObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CustomAttributeDefinitionEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeDefinitionEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeDefinitionEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeDefinitionEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeDefinitionEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomAttributeDefinitionEventDataObject struct {
	// The custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomAttributeDefinitionEventDataObject) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if c == nil {
		return nil
	}
	return c.CustomAttributeDefinition
}

func (c *CustomAttributeDefinitionEventDataObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeDefinitionEventDataObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeDefinitionEventDataObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeDefinitionEventDataObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeDefinitionEventDataObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The level of permission that a seller or other applications requires to
// view this custom attribute definition.
// The `Visibility` field controls who can read and write the custom attribute values
// and custom attribute definition.
type CustomAttributeDefinitionVisibility string

const (
	CustomAttributeDefinitionVisibilityVisibilityHidden          CustomAttributeDefinitionVisibility = "VISIBILITY_HIDDEN"
	CustomAttributeDefinitionVisibilityVisibilityReadOnly        CustomAttributeDefinitionVisibility = "VISIBILITY_READ_ONLY"
	CustomAttributeDefinitionVisibilityVisibilityReadWriteValues CustomAttributeDefinitionVisibility = "VISIBILITY_READ_WRITE_VALUES"
)

func NewCustomAttributeDefinitionVisibilityFromString(s string) (CustomAttributeDefinitionVisibility, error) {
	switch s {
	case "VISIBILITY_HIDDEN":
		return CustomAttributeDefinitionVisibilityVisibilityHidden, nil
	case "VISIBILITY_READ_ONLY":
		return CustomAttributeDefinitionVisibilityVisibilityReadOnly, nil
	case "VISIBILITY_READ_WRITE_VALUES":
		return CustomAttributeDefinitionVisibilityVisibilityReadWriteValues, nil
	}
	var t CustomAttributeDefinitionVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomAttributeDefinitionVisibility) Ptr() *CustomAttributeDefinitionVisibility {
	return &c
}

type CustomAttributeEventData struct {
	// The type of the event data object. The value is `"custom_attribute"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the custom attribute.
	Object *CustomAttributeEventDataObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomAttributeEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomAttributeEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CustomAttributeEventData) GetObject() *CustomAttributeEventDataObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CustomAttributeEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CustomAttributeEventDataObject struct {
	// The custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomAttributeEventDataObject) GetCustomAttribute() *CustomAttribute {
	if c == nil {
		return nil
	}
	return c.CustomAttribute
}

func (c *CustomAttributeEventDataObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomAttributeEventDataObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomAttributeEventDataObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomAttributeEventDataObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomAttributeEventDataObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a custom form field to add to the checkout page to collect more information from buyers during checkout.
// For more information,
// see [Specify checkout options](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations#specify-checkout-options-1).
type CustomField struct {
	// The title of the custom field.
	Title string `json:"title" url:"title"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomField) GetTitle() string {
	if c == nil {
		return ""
	}
	return c.Title
}

func (c *CustomField) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomField) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomField) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [customer](entity:Customer) is created. Subscribe to this event to track customer profiles affected by a merge operation.
// For more information, see [Use Customer Webhooks](https://developer.squareup.com/docs/customers-api/use-the-api/customer-webhooks).
//
// The `customer` object in the event notification does not include the `segment_ids` field.
type CustomerCreatedEvent struct {
	// The ID of the seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this object, the value is `customer.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomerCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCreatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCreatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCreatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCreatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCreatedEvent) GetData() *CustomerCreatedEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCreatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The data associated with the event.
type CustomerCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `customer`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the new customer.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new customer.
	Object *CustomerCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCreatedEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCreatedEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CustomerCreatedEventData) GetObject() *CustomerCreatedEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CustomerCreatedEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about the change that triggered the event.
type CustomerCreatedEventEventContext struct {
	// Information about the merge operation associated with the event.
	Merge *CustomerCreatedEventEventContextMerge `json:"merge,omitempty" url:"merge,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCreatedEventEventContext) GetMerge() *CustomerCreatedEventEventContextMerge {
	if c == nil {
		return nil
	}
	return c.Merge
}

func (c *CustomerCreatedEventEventContext) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedEventEventContext) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedEventEventContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedEventEventContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedEventEventContext) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about a merge operation, which creates a new customer using aggregated properties from two or more existing customers.
type CustomerCreatedEventEventContextMerge struct {
	// The IDs of the existing customers that were merged and then deleted.
	FromCustomerIDs []string `json:"from_customer_ids,omitempty" url:"from_customer_ids,omitempty"`
	// The ID of the new customer created by the merge.
	ToCustomerID *string `json:"to_customer_id,omitempty" url:"to_customer_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCreatedEventEventContextMerge) GetFromCustomerIDs() []string {
	if c == nil {
		return nil
	}
	return c.FromCustomerIDs
}

func (c *CustomerCreatedEventEventContextMerge) GetToCustomerID() *string {
	if c == nil {
		return nil
	}
	return c.ToCustomerID
}

func (c *CustomerCreatedEventEventContextMerge) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedEventEventContextMerge) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedEventEventContextMerge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedEventEventContextMerge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedEventEventContextMerge) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An object that contains the customer associated with the event.
type CustomerCreatedEventObject struct {
	// The new customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`
	// Information about the change that triggered the event. This field is returned only if the customer is created by a merge operation.
	EventContext *CustomerCreatedEventEventContext `json:"event_context,omitempty" url:"event_context,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCreatedEventObject) GetCustomer() *Customer {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *CustomerCreatedEventObject) GetEventContext() *CustomerCreatedEventEventContext {
	if c == nil {
		return nil
	}
	return c.EventContext
}

func (c *CustomerCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCreatedEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// is created by the subscribing application.
//
// This event is replaced by
// [customer.custom_attribute_definition.owned.created](webhook:customer.custom_attribute_definition.owned.created).
type CustomerCustomAttributeDefinitionCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionCreatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to all applications is created. A notification is sent when any application creates a custom
// attribute definition whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute_definition.visible.created](webhook:customer.custom_attribute_definition.visible.created),
// which applies to custom attribute definitions that are visible to the subscribing application.
type CustomerCustomAttributeDefinitionCreatedPublicEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.public.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionCreatedPublicEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionCreatedPublicEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionCreatedPublicEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is deleted. A custom attribute definition can only be deleted by
// the application that created it.
//
// This event is replaced by
// [customer.custom_attribute_definition.owned.deleted](webhook:customer.custom_attribute_definition.owned.deleted).
type CustomerCustomAttributeDefinitionDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionDeletedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to all applications is deleted. A notification is sent when any application deletes a custom
// attribute definition whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute_definition.visible.deleted](webhook:customer.custom_attribute_definition.visible.deleted),
// which applies to custom attribute definitions that are visible to the subscribing application.
type CustomerCustomAttributeDefinitionDeletedPublicEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.public.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionDeletedPublicEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionDeletedPublicEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionDeletedPublicEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// is created by the subscribing application.
type CustomerCustomAttributeDefinitionOwnedCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.owned.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionOwnedCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionOwnedCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionOwnedCreatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is deleted. A custom attribute definition can only be deleted by
// the application that created it.
type CustomerCustomAttributeDefinitionOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionOwnedDeletedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is updated. A custom attribute definition can only be updated by
// the application that created it.
type CustomerCustomAttributeDefinitionOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionOwnedUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is updated. A custom attribute definition can only be updated by
// the application that created it.
//
// This event is replaced by
// [customer.custom_attribute_definition.owned.updated](webhook:customer.custom_attribute_definition.owned.updated).
type CustomerCustomAttributeDefinitionUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to all applications is updated. A notification is sent when any application updates a custom
// attribute definition whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute_definition.visible.updated](webhook:customer.custom_attribute_definition.visible.updated),
// which applies to custom attribute definitions that are visible to the subscribing application.
type CustomerCustomAttributeDefinitionUpdatedPublicEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.public.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionUpdatedPublicEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionUpdatedPublicEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionUpdatedPublicEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is created. A notification is sent when your application
// creates a custom attribute definition or another application creates a custom attribute definition whose
// `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type CustomerCustomAttributeDefinitionVisibleCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.visible.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionVisibleCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionVisibleCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionVisibleCreatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is deleted. A custom attribute definition can only be deleted
// by the application that created it. A notification is sent when your application deletes a custom attribute
// definition or when another application deletes a custom attribute definition whose `visibility` is
// `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type CustomerCustomAttributeDefinitionVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionVisibleDeletedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is updated. A custom attribute definition can only be updated
// by the application that created it. A notification is sent when your application updates a custom
// attribute definition or when another application updates a custom attribute definition whose `visibility` is
// `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type CustomerCustomAttributeDefinitionVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute_definition.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDefinitionVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDefinitionVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDefinitionVisibleUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is deleted. Custom attributes are owned by the application that created the
// corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application.
//
// This event is replaced by
// [customer.custom_attribute.owned.deleted](webhook:customer.custom_attribute.owned.deleted).
type CustomerCustomAttributeDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDeletedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDeletedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDeletedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDeletedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDeletedEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDeletedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDeletedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible
// to all applications is deleted. A notification is sent when any application deletes a custom attribute
// whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute.visible.deleted](webhook:customer.custom_attribute.visible.deleted),
// which applies to custom attributes that are visible to the subscribing application.
type CustomerCustomAttributeDeletedPublicEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.public.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeDeletedPublicEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeDeletedPublicEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeDeletedPublicEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeDeletedPublicEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeDeletedPublicEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeDeletedPublicEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeDeletedPublicEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeDeletedPublicEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeDeletedPublicEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeDeletedPublicEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is deleted. Custom attributes are owned by the application that created the
// corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application.
type CustomerCustomAttributeOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeOwnedDeletedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is created or updated. Custom attributes are owned by the application that created
// the corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application.
type CustomerCustomAttributeOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeOwnedUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is created or updated. Custom attributes are owned by the application that created
// the corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application.
//
// This event is replaced by
// [customer.custom_attribute.owned.updated](webhook:customer.custom_attribute.owned.updated).
type CustomerCustomAttributeUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeUpdatedEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible
// to all applications is created or updated. A notification is sent when any application creates or updates
// a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
//
// This event is replaced by
// [customer.custom_attribute.visible.updated](webhook:customer.custom_attribute.visible.updated),
// which applies to custom attributes that are visible to the subscribing application.
type CustomerCustomAttributeUpdatedPublicEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.public.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeUpdatedPublicEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeUpdatedPublicEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeUpdatedPublicEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible to the
// subscribing application is deleted. A notification is sent when:
// - Your application deletes a custom attribute owned by your application, regardless of the `visibility` setting.
// - Any application deletes a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY`
// or `VISIBILITY_READ_WRITE_VALUES`.
//
// Custom attributes set to `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application, but those set to
// `VISIBILITY_READ_ONLY` or `VISIBILITY_HIDDEN` can only be deleted by the owner. Custom attributes are owned
// by the application that created the corresponding [custom attribute definition](entity:CustomAttributeDefinition).
type CustomerCustomAttributeVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeVisibleDeletedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a customer [custom attribute](entity:CustomAttribute) that is visible to the
// subscribing application is created or updated. A notification is sent when:
// - Your application creates or updates a custom attribute owned by your application, regardless of the `visibility` setting.
// - Any application creates or updates a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY`
// or `VISIBILITY_READ_WRITE_VALUES`.
//
// Custom attributes set to `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application, but those set to
// `VISIBILITY_READ_ONLY` or `VISIBILITY_HIDDEN` can only be created or updated by the owner. Custom attributes are owned
// by the application that created the corresponding [custom attribute definition](entity:CustomAttributeDefinition).
type CustomerCustomAttributeVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"customer.custom_attribute.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) GetData() *CustomAttributeEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerCustomAttributeVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerCustomAttributeVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerCustomAttributeVisibleUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [customer](entity:Customer) is deleted.  For more information, see [Use Customer Webhooks](https://developer.squareup.com/docs/customers-api/use-the-api/customer-webhooks).
//
// The `customer` object in the event notification does not include the following fields: `group_ids` and `segment_ids`.
type CustomerDeletedEvent struct {
	// The ID of the seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this object, the value is `customer.deleted`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomerDeletedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerDeletedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerDeletedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerDeletedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerDeletedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerDeletedEvent) GetData() *CustomerDeletedEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerDeletedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The data associated with the event.
type CustomerDeletedEventData struct {
	// The type of object affected by the event. For this event, the value is `customer`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the deleted customer.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the deleted customer.
	Object *CustomerDeletedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerDeletedEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerDeletedEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CustomerDeletedEventData) GetObject() *CustomerDeletedEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CustomerDeletedEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about the change that triggered the event.
type CustomerDeletedEventEventContext struct {
	// Information about the merge operation associated with the event.
	Merge *CustomerDeletedEventEventContextMerge `json:"merge,omitempty" url:"merge,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerDeletedEventEventContext) GetMerge() *CustomerDeletedEventEventContextMerge {
	if c == nil {
		return nil
	}
	return c.Merge
}

func (c *CustomerDeletedEventEventContext) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedEventEventContext) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedEventEventContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedEventEventContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedEventEventContext) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Information about a merge operation, which creates a new customer using aggregated properties from two or more existing customers.
type CustomerDeletedEventEventContextMerge struct {
	// The IDs of the existing customers that were merged and then deleted.
	FromCustomerIDs []string `json:"from_customer_ids,omitempty" url:"from_customer_ids,omitempty"`
	// The ID of the new customer created by the merge.
	ToCustomerID *string `json:"to_customer_id,omitempty" url:"to_customer_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerDeletedEventEventContextMerge) GetFromCustomerIDs() []string {
	if c == nil {
		return nil
	}
	return c.FromCustomerIDs
}

func (c *CustomerDeletedEventEventContextMerge) GetToCustomerID() *string {
	if c == nil {
		return nil
	}
	return c.ToCustomerID
}

func (c *CustomerDeletedEventEventContextMerge) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedEventEventContextMerge) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedEventEventContextMerge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedEventEventContextMerge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedEventEventContextMerge) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An object that contains the customer associated with the event.
type CustomerDeletedEventObject struct {
	// The deleted customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`
	// Information about the change that triggered the event. This field is returned only if the customer is deleted by a merge operation.
	EventContext *CustomerDeletedEventEventContext `json:"event_context,omitempty" url:"event_context,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerDeletedEventObject) GetCustomer() *Customer {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *CustomerDeletedEventObject) GetEventContext() *CustomerDeletedEventEventContext {
	if c == nil {
		return nil
	}
	return c.EventContext
}

func (c *CustomerDeletedEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerDeletedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerDeletedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerDeletedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerDeletedEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a group of customer profiles.
//
// Customer groups can be created, be modified, and have their membership defined using
// the Customers API or within the Customer Directory in the Square Seller Dashboard or Point of Sale.
type CustomerGroup struct {
	// A unique Square-generated ID for the customer group.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the customer group.
	Name string `json:"name" url:"name"`
	// The timestamp when the customer group was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the customer group was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerGroup) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CustomerGroup) GetName() string {
	if c == nil {
		return ""
	}
	return c.Name
}

func (c *CustomerGroup) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerGroup) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CustomerGroup) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerGroup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerGroup) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a group of customer profiles that match one or more predefined filter criteria.
//
// Segments (also known as Smart Groups) are defined and created within the Customer Directory in the
// Square Seller Dashboard or Point of Sale.
type CustomerSegment struct {
	// A unique Square-generated ID for the segment.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the segment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The timestamp when the segment was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the segment was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerSegment) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CustomerSegment) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CustomerSegment) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerSegment) GetUpdatedAt() *string {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *CustomerSegment) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerSegment) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerSegment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerSegment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerSegment) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Published when a [customer](entity:Customer) is updated. For more information, see [Use Customer Webhooks](https://developer.squareup.com/docs/customers-api/use-the-api/customer-webhooks).
//
// Updates to the 'segment_ids' customer field does not invoke a `customer.updated` event. In addition, the `customer` object in the event notification does not include this field.
type CustomerUpdatedEvent struct {
	// The ID of the seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this object, the value is `customer.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomerUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerUpdatedEvent) GetMerchantID() *string {
	if c == nil {
		return nil
	}
	return c.MerchantID
}

func (c *CustomerUpdatedEvent) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerUpdatedEvent) GetEventID() *string {
	if c == nil {
		return nil
	}
	return c.EventID
}

func (c *CustomerUpdatedEvent) GetCreatedAt() *string {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *CustomerUpdatedEvent) GetData() *CustomerUpdatedEventData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CustomerUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerUpdatedEvent) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The data associated with the event.
type CustomerUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `customer`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated customer.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated customer.
	Object *CustomerUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerUpdatedEventData) GetType() *string {
	if c == nil {
		return nil
	}
	return c.Type
}

func (c *CustomerUpdatedEventData) GetID() *string {
	if c == nil {
		return nil
	}
	return c.ID
}

func (c *CustomerUpdatedEventData) GetObject() *CustomerUpdatedEventObject {
	if c == nil {
		return nil
	}
	return c.Object
}

func (c *CustomerUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerUpdatedEventData) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An object that contains the customer associated with the event.
type CustomerUpdatedEventObject struct {
	// The updated customer.
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CustomerUpdatedEventObject) GetCustomer() *Customer {
	if c == nil {
		return nil
	}
	return c.Customer
}

func (c *CustomerUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerUpdatedEventObject) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DataCollectionOptions struct {
	// The title text to display in the data collection flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display under the title in the data collection screen flow on the
	// Terminal.
	Body string `json:"body" url:"body"`
	// Represents the type of the input text.
	// See [InputType](#type-inputtype) for possible values
	InputType DataCollectionOptionsInputType `json:"input_type" url:"input_type"`
	// The buyer’s input text from the data collection screen.
	CollectedData *CollectedData `json:"collected_data,omitempty" url:"collected_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DataCollectionOptions) GetTitle() string {
	if d == nil {
		return ""
	}
	return d.Title
}

func (d *DataCollectionOptions) GetBody() string {
	if d == nil {
		return ""
	}
	return d.Body
}

func (d *DataCollectionOptions) GetInputType() DataCollectionOptionsInputType {
	if d == nil {
		return ""
	}
	return d.InputType
}

func (d *DataCollectionOptions) GetCollectedData() *CollectedData {
	if d == nil {
		return nil
	}
	return d.CollectedData
}

func (d *DataCollectionOptions) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DataCollectionOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler DataCollectionOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DataCollectionOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DataCollectionOptions) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Describes the input type of the data.
type DataCollectionOptionsInputType string

const (
	DataCollectionOptionsInputTypeEmail       DataCollectionOptionsInputType = "EMAIL"
	DataCollectionOptionsInputTypePhoneNumber DataCollectionOptionsInputType = "PHONE_NUMBER"
)

func NewDataCollectionOptionsInputTypeFromString(s string) (DataCollectionOptionsInputType, error) {
	switch s {
	case "EMAIL":
		return DataCollectionOptionsInputTypeEmail, nil
	case "PHONE_NUMBER":
		return DataCollectionOptionsInputTypePhoneNumber, nil
	}
	var t DataCollectionOptionsInputType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DataCollectionOptionsInputType) Ptr() *DataCollectionOptionsInputType {
	return &d
}

// A range defined by two dates. Used for filtering a query for Connect v2
// objects that have date properties.
type DateRange struct {
	// A string in `YYYY-MM-DD` format, such as `2017-10-31`, per the ISO 8601
	// extended format for calendar dates.
	// The beginning of a date range (inclusive).
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// A string in `YYYY-MM-DD` format, such as `2017-10-31`, per the ISO 8601
	// extended format for calendar dates.
	// The end of a date range (inclusive).
	EndDate *string `json:"end_date,omitempty" url:"end_date,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DateRange) GetStartDate() *string {
	if d == nil {
		return nil
	}
	return d.StartDate
}

func (d *DateRange) GetEndDate() *string {
	if d == nil {
		return nil
	}
	return d.EndDate
}

func (d *DateRange) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateRange) UnmarshalJSON(data []byte) error {
	type unmarshaler DateRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateRange) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Indicates the specific day  of the week.
type DayOfWeek string

const (
	DayOfWeekSun DayOfWeek = "SUN"
	DayOfWeekMon DayOfWeek = "MON"
	DayOfWeekTue DayOfWeek = "TUE"
	DayOfWeekWed DayOfWeek = "WED"
	DayOfWeekThu DayOfWeek = "THU"
	DayOfWeekFri DayOfWeek = "FRI"
	DayOfWeekSat DayOfWeek = "SAT"
)

func NewDayOfWeekFromString(s string) (DayOfWeek, error) {
	switch s {
	case "SUN":
		return DayOfWeekSun, nil
	case "MON":
		return DayOfWeekMon, nil
	case "TUE":
		return DayOfWeekTue, nil
	case "WED":
		return DayOfWeekWed, nil
	case "THU":
		return DayOfWeekThu, nil
	case "FRI":
		return DayOfWeekFri, nil
	case "SAT":
		return DayOfWeekSat, nil
	}
	var t DayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfWeek) Ptr() *DayOfWeek {
	return &d
}

// Represents a [DeleteBookingCustomAttributeDefinition](api-endpoint:BookingCustomAttributes-DeleteBookingCustomAttributeDefinition) response
// containing error messages when errors occurred during the request. The successful response does not contain any payload.
type DeleteBookingCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteBookingCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBookingCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBookingCustomAttributeDefinitionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteBookingCustomAttribute](api-endpoint:BookingCustomAttributes-DeleteBookingCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteBookingCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteBookingCustomAttributeResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteBookingCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBookingCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBookingCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBookingCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBookingCustomAttributeResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The response to a request to delete a `BreakType`. The response might contain a set
// of `Error` objects if the request resulted in errors.
type DeleteBreakTypeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteBreakTypeResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteBreakTypeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteBreakTypeResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeleteCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The IDs of all catalog objects deleted by this request.
	// Multiple IDs may be returned when associated objects are also deleted, for example
	// a catalog item variation will be deleted (and its ID included in this field)
	// when its parent catalog item is deleted.
	DeletedObjectIDs []string `json:"deleted_object_ids,omitempty" url:"deleted_object_ids,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// of this deletion in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
	DeletedAt *string `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteCatalogObjectResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteCatalogObjectResponse) GetDeletedObjectIDs() []string {
	if d == nil {
		return nil
	}
	return d.DeletedObjectIDs
}

func (d *DeleteCatalogObjectResponse) GetDeletedAt() *string {
	if d == nil {
		return nil
	}
	return d.DeletedAt
}

func (d *DeleteCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCatalogObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCatalogObjectResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the `DeleteCustomerCard` endpoint.
type DeleteCustomerCardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteCustomerCardResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteCustomerCardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCardResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from a delete request containing error messages if there are any.
type DeleteCustomerCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteCustomerCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeDefinitionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-DeleteCustomerCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteCustomerCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteCustomerCustomAttributeResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerCustomAttributeResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DeleteCustomerGroup](api-endpoint:CustomerGroups-DeleteCustomerGroup) endpoint.
type DeleteCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteCustomerGroupResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerGroupResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerGroupResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields in a `DeleteDisputeEvidence` response.
type DeleteDisputeEvidenceResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteDisputeEvidenceResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteDisputeEvidenceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteDisputeEvidenceResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from a delete request containing error messages if there are any.
type DeleteLocationCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteLocationCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLocationCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLocationCustomAttributeDefinitionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteLocationCustomAttribute](api-endpoint:LocationCustomAttributes-DeleteLocationCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteLocationCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteLocationCustomAttributeResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteLocationCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLocationCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLocationCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLocationCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLocationCustomAttributeResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A response returned by the API call.
type DeleteLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteLoyaltyRewardResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteLoyaltyRewardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteLoyaltyRewardResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from a delete request containing error messages if there are any.
type DeleteMerchantCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteMerchantCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteMerchantCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteMerchantCustomAttributeDefinitionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [DeleteMerchantCustomAttribute](api-endpoint:MerchantCustomAttributes-DeleteMerchantCustomAttribute) response.
// Either an empty object `{}` (for a successful deletion) or `errors` is present in the response.
type DeleteMerchantCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteMerchantCustomAttributeResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteMerchantCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteMerchantCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteMerchantCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteMerchantCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteMerchantCustomAttributeResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from deleting an order custom attribute definition.
type DeleteOrderCustomAttributeDefinitionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteOrderCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteOrderCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteOrderCustomAttributeDefinitionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a response from deleting an order custom attribute.
type DeleteOrderCustomAttributeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteOrderCustomAttributeResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteOrderCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteOrderCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteOrderCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteOrderCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteOrderCustomAttributeResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeletePaymentLinkResponse struct {
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The ID of the link that is deleted.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the order that is canceled. When a payment link is deleted, Square updates the
	// the `state` (of the order that the checkout link created) to CANCELED.
	CancelledOrderID *string `json:"cancelled_order_id,omitempty" url:"cancelled_order_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeletePaymentLinkResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeletePaymentLinkResponse) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DeletePaymentLinkResponse) GetCancelledOrderID() *string {
	if d == nil {
		return nil
	}
	return d.CancelledOrderID
}

func (d *DeletePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeletePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeletePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeletePaymentLinkResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeletePaymentLinkResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The response to a request to delete a `Shift`. The response might contain a set of
// `Error` objects if the request resulted in errors.
type DeleteShiftResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteShiftResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteShiftResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteShiftResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the [DeleteWebhookSubscription](api-endpoint:WebhookSubscriptions-DeleteWebhookSubscription) endpoint.
type DeleteWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteWebhookSubscriptionResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteWebhookSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteWebhookSubscriptionResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCheckoutOptions struct {
	// The unique ID of the device intended for this `TerminalCheckout`.
	// A list of `DeviceCode` objects can be retrieved from the /v2/devices/codes endpoint.
	// Match a `DeviceCode.device_id` value with `device_id` to get the associated device code.
	DeviceID string `json:"device_id" url:"device_id"`
	// Instructs the device to skip the receipt screen. Defaults to false.
	SkipReceiptScreen *bool `json:"skip_receipt_screen,omitempty" url:"skip_receipt_screen,omitempty"`
	// Indicates that signature collection is desired during checkout. Defaults to false.
	CollectSignature *bool `json:"collect_signature,omitempty" url:"collect_signature,omitempty"`
	// Tip-specific settings.
	TipSettings *TipSettings `json:"tip_settings,omitempty" url:"tip_settings,omitempty"`
	// Show the itemization screen prior to taking a payment. This field is only meaningful when the
	// checkout includes an order ID. Defaults to true.
	ShowItemizedCart *bool `json:"show_itemized_cart,omitempty" url:"show_itemized_cart,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCheckoutOptions) GetDeviceID() string {
	if d == nil {
		return ""
	}
	return d.DeviceID
}

func (d *DeviceCheckoutOptions) GetSkipReceiptScreen() *bool {
	if d == nil {
		return nil
	}
	return d.SkipReceiptScreen
}

func (d *DeviceCheckoutOptions) GetCollectSignature() *bool {
	if d == nil {
		return nil
	}
	return d.CollectSignature
}

func (d *DeviceCheckoutOptions) GetTipSettings() *TipSettings {
	if d == nil {
		return nil
	}
	return d.TipSettings
}

func (d *DeviceCheckoutOptions) GetShowItemizedCart() *bool {
	if d == nil {
		return nil
	}
	return d.ShowItemizedCart
}

func (d *DeviceCheckoutOptions) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCheckoutOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCheckoutOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCheckoutOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCheckoutOptions) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCode struct {
	// The unique id for this device code.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An optional user-defined name for the device code.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The unique code that can be used to login.
	Code *string `json:"code,omitempty" url:"code,omitempty"`
	// The unique id of the device that used this code. Populated when the device is paired up.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The targeting product type of the device code.
	ProductType ProductType `json:"product_type" url:"product_type"`
	// The location assigned to this code.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The pairing status of the device code.
	// See [DeviceCodeStatus](#type-devicecodestatus) for possible values
	Status *DeviceCodeStatus `json:"status,omitempty" url:"status,omitempty"`
	// When this DeviceCode will expire and no longer login. Timestamp in RFC 3339 format.
	PairBy *string `json:"pair_by,omitempty" url:"pair_by,omitempty"`
	// When this DeviceCode was created. Timestamp in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// When this DeviceCode's status was last changed. Timestamp in RFC 3339 format.
	StatusChangedAt *string `json:"status_changed_at,omitempty" url:"status_changed_at,omitempty"`
	// When this DeviceCode was paired. Timestamp in RFC 3339 format.
	PairedAt *string `json:"paired_at,omitempty" url:"paired_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCode) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DeviceCode) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeviceCode) GetCode() *string {
	if d == nil {
		return nil
	}
	return d.Code
}

func (d *DeviceCode) GetDeviceID() *string {
	if d == nil {
		return nil
	}
	return d.DeviceID
}

func (d *DeviceCode) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DeviceCode) GetStatus() *DeviceCodeStatus {
	if d == nil {
		return nil
	}
	return d.Status
}

func (d *DeviceCode) GetPairBy() *string {
	if d == nil {
		return nil
	}
	return d.PairBy
}

func (d *DeviceCode) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DeviceCode) GetStatusChangedAt() *string {
	if d == nil {
		return nil
	}
	return d.StatusChangedAt
}

func (d *DeviceCode) GetPairedAt() *string {
	if d == nil {
		return nil
	}
	return d.PairedAt
}

func (d *DeviceCode) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCode) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCode(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCode) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when a Square Terminal has been paired with a
// Terminal API client and the device_id of the paired Square Terminal is
// available.
type DeviceCodePairedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"device.code.paired"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DeviceCodePairedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCodePairedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DeviceCodePairedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DeviceCodePairedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DeviceCodePairedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DeviceCodePairedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DeviceCodePairedEvent) GetData() *DeviceCodePairedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DeviceCodePairedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCodePairedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCodePairedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCodePairedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCodePairedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCodePairedEventData struct {
	// Name of the paired object’s type, `"device_code"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the paired device code.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the paired device code.
	Object *DeviceCodePairedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCodePairedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DeviceCodePairedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DeviceCodePairedEventData) GetObject() *DeviceCodePairedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DeviceCodePairedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCodePairedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCodePairedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCodePairedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCodePairedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCodePairedEventObject struct {
	// The created terminal checkout
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCodePairedEventObject) GetDeviceCode() *DeviceCode {
	if d == nil {
		return nil
	}
	return d.DeviceCode
}

func (d *DeviceCodePairedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCodePairedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCodePairedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCodePairedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCodePairedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// DeviceCode.Status enum.
type DeviceCodeStatus string

const (
	DeviceCodeStatusUnknown  DeviceCodeStatus = "UNKNOWN"
	DeviceCodeStatusUnpaired DeviceCodeStatus = "UNPAIRED"
	DeviceCodeStatusPaired   DeviceCodeStatus = "PAIRED"
	DeviceCodeStatusExpired  DeviceCodeStatus = "EXPIRED"
)

func NewDeviceCodeStatusFromString(s string) (DeviceCodeStatus, error) {
	switch s {
	case "UNKNOWN":
		return DeviceCodeStatusUnknown, nil
	case "UNPAIRED":
		return DeviceCodeStatusUnpaired, nil
	case "PAIRED":
		return DeviceCodeStatusPaired, nil
	case "EXPIRED":
		return DeviceCodeStatusExpired, nil
	}
	var t DeviceCodeStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceCodeStatus) Ptr() *DeviceCodeStatus {
	return &d
}

// Published when a Device is created.
type DeviceCreatedEvent struct {
	// The merchant the newly created device belongs to.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents. The value is `"device.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A UUID that uniquely identifies this device creation event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The time when the device creation event was first created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The metadata associated with the device creation event.
	Data *DeviceCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCreatedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DeviceCreatedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DeviceCreatedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DeviceCreatedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DeviceCreatedEvent) GetData() *DeviceCreatedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DeviceCreatedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCreatedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCreatedEventData struct {
	// The type of the event data object. The value is `"device"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the device.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created device.
	Object *DeviceCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCreatedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DeviceCreatedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DeviceCreatedEventData) GetObject() *DeviceCreatedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DeviceCreatedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCreatedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceCreatedEventObject struct {
	// The created device.
	Device *Device `json:"device,omitempty" url:"device,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceCreatedEventObject) GetDevice() *Device {
	if d == nil {
		return nil
	}
	return d.Device
}

func (d *DeviceCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceCreatedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceMetadata struct {
	// The Terminal’s remaining battery percentage, between 1-100.
	BatteryPercentage *string `json:"battery_percentage,omitempty" url:"battery_percentage,omitempty"`
	// The current charging state of the Terminal.
	// Options: `CHARGING`, `NOT_CHARGING`
	ChargingState *string `json:"charging_state,omitempty" url:"charging_state,omitempty"`
	// The ID of the Square seller business location associated with the Terminal.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the Square merchant account that is currently signed-in to the Terminal.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The Terminal’s current network connection type.
	// Options: `WIFI`, `ETHERNET`
	NetworkConnectionType *string `json:"network_connection_type,omitempty" url:"network_connection_type,omitempty"`
	// The country in which the Terminal is authorized to take payments.
	PaymentRegion *string `json:"payment_region,omitempty" url:"payment_region,omitempty"`
	// The unique identifier assigned to the Terminal, which can be found on the lower back
	// of the device.
	SerialNumber *string `json:"serial_number,omitempty" url:"serial_number,omitempty"`
	// The current version of the Terminal’s operating system.
	OsVersion *string `json:"os_version,omitempty" url:"os_version,omitempty"`
	// The current version of the application running on the Terminal.
	AppVersion *string `json:"app_version,omitempty" url:"app_version,omitempty"`
	// The name of the Wi-Fi network to which the Terminal is connected.
	WifiNetworkName *string `json:"wifi_network_name,omitempty" url:"wifi_network_name,omitempty"`
	// The signal strength of the Wi-FI network connection.
	// Options: `POOR`, `FAIR`, `GOOD`, `EXCELLENT`
	WifiNetworkStrength *string `json:"wifi_network_strength,omitempty" url:"wifi_network_strength,omitempty"`
	// The IP address of the Terminal.
	IPAddress *string `json:"ip_address,omitempty" url:"ip_address,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceMetadata) GetBatteryPercentage() *string {
	if d == nil {
		return nil
	}
	return d.BatteryPercentage
}

func (d *DeviceMetadata) GetChargingState() *string {
	if d == nil {
		return nil
	}
	return d.ChargingState
}

func (d *DeviceMetadata) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DeviceMetadata) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DeviceMetadata) GetNetworkConnectionType() *string {
	if d == nil {
		return nil
	}
	return d.NetworkConnectionType
}

func (d *DeviceMetadata) GetPaymentRegion() *string {
	if d == nil {
		return nil
	}
	return d.PaymentRegion
}

func (d *DeviceMetadata) GetSerialNumber() *string {
	if d == nil {
		return nil
	}
	return d.SerialNumber
}

func (d *DeviceMetadata) GetOsVersion() *string {
	if d == nil {
		return nil
	}
	return d.OsVersion
}

func (d *DeviceMetadata) GetAppVersion() *string {
	if d == nil {
		return nil
	}
	return d.AppVersion
}

func (d *DeviceMetadata) GetWifiNetworkName() *string {
	if d == nil {
		return nil
	}
	return d.WifiNetworkName
}

func (d *DeviceMetadata) GetWifiNetworkStrength() *string {
	if d == nil {
		return nil
	}
	return d.WifiNetworkStrength
}

func (d *DeviceMetadata) GetIPAddress() *string {
	if d == nil {
		return nil
	}
	return d.IPAddress
}

func (d *DeviceMetadata) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceMetadata) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when a [Dispute](entity:Dispute) is created.
type DisputeCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeCreatedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DisputeCreatedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DisputeCreatedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeCreatedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DisputeCreatedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DisputeCreatedEvent) GetData() *DisputeCreatedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DisputeCreatedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeCreatedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeCreatedEventData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeCreatedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeCreatedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeCreatedEventData) GetObject() *DisputeCreatedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeCreatedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeCreatedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeCreatedEventObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeCreatedEventObject) GetObject() *Dispute {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeCreatedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidence struct {
	// The Square-generated ID of the evidence.
	EvidenceID *string `json:"evidence_id,omitempty" url:"evidence_id,omitempty"`
	// The Square-generated ID of the evidence.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the dispute the evidence is associated with.
	DisputeID *string `json:"dispute_id,omitempty" url:"dispute_id,omitempty"`
	// Image, PDF, TXT
	EvidenceFile *DisputeEvidenceFile `json:"evidence_file,omitempty" url:"evidence_file,omitempty"`
	// Raw text
	EvidenceText *string `json:"evidence_text,omitempty" url:"evidence_text,omitempty"`
	// The time when the evidence was uploaded, in RFC 3339 format.
	UploadedAt *string `json:"uploaded_at,omitempty" url:"uploaded_at,omitempty"`
	// The type of the evidence.
	// See [DisputeEvidenceType](#type-disputeevidencetype) for possible values
	EvidenceType *DisputeEvidenceType `json:"evidence_type,omitempty" url:"evidence_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidence) GetEvidenceID() *string {
	if d == nil {
		return nil
	}
	return d.EvidenceID
}

func (d *DisputeEvidence) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeEvidence) GetDisputeID() *string {
	if d == nil {
		return nil
	}
	return d.DisputeID
}

func (d *DisputeEvidence) GetEvidenceFile() *DisputeEvidenceFile {
	if d == nil {
		return nil
	}
	return d.EvidenceFile
}

func (d *DisputeEvidence) GetEvidenceText() *string {
	if d == nil {
		return nil
	}
	return d.EvidenceText
}

func (d *DisputeEvidence) GetUploadedAt() *string {
	if d == nil {
		return nil
	}
	return d.UploadedAt
}

func (d *DisputeEvidence) GetEvidenceType() *DisputeEvidenceType {
	if d == nil {
		return nil
	}
	return d.EvidenceType
}

func (d *DisputeEvidence) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidence) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidence
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidence(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidence) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is added to a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling either [CreateDisputeEvidenceFile](api-endpoint:Disputes-CreateDisputeEvidenceFile) or [CreateDisputeEvidenceText](api-endpoint:Disputes-CreateDisputeEvidenceText).
type DisputeEvidenceAddedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceAddedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceAddedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DisputeEvidenceAddedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DisputeEvidenceAddedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceAddedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DisputeEvidenceAddedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DisputeEvidenceAddedEvent) GetData() *DisputeEvidenceAddedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DisputeEvidenceAddedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceAddedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceAddedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceAddedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceAddedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceAddedEventData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceAddedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceAddedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceAddedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeEvidenceAddedEventData) GetObject() *DisputeEvidenceAddedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceAddedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceAddedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceAddedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceAddedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceAddedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceAddedEventObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceAddedEventObject) GetObject() *Dispute {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceAddedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceAddedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceAddedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceAddedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceAddedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is added to a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling either [CreateDisputeEvidenceFile](api-endpoint:Disputes-CreateDisputeEvidenceFile) or [CreateDisputeEvidenceText](api-endpoint:Disputes-CreateDisputeEvidenceText).
type DisputeEvidenceCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceCreatedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DisputeEvidenceCreatedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DisputeEvidenceCreatedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceCreatedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DisputeEvidenceCreatedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DisputeEvidenceCreatedEvent) GetData() *DisputeEvidenceCreatedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DisputeEvidenceCreatedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceCreatedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceCreatedEventData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceCreatedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceCreatedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeEvidenceCreatedEventData) GetObject() *DisputeEvidenceCreatedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceCreatedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceCreatedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceCreatedEventObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceCreatedEventObject) GetObject() *Dispute {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceCreatedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is removed from a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling [DeleteDisputeEvidence](api-endpoint:Disputes-DeleteDisputeEvidence).
type DisputeEvidenceDeletedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceDeletedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceDeletedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DisputeEvidenceDeletedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DisputeEvidenceDeletedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceDeletedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DisputeEvidenceDeletedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DisputeEvidenceDeletedEvent) GetData() *DisputeEvidenceDeletedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DisputeEvidenceDeletedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceDeletedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceDeletedEventData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceDeletedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceDeletedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceDeletedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeEvidenceDeletedEventData) GetObject() *DisputeEvidenceDeletedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceDeletedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceDeletedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceDeletedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceDeletedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceDeletedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceDeletedEventObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceDeletedEventObject) GetObject() *Dispute {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceDeletedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceDeletedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceDeletedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceDeletedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceDeletedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A file to be uploaded as dispute evidence.
type DisputeEvidenceFile struct {
	// The file name including the file extension. For example: "receipt.tiff".
	Filename *string `json:"filename,omitempty" url:"filename,omitempty"`
	// Dispute evidence files must be application/pdf, image/heic, image/heif, image/jpeg, image/png, or image/tiff formats.
	Filetype *string `json:"filetype,omitempty" url:"filetype,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceFile) GetFilename() *string {
	if d == nil {
		return nil
	}
	return d.Filename
}

func (d *DisputeEvidenceFile) GetFiletype() *string {
	if d == nil {
		return nil
	}
	return d.Filetype
}

func (d *DisputeEvidenceFile) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceFile) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceFile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceFile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceFile) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when evidence is removed from a [Dispute](entity:Dispute)
// from the Disputes Dashboard in the Seller Dashboard, the Square Point of Sale app,
// or by calling [DeleteDisputeEvidence](api-endpoint:Disputes-DeleteDisputeEvidence).
type DisputeEvidenceRemovedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeEvidenceRemovedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceRemovedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DisputeEvidenceRemovedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DisputeEvidenceRemovedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceRemovedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DisputeEvidenceRemovedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DisputeEvidenceRemovedEvent) GetData() *DisputeEvidenceRemovedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DisputeEvidenceRemovedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceRemovedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceRemovedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceRemovedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceRemovedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceRemovedEventData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeEvidenceRemovedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceRemovedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeEvidenceRemovedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeEvidenceRemovedEventData) GetObject() *DisputeEvidenceRemovedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceRemovedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceRemovedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceRemovedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceRemovedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceRemovedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeEvidenceRemovedEventObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeEvidenceRemovedEventObject) GetObject() *Dispute {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeEvidenceRemovedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeEvidenceRemovedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeEvidenceRemovedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeEvidenceRemovedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeEvidenceRemovedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of the dispute evidence.
type DisputeEvidenceType string

const (
	DisputeEvidenceTypeGenericEvidence                   DisputeEvidenceType = "GENERIC_EVIDENCE"
	DisputeEvidenceTypeOnlineOrAppAccessLog              DisputeEvidenceType = "ONLINE_OR_APP_ACCESS_LOG"
	DisputeEvidenceTypeAuthorizationDocumentation        DisputeEvidenceType = "AUTHORIZATION_DOCUMENTATION"
	DisputeEvidenceTypeCancellationOrRefundDocumentation DisputeEvidenceType = "CANCELLATION_OR_REFUND_DOCUMENTATION"
	DisputeEvidenceTypeCardholderCommunication           DisputeEvidenceType = "CARDHOLDER_COMMUNICATION"
	DisputeEvidenceTypeCardholderInformation             DisputeEvidenceType = "CARDHOLDER_INFORMATION"
	DisputeEvidenceTypePurchaseAcknowledgement           DisputeEvidenceType = "PURCHASE_ACKNOWLEDGEMENT"
	DisputeEvidenceTypeDuplicateChargeDocumentation      DisputeEvidenceType = "DUPLICATE_CHARGE_DOCUMENTATION"
	DisputeEvidenceTypeProductOrServiceDescription       DisputeEvidenceType = "PRODUCT_OR_SERVICE_DESCRIPTION"
	DisputeEvidenceTypeReceipt                           DisputeEvidenceType = "RECEIPT"
	DisputeEvidenceTypeServiceReceivedDocumentation      DisputeEvidenceType = "SERVICE_RECEIVED_DOCUMENTATION"
	DisputeEvidenceTypeProofOfDeliveryDocumentation      DisputeEvidenceType = "PROOF_OF_DELIVERY_DOCUMENTATION"
	DisputeEvidenceTypeRelatedTransactionDocumentation   DisputeEvidenceType = "RELATED_TRANSACTION_DOCUMENTATION"
	DisputeEvidenceTypeRebuttalExplanation               DisputeEvidenceType = "REBUTTAL_EXPLANATION"
	DisputeEvidenceTypeTrackingNumber                    DisputeEvidenceType = "TRACKING_NUMBER"
)

func NewDisputeEvidenceTypeFromString(s string) (DisputeEvidenceType, error) {
	switch s {
	case "GENERIC_EVIDENCE":
		return DisputeEvidenceTypeGenericEvidence, nil
	case "ONLINE_OR_APP_ACCESS_LOG":
		return DisputeEvidenceTypeOnlineOrAppAccessLog, nil
	case "AUTHORIZATION_DOCUMENTATION":
		return DisputeEvidenceTypeAuthorizationDocumentation, nil
	case "CANCELLATION_OR_REFUND_DOCUMENTATION":
		return DisputeEvidenceTypeCancellationOrRefundDocumentation, nil
	case "CARDHOLDER_COMMUNICATION":
		return DisputeEvidenceTypeCardholderCommunication, nil
	case "CARDHOLDER_INFORMATION":
		return DisputeEvidenceTypeCardholderInformation, nil
	case "PURCHASE_ACKNOWLEDGEMENT":
		return DisputeEvidenceTypePurchaseAcknowledgement, nil
	case "DUPLICATE_CHARGE_DOCUMENTATION":
		return DisputeEvidenceTypeDuplicateChargeDocumentation, nil
	case "PRODUCT_OR_SERVICE_DESCRIPTION":
		return DisputeEvidenceTypeProductOrServiceDescription, nil
	case "RECEIPT":
		return DisputeEvidenceTypeReceipt, nil
	case "SERVICE_RECEIVED_DOCUMENTATION":
		return DisputeEvidenceTypeServiceReceivedDocumentation, nil
	case "PROOF_OF_DELIVERY_DOCUMENTATION":
		return DisputeEvidenceTypeProofOfDeliveryDocumentation, nil
	case "RELATED_TRANSACTION_DOCUMENTATION":
		return DisputeEvidenceTypeRelatedTransactionDocumentation, nil
	case "REBUTTAL_EXPLANATION":
		return DisputeEvidenceTypeRebuttalExplanation, nil
	case "TRACKING_NUMBER":
		return DisputeEvidenceTypeTrackingNumber, nil
	}
	var t DisputeEvidenceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DisputeEvidenceType) Ptr() *DisputeEvidenceType {
	return &d
}

// Published when the state of a [Dispute](entity:Dispute) changes.
// This includes the dispute resolution (WON, LOST) reported by the bank. The event
// data includes details of what changed.
type DisputeStateChangedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeStateChangedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeStateChangedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DisputeStateChangedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DisputeStateChangedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeStateChangedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DisputeStateChangedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DisputeStateChangedEvent) GetData() *DisputeStateChangedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DisputeStateChangedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateChangedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateChangedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateChangedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateChangedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateChangedEventData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeStateChangedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeStateChangedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeStateChangedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeStateChangedEventData) GetObject() *DisputeStateChangedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeStateChangedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateChangedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateChangedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateChangedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateChangedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateChangedEventObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeStateChangedEventObject) GetObject() *Dispute {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeStateChangedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateChangedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateChangedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateChangedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateChangedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Published when the state of a [Dispute](entity:Dispute) changes.
// This includes the dispute resolution (WON, LOST) reported by the bank. The event
// data includes details of what changed.
type DisputeStateUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *DisputeStateUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeStateUpdatedEvent) GetMerchantID() *string {
	if d == nil {
		return nil
	}
	return d.MerchantID
}

func (d *DisputeStateUpdatedEvent) GetLocationID() *string {
	if d == nil {
		return nil
	}
	return d.LocationID
}

func (d *DisputeStateUpdatedEvent) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeStateUpdatedEvent) GetEventID() *string {
	if d == nil {
		return nil
	}
	return d.EventID
}

func (d *DisputeStateUpdatedEvent) GetCreatedAt() *string {
	if d == nil {
		return nil
	}
	return d.CreatedAt
}

func (d *DisputeStateUpdatedEvent) GetData() *DisputeStateUpdatedEventData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DisputeStateUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateUpdatedEvent) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateUpdatedEventData struct {
	// Name of the affected dispute's type.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected dispute.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event.
	Object *DisputeStateUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeStateUpdatedEventData) GetType() *string {
	if d == nil {
		return nil
	}
	return d.Type
}

func (d *DisputeStateUpdatedEventData) GetID() *string {
	if d == nil {
		return nil
	}
	return d.ID
}

func (d *DisputeStateUpdatedEventData) GetObject() *DisputeStateUpdatedEventObject {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeStateUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateUpdatedEventData) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DisputeStateUpdatedEventObject struct {
	// The dispute object.
	Object *Dispute `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DisputeStateUpdatedEventObject) GetObject() *Dispute {
	if d == nil {
		return nil
	}
	return d.Object
}

func (d *DisputeStateUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DisputeStateUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler DisputeStateUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DisputeStateUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DisputeStateUpdatedEventObject) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Determines item visibility in Ecom (Online Store) and Online Checkout.
type EcomVisibility string

const (
	EcomVisibilityUnindexed   EcomVisibility = "UNINDEXED"
	EcomVisibilityUnavailable EcomVisibility = "UNAVAILABLE"
	EcomVisibilityHidden      EcomVisibility = "HIDDEN"
	EcomVisibilityVisible     EcomVisibility = "VISIBLE"
)

func NewEcomVisibilityFromString(s string) (EcomVisibility, error) {
	switch s {
	case "UNINDEXED":
		return EcomVisibilityUnindexed, nil
	case "UNAVAILABLE":
		return EcomVisibilityUnavailable, nil
	case "HIDDEN":
		return EcomVisibilityHidden, nil
	case "VISIBLE":
		return EcomVisibilityVisible, nil
	}
	var t EcomVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EcomVisibility) Ptr() *EcomVisibility {
	return &e
}

// The hourly wage rate that an employee earns on a `Shift` for doing the job specified by the `title` property of this object. Deprecated at version 2020-08-26. Use [TeamMemberWage](entity:TeamMemberWage).
type EmployeeWage struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The `Employee` that this wage is assigned to.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The job title that this wage relates to.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EmployeeWage) GetID() *string {
	if e == nil {
		return nil
	}
	return e.ID
}

func (e *EmployeeWage) GetEmployeeID() *string {
	if e == nil {
		return nil
	}
	return e.EmployeeID
}

func (e *EmployeeWage) GetTitle() *string {
	if e == nil {
		return nil
	}
	return e.Title
}

func (e *EmployeeWage) GetHourlyRate() *Money {
	if e == nil {
		return nil
	}
	return e.HourlyRate
}

func (e *EmployeeWage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EmployeeWage) UnmarshalJSON(data []byte) error {
	type unmarshaler EmployeeWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmployeeWage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmployeeWage) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Represents an error encountered during a request to the Connect API.
//
// See [Handling errors](https://developer.squareup.com/docs/build-basics/handling-errors) for more information.
type Error struct {
	// The high-level category for the error.
	// See [ErrorCategory](#type-errorcategory) for possible values
	Category ErrorCategory `json:"category" url:"category"`
	// The specific code of the error.
	// See [ErrorCode](#type-errorcode) for possible values
	Code ErrorCode `json:"code" url:"code"`
	// A human-readable description of the error for debugging purposes.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// The name of the field provided in the original request (if any) that
	// the error pertains to.
	Field *string `json:"field,omitempty" url:"field,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Error) GetCategory() ErrorCategory {
	if e == nil {
		return ""
	}
	return e.Category
}

func (e *Error) GetCode() ErrorCode {
	if e == nil {
		return ""
	}
	return e.Code
}

func (e *Error) GetDetail() *string {
	if e == nil {
		return nil
	}
	return e.Detail
}

func (e *Error) GetField() *string {
	if e == nil {
		return nil
	}
	return e.Field
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which high-level category of error has occurred during a
// request to the Connect API.
type ErrorCategory string

const (
	ErrorCategoryAPIError                  ErrorCategory = "API_ERROR"
	ErrorCategoryAuthenticationError       ErrorCategory = "AUTHENTICATION_ERROR"
	ErrorCategoryInvalidRequestError       ErrorCategory = "INVALID_REQUEST_ERROR"
	ErrorCategoryRateLimitError            ErrorCategory = "RATE_LIMIT_ERROR"
	ErrorCategoryPaymentMethodError        ErrorCategory = "PAYMENT_METHOD_ERROR"
	ErrorCategoryRefundError               ErrorCategory = "REFUND_ERROR"
	ErrorCategoryMerchantSubscriptionError ErrorCategory = "MERCHANT_SUBSCRIPTION_ERROR"
	ErrorCategoryExternalVendorError       ErrorCategory = "EXTERNAL_VENDOR_ERROR"
)

func NewErrorCategoryFromString(s string) (ErrorCategory, error) {
	switch s {
	case "API_ERROR":
		return ErrorCategoryAPIError, nil
	case "AUTHENTICATION_ERROR":
		return ErrorCategoryAuthenticationError, nil
	case "INVALID_REQUEST_ERROR":
		return ErrorCategoryInvalidRequestError, nil
	case "RATE_LIMIT_ERROR":
		return ErrorCategoryRateLimitError, nil
	case "PAYMENT_METHOD_ERROR":
		return ErrorCategoryPaymentMethodError, nil
	case "REFUND_ERROR":
		return ErrorCategoryRefundError, nil
	case "MERCHANT_SUBSCRIPTION_ERROR":
		return ErrorCategoryMerchantSubscriptionError, nil
	case "EXTERNAL_VENDOR_ERROR":
		return ErrorCategoryExternalVendorError, nil
	}
	var t ErrorCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCategory) Ptr() *ErrorCategory {
	return &e
}

// Indicates the specific error that occurred during a request to a
// Square API.
type ErrorCode string

const (
	ErrorCodeInternalServerError                           ErrorCode = "INTERNAL_SERVER_ERROR"
	ErrorCodeUnauthorized                                  ErrorCode = "UNAUTHORIZED"
	ErrorCodeAccessTokenExpired                            ErrorCode = "ACCESS_TOKEN_EXPIRED"
	ErrorCodeAccessTokenRevoked                            ErrorCode = "ACCESS_TOKEN_REVOKED"
	ErrorCodeClientDisabled                                ErrorCode = "CLIENT_DISABLED"
	ErrorCodeForbidden                                     ErrorCode = "FORBIDDEN"
	ErrorCodeInsufficientScopes                            ErrorCode = "INSUFFICIENT_SCOPES"
	ErrorCodeApplicationDisabled                           ErrorCode = "APPLICATION_DISABLED"
	ErrorCodeV1Application                                 ErrorCode = "V1_APPLICATION"
	ErrorCodeV1AccessToken                                 ErrorCode = "V1_ACCESS_TOKEN"
	ErrorCodeCardProcessingNotEnabled                      ErrorCode = "CARD_PROCESSING_NOT_ENABLED"
	ErrorCodeMerchantSubscriptionNotFound                  ErrorCode = "MERCHANT_SUBSCRIPTION_NOT_FOUND"
	ErrorCodeBadRequest                                    ErrorCode = "BAD_REQUEST"
	ErrorCodeMissingRequiredParameter                      ErrorCode = "MISSING_REQUIRED_PARAMETER"
	ErrorCodeIncorrectType                                 ErrorCode = "INCORRECT_TYPE"
	ErrorCodeInvalidTime                                   ErrorCode = "INVALID_TIME"
	ErrorCodeInvalidTimeRange                              ErrorCode = "INVALID_TIME_RANGE"
	ErrorCodeInvalidValue                                  ErrorCode = "INVALID_VALUE"
	ErrorCodeInvalidCursor                                 ErrorCode = "INVALID_CURSOR"
	ErrorCodeUnknownQueryParameter                         ErrorCode = "UNKNOWN_QUERY_PARAMETER"
	ErrorCodeConflictingParameters                         ErrorCode = "CONFLICTING_PARAMETERS"
	ErrorCodeExpectedJSONBody                              ErrorCode = "EXPECTED_JSON_BODY"
	ErrorCodeInvalidSortOrder                              ErrorCode = "INVALID_SORT_ORDER"
	ErrorCodeValueRegexMismatch                            ErrorCode = "VALUE_REGEX_MISMATCH"
	ErrorCodeValueTooShort                                 ErrorCode = "VALUE_TOO_SHORT"
	ErrorCodeValueTooLong                                  ErrorCode = "VALUE_TOO_LONG"
	ErrorCodeValueTooLow                                   ErrorCode = "VALUE_TOO_LOW"
	ErrorCodeValueTooHigh                                  ErrorCode = "VALUE_TOO_HIGH"
	ErrorCodeValueEmpty                                    ErrorCode = "VALUE_EMPTY"
	ErrorCodeArrayLengthTooLong                            ErrorCode = "ARRAY_LENGTH_TOO_LONG"
	ErrorCodeArrayLengthTooShort                           ErrorCode = "ARRAY_LENGTH_TOO_SHORT"
	ErrorCodeArrayEmpty                                    ErrorCode = "ARRAY_EMPTY"
	ErrorCodeExpectedBoolean                               ErrorCode = "EXPECTED_BOOLEAN"
	ErrorCodeExpectedInteger                               ErrorCode = "EXPECTED_INTEGER"
	ErrorCodeExpectedFloat                                 ErrorCode = "EXPECTED_FLOAT"
	ErrorCodeExpectedString                                ErrorCode = "EXPECTED_STRING"
	ErrorCodeExpectedObject                                ErrorCode = "EXPECTED_OBJECT"
	ErrorCodeExpectedArray                                 ErrorCode = "EXPECTED_ARRAY"
	ErrorCodeExpectedMap                                   ErrorCode = "EXPECTED_MAP"
	ErrorCodeExpectedBase64EncodedByteArray                ErrorCode = "EXPECTED_BASE64_ENCODED_BYTE_ARRAY"
	ErrorCodeInvalidArrayValue                             ErrorCode = "INVALID_ARRAY_VALUE"
	ErrorCodeInvalidEnumValue                              ErrorCode = "INVALID_ENUM_VALUE"
	ErrorCodeInvalidContentType                            ErrorCode = "INVALID_CONTENT_TYPE"
	ErrorCodeInvalidFormValue                              ErrorCode = "INVALID_FORM_VALUE"
	ErrorCodeCustomerNotFound                              ErrorCode = "CUSTOMER_NOT_FOUND"
	ErrorCodeOneInstrumentExpected                         ErrorCode = "ONE_INSTRUMENT_EXPECTED"
	ErrorCodeNoFieldsSet                                   ErrorCode = "NO_FIELDS_SET"
	ErrorCodeTooManyMapEntries                             ErrorCode = "TOO_MANY_MAP_ENTRIES"
	ErrorCodeMapKeyLengthTooShort                          ErrorCode = "MAP_KEY_LENGTH_TOO_SHORT"
	ErrorCodeMapKeyLengthTooLong                           ErrorCode = "MAP_KEY_LENGTH_TOO_LONG"
	ErrorCodeCustomerMissingName                           ErrorCode = "CUSTOMER_MISSING_NAME"
	ErrorCodeCustomerMissingEmail                          ErrorCode = "CUSTOMER_MISSING_EMAIL"
	ErrorCodeInvalidPauseLength                            ErrorCode = "INVALID_PAUSE_LENGTH"
	ErrorCodeInvalidDate                                   ErrorCode = "INVALID_DATE"
	ErrorCodeUnsupportedCountry                            ErrorCode = "UNSUPPORTED_COUNTRY"
	ErrorCodeUnsupportedCurrency                           ErrorCode = "UNSUPPORTED_CURRENCY"
	ErrorCodeAppleTtpPinToken                              ErrorCode = "APPLE_TTP_PIN_TOKEN"
	ErrorCodeCardExpired                                   ErrorCode = "CARD_EXPIRED"
	ErrorCodeInvalidExpiration                             ErrorCode = "INVALID_EXPIRATION"
	ErrorCodeInvalidExpirationYear                         ErrorCode = "INVALID_EXPIRATION_YEAR"
	ErrorCodeInvalidExpirationDate                         ErrorCode = "INVALID_EXPIRATION_DATE"
	ErrorCodeUnsupportedCardBrand                          ErrorCode = "UNSUPPORTED_CARD_BRAND"
	ErrorCodeUnsupportedEntryMethod                        ErrorCode = "UNSUPPORTED_ENTRY_METHOD"
	ErrorCodeInvalidEncryptedCard                          ErrorCode = "INVALID_ENCRYPTED_CARD"
	ErrorCodeInvalidCard                                   ErrorCode = "INVALID_CARD"
	ErrorCodePaymentAmountMismatch                         ErrorCode = "PAYMENT_AMOUNT_MISMATCH"
	ErrorCodeGenericDecline                                ErrorCode = "GENERIC_DECLINE"
	ErrorCodeCvvFailure                                    ErrorCode = "CVV_FAILURE"
	ErrorCodeAddressVerificationFailure                    ErrorCode = "ADDRESS_VERIFICATION_FAILURE"
	ErrorCodeInvalidAccount                                ErrorCode = "INVALID_ACCOUNT"
	ErrorCodeCurrencyMismatch                              ErrorCode = "CURRENCY_MISMATCH"
	ErrorCodeInsufficientFunds                             ErrorCode = "INSUFFICIENT_FUNDS"
	ErrorCodeInsufficientPermissions                       ErrorCode = "INSUFFICIENT_PERMISSIONS"
	ErrorCodeCardholderInsufficientPermissions             ErrorCode = "CARDHOLDER_INSUFFICIENT_PERMISSIONS"
	ErrorCodeInvalidLocation                               ErrorCode = "INVALID_LOCATION"
	ErrorCodeTransactionLimit                              ErrorCode = "TRANSACTION_LIMIT"
	ErrorCodeVoiceFailure                                  ErrorCode = "VOICE_FAILURE"
	ErrorCodePanFailure                                    ErrorCode = "PAN_FAILURE"
	ErrorCodeExpirationFailure                             ErrorCode = "EXPIRATION_FAILURE"
	ErrorCodeCardNotSupported                              ErrorCode = "CARD_NOT_SUPPORTED"
	ErrorCodeReaderDeclined                                ErrorCode = "READER_DECLINED"
	ErrorCodeInvalidPin                                    ErrorCode = "INVALID_PIN"
	ErrorCodeMissingPin                                    ErrorCode = "MISSING_PIN"
	ErrorCodeMissingAccountType                            ErrorCode = "MISSING_ACCOUNT_TYPE"
	ErrorCodeInvalidPostalCode                             ErrorCode = "INVALID_POSTAL_CODE"
	ErrorCodeInvalidFees                                   ErrorCode = "INVALID_FEES"
	ErrorCodeManuallyEnteredPaymentNotSupported            ErrorCode = "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED"
	ErrorCodePaymentLimitExceeded                          ErrorCode = "PAYMENT_LIMIT_EXCEEDED"
	ErrorCodeGiftCardAvailableAmount                       ErrorCode = "GIFT_CARD_AVAILABLE_AMOUNT"
	ErrorCodeAccountUnusable                               ErrorCode = "ACCOUNT_UNUSABLE"
	ErrorCodeBuyerRefusedPayment                           ErrorCode = "BUYER_REFUSED_PAYMENT"
	ErrorCodeDelayedTransactionExpired                     ErrorCode = "DELAYED_TRANSACTION_EXPIRED"
	ErrorCodeDelayedTransactionCanceled                    ErrorCode = "DELAYED_TRANSACTION_CANCELED"
	ErrorCodeDelayedTransactionCaptured                    ErrorCode = "DELAYED_TRANSACTION_CAPTURED"
	ErrorCodeDelayedTransactionFailed                      ErrorCode = "DELAYED_TRANSACTION_FAILED"
	ErrorCodeCardTokenExpired                              ErrorCode = "CARD_TOKEN_EXPIRED"
	ErrorCodeCardTokenUsed                                 ErrorCode = "CARD_TOKEN_USED"
	ErrorCodeAmountTooHigh                                 ErrorCode = "AMOUNT_TOO_HIGH"
	ErrorCodeUnsupportedInstrumentType                     ErrorCode = "UNSUPPORTED_INSTRUMENT_TYPE"
	ErrorCodeRefundAmountInvalid                           ErrorCode = "REFUND_AMOUNT_INVALID"
	ErrorCodeRefundAlreadyPending                          ErrorCode = "REFUND_ALREADY_PENDING"
	ErrorCodePaymentNotRefundable                          ErrorCode = "PAYMENT_NOT_REFUNDABLE"
	ErrorCodePaymentNotRefundableDueToDispute              ErrorCode = "PAYMENT_NOT_REFUNDABLE_DUE_TO_DISPUTE"
	ErrorCodeRefundErrorPaymentNeedsCompletion             ErrorCode = "REFUND_ERROR_PAYMENT_NEEDS_COMPLETION"
	ErrorCodeRefundDeclined                                ErrorCode = "REFUND_DECLINED"
	ErrorCodeInsufficientPermissionsForRefund              ErrorCode = "INSUFFICIENT_PERMISSIONS_FOR_REFUND"
	ErrorCodeInvalidCardData                               ErrorCode = "INVALID_CARD_DATA"
	ErrorCodeSourceUsed                                    ErrorCode = "SOURCE_USED"
	ErrorCodeSourceExpired                                 ErrorCode = "SOURCE_EXPIRED"
	ErrorCodeUnsupportedLoyaltyRewardTier                  ErrorCode = "UNSUPPORTED_LOYALTY_REWARD_TIER"
	ErrorCodeLocationMismatch                              ErrorCode = "LOCATION_MISMATCH"
	ErrorCodeOrderUnpaidNotReturnable                      ErrorCode = "ORDER_UNPAID_NOT_RETURNABLE"
	ErrorCodeIdempotencyKeyReused                          ErrorCode = "IDEMPOTENCY_KEY_REUSED"
	ErrorCodeUnexpectedValue                               ErrorCode = "UNEXPECTED_VALUE"
	ErrorCodeSandboxNotSupported                           ErrorCode = "SANDBOX_NOT_SUPPORTED"
	ErrorCodeInvalidEmailAddress                           ErrorCode = "INVALID_EMAIL_ADDRESS"
	ErrorCodeInvalidPhoneNumber                            ErrorCode = "INVALID_PHONE_NUMBER"
	ErrorCodeCheckoutExpired                               ErrorCode = "CHECKOUT_EXPIRED"
	ErrorCodeBadCertificate                                ErrorCode = "BAD_CERTIFICATE"
	ErrorCodeInvalidSquareVersionFormat                    ErrorCode = "INVALID_SQUARE_VERSION_FORMAT"
	ErrorCodeAPIVersionIncompatible                        ErrorCode = "API_VERSION_INCOMPATIBLE"
	ErrorCodeCardPresenceRequired                          ErrorCode = "CARD_PRESENCE_REQUIRED"
	ErrorCodeUnsupportedSourceType                         ErrorCode = "UNSUPPORTED_SOURCE_TYPE"
	ErrorCodeCardMismatch                                  ErrorCode = "CARD_MISMATCH"
	ErrorCodePlaidError                                    ErrorCode = "PLAID_ERROR"
	ErrorCodePlaidErrorItemLoginRequired                   ErrorCode = "PLAID_ERROR_ITEM_LOGIN_REQUIRED"
	ErrorCodePlaidErrorRateLimit                           ErrorCode = "PLAID_ERROR_RATE_LIMIT"
	ErrorCodeCardDeclined                                  ErrorCode = "CARD_DECLINED"
	ErrorCodeVerifyCvvFailure                              ErrorCode = "VERIFY_CVV_FAILURE"
	ErrorCodeVerifyAvsFailure                              ErrorCode = "VERIFY_AVS_FAILURE"
	ErrorCodeCardDeclinedCallIssuer                        ErrorCode = "CARD_DECLINED_CALL_ISSUER"
	ErrorCodeCardDeclinedVerificationRequired              ErrorCode = "CARD_DECLINED_VERIFICATION_REQUIRED"
	ErrorCodeBadExpiration                                 ErrorCode = "BAD_EXPIRATION"
	ErrorCodeChipInsertionRequired                         ErrorCode = "CHIP_INSERTION_REQUIRED"
	ErrorCodeAllowablePinTriesExceeded                     ErrorCode = "ALLOWABLE_PIN_TRIES_EXCEEDED"
	ErrorCodeReservationDeclined                           ErrorCode = "RESERVATION_DECLINED"
	ErrorCodeUnknownBodyParameter                          ErrorCode = "UNKNOWN_BODY_PARAMETER"
	ErrorCodeNotFound                                      ErrorCode = "NOT_FOUND"
	ErrorCodeApplePaymentProcessingCertificateHashNotFound ErrorCode = "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND"
	ErrorCodeMethodNotAllowed                              ErrorCode = "METHOD_NOT_ALLOWED"
	ErrorCodeNotAcceptable                                 ErrorCode = "NOT_ACCEPTABLE"
	ErrorCodeRequestTimeout                                ErrorCode = "REQUEST_TIMEOUT"
	ErrorCodeConflict                                      ErrorCode = "CONFLICT"
	ErrorCodeGone                                          ErrorCode = "GONE"
	ErrorCodeRequestEntityTooLarge                         ErrorCode = "REQUEST_ENTITY_TOO_LARGE"
	ErrorCodeUnsupportedMediaType                          ErrorCode = "UNSUPPORTED_MEDIA_TYPE"
	ErrorCodeUnprocessableEntity                           ErrorCode = "UNPROCESSABLE_ENTITY"
	ErrorCodeRateLimited                                   ErrorCode = "RATE_LIMITED"
	ErrorCodeNotImplemented                                ErrorCode = "NOT_IMPLEMENTED"
	ErrorCodeBadGateway                                    ErrorCode = "BAD_GATEWAY"
	ErrorCodeServiceUnavailable                            ErrorCode = "SERVICE_UNAVAILABLE"
	ErrorCodeTemporaryError                                ErrorCode = "TEMPORARY_ERROR"
	ErrorCodeGatewayTimeout                                ErrorCode = "GATEWAY_TIMEOUT"
)

func NewErrorCodeFromString(s string) (ErrorCode, error) {
	switch s {
	case "INTERNAL_SERVER_ERROR":
		return ErrorCodeInternalServerError, nil
	case "UNAUTHORIZED":
		return ErrorCodeUnauthorized, nil
	case "ACCESS_TOKEN_EXPIRED":
		return ErrorCodeAccessTokenExpired, nil
	case "ACCESS_TOKEN_REVOKED":
		return ErrorCodeAccessTokenRevoked, nil
	case "CLIENT_DISABLED":
		return ErrorCodeClientDisabled, nil
	case "FORBIDDEN":
		return ErrorCodeForbidden, nil
	case "INSUFFICIENT_SCOPES":
		return ErrorCodeInsufficientScopes, nil
	case "APPLICATION_DISABLED":
		return ErrorCodeApplicationDisabled, nil
	case "V1_APPLICATION":
		return ErrorCodeV1Application, nil
	case "V1_ACCESS_TOKEN":
		return ErrorCodeV1AccessToken, nil
	case "CARD_PROCESSING_NOT_ENABLED":
		return ErrorCodeCardProcessingNotEnabled, nil
	case "MERCHANT_SUBSCRIPTION_NOT_FOUND":
		return ErrorCodeMerchantSubscriptionNotFound, nil
	case "BAD_REQUEST":
		return ErrorCodeBadRequest, nil
	case "MISSING_REQUIRED_PARAMETER":
		return ErrorCodeMissingRequiredParameter, nil
	case "INCORRECT_TYPE":
		return ErrorCodeIncorrectType, nil
	case "INVALID_TIME":
		return ErrorCodeInvalidTime, nil
	case "INVALID_TIME_RANGE":
		return ErrorCodeInvalidTimeRange, nil
	case "INVALID_VALUE":
		return ErrorCodeInvalidValue, nil
	case "INVALID_CURSOR":
		return ErrorCodeInvalidCursor, nil
	case "UNKNOWN_QUERY_PARAMETER":
		return ErrorCodeUnknownQueryParameter, nil
	case "CONFLICTING_PARAMETERS":
		return ErrorCodeConflictingParameters, nil
	case "EXPECTED_JSON_BODY":
		return ErrorCodeExpectedJSONBody, nil
	case "INVALID_SORT_ORDER":
		return ErrorCodeInvalidSortOrder, nil
	case "VALUE_REGEX_MISMATCH":
		return ErrorCodeValueRegexMismatch, nil
	case "VALUE_TOO_SHORT":
		return ErrorCodeValueTooShort, nil
	case "VALUE_TOO_LONG":
		return ErrorCodeValueTooLong, nil
	case "VALUE_TOO_LOW":
		return ErrorCodeValueTooLow, nil
	case "VALUE_TOO_HIGH":
		return ErrorCodeValueTooHigh, nil
	case "VALUE_EMPTY":
		return ErrorCodeValueEmpty, nil
	case "ARRAY_LENGTH_TOO_LONG":
		return ErrorCodeArrayLengthTooLong, nil
	case "ARRAY_LENGTH_TOO_SHORT":
		return ErrorCodeArrayLengthTooShort, nil
	case "ARRAY_EMPTY":
		return ErrorCodeArrayEmpty, nil
	case "EXPECTED_BOOLEAN":
		return ErrorCodeExpectedBoolean, nil
	case "EXPECTED_INTEGER":
		return ErrorCodeExpectedInteger, nil
	case "EXPECTED_FLOAT":
		return ErrorCodeExpectedFloat, nil
	case "EXPECTED_STRING":
		return ErrorCodeExpectedString, nil
	case "EXPECTED_OBJECT":
		return ErrorCodeExpectedObject, nil
	case "EXPECTED_ARRAY":
		return ErrorCodeExpectedArray, nil
	case "EXPECTED_MAP":
		return ErrorCodeExpectedMap, nil
	case "EXPECTED_BASE64_ENCODED_BYTE_ARRAY":
		return ErrorCodeExpectedBase64EncodedByteArray, nil
	case "INVALID_ARRAY_VALUE":
		return ErrorCodeInvalidArrayValue, nil
	case "INVALID_ENUM_VALUE":
		return ErrorCodeInvalidEnumValue, nil
	case "INVALID_CONTENT_TYPE":
		return ErrorCodeInvalidContentType, nil
	case "INVALID_FORM_VALUE":
		return ErrorCodeInvalidFormValue, nil
	case "CUSTOMER_NOT_FOUND":
		return ErrorCodeCustomerNotFound, nil
	case "ONE_INSTRUMENT_EXPECTED":
		return ErrorCodeOneInstrumentExpected, nil
	case "NO_FIELDS_SET":
		return ErrorCodeNoFieldsSet, nil
	case "TOO_MANY_MAP_ENTRIES":
		return ErrorCodeTooManyMapEntries, nil
	case "MAP_KEY_LENGTH_TOO_SHORT":
		return ErrorCodeMapKeyLengthTooShort, nil
	case "MAP_KEY_LENGTH_TOO_LONG":
		return ErrorCodeMapKeyLengthTooLong, nil
	case "CUSTOMER_MISSING_NAME":
		return ErrorCodeCustomerMissingName, nil
	case "CUSTOMER_MISSING_EMAIL":
		return ErrorCodeCustomerMissingEmail, nil
	case "INVALID_PAUSE_LENGTH":
		return ErrorCodeInvalidPauseLength, nil
	case "INVALID_DATE":
		return ErrorCodeInvalidDate, nil
	case "UNSUPPORTED_COUNTRY":
		return ErrorCodeUnsupportedCountry, nil
	case "UNSUPPORTED_CURRENCY":
		return ErrorCodeUnsupportedCurrency, nil
	case "APPLE_TTP_PIN_TOKEN":
		return ErrorCodeAppleTtpPinToken, nil
	case "CARD_EXPIRED":
		return ErrorCodeCardExpired, nil
	case "INVALID_EXPIRATION":
		return ErrorCodeInvalidExpiration, nil
	case "INVALID_EXPIRATION_YEAR":
		return ErrorCodeInvalidExpirationYear, nil
	case "INVALID_EXPIRATION_DATE":
		return ErrorCodeInvalidExpirationDate, nil
	case "UNSUPPORTED_CARD_BRAND":
		return ErrorCodeUnsupportedCardBrand, nil
	case "UNSUPPORTED_ENTRY_METHOD":
		return ErrorCodeUnsupportedEntryMethod, nil
	case "INVALID_ENCRYPTED_CARD":
		return ErrorCodeInvalidEncryptedCard, nil
	case "INVALID_CARD":
		return ErrorCodeInvalidCard, nil
	case "PAYMENT_AMOUNT_MISMATCH":
		return ErrorCodePaymentAmountMismatch, nil
	case "GENERIC_DECLINE":
		return ErrorCodeGenericDecline, nil
	case "CVV_FAILURE":
		return ErrorCodeCvvFailure, nil
	case "ADDRESS_VERIFICATION_FAILURE":
		return ErrorCodeAddressVerificationFailure, nil
	case "INVALID_ACCOUNT":
		return ErrorCodeInvalidAccount, nil
	case "CURRENCY_MISMATCH":
		return ErrorCodeCurrencyMismatch, nil
	case "INSUFFICIENT_FUNDS":
		return ErrorCodeInsufficientFunds, nil
	case "INSUFFICIENT_PERMISSIONS":
		return ErrorCodeInsufficientPermissions, nil
	case "CARDHOLDER_INSUFFICIENT_PERMISSIONS":
		return ErrorCodeCardholderInsufficientPermissions, nil
	case "INVALID_LOCATION":
		return ErrorCodeInvalidLocation, nil
	case "TRANSACTION_LIMIT":
		return ErrorCodeTransactionLimit, nil
	case "VOICE_FAILURE":
		return ErrorCodeVoiceFailure, nil
	case "PAN_FAILURE":
		return ErrorCodePanFailure, nil
	case "EXPIRATION_FAILURE":
		return ErrorCodeExpirationFailure, nil
	case "CARD_NOT_SUPPORTED":
		return ErrorCodeCardNotSupported, nil
	case "READER_DECLINED":
		return ErrorCodeReaderDeclined, nil
	case "INVALID_PIN":
		return ErrorCodeInvalidPin, nil
	case "MISSING_PIN":
		return ErrorCodeMissingPin, nil
	case "MISSING_ACCOUNT_TYPE":
		return ErrorCodeMissingAccountType, nil
	case "INVALID_POSTAL_CODE":
		return ErrorCodeInvalidPostalCode, nil
	case "INVALID_FEES":
		return ErrorCodeInvalidFees, nil
	case "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED":
		return ErrorCodeManuallyEnteredPaymentNotSupported, nil
	case "PAYMENT_LIMIT_EXCEEDED":
		return ErrorCodePaymentLimitExceeded, nil
	case "GIFT_CARD_AVAILABLE_AMOUNT":
		return ErrorCodeGiftCardAvailableAmount, nil
	case "ACCOUNT_UNUSABLE":
		return ErrorCodeAccountUnusable, nil
	case "BUYER_REFUSED_PAYMENT":
		return ErrorCodeBuyerRefusedPayment, nil
	case "DELAYED_TRANSACTION_EXPIRED":
		return ErrorCodeDelayedTransactionExpired, nil
	case "DELAYED_TRANSACTION_CANCELED":
		return ErrorCodeDelayedTransactionCanceled, nil
	case "DELAYED_TRANSACTION_CAPTURED":
		return ErrorCodeDelayedTransactionCaptured, nil
	case "DELAYED_TRANSACTION_FAILED":
		return ErrorCodeDelayedTransactionFailed, nil
	case "CARD_TOKEN_EXPIRED":
		return ErrorCodeCardTokenExpired, nil
	case "CARD_TOKEN_USED":
		return ErrorCodeCardTokenUsed, nil
	case "AMOUNT_TOO_HIGH":
		return ErrorCodeAmountTooHigh, nil
	case "UNSUPPORTED_INSTRUMENT_TYPE":
		return ErrorCodeUnsupportedInstrumentType, nil
	case "REFUND_AMOUNT_INVALID":
		return ErrorCodeRefundAmountInvalid, nil
	case "REFUND_ALREADY_PENDING":
		return ErrorCodeRefundAlreadyPending, nil
	case "PAYMENT_NOT_REFUNDABLE":
		return ErrorCodePaymentNotRefundable, nil
	case "PAYMENT_NOT_REFUNDABLE_DUE_TO_DISPUTE":
		return ErrorCodePaymentNotRefundableDueToDispute, nil
	case "REFUND_ERROR_PAYMENT_NEEDS_COMPLETION":
		return ErrorCodeRefundErrorPaymentNeedsCompletion, nil
	case "REFUND_DECLINED":
		return ErrorCodeRefundDeclined, nil
	case "INSUFFICIENT_PERMISSIONS_FOR_REFUND":
		return ErrorCodeInsufficientPermissionsForRefund, nil
	case "INVALID_CARD_DATA":
		return ErrorCodeInvalidCardData, nil
	case "SOURCE_USED":
		return ErrorCodeSourceUsed, nil
	case "SOURCE_EXPIRED":
		return ErrorCodeSourceExpired, nil
	case "UNSUPPORTED_LOYALTY_REWARD_TIER":
		return ErrorCodeUnsupportedLoyaltyRewardTier, nil
	case "LOCATION_MISMATCH":
		return ErrorCodeLocationMismatch, nil
	case "ORDER_UNPAID_NOT_RETURNABLE":
		return ErrorCodeOrderUnpaidNotReturnable, nil
	case "IDEMPOTENCY_KEY_REUSED":
		return ErrorCodeIdempotencyKeyReused, nil
	case "UNEXPECTED_VALUE":
		return ErrorCodeUnexpectedValue, nil
	case "SANDBOX_NOT_SUPPORTED":
		return ErrorCodeSandboxNotSupported, nil
	case "INVALID_EMAIL_ADDRESS":
		return ErrorCodeInvalidEmailAddress, nil
	case "INVALID_PHONE_NUMBER":
		return ErrorCodeInvalidPhoneNumber, nil
	case "CHECKOUT_EXPIRED":
		return ErrorCodeCheckoutExpired, nil
	case "BAD_CERTIFICATE":
		return ErrorCodeBadCertificate, nil
	case "INVALID_SQUARE_VERSION_FORMAT":
		return ErrorCodeInvalidSquareVersionFormat, nil
	case "API_VERSION_INCOMPATIBLE":
		return ErrorCodeAPIVersionIncompatible, nil
	case "CARD_PRESENCE_REQUIRED":
		return ErrorCodeCardPresenceRequired, nil
	case "UNSUPPORTED_SOURCE_TYPE":
		return ErrorCodeUnsupportedSourceType, nil
	case "CARD_MISMATCH":
		return ErrorCodeCardMismatch, nil
	case "PLAID_ERROR":
		return ErrorCodePlaidError, nil
	case "PLAID_ERROR_ITEM_LOGIN_REQUIRED":
		return ErrorCodePlaidErrorItemLoginRequired, nil
	case "PLAID_ERROR_RATE_LIMIT":
		return ErrorCodePlaidErrorRateLimit, nil
	case "CARD_DECLINED":
		return ErrorCodeCardDeclined, nil
	case "VERIFY_CVV_FAILURE":
		return ErrorCodeVerifyCvvFailure, nil
	case "VERIFY_AVS_FAILURE":
		return ErrorCodeVerifyAvsFailure, nil
	case "CARD_DECLINED_CALL_ISSUER":
		return ErrorCodeCardDeclinedCallIssuer, nil
	case "CARD_DECLINED_VERIFICATION_REQUIRED":
		return ErrorCodeCardDeclinedVerificationRequired, nil
	case "BAD_EXPIRATION":
		return ErrorCodeBadExpiration, nil
	case "CHIP_INSERTION_REQUIRED":
		return ErrorCodeChipInsertionRequired, nil
	case "ALLOWABLE_PIN_TRIES_EXCEEDED":
		return ErrorCodeAllowablePinTriesExceeded, nil
	case "RESERVATION_DECLINED":
		return ErrorCodeReservationDeclined, nil
	case "UNKNOWN_BODY_PARAMETER":
		return ErrorCodeUnknownBodyParameter, nil
	case "NOT_FOUND":
		return ErrorCodeNotFound, nil
	case "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND":
		return ErrorCodeApplePaymentProcessingCertificateHashNotFound, nil
	case "METHOD_NOT_ALLOWED":
		return ErrorCodeMethodNotAllowed, nil
	case "NOT_ACCEPTABLE":
		return ErrorCodeNotAcceptable, nil
	case "REQUEST_TIMEOUT":
		return ErrorCodeRequestTimeout, nil
	case "CONFLICT":
		return ErrorCodeConflict, nil
	case "GONE":
		return ErrorCodeGone, nil
	case "REQUEST_ENTITY_TOO_LARGE":
		return ErrorCodeRequestEntityTooLarge, nil
	case "UNSUPPORTED_MEDIA_TYPE":
		return ErrorCodeUnsupportedMediaType, nil
	case "UNPROCESSABLE_ENTITY":
		return ErrorCodeUnprocessableEntity, nil
	case "RATE_LIMITED":
		return ErrorCodeRateLimited, nil
	case "NOT_IMPLEMENTED":
		return ErrorCodeNotImplemented, nil
	case "BAD_GATEWAY":
		return ErrorCodeBadGateway, nil
	case "SERVICE_UNAVAILABLE":
		return ErrorCodeServiceUnavailable, nil
	case "TEMPORARY_ERROR":
		return ErrorCodeTemporaryError, nil
	case "GATEWAY_TIMEOUT":
		return ErrorCodeGatewayTimeout, nil
	}
	var t ErrorCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCode) Ptr() *ErrorCode {
	return &e
}

// Contains the metadata of a webhook event type.
type EventTypeMetadata struct {
	// The event type.
	EventType *string `json:"event_type,omitempty" url:"event_type,omitempty"`
	// The API version at which the event type was introduced.
	APIVersionIntroduced *string `json:"api_version_introduced,omitempty" url:"api_version_introduced,omitempty"`
	// The release status of the event type.
	ReleaseStatus *string `json:"release_status,omitempty" url:"release_status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventTypeMetadata) GetEventType() *string {
	if e == nil {
		return nil
	}
	return e.EventType
}

func (e *EventTypeMetadata) GetAPIVersionIntroduced() *string {
	if e == nil {
		return nil
	}
	return e.APIVersionIntroduced
}

func (e *EventTypeMetadata) GetReleaseStatus() *string {
	if e == nil {
		return nil
	}
	return e.ReleaseStatus
}

func (e *EventTypeMetadata) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTypeMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTypeMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTypeMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTypeMetadata) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which products matched by a CatalogPricingRule
// will be excluded if the pricing rule uses an exclude set.
type ExcludeStrategy string

const (
	ExcludeStrategyLeastExpensive ExcludeStrategy = "LEAST_EXPENSIVE"
	ExcludeStrategyMostExpensive  ExcludeStrategy = "MOST_EXPENSIVE"
)

func NewExcludeStrategyFromString(s string) (ExcludeStrategy, error) {
	switch s {
	case "LEAST_EXPENSIVE":
		return ExcludeStrategyLeastExpensive, nil
	case "MOST_EXPENSIVE":
		return ExcludeStrategyMostExpensive, nil
	}
	var t ExcludeStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExcludeStrategy) Ptr() *ExcludeStrategy {
	return &e
}

// A filter to select resources based on an exact field value. For any given
// value, the value can only be in one property. Depending on the field, either
// all properties can be set or only a subset will be available.
//
// Refer to the documentation of the field.
type FilterValue struct {
	// A list of terms that must be present on the field of the resource.
	All []string `json:"all,omitempty" url:"all,omitempty"`
	// A list of terms where at least one of them must be present on the
	// field of the resource.
	Any []string `json:"any,omitempty" url:"any,omitempty"`
	// A list of terms that must not be present on the field the resource
	None []string `json:"none,omitempty" url:"none,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FilterValue) GetAll() []string {
	if f == nil {
		return nil
	}
	return f.All
}

func (f *FilterValue) GetAny() []string {
	if f == nil {
		return nil
	}
	return f.Any
}

func (f *FilterValue) GetNone() []string {
	if f == nil {
		return nil
	}
	return f.None
}

func (f *FilterValue) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FilterValue) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterValue(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FilterValue) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Contains details about how to fulfill this order.
// Orders can only be created with at most one fulfillment using the API.
// However, orders returned by the Orders API might contain multiple fulfillments because sellers can create multiple fulfillments using Square products such as Square Online.
type Fulfillment struct {
	// A unique ID that identifies the fulfillment only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The type of the fulfillment.
	// See [FulfillmentType](#type-fulfillmenttype) for possible values
	Type *FulfillmentType `json:"type,omitempty" url:"type,omitempty"`
	// The state of the fulfillment.
	// See [FulfillmentState](#type-fulfillmentstate) for possible values
	State *FulfillmentState `json:"state,omitempty" url:"state,omitempty"`
	// Describes what order line items this fulfillment applies to.
	// It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
	// See [FulfillmentFulfillmentLineItemApplication](#type-fulfillmentfulfillmentlineitemapplication) for possible values
	LineItemApplication *FulfillmentFulfillmentLineItemApplication `json:"line_item_application,omitempty" url:"line_item_application,omitempty"`
	// A list of entries pertaining to the fulfillment of an order. Each entry must reference
	// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
	// fulfill.
	//
	// Multiple entries can reference the same line item `uid`, as long as the total quantity among
	// all fulfillment entries referencing a single line item does not exceed the quantity of the
	// order's line item itself.
	//
	// An order cannot be marked as `COMPLETED` before all fulfillments are `COMPLETED`,
	// `CANCELED`, or `FAILED`. Fulfillments can be created and completed independently
	// before order completion.
	Entries []*FulfillmentFulfillmentEntry `json:"entries,omitempty" url:"entries,omitempty"`
	// Application-defined data attached to this fulfillment. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Contains details for a pickup fulfillment. These details are required when the fulfillment
	// type is `PICKUP`.
	PickupDetails *FulfillmentPickupDetails `json:"pickup_details,omitempty" url:"pickup_details,omitempty"`
	// Contains details for a shipment fulfillment. These details are required when the fulfillment type
	// is `SHIPMENT`.
	//
	// A shipment fulfillment's relationship to fulfillment `state`:
	// `PROPOSED`: A shipment is requested.
	// `RESERVED`: Fulfillment in progress. Shipment processing.
	// `PREPARED`: Shipment packaged. Shipping label created.
	// `COMPLETED`: Package has been shipped.
	// `CANCELED`: Shipment has been canceled.
	// `FAILED`: Shipment has failed.
	ShipmentDetails *FulfillmentShipmentDetails `json:"shipment_details,omitempty" url:"shipment_details,omitempty"`
	// Describes delivery details of an order fulfillment.
	DeliveryDetails *FulfillmentDeliveryDetails `json:"delivery_details,omitempty" url:"delivery_details,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Fulfillment) GetUID() *string {
	if f == nil {
		return nil
	}
	return f.UID
}

func (f *Fulfillment) GetType() *FulfillmentType {
	if f == nil {
		return nil
	}
	return f.Type
}

func (f *Fulfillment) GetState() *FulfillmentState {
	if f == nil {
		return nil
	}
	return f.State
}

func (f *Fulfillment) GetLineItemApplication() *FulfillmentFulfillmentLineItemApplication {
	if f == nil {
		return nil
	}
	return f.LineItemApplication
}

func (f *Fulfillment) GetEntries() []*FulfillmentFulfillmentEntry {
	if f == nil {
		return nil
	}
	return f.Entries
}

func (f *Fulfillment) GetMetadata() map[string]*string {
	if f == nil {
		return nil
	}
	return f.Metadata
}

func (f *Fulfillment) GetPickupDetails() *FulfillmentPickupDetails {
	if f == nil {
		return nil
	}
	return f.PickupDetails
}

func (f *Fulfillment) GetShipmentDetails() *FulfillmentShipmentDetails {
	if f == nil {
		return nil
	}
	return f.ShipmentDetails
}

func (f *Fulfillment) GetDeliveryDetails() *FulfillmentDeliveryDetails {
	if f == nil {
		return nil
	}
	return f.DeliveryDetails
}

func (f *Fulfillment) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Fulfillment) UnmarshalJSON(data []byte) error {
	type unmarshaler Fulfillment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Fulfillment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Fulfillment) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Describes delivery details of an order fulfillment.
type FulfillmentDeliveryDetails struct {
	// The contact information for the person to receive the fulfillment.
	Recipient *FulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// Indicates the fulfillment delivery schedule type. If `SCHEDULED`, then
	// `deliver_at` is required. If `ASAP`, then `prep_time_duration` is required. The default is `SCHEDULED`.
	// See [OrderFulfillmentDeliveryDetailsScheduleType](#type-orderfulfillmentdeliverydetailsscheduletype) for possible values
	ScheduleType *FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType `json:"schedule_type,omitempty" url:"schedule_type,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	//
	// Must be in RFC 3339 timestamp format, e.g., "2016-09-04T23:59:33.123Z".
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the delivery period.
	// When the fulfillment `schedule_type` is `ASAP`, the field is automatically
	// set to the current time plus the `prep_time_duration`.
	// Otherwise, the application can set this field while the fulfillment `state` is
	// `PROPOSED`, `RESERVED`, or `PREPARED` (any time before the
	// terminal state such as `COMPLETED`, `CANCELED`, and `FAILED`).
	//
	// The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	DeliverAt *string `json:"deliver_at,omitempty" url:"deliver_at,omitempty"`
	// The duration of time it takes to prepare and deliver this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// The time period after `deliver_at` in which to deliver the order.
	// Applications can set this field when the fulfillment `state` is
	// `PROPOSED`, `RESERVED`, or `PREPARED` (any time before the terminal state
	// such as `COMPLETED`, `CANCELED`, and `FAILED`).
	//
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	DeliveryWindowDuration *string `json:"delivery_window_duration,omitempty" url:"delivery_window_duration,omitempty"`
	// Provides additional instructions about the delivery fulfillment.
	// It is displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicates when the seller completed the fulfillment.
	// This field is automatically set when  fulfillment `state` changes to `COMPLETED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CompletedAt *string `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicates when the seller started processing the fulfillment.
	// This field is automatically set when the fulfillment `state` changes to `RESERVED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. This field is
	// automatically set when the fulfillment `state` changes to `FAILED`.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the seller marked the fulfillment as ready for
	// courier pickup. This field is automatically set when the fulfillment `state` changes
	// to PREPARED.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was delivered to the recipient.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	DeliveredAt *string `json:"delivered_at,omitempty" url:"delivered_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. This field is automatically
	// set when the fulfillment `state` changes to `CANCELED`.
	//
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// The delivery cancellation reason. Max length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when an order can be picked up by the courier for delivery.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CourierPickupAt *string `json:"courier_pickup_at,omitempty" url:"courier_pickup_at,omitempty"`
	// The time period after `courier_pickup_at` in which the courier should pick up the order.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	CourierPickupWindowDuration *string `json:"courier_pickup_window_duration,omitempty" url:"courier_pickup_window_duration,omitempty"`
	// Whether the delivery is preferred to be no contact.
	IsNoContactDelivery *bool `json:"is_no_contact_delivery,omitempty" url:"is_no_contact_delivery,omitempty"`
	// A note to provide additional instructions about how to deliver the order.
	DropoffNotes *string `json:"dropoff_notes,omitempty" url:"dropoff_notes,omitempty"`
	// The name of the courier provider.
	CourierProviderName *string `json:"courier_provider_name,omitempty" url:"courier_provider_name,omitempty"`
	// The support phone number of the courier.
	CourierSupportPhoneNumber *string `json:"courier_support_phone_number,omitempty" url:"courier_support_phone_number,omitempty"`
	// The identifier for the delivery created by Square.
	SquareDeliveryID *string `json:"square_delivery_id,omitempty" url:"square_delivery_id,omitempty"`
	// The identifier for the delivery created by the third-party courier service.
	ExternalDeliveryID *string `json:"external_delivery_id,omitempty" url:"external_delivery_id,omitempty"`
	// The flag to indicate the delivery is managed by a third party (ie DoorDash), which means
	// we may not receive all recipient information for PII purposes.
	ManagedDelivery *bool `json:"managed_delivery,omitempty" url:"managed_delivery,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FulfillmentDeliveryDetails) GetRecipient() *FulfillmentRecipient {
	if f == nil {
		return nil
	}
	return f.Recipient
}

func (f *FulfillmentDeliveryDetails) GetScheduleType() *FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType {
	if f == nil {
		return nil
	}
	return f.ScheduleType
}

func (f *FulfillmentDeliveryDetails) GetPlacedAt() *string {
	if f == nil {
		return nil
	}
	return f.PlacedAt
}

func (f *FulfillmentDeliveryDetails) GetDeliverAt() *string {
	if f == nil {
		return nil
	}
	return f.DeliverAt
}

func (f *FulfillmentDeliveryDetails) GetPrepTimeDuration() *string {
	if f == nil {
		return nil
	}
	return f.PrepTimeDuration
}

func (f *FulfillmentDeliveryDetails) GetDeliveryWindowDuration() *string {
	if f == nil {
		return nil
	}
	return f.DeliveryWindowDuration
}

func (f *FulfillmentDeliveryDetails) GetNote() *string {
	if f == nil {
		return nil
	}
	return f.Note
}

func (f *FulfillmentDeliveryDetails) GetCompletedAt() *string {
	if f == nil {
		return nil
	}
	return f.CompletedAt
}

func (f *FulfillmentDeliveryDetails) GetInProgressAt() *string {
	if f == nil {
		return nil
	}
	return f.InProgressAt
}

func (f *FulfillmentDeliveryDetails) GetRejectedAt() *string {
	if f == nil {
		return nil
	}
	return f.RejectedAt
}

func (f *FulfillmentDeliveryDetails) GetReadyAt() *string {
	if f == nil {
		return nil
	}
	return f.ReadyAt
}

func (f *FulfillmentDeliveryDetails) GetDeliveredAt() *string {
	if f == nil {
		return nil
	}
	return f.DeliveredAt
}

func (f *FulfillmentDeliveryDetails) GetCanceledAt() *string {
	if f == nil {
		return nil
	}
	return f.CanceledAt
}

func (f *FulfillmentDeliveryDetails) GetCancelReason() *string {
	if f == nil {
		return nil
	}
	return f.CancelReason
}

func (f *FulfillmentDeliveryDetails) GetCourierPickupAt() *string {
	if f == nil {
		return nil
	}
	return f.CourierPickupAt
}

func (f *FulfillmentDeliveryDetails) GetCourierPickupWindowDuration() *string {
	if f == nil {
		return nil
	}
	return f.CourierPickupWindowDuration
}

func (f *FulfillmentDeliveryDetails) GetIsNoContactDelivery() *bool {
	if f == nil {
		return nil
	}
	return f.IsNoContactDelivery
}

func (f *FulfillmentDeliveryDetails) GetDropoffNotes() *string {
	if f == nil {
		return nil
	}
	return f.DropoffNotes
}

func (f *FulfillmentDeliveryDetails) GetCourierProviderName() *string {
	if f == nil {
		return nil
	}
	return f.CourierProviderName
}

func (f *FulfillmentDeliveryDetails) GetCourierSupportPhoneNumber() *string {
	if f == nil {
		return nil
	}
	return f.CourierSupportPhoneNumber
}

func (f *FulfillmentDeliveryDetails) GetSquareDeliveryID() *string {
	if f == nil {
		return nil
	}
	return f.SquareDeliveryID
}

func (f *FulfillmentDeliveryDetails) GetExternalDeliveryID() *string {
	if f == nil {
		return nil
	}
	return f.ExternalDeliveryID
}

func (f *FulfillmentDeliveryDetails) GetManagedDelivery() *bool {
	if f == nil {
		return nil
	}
	return f.ManagedDelivery
}

func (f *FulfillmentDeliveryDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentDeliveryDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentDeliveryDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentDeliveryDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentDeliveryDetails) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The schedule type of the delivery fulfillment.
type FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType string

const (
	FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeScheduled FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType = "SCHEDULED"
	FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeAsap      FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType = "ASAP"
)

func NewFulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeFromString(s string) (FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleTypeAsap, nil
	}
	var t FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType) Ptr() *FulfillmentDeliveryDetailsOrderFulfillmentDeliveryDetailsScheduleType {
	return &f
}

// Links an order line item to a fulfillment. Each entry must reference
// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
// fulfill.
type FulfillmentFulfillmentEntry struct {
	// A unique ID that identifies the fulfillment entry only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` from the order line item.
	LineItemUID string `json:"line_item_uid" url:"line_item_uid"`
	// The quantity of the line item being fulfilled, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Fulfillments for line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// Application-defined data attached to this fulfillment entry. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FulfillmentFulfillmentEntry) GetUID() *string {
	if f == nil {
		return nil
	}
	return f.UID
}

func (f *FulfillmentFulfillmentEntry) GetLineItemUID() string {
	if f == nil {
		return ""
	}
	return f.LineItemUID
}

func (f *FulfillmentFulfillmentEntry) GetQuantity() string {
	if f == nil {
		return ""
	}
	return f.Quantity
}

func (f *FulfillmentFulfillmentEntry) GetMetadata() map[string]*string {
	if f == nil {
		return nil
	}
	return f.Metadata
}

func (f *FulfillmentFulfillmentEntry) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentFulfillmentEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentFulfillmentEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentFulfillmentEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentFulfillmentEntry) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The `line_item_application` describes what order line items this fulfillment applies
// to. It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
type FulfillmentFulfillmentLineItemApplication string

const (
	FulfillmentFulfillmentLineItemApplicationAll       FulfillmentFulfillmentLineItemApplication = "ALL"
	FulfillmentFulfillmentLineItemApplicationEntryList FulfillmentFulfillmentLineItemApplication = "ENTRY_LIST"
)

func NewFulfillmentFulfillmentLineItemApplicationFromString(s string) (FulfillmentFulfillmentLineItemApplication, error) {
	switch s {
	case "ALL":
		return FulfillmentFulfillmentLineItemApplicationAll, nil
	case "ENTRY_LIST":
		return FulfillmentFulfillmentLineItemApplicationEntryList, nil
	}
	var t FulfillmentFulfillmentLineItemApplication
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentFulfillmentLineItemApplication) Ptr() *FulfillmentFulfillmentLineItemApplication {
	return &f
}

// Contains details necessary to fulfill a pickup order.
type FulfillmentPickupDetails struct {
	// Information about the person to pick up this fulfillment from a physical
	// location.
	Recipient *FulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment expires if it is not marked in progress. The timestamp must be
	// in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z"). The expiration time can only be set
	// up to 7 days in the future. If `expires_at` is not set, any new payments attached to the order
	// are automatically completed.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The duration of time after which an in progress pickup fulfillment is automatically moved
	// to the `COMPLETED` state. The duration must be in RFC 3339 format (for example, "P1W3D").
	//
	// If not set, this pickup fulfillment remains in progress until it is canceled or completed.
	AutoCompleteDuration *string `json:"auto_complete_duration,omitempty" url:"auto_complete_duration,omitempty"`
	// The schedule type of the pickup fulfillment. Defaults to `SCHEDULED`.
	// See [FulfillmentPickupDetailsScheduleType](#type-fulfillmentpickupdetailsscheduletype) for possible values
	ScheduleType *FulfillmentPickupDetailsScheduleType `json:"schedule_type,omitempty" url:"schedule_type,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the pickup window. Must be in RFC 3339 timestamp format, e.g.,
	// "2016-09-04T23:59:33.123Z".
	//
	// For fulfillments with the schedule type `ASAP`, this is automatically set
	// to the current time plus the expected duration to prepare the fulfillment.
	PickupAt *string `json:"pickup_at,omitempty" url:"pickup_at,omitempty"`
	// The window of time in which the order should be picked up after the `pickup_at` timestamp.
	// Must be in RFC 3339 duration format, e.g., "P1W3D". Can be used as an
	// informational guideline for merchants.
	PickupWindowDuration *string `json:"pickup_window_duration,omitempty" url:"pickup_window_duration,omitempty"`
	// The duration of time it takes to prepare this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// A note to provide additional instructions about the pickup
	// fulfillment displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was marked in progress. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	AcceptedAt *string `json:"accepted_at,omitempty" url:"accepted_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment is marked as ready for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment expired. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ExpiredAt *string `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was picked up by the recipient. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PickedUpAt *string `json:"picked_up_at,omitempty" url:"picked_up_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the pickup was canceled. The maximum length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// If set to `true`, indicates that this pickup order is for curbside pickup, not in-store pickup.
	IsCurbsidePickup *bool `json:"is_curbside_pickup,omitempty" url:"is_curbside_pickup,omitempty"`
	// Specific details for curbside pickup. These details can only be populated if `is_curbside_pickup` is set to `true`.
	CurbsidePickupDetails *FulfillmentPickupDetailsCurbsidePickupDetails `json:"curbside_pickup_details,omitempty" url:"curbside_pickup_details,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FulfillmentPickupDetails) GetRecipient() *FulfillmentRecipient {
	if f == nil {
		return nil
	}
	return f.Recipient
}

func (f *FulfillmentPickupDetails) GetExpiresAt() *string {
	if f == nil {
		return nil
	}
	return f.ExpiresAt
}

func (f *FulfillmentPickupDetails) GetAutoCompleteDuration() *string {
	if f == nil {
		return nil
	}
	return f.AutoCompleteDuration
}

func (f *FulfillmentPickupDetails) GetScheduleType() *FulfillmentPickupDetailsScheduleType {
	if f == nil {
		return nil
	}
	return f.ScheduleType
}

func (f *FulfillmentPickupDetails) GetPickupAt() *string {
	if f == nil {
		return nil
	}
	return f.PickupAt
}

func (f *FulfillmentPickupDetails) GetPickupWindowDuration() *string {
	if f == nil {
		return nil
	}
	return f.PickupWindowDuration
}

func (f *FulfillmentPickupDetails) GetPrepTimeDuration() *string {
	if f == nil {
		return nil
	}
	return f.PrepTimeDuration
}

func (f *FulfillmentPickupDetails) GetNote() *string {
	if f == nil {
		return nil
	}
	return f.Note
}

func (f *FulfillmentPickupDetails) GetPlacedAt() *string {
	if f == nil {
		return nil
	}
	return f.PlacedAt
}

func (f *FulfillmentPickupDetails) GetAcceptedAt() *string {
	if f == nil {
		return nil
	}
	return f.AcceptedAt
}

func (f *FulfillmentPickupDetails) GetRejectedAt() *string {
	if f == nil {
		return nil
	}
	return f.RejectedAt
}

func (f *FulfillmentPickupDetails) GetReadyAt() *string {
	if f == nil {
		return nil
	}
	return f.ReadyAt
}

func (f *FulfillmentPickupDetails) GetExpiredAt() *string {
	if f == nil {
		return nil
	}
	return f.ExpiredAt
}

func (f *FulfillmentPickupDetails) GetPickedUpAt() *string {
	if f == nil {
		return nil
	}
	return f.PickedUpAt
}

func (f *FulfillmentPickupDetails) GetCanceledAt() *string {
	if f == nil {
		return nil
	}
	return f.CanceledAt
}

func (f *FulfillmentPickupDetails) GetCancelReason() *string {
	if f == nil {
		return nil
	}
	return f.CancelReason
}

func (f *FulfillmentPickupDetails) GetIsCurbsidePickup() *bool {
	if f == nil {
		return nil
	}
	return f.IsCurbsidePickup
}

func (f *FulfillmentPickupDetails) GetCurbsidePickupDetails() *FulfillmentPickupDetailsCurbsidePickupDetails {
	if f == nil {
		return nil
	}
	return f.CurbsidePickupDetails
}

func (f *FulfillmentPickupDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentPickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentPickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentPickupDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentPickupDetails) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Specific details for curbside pickup.
type FulfillmentPickupDetailsCurbsidePickupDetails struct {
	// Specific details for curbside pickup, such as parking number and vehicle model.
	CurbsideDetails *string `json:"curbside_details,omitempty" url:"curbside_details,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the buyer arrived and is waiting for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	BuyerArrivedAt *string `json:"buyer_arrived_at,omitempty" url:"buyer_arrived_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) GetCurbsideDetails() *string {
	if f == nil {
		return nil
	}
	return f.CurbsideDetails
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) GetBuyerArrivedAt() *string {
	if f == nil {
		return nil
	}
	return f.BuyerArrivedAt
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentPickupDetailsCurbsidePickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentPickupDetailsCurbsidePickupDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentPickupDetailsCurbsidePickupDetails) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The schedule type of the pickup fulfillment.
type FulfillmentPickupDetailsScheduleType string

const (
	FulfillmentPickupDetailsScheduleTypeScheduled FulfillmentPickupDetailsScheduleType = "SCHEDULED"
	FulfillmentPickupDetailsScheduleTypeAsap      FulfillmentPickupDetailsScheduleType = "ASAP"
)

func NewFulfillmentPickupDetailsScheduleTypeFromString(s string) (FulfillmentPickupDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return FulfillmentPickupDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return FulfillmentPickupDetailsScheduleTypeAsap, nil
	}
	var t FulfillmentPickupDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentPickupDetailsScheduleType) Ptr() *FulfillmentPickupDetailsScheduleType {
	return &f
}

// Information about the fulfillment recipient.
type FulfillmentRecipient struct {
	// The ID of the customer associated with the fulfillment.
	//
	// If `customer_id` is provided, the fulfillment recipient's `display_name`,
	// `email_address`, and `phone_number` are automatically populated from the
	// targeted customer profile. If these fields are set in the request, the request
	// values override the information from the customer profile. If the
	// targeted customer profile does not contain the necessary information and
	// these fields are left unset, the request results in an error.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The display name of the fulfillment recipient. This field is required.
	//
	// If provided, the display name overrides the corresponding customer profile value
	// indicated by `customer_id`.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The email address of the fulfillment recipient.
	//
	// If provided, the email address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the fulfillment recipient. This field is required.
	//
	// If provided, the phone number overrides the corresponding customer profile value
	// indicated by `customer_id`.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The address of the fulfillment recipient. This field is required.
	//
	// If provided, the address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	Address *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FulfillmentRecipient) GetCustomerID() *string {
	if f == nil {
		return nil
	}
	return f.CustomerID
}

func (f *FulfillmentRecipient) GetDisplayName() *string {
	if f == nil {
		return nil
	}
	return f.DisplayName
}

func (f *FulfillmentRecipient) GetEmailAddress() *string {
	if f == nil {
		return nil
	}
	return f.EmailAddress
}

func (f *FulfillmentRecipient) GetPhoneNumber() *string {
	if f == nil {
		return nil
	}
	return f.PhoneNumber
}

func (f *FulfillmentRecipient) GetAddress() *Address {
	if f == nil {
		return nil
	}
	return f.Address
}

func (f *FulfillmentRecipient) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentRecipient(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentRecipient) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Contains the details necessary to fulfill a shipment order.
type FulfillmentShipmentDetails struct {
	// Information about the person to receive this shipment fulfillment.
	Recipient *FulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The shipping carrier being used to ship this fulfillment (such as UPS, FedEx, or USPS).
	Carrier *string `json:"carrier,omitempty" url:"carrier,omitempty"`
	// A note with additional information for the shipping carrier.
	ShippingNote *string `json:"shipping_note,omitempty" url:"shipping_note,omitempty"`
	// A description of the type of shipping product purchased from the carrier
	// (such as First Class, Priority, or Express).
	ShippingType *string `json:"shipping_type,omitempty" url:"shipping_type,omitempty"`
	// The reference number provided by the carrier to track the shipment's progress.
	TrackingNumber *string `json:"tracking_number,omitempty" url:"tracking_number,omitempty"`
	// A link to the tracking webpage on the carrier's website.
	TrackingURL *string `json:"tracking_url,omitempty" url:"tracking_url,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment was requested. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `RESERVED` state, which  indicates that preparation
	// of this shipment has begun. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `PREPARED` state, which indicates that the
	// fulfillment is packaged. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	PackagedAt *string `json:"packaged_at,omitempty" url:"packaged_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment is expected to be delivered to the shipping carrier.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ExpectedShippedAt *string `json:"expected_shipped_at,omitempty" url:"expected_shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `COMPLETED` state, which indicates that
	// the fulfillment has been given to the shipping carrier. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ShippedAt *string `json:"shipped_at,omitempty" url:"shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating the shipment was canceled.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the shipment was canceled.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment failed to be completed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	FailedAt *string `json:"failed_at,omitempty" url:"failed_at,omitempty"`
	// A description of why the shipment failed to be completed.
	FailureReason *string `json:"failure_reason,omitempty" url:"failure_reason,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FulfillmentShipmentDetails) GetRecipient() *FulfillmentRecipient {
	if f == nil {
		return nil
	}
	return f.Recipient
}

func (f *FulfillmentShipmentDetails) GetCarrier() *string {
	if f == nil {
		return nil
	}
	return f.Carrier
}

func (f *FulfillmentShipmentDetails) GetShippingNote() *string {
	if f == nil {
		return nil
	}
	return f.ShippingNote
}

func (f *FulfillmentShipmentDetails) GetShippingType() *string {
	if f == nil {
		return nil
	}
	return f.ShippingType
}

func (f *FulfillmentShipmentDetails) GetTrackingNumber() *string {
	if f == nil {
		return nil
	}
	return f.TrackingNumber
}

func (f *FulfillmentShipmentDetails) GetTrackingURL() *string {
	if f == nil {
		return nil
	}
	return f.TrackingURL
}

func (f *FulfillmentShipmentDetails) GetPlacedAt() *string {
	if f == nil {
		return nil
	}
	return f.PlacedAt
}

func (f *FulfillmentShipmentDetails) GetInProgressAt() *string {
	if f == nil {
		return nil
	}
	return f.InProgressAt
}

func (f *FulfillmentShipmentDetails) GetPackagedAt() *string {
	if f == nil {
		return nil
	}
	return f.PackagedAt
}

func (f *FulfillmentShipmentDetails) GetExpectedShippedAt() *string {
	if f == nil {
		return nil
	}
	return f.ExpectedShippedAt
}

func (f *FulfillmentShipmentDetails) GetShippedAt() *string {
	if f == nil {
		return nil
	}
	return f.ShippedAt
}

func (f *FulfillmentShipmentDetails) GetCanceledAt() *string {
	if f == nil {
		return nil
	}
	return f.CanceledAt
}

func (f *FulfillmentShipmentDetails) GetCancelReason() *string {
	if f == nil {
		return nil
	}
	return f.CancelReason
}

func (f *FulfillmentShipmentDetails) GetFailedAt() *string {
	if f == nil {
		return nil
	}
	return f.FailedAt
}

func (f *FulfillmentShipmentDetails) GetFailureReason() *string {
	if f == nil {
		return nil
	}
	return f.FailureReason
}

func (f *FulfillmentShipmentDetails) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FulfillmentShipmentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler FulfillmentShipmentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FulfillmentShipmentDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FulfillmentShipmentDetails) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The current state of this fulfillment.
type FulfillmentState string

const (
	FulfillmentStateProposed  FulfillmentState = "PROPOSED"
	FulfillmentStateReserved  FulfillmentState = "RESERVED"
	FulfillmentStatePrepared  FulfillmentState = "PREPARED"
	FulfillmentStateCompleted FulfillmentState = "COMPLETED"
	FulfillmentStateCanceled  FulfillmentState = "CANCELED"
	FulfillmentStateFailed    FulfillmentState = "FAILED"
)

func NewFulfillmentStateFromString(s string) (FulfillmentState, error) {
	switch s {
	case "PROPOSED":
		return FulfillmentStateProposed, nil
	case "RESERVED":
		return FulfillmentStateReserved, nil
	case "PREPARED":
		return FulfillmentStatePrepared, nil
	case "COMPLETED":
		return FulfillmentStateCompleted, nil
	case "CANCELED":
		return FulfillmentStateCanceled, nil
	case "FAILED":
		return FulfillmentStateFailed, nil
	}
	var t FulfillmentState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentState) Ptr() *FulfillmentState {
	return &f
}

// The type of fulfillment.
type FulfillmentType string

const (
	FulfillmentTypePickup   FulfillmentType = "PICKUP"
	FulfillmentTypeShipment FulfillmentType = "SHIPMENT"
	FulfillmentTypeDelivery FulfillmentType = "DELIVERY"
)

func NewFulfillmentTypeFromString(s string) (FulfillmentType, error) {
	switch s {
	case "PICKUP":
		return FulfillmentTypePickup, nil
	case "SHIPMENT":
		return FulfillmentTypeShipment, nil
	case "DELIVERY":
		return FulfillmentTypeDelivery, nil
	}
	var t FulfillmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FulfillmentType) Ptr() *FulfillmentType {
	return &f
}

type GetBookingRequest = interface{}

// The response to a request to get a `BreakType`. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetBreakTypeResponse struct {
	// The response object.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetBreakTypeResponse) GetBreakType() *BreakType {
	if g == nil {
		return nil
	}
	return g.BreakType
}

func (g *GetBreakTypeResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBreakTypeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBreakTypeResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetBusinessBookingProfileRequest = interface{}

type GetCardRequest = interface{}

type GetCashDrawerShiftResponse struct {
	// The cash drawer shift queried for.
	CashDrawerShift *CashDrawerShift `json:"cash_drawer_shift,omitempty" url:"cash_drawer_shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetCashDrawerShiftResponse) GetCashDrawerShift() *CashDrawerShift {
	if g == nil {
		return nil
	}
	return g.CashDrawerShift
}

func (g *GetCashDrawerShiftResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetCashDrawerShiftResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCashDrawerShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCashDrawerShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCashDrawerShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCashDrawerShiftResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The `CatalogObject`s returned.
	Object *CatalogObject `json:"object,omitempty" url:"object,omitempty"`
	// A list of `CatalogObject`s referenced by the object in the `object` field.
	RelatedObjects []*CatalogObject `json:"related_objects,omitempty" url:"related_objects,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetCatalogObjectResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetCatalogObjectResponse) GetObject() *CatalogObject {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GetCatalogObjectResponse) GetRelatedObjects() []*CatalogObject {
	if g == nil {
		return nil
	}
	return g.RelatedObjects
}

func (g *GetCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCatalogObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCatalogObjectResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveCustomerCustomAttributeDefinition](api-endpoint:CustomerCustomAttributes-RetrieveCustomerCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type GetCustomerCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetCustomerCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if g == nil {
		return nil
	}
	return g.CustomAttributeDefinition
}

func (g *GetCustomerCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerCustomAttributeDefinitionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents a [RetrieveCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-RetrieveCustomerCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type GetCustomerCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetCustomerCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if g == nil {
		return nil
	}
	return g.CustomAttribute
}

func (g *GetCustomerCustomAttributeResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerCustomAttributeResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCustomerGroupRequest = interface{}

// Defines the fields that are included in the response body of
// a request to the [RetrieveCustomerGroup](api-endpoint:CustomerGroups-RetrieveCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type GetCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetCustomerGroupResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetCustomerGroupResponse) GetGroup() *CustomerGroup {
	if g == nil {
		return nil
	}
	return g.Group
}

func (g *GetCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerGroupResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerGroupResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetCustomerRequest = interface{}

type GetCustomerSegmentRequest = interface{}

// Defines the fields that are included in the response body for requests to the `RetrieveCustomerSegment` endpoint.
//
// Either `errors` or `segment` is present in a given response (never both).
type GetCustomerSegmentResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved customer segment.
	Segment *CustomerSegment `json:"segment,omitempty" url:"segment,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetCustomerSegmentResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetCustomerSegmentResponse) GetSegment() *CustomerSegment {
	if g == nil {
		return nil
	}
	return g.Segment
}

func (g *GetCustomerSegmentResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetCustomerSegmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetCustomerSegmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetCustomerSegmentResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetCustomerSegmentResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDeviceCodeResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The queried DeviceCode.
	DeviceCode *DeviceCode `json:"device_code,omitempty" url:"device_code,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetDeviceCodeResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetDeviceCodeResponse) GetDeviceCode() *DeviceCode {
	if g == nil {
		return nil
	}
	return g.DeviceCode
}

func (g *GetDeviceCodeResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDeviceCodeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDeviceCodeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDeviceCodeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDeviceCodeResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDisputeEvidenceRequest = interface{}

// Defines the fields in a `RetrieveDisputeEvidence` response.
type GetDisputeEvidenceResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// Metadata about the dispute evidence file.
	Evidence *DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetDisputeEvidenceResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetDisputeEvidenceResponse) GetEvidence() *DisputeEvidence {
	if g == nil {
		return nil
	}
	return g.Evidence
}

func (g *GetDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetDisputeEvidenceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetDisputeEvidenceResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetDisputeRequest = interface{}

type GetEmployeeRequest = interface{}

// A response to a request to get an `EmployeeWage`. The response contains
// the requested `EmployeeWage` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetEmployeeWageResponse struct {
	// The requested `EmployeeWage` object.
	EmployeeWage *EmployeeWage `json:"employee_wage,omitempty" url:"employee_wage,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetEmployeeWageResponse) GetEmployeeWage() *EmployeeWage {
	if g == nil {
		return nil
	}
	return g.EmployeeWage
}

func (g *GetEmployeeWageResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetEmployeeWageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetEmployeeWageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetEmployeeWageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetEmployeeWageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetEmployeeWageResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetGiftCardRequest = interface{}

type GetInventoryAdjustmentRequest = interface{}

type GetInventoryPhysicalCountRequest = interface{}

type GetInventoryTransferRequest = interface{}

type GetLocationRequest = interface{}

type GetLoyaltyAccountRequest = interface{}

// A response that includes the loyalty account.
type GetLoyaltyAccountResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty account.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetLoyaltyAccountResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetLoyaltyAccountResponse) GetLoyaltyAccount() *LoyaltyAccount {
	if g == nil {
		return nil
	}
	return g.LoyaltyAccount
}

func (g *GetLoyaltyAccountResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyAccountResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyAccountResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetLoyaltyProgramRequest = interface{}

// A response that contains the loyalty program.
type GetLoyaltyProgramResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty program that was requested.
	Program *LoyaltyProgram `json:"program,omitempty" url:"program,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetLoyaltyProgramResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetLoyaltyProgramResponse) GetProgram() *LoyaltyProgram {
	if g == nil {
		return nil
	}
	return g.Program
}

func (g *GetLoyaltyProgramResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyProgramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyProgramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyProgramResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyProgramResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetLoyaltyPromotionRequest = interface{}

// Represents a [RetrieveLoyaltyPromotionPromotions](api-endpoint:Loyalty-RetrieveLoyaltyPromotion) response.
type GetLoyaltyPromotionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved loyalty promotion.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetLoyaltyPromotionResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetLoyaltyPromotionResponse) GetLoyaltyPromotion() *LoyaltyPromotion {
	if g == nil {
		return nil
	}
	return g.LoyaltyPromotion
}

func (g *GetLoyaltyPromotionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyPromotionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyPromotionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyPromotionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyPromotionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetLoyaltyRewardRequest = interface{}

// A response that includes the loyalty reward.
type GetLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty reward retrieved.
	Reward *LoyaltyReward `json:"reward,omitempty" url:"reward,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetLoyaltyRewardResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetLoyaltyRewardResponse) GetReward() *LoyaltyReward {
	if g == nil {
		return nil
	}
	return g.Reward
}

func (g *GetLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetLoyaltyRewardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetLoyaltyRewardResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetMerchantRequest = interface{}

type GetOrderRequest = interface{}

type GetPaymentLinkRequest = interface{}

type GetPaymentLinkResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The payment link that is retrieved.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetPaymentLinkResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetPaymentLinkResponse) GetPaymentLink() *PaymentLink {
	if g == nil {
		return nil
	}
	return g.PaymentLink
}

func (g *GetPaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentLinkResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentLinkResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// A response to a request to get a `Shift`. The response contains
// the requested `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type GetShiftResponse struct {
	// The requested `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetShiftResponse) GetShift() *Shift {
	if g == nil {
		return nil
	}
	return g.Shift
}

func (g *GetShiftResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetShiftResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetShiftResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetSnippetRequest = interface{}

type GetTeamMemberBookingProfileRequest = interface{}

type GetTeamMemberBookingProfileResponse struct {
	// The returned team member booking profile.
	TeamMemberBookingProfile *TeamMemberBookingProfile `json:"team_member_booking_profile,omitempty" url:"team_member_booking_profile,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetTeamMemberBookingProfileResponse) GetTeamMemberBookingProfile() *TeamMemberBookingProfile {
	if g == nil {
		return nil
	}
	return g.TeamMemberBookingProfile
}

func (g *GetTeamMemberBookingProfileResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetTeamMemberBookingProfileResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberBookingProfileResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberBookingProfileResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberBookingProfileResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberBookingProfileResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTeamMemberRequest = interface{}

// A response to a request to get a `TeamMemberWage`. The response contains
// the requested `TeamMemberWage` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type GetTeamMemberWageResponse struct {
	// The requested `TeamMemberWage` object.
	TeamMemberWage *TeamMemberWage `json:"team_member_wage,omitempty" url:"team_member_wage,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetTeamMemberWageResponse) GetTeamMemberWage() *TeamMemberWage {
	if g == nil {
		return nil
	}
	return g.TeamMemberWage
}

func (g *GetTeamMemberWageResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetTeamMemberWageResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTeamMemberWageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTeamMemberWageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTeamMemberWageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTeamMemberWageResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalActionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `TerminalAction`
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetTerminalActionResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetTerminalActionResponse) GetAction() *TerminalAction {
	if g == nil {
		return nil
	}
	return g.Action
}

func (g *GetTerminalActionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalActionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalActionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalCheckoutResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `TerminalCheckout`.
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetTerminalCheckoutResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetTerminalCheckoutResponse) GetCheckout() *TerminalCheckout {
	if g == nil {
		return nil
	}
	return g.Checkout
}

func (g *GetTerminalCheckoutResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalCheckoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalCheckoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalCheckoutResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalCheckoutResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTerminalRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `Refund`.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetTerminalRefundResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetTerminalRefundResponse) GetRefund() *TerminalRefund {
	if g == nil {
		return nil
	}
	return g.Refund
}

func (g *GetTerminalRefundResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTerminalRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTerminalRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTerminalRefundResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTerminalRefundResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetTransactionRequest = interface{}

// Defines the fields that are included in the response body of
// a request to the [RetrieveTransaction](api-endpoint:Transactions-RetrieveTransaction) endpoint.
//
// One of `errors` or `transaction` is present in a given response (never both).
type GetTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested transaction.
	Transaction *Transaction `json:"transaction,omitempty" url:"transaction,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetTransactionResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetTransactionResponse) GetTransaction() *Transaction {
	if g == nil {
		return nil
	}
	return g.Transaction
}

func (g *GetTransactionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetTransactionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetTransactionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetVendorRequest = interface{}

type GetWageSettingRequest = interface{}

// Represents a response from a retrieve request containing the specified `WageSetting` object or error messages.
type GetWageSettingResponse struct {
	// The successfully retrieved `WageSetting` object.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetWageSettingResponse) GetWageSetting() *WageSetting {
	if g == nil {
		return nil
	}
	return g.WageSetting
}

func (g *GetWageSettingResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetWageSettingResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWageSettingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWageSettingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWageSettingResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWageSettingResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetWebhookSubscriptionRequest = interface{}

// Defines the fields that are included in the response body of
// a request to the [RetrieveWebhookSubscription](api-endpoint:WebhookSubscriptions-RetrieveWebhookSubscription) endpoint.
//
// Note: if there are errors processing the request, the [Subscription](entity:WebhookSubscription) will not be
// present.
type GetWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetWebhookSubscriptionResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetWebhookSubscriptionResponse) GetSubscription() *WebhookSubscription {
	if g == nil {
		return nil
	}
	return g.Subscription
}

func (g *GetWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetWebhookSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetWebhookSubscriptionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents an action performed on a [gift card](entity:GiftCard) that affects its state or balance.
// A gift card activity contains information about a specific activity type. For example, a `REDEEM` activity
// includes a `redeem_activity_details` field that contains information about the redemption.
type GiftCardActivity struct {
	// The Square-assigned ID of the gift card activity.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of gift card activity.
	// See [Type](#type-type) for possible values
	Type GiftCardActivityType `json:"type" url:"type"`
	// The ID of the [business location](entity:Location) where the activity occurred.
	LocationID string `json:"location_id" url:"location_id"`
	// The timestamp when the gift card activity was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The gift card ID. When creating a gift card activity, `gift_card_id` is not required if
	// `gift_card_gan` is specified.
	GiftCardID *string `json:"gift_card_id,omitempty" url:"gift_card_id,omitempty"`
	// The gift card account number (GAN). When creating a gift card activity, `gift_card_gan`
	// is not required if `gift_card_id` is specified.
	GiftCardGan *string `json:"gift_card_gan,omitempty" url:"gift_card_gan,omitempty"`
	// The final balance on the gift card after the action is completed.
	GiftCardBalanceMoney *Money `json:"gift_card_balance_money,omitempty" url:"gift_card_balance_money,omitempty"`
	// Additional details about a `LOAD` activity, which is used to reload money onto a gift card.
	LoadActivityDetails *GiftCardActivityLoad `json:"load_activity_details,omitempty" url:"load_activity_details,omitempty"`
	// Additional details about an `ACTIVATE` activity, which is used to activate a gift card with
	// an initial balance.
	ActivateActivityDetails *GiftCardActivityActivate `json:"activate_activity_details,omitempty" url:"activate_activity_details,omitempty"`
	// Additional details about a `REDEEM` activity, which is used to redeem a gift card for a purchase.
	//
	// For applications that process payments using the Square Payments API, Square creates a `REDEEM` activity that
	// updates the gift card balance after the corresponding [CreatePayment](api-endpoint:Payments-CreatePayment)
	// request is completed. Applications that use a custom payment processing system must call
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) to create the `REDEEM` activity.
	RedeemActivityDetails *GiftCardActivityRedeem `json:"redeem_activity_details,omitempty" url:"redeem_activity_details,omitempty"`
	// Additional details about a `CLEAR_BALANCE` activity, which is used to set the balance of a gift card to zero.
	ClearBalanceActivityDetails *GiftCardActivityClearBalance `json:"clear_balance_activity_details,omitempty" url:"clear_balance_activity_details,omitempty"`
	// Additional details about a `DEACTIVATE` activity, which is used to deactivate a gift card.
	DeactivateActivityDetails *GiftCardActivityDeactivate `json:"deactivate_activity_details,omitempty" url:"deactivate_activity_details,omitempty"`
	// Additional details about an `ADJUST_INCREMENT` activity, which is used to add money to a gift card
	// outside of a typical `ACTIVATE`, `LOAD`, or `REFUND` activity flow.
	AdjustIncrementActivityDetails *GiftCardActivityAdjustIncrement `json:"adjust_increment_activity_details,omitempty" url:"adjust_increment_activity_details,omitempty"`
	// Additional details about an `ADJUST_DECREMENT` activity, which is used to deduct money from a gift
	// card outside of a typical `REDEEM` activity flow.
	AdjustDecrementActivityDetails *GiftCardActivityAdjustDecrement `json:"adjust_decrement_activity_details,omitempty" url:"adjust_decrement_activity_details,omitempty"`
	// Additional details about a `REFUND` activity, which is used to add money to a gift card when
	// refunding a payment.
	//
	// For applications that refund payments to a gift card using the Square Refunds API, Square automatically
	// creates a `REFUND` activity that updates the gift card balance after a [RefundPayment](api-endpoint:Refunds-RefundPayment)
	// request is completed. Applications that use a custom processing system must call
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) to create the `REFUND` activity.
	RefundActivityDetails *GiftCardActivityRefund `json:"refund_activity_details,omitempty" url:"refund_activity_details,omitempty"`
	// Additional details about an `UNLINKED_ACTIVITY_REFUND` activity. This activity is used to add money
	// to a gift card when refunding a payment that was processed using a custom payment processing system
	// and not linked to the gift card.
	UnlinkedActivityRefundActivityDetails *GiftCardActivityUnlinkedActivityRefund `json:"unlinked_activity_refund_activity_details,omitempty" url:"unlinked_activity_refund_activity_details,omitempty"`
	// Additional details about an `IMPORT` activity, which Square uses to import a third-party
	// gift card with a balance.
	ImportActivityDetails *GiftCardActivityImport `json:"import_activity_details,omitempty" url:"import_activity_details,omitempty"`
	// Additional details about a `BLOCK` activity, which Square uses to temporarily block a gift card.
	BlockActivityDetails *GiftCardActivityBlock `json:"block_activity_details,omitempty" url:"block_activity_details,omitempty"`
	// Additional details about an `UNBLOCK` activity, which Square uses to unblock a gift card.
	UnblockActivityDetails *GiftCardActivityUnblock `json:"unblock_activity_details,omitempty" url:"unblock_activity_details,omitempty"`
	// Additional details about an `IMPORT_REVERSAL` activity, which Square uses to reverse the
	// import of a third-party gift card.
	ImportReversalActivityDetails *GiftCardActivityImportReversal `json:"import_reversal_activity_details,omitempty" url:"import_reversal_activity_details,omitempty"`
	// Additional details about a `TRANSFER_BALANCE_TO` activity, which Square uses to add money to
	// a gift card as the result of a transfer from another gift card.
	TransferBalanceToActivityDetails *GiftCardActivityTransferBalanceTo `json:"transfer_balance_to_activity_details,omitempty" url:"transfer_balance_to_activity_details,omitempty"`
	// Additional details about a `TRANSFER_BALANCE_FROM` activity, which Square uses to deduct money from
	// a gift as the result of a transfer to another gift card.
	TransferBalanceFromActivityDetails *GiftCardActivityTransferBalanceFrom `json:"transfer_balance_from_activity_details,omitempty" url:"transfer_balance_from_activity_details,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivity) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GiftCardActivity) GetType() GiftCardActivityType {
	if g == nil {
		return ""
	}
	return g.Type
}

func (g *GiftCardActivity) GetLocationID() string {
	if g == nil {
		return ""
	}
	return g.LocationID
}

func (g *GiftCardActivity) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GiftCardActivity) GetGiftCardID() *string {
	if g == nil {
		return nil
	}
	return g.GiftCardID
}

func (g *GiftCardActivity) GetGiftCardGan() *string {
	if g == nil {
		return nil
	}
	return g.GiftCardGan
}

func (g *GiftCardActivity) GetGiftCardBalanceMoney() *Money {
	if g == nil {
		return nil
	}
	return g.GiftCardBalanceMoney
}

func (g *GiftCardActivity) GetLoadActivityDetails() *GiftCardActivityLoad {
	if g == nil {
		return nil
	}
	return g.LoadActivityDetails
}

func (g *GiftCardActivity) GetActivateActivityDetails() *GiftCardActivityActivate {
	if g == nil {
		return nil
	}
	return g.ActivateActivityDetails
}

func (g *GiftCardActivity) GetRedeemActivityDetails() *GiftCardActivityRedeem {
	if g == nil {
		return nil
	}
	return g.RedeemActivityDetails
}

func (g *GiftCardActivity) GetClearBalanceActivityDetails() *GiftCardActivityClearBalance {
	if g == nil {
		return nil
	}
	return g.ClearBalanceActivityDetails
}

func (g *GiftCardActivity) GetDeactivateActivityDetails() *GiftCardActivityDeactivate {
	if g == nil {
		return nil
	}
	return g.DeactivateActivityDetails
}

func (g *GiftCardActivity) GetAdjustIncrementActivityDetails() *GiftCardActivityAdjustIncrement {
	if g == nil {
		return nil
	}
	return g.AdjustIncrementActivityDetails
}

func (g *GiftCardActivity) GetAdjustDecrementActivityDetails() *GiftCardActivityAdjustDecrement {
	if g == nil {
		return nil
	}
	return g.AdjustDecrementActivityDetails
}

func (g *GiftCardActivity) GetRefundActivityDetails() *GiftCardActivityRefund {
	if g == nil {
		return nil
	}
	return g.RefundActivityDetails
}

func (g *GiftCardActivity) GetUnlinkedActivityRefundActivityDetails() *GiftCardActivityUnlinkedActivityRefund {
	if g == nil {
		return nil
	}
	return g.UnlinkedActivityRefundActivityDetails
}

func (g *GiftCardActivity) GetImportActivityDetails() *GiftCardActivityImport {
	if g == nil {
		return nil
	}
	return g.ImportActivityDetails
}

func (g *GiftCardActivity) GetBlockActivityDetails() *GiftCardActivityBlock {
	if g == nil {
		return nil
	}
	return g.BlockActivityDetails
}

func (g *GiftCardActivity) GetUnblockActivityDetails() *GiftCardActivityUnblock {
	if g == nil {
		return nil
	}
	return g.UnblockActivityDetails
}

func (g *GiftCardActivity) GetImportReversalActivityDetails() *GiftCardActivityImportReversal {
	if g == nil {
		return nil
	}
	return g.ImportReversalActivityDetails
}

func (g *GiftCardActivity) GetTransferBalanceToActivityDetails() *GiftCardActivityTransferBalanceTo {
	if g == nil {
		return nil
	}
	return g.TransferBalanceToActivityDetails
}

func (g *GiftCardActivity) GetTransferBalanceFromActivityDetails() *GiftCardActivityTransferBalanceFrom {
	if g == nil {
		return nil
	}
	return g.TransferBalanceFromActivityDetails
}

func (g *GiftCardActivity) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivity) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivity) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `ACTIVATE` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityActivate struct {
	// The amount added to the gift card. This value is a positive integer.
	//
	// Applications that use a custom order processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the [order](entity:Order) that contains the `GIFT_CARD` line item.
	//
	// Applications that use the Square Orders API to process orders must specify the order ID
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The UID of the `GIFT_CARD` line item in the order that represents the gift card purchase.
	//
	// Applications that use the Square Orders API to process orders must specify the line item UID
	// in the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	LineItemUID *string `json:"line_item_uid,omitempty" url:"line_item_uid,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom order processing system can use this field to track information
	// related to an order or payment.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The payment instrument IDs used to process the gift card purchase, such as a credit card ID
	// or bank account ID.
	//
	// Applications that use a custom order processing system must specify payment instrument IDs in
	// the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	// Square uses this information to perform compliance checks.
	//
	// For applications that use the Square Orders API to process payments, Square has the necessary
	// instrument IDs to perform compliance checks.
	//
	// Each buyer payment instrument ID can contain a maximum of 255 characters.
	BuyerPaymentInstrumentIDs []string `json:"buyer_payment_instrument_ids,omitempty" url:"buyer_payment_instrument_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityActivate) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityActivate) GetOrderID() *string {
	if g == nil {
		return nil
	}
	return g.OrderID
}

func (g *GiftCardActivityActivate) GetLineItemUID() *string {
	if g == nil {
		return nil
	}
	return g.LineItemUID
}

func (g *GiftCardActivityActivate) GetReferenceID() *string {
	if g == nil {
		return nil
	}
	return g.ReferenceID
}

func (g *GiftCardActivityActivate) GetBuyerPaymentInstrumentIDs() []string {
	if g == nil {
		return nil
	}
	return g.BuyerPaymentInstrumentIDs
}

func (g *GiftCardActivityActivate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityActivate) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityActivate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityActivate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityActivate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `ADJUST_DECREMENT` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityAdjustDecrement struct {
	// The amount deducted from the gift card balance. This value is a positive integer.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// The reason the gift card balance was adjusted.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityAdjustDecrementReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityAdjustDecrement) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityAdjustDecrement) GetReason() GiftCardActivityAdjustDecrementReason {
	if g == nil {
		return ""
	}
	return g.Reason
}

func (g *GiftCardActivityAdjustDecrement) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityAdjustDecrement) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityAdjustDecrement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityAdjustDecrement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityAdjustDecrement) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for deducting money from a [gift card](entity:GiftCard).
type GiftCardActivityAdjustDecrementReason string

const (
	GiftCardActivityAdjustDecrementReasonSuspiciousActivity           GiftCardActivityAdjustDecrementReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityAdjustDecrementReasonBalanceAccidentallyIncreased GiftCardActivityAdjustDecrementReason = "BALANCE_ACCIDENTALLY_INCREASED"
	GiftCardActivityAdjustDecrementReasonSupportIssue                 GiftCardActivityAdjustDecrementReason = "SUPPORT_ISSUE"
	GiftCardActivityAdjustDecrementReasonPurchaseWasRefunded          GiftCardActivityAdjustDecrementReason = "PURCHASE_WAS_REFUNDED"
)

func NewGiftCardActivityAdjustDecrementReasonFromString(s string) (GiftCardActivityAdjustDecrementReason, error) {
	switch s {
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityAdjustDecrementReasonSuspiciousActivity, nil
	case "BALANCE_ACCIDENTALLY_INCREASED":
		return GiftCardActivityAdjustDecrementReasonBalanceAccidentallyIncreased, nil
	case "SUPPORT_ISSUE":
		return GiftCardActivityAdjustDecrementReasonSupportIssue, nil
	case "PURCHASE_WAS_REFUNDED":
		return GiftCardActivityAdjustDecrementReasonPurchaseWasRefunded, nil
	}
	var t GiftCardActivityAdjustDecrementReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityAdjustDecrementReason) Ptr() *GiftCardActivityAdjustDecrementReason {
	return &g
}

// Represents details about an `ADJUST_INCREMENT` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityAdjustIncrement struct {
	// The amount added to the gift card balance. This value is a positive integer.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// The reason the gift card balance was adjusted.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityAdjustIncrementReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityAdjustIncrement) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityAdjustIncrement) GetReason() GiftCardActivityAdjustIncrementReason {
	if g == nil {
		return ""
	}
	return g.Reason
}

func (g *GiftCardActivityAdjustIncrement) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityAdjustIncrement) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityAdjustIncrement
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityAdjustIncrement(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityAdjustIncrement) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for adding money to a [gift card](entity:GiftCard).
type GiftCardActivityAdjustIncrementReason string

const (
	GiftCardActivityAdjustIncrementReasonComplimentary     GiftCardActivityAdjustIncrementReason = "COMPLIMENTARY"
	GiftCardActivityAdjustIncrementReasonSupportIssue      GiftCardActivityAdjustIncrementReason = "SUPPORT_ISSUE"
	GiftCardActivityAdjustIncrementReasonTransactionVoided GiftCardActivityAdjustIncrementReason = "TRANSACTION_VOIDED"
)

func NewGiftCardActivityAdjustIncrementReasonFromString(s string) (GiftCardActivityAdjustIncrementReason, error) {
	switch s {
	case "COMPLIMENTARY":
		return GiftCardActivityAdjustIncrementReasonComplimentary, nil
	case "SUPPORT_ISSUE":
		return GiftCardActivityAdjustIncrementReasonSupportIssue, nil
	case "TRANSACTION_VOIDED":
		return GiftCardActivityAdjustIncrementReasonTransactionVoided, nil
	}
	var t GiftCardActivityAdjustIncrementReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityAdjustIncrementReason) Ptr() *GiftCardActivityAdjustIncrementReason {
	return &g
}

// Represents details about a `BLOCK` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityBlock struct {
	// The reason the gift card was blocked.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityBlockReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityBlock) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityBlock) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityBlock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityBlock(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityBlock) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for blocking a [gift card](entity:GiftCard).
type GiftCardActivityBlockReason = string

// Represents details about a `CLEAR_BALANCE` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityClearBalance struct {
	// The reason the gift card balance was cleared.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityClearBalanceReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityClearBalance) GetReason() GiftCardActivityClearBalanceReason {
	if g == nil {
		return ""
	}
	return g.Reason
}

func (g *GiftCardActivityClearBalance) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityClearBalance) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityClearBalance
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityClearBalance(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityClearBalance) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for clearing the balance of a [gift card](entity:GiftCard).
type GiftCardActivityClearBalanceReason string

const (
	GiftCardActivityClearBalanceReasonSuspiciousActivity GiftCardActivityClearBalanceReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityClearBalanceReasonReuseGiftcard      GiftCardActivityClearBalanceReason = "REUSE_GIFTCARD"
	GiftCardActivityClearBalanceReasonUnknownReason      GiftCardActivityClearBalanceReason = "UNKNOWN_REASON"
)

func NewGiftCardActivityClearBalanceReasonFromString(s string) (GiftCardActivityClearBalanceReason, error) {
	switch s {
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityClearBalanceReasonSuspiciousActivity, nil
	case "REUSE_GIFTCARD":
		return GiftCardActivityClearBalanceReasonReuseGiftcard, nil
	case "UNKNOWN_REASON":
		return GiftCardActivityClearBalanceReasonUnknownReason, nil
	}
	var t GiftCardActivityClearBalanceReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityClearBalanceReason) Ptr() *GiftCardActivityClearBalanceReason {
	return &g
}

// Published when a [gift card activity](entity:GiftCardActivity) is created.
type GiftCardActivityCreatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.activity.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardActivityCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityCreatedEvent) GetMerchantID() *string {
	if g == nil {
		return nil
	}
	return g.MerchantID
}

func (g *GiftCardActivityCreatedEvent) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardActivityCreatedEvent) GetEventID() *string {
	if g == nil {
		return nil
	}
	return g.EventID
}

func (g *GiftCardActivityCreatedEvent) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GiftCardActivityCreatedEvent) GetData() *GiftCardActivityCreatedEventData {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GiftCardActivityCreatedEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityCreatedEvent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents the data associated with a `gift_card.activity.created` event.
type GiftCardActivityCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `gift_card_activity`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the new gift card activity.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new gift card activity.
	Object *GiftCardActivityCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityCreatedEventData) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardActivityCreatedEventData) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GiftCardActivityCreatedEventData) GetObject() *GiftCardActivityCreatedEventObject {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GiftCardActivityCreatedEventData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityCreatedEventData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card activity associated with a
// `gift_card.activity.created` event.
type GiftCardActivityCreatedEventObject struct {
	// The new gift card activity.
	GiftCardActivity *GiftCardActivity `json:"gift_card_activity,omitempty" url:"gift_card_activity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityCreatedEventObject) GetGiftCardActivity() *GiftCardActivity {
	if g == nil {
		return nil
	}
	return g.GiftCardActivity
}

func (g *GiftCardActivityCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityCreatedEventObject) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `DEACTIVATE` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityDeactivate struct {
	// The reason the gift card was deactivated.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityDeactivateReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityDeactivate) GetReason() GiftCardActivityDeactivateReason {
	if g == nil {
		return ""
	}
	return g.Reason
}

func (g *GiftCardActivityDeactivate) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityDeactivate) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityDeactivate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityDeactivate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityDeactivate) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for deactivating a [gift card](entity:GiftCard).
type GiftCardActivityDeactivateReason string

const (
	GiftCardActivityDeactivateReasonSuspiciousActivity   GiftCardActivityDeactivateReason = "SUSPICIOUS_ACTIVITY"
	GiftCardActivityDeactivateReasonUnknownReason        GiftCardActivityDeactivateReason = "UNKNOWN_REASON"
	GiftCardActivityDeactivateReasonChargebackDeactivate GiftCardActivityDeactivateReason = "CHARGEBACK_DEACTIVATE"
)

func NewGiftCardActivityDeactivateReasonFromString(s string) (GiftCardActivityDeactivateReason, error) {
	switch s {
	case "SUSPICIOUS_ACTIVITY":
		return GiftCardActivityDeactivateReasonSuspiciousActivity, nil
	case "UNKNOWN_REASON":
		return GiftCardActivityDeactivateReasonUnknownReason, nil
	case "CHARGEBACK_DEACTIVATE":
		return GiftCardActivityDeactivateReasonChargebackDeactivate, nil
	}
	var t GiftCardActivityDeactivateReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityDeactivateReason) Ptr() *GiftCardActivityDeactivateReason {
	return &g
}

// Represents details about an `IMPORT` [gift card activity type](entity:GiftCardActivityType).
// This activity type is used when Square imports a third-party gift card, in which case the
// `gan_source` of the gift card is set to `OTHER`.
type GiftCardActivityImport struct {
	// The balance amount on the imported gift card.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityImport) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityImport) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityImport) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityImport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityImport(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityImport) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about an `IMPORT_REVERSAL` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityImportReversal struct {
	// The amount of money cleared from the third-party gift card when
	// the import was reversed.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityImportReversal) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityImportReversal) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityImportReversal) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityImportReversal
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityImportReversal(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityImportReversal) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `LOAD` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityLoad struct {
	// The amount added to the gift card. This value is a positive integer.
	//
	// Applications that use a custom order processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The ID of the [order](entity:Order) that contains the `GIFT_CARD` line item.
	//
	// Applications that use the Square Orders API to process orders must specify the order ID in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The UID of the `GIFT_CARD` line item in the order that represents the additional funds for the gift card.
	//
	// Applications that use the Square Orders API to process orders must specify the line item UID
	// in the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	LineItemUID *string `json:"line_item_uid,omitempty" url:"line_item_uid,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom order processing system can use this field to track information related to
	// an order or payment.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The payment instrument IDs used to process the order for the additional funds, such as a credit card ID
	// or bank account ID.
	//
	// Applications that use a custom order processing system must specify payment instrument IDs in
	// the [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	// Square uses this information to perform compliance checks.
	//
	// For applications that use the Square Orders API to process payments, Square has the necessary
	// instrument IDs to perform compliance checks.
	//
	// Each buyer payment instrument ID can contain a maximum of 255 characters.
	BuyerPaymentInstrumentIDs []string `json:"buyer_payment_instrument_ids,omitempty" url:"buyer_payment_instrument_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityLoad) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityLoad) GetOrderID() *string {
	if g == nil {
		return nil
	}
	return g.OrderID
}

func (g *GiftCardActivityLoad) GetLineItemUID() *string {
	if g == nil {
		return nil
	}
	return g.LineItemUID
}

func (g *GiftCardActivityLoad) GetReferenceID() *string {
	if g == nil {
		return nil
	}
	return g.ReferenceID
}

func (g *GiftCardActivityLoad) GetBuyerPaymentInstrumentIDs() []string {
	if g == nil {
		return nil
	}
	return g.BuyerPaymentInstrumentIDs
}

func (g *GiftCardActivityLoad) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityLoad) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityLoad
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityLoad(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityLoad) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `REDEEM` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityRedeem struct {
	// The amount deducted from the gift card for the redemption. This value is a positive integer.
	//
	// Applications that use a custom payment processing system must specify this amount in the
	// [CreateGiftCardActivity](api-endpoint:GiftCardActivities-CreateGiftCardActivity) request.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// The ID of the payment that represents the gift card redemption. Square populates this field
	// if the payment was processed by Square.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	//
	// Applications that use a custom payment processing system can use this field to track information
	// related to an order or payment.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The status of the gift card redemption. Gift cards redeemed from Square Point of Sale or the
	// Square Seller Dashboard use a two-state process: `PENDING`
	// to `COMPLETED` or `PENDING` to  `CANCELED`. Gift cards redeemed using the Gift Card Activities API
	// always have a `COMPLETED` status.
	// See [Status](#type-status) for possible values
	Status *GiftCardActivityRedeemStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityRedeem) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityRedeem) GetPaymentID() *string {
	if g == nil {
		return nil
	}
	return g.PaymentID
}

func (g *GiftCardActivityRedeem) GetReferenceID() *string {
	if g == nil {
		return nil
	}
	return g.ReferenceID
}

func (g *GiftCardActivityRedeem) GetStatus() *GiftCardActivityRedeemStatus {
	if g == nil {
		return nil
	}
	return g.Status
}

func (g *GiftCardActivityRedeem) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityRedeem) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityRedeem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityRedeem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityRedeem) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the status of a [gift card](entity:GiftCard) redemption. This status is relevant only for
// redemptions made from Square products (such as Square Point of Sale) because Square products use a
// two-state process. Gift cards redeemed using the Gift Card Activities API always have a `COMPLETED` status.
type GiftCardActivityRedeemStatus string

const (
	GiftCardActivityRedeemStatusPending   GiftCardActivityRedeemStatus = "PENDING"
	GiftCardActivityRedeemStatusCompleted GiftCardActivityRedeemStatus = "COMPLETED"
	GiftCardActivityRedeemStatusCanceled  GiftCardActivityRedeemStatus = "CANCELED"
)

func NewGiftCardActivityRedeemStatusFromString(s string) (GiftCardActivityRedeemStatus, error) {
	switch s {
	case "PENDING":
		return GiftCardActivityRedeemStatusPending, nil
	case "COMPLETED":
		return GiftCardActivityRedeemStatusCompleted, nil
	case "CANCELED":
		return GiftCardActivityRedeemStatusCanceled, nil
	}
	var t GiftCardActivityRedeemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityRedeemStatus) Ptr() *GiftCardActivityRedeemStatus {
	return &g
}

// Represents details about a `REFUND` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityRefund struct {
	// The ID of the refunded `REDEEM` gift card activity. Square populates this field if the
	// `payment_id` in the corresponding [RefundPayment](api-endpoint:Refunds-RefundPayment) request
	// represents a gift card redemption.
	//
	// For applications that use a custom payment processing system, this field is required when creating
	// a `REFUND` activity. The provided `REDEEM` activity ID must be linked to the same gift card.
	RedeemActivityID *string `json:"redeem_activity_id,omitempty" url:"redeem_activity_id,omitempty"`
	// The amount added to the gift card for the refund. This value is a positive integer.
	//
	// This field is required when creating a `REFUND` activity. The amount can represent a full or partial refund.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The ID of the refunded payment. Square populates this field if the refund is for a
	// payment processed by Square. This field matches the `payment_id` in the corresponding
	// [RefundPayment](api-endpoint:Refunds-RefundPayment) request.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityRefund) GetRedeemActivityID() *string {
	if g == nil {
		return nil
	}
	return g.RedeemActivityID
}

func (g *GiftCardActivityRefund) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityRefund) GetReferenceID() *string {
	if g == nil {
		return nil
	}
	return g.ReferenceID
}

func (g *GiftCardActivityRefund) GetPaymentID() *string {
	if g == nil {
		return nil
	}
	return g.PaymentID
}

func (g *GiftCardActivityRefund) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityRefund(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityRefund) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `TRANSFER_BALANCE_FROM` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityTransferBalanceFrom struct {
	// The ID of the gift card to which the specified amount was transferred.
	TransferToGiftCardID string `json:"transfer_to_gift_card_id" url:"transfer_to_gift_card_id"`
	// The amount deducted from the gift card for the transfer. This value is a positive integer.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityTransferBalanceFrom) GetTransferToGiftCardID() string {
	if g == nil {
		return ""
	}
	return g.TransferToGiftCardID
}

func (g *GiftCardActivityTransferBalanceFrom) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityTransferBalanceFrom) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityTransferBalanceFrom) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityTransferBalanceFrom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityTransferBalanceFrom(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityTransferBalanceFrom) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Represents details about a `TRANSFER_BALANCE_TO` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityTransferBalanceTo struct {
	// The ID of the gift card from which the specified amount was transferred.
	TransferFromGiftCardID string `json:"transfer_from_gift_card_id" url:"transfer_from_gift_card_id"`
	// The amount added to the gift card balance for the transfer. This value is a positive integer.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityTransferBalanceTo) GetTransferFromGiftCardID() string {
	if g == nil {
		return ""
	}
	return g.TransferFromGiftCardID
}

func (g *GiftCardActivityTransferBalanceTo) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityTransferBalanceTo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityTransferBalanceTo) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityTransferBalanceTo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityTransferBalanceTo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityTransferBalanceTo) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the type of [gift card activity](entity:GiftCardActivity).
type GiftCardActivityType string

const (
	GiftCardActivityTypeActivate               GiftCardActivityType = "ACTIVATE"
	GiftCardActivityTypeLoad                   GiftCardActivityType = "LOAD"
	GiftCardActivityTypeRedeem                 GiftCardActivityType = "REDEEM"
	GiftCardActivityTypeClearBalance           GiftCardActivityType = "CLEAR_BALANCE"
	GiftCardActivityTypeDeactivate             GiftCardActivityType = "DEACTIVATE"
	GiftCardActivityTypeAdjustIncrement        GiftCardActivityType = "ADJUST_INCREMENT"
	GiftCardActivityTypeAdjustDecrement        GiftCardActivityType = "ADJUST_DECREMENT"
	GiftCardActivityTypeRefund                 GiftCardActivityType = "REFUND"
	GiftCardActivityTypeUnlinkedActivityRefund GiftCardActivityType = "UNLINKED_ACTIVITY_REFUND"
	GiftCardActivityTypeImport                 GiftCardActivityType = "IMPORT"
	GiftCardActivityTypeBlock                  GiftCardActivityType = "BLOCK"
	GiftCardActivityTypeUnblock                GiftCardActivityType = "UNBLOCK"
	GiftCardActivityTypeImportReversal         GiftCardActivityType = "IMPORT_REVERSAL"
	GiftCardActivityTypeTransferBalanceFrom    GiftCardActivityType = "TRANSFER_BALANCE_FROM"
	GiftCardActivityTypeTransferBalanceTo      GiftCardActivityType = "TRANSFER_BALANCE_TO"
)

func NewGiftCardActivityTypeFromString(s string) (GiftCardActivityType, error) {
	switch s {
	case "ACTIVATE":
		return GiftCardActivityTypeActivate, nil
	case "LOAD":
		return GiftCardActivityTypeLoad, nil
	case "REDEEM":
		return GiftCardActivityTypeRedeem, nil
	case "CLEAR_BALANCE":
		return GiftCardActivityTypeClearBalance, nil
	case "DEACTIVATE":
		return GiftCardActivityTypeDeactivate, nil
	case "ADJUST_INCREMENT":
		return GiftCardActivityTypeAdjustIncrement, nil
	case "ADJUST_DECREMENT":
		return GiftCardActivityTypeAdjustDecrement, nil
	case "REFUND":
		return GiftCardActivityTypeRefund, nil
	case "UNLINKED_ACTIVITY_REFUND":
		return GiftCardActivityTypeUnlinkedActivityRefund, nil
	case "IMPORT":
		return GiftCardActivityTypeImport, nil
	case "BLOCK":
		return GiftCardActivityTypeBlock, nil
	case "UNBLOCK":
		return GiftCardActivityTypeUnblock, nil
	case "IMPORT_REVERSAL":
		return GiftCardActivityTypeImportReversal, nil
	case "TRANSFER_BALANCE_FROM":
		return GiftCardActivityTypeTransferBalanceFrom, nil
	case "TRANSFER_BALANCE_TO":
		return GiftCardActivityTypeTransferBalanceTo, nil
	}
	var t GiftCardActivityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GiftCardActivityType) Ptr() *GiftCardActivityType {
	return &g
}

// Represents details about an `UNBLOCK` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityUnblock struct {
	// The reason the gift card was unblocked.
	// See [Reason](#type-reason) for possible values
	Reason GiftCardActivityUnblockReason `json:"reason" url:"reason"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityUnblock) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUnblock) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUnblock
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUnblock(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUnblock) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates the reason for unblocking a [gift card](entity:GiftCard).
type GiftCardActivityUnblockReason = string

// Represents details about an `UNLINKED_ACTIVITY_REFUND` [gift card activity type](entity:GiftCardActivityType).
type GiftCardActivityUnlinkedActivityRefund struct {
	// The amount added to the gift card for the refund. This value is a positive integer.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// A client-specified ID that associates the gift card activity with an entity in another system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The ID of the refunded payment. This field is not used starting in Square version 2022-06-16.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityUnlinkedActivityRefund) GetAmountMoney() *Money {
	if g == nil {
		return nil
	}
	return g.AmountMoney
}

func (g *GiftCardActivityUnlinkedActivityRefund) GetReferenceID() *string {
	if g == nil {
		return nil
	}
	return g.ReferenceID
}

func (g *GiftCardActivityUnlinkedActivityRefund) GetPaymentID() *string {
	if g == nil {
		return nil
	}
	return g.PaymentID
}

func (g *GiftCardActivityUnlinkedActivityRefund) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUnlinkedActivityRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUnlinkedActivityRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUnlinkedActivityRefund(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUnlinkedActivityRefund) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [gift card activity](entity:GiftCardActivity) is updated.
// Subscribe to this event to be notified about the following changes:
// - An update to the `REDEEM` activity for a gift card redemption made from a Square product (such as Square Point of Sale).
// These redemptions are initially assigned a `PENDING` state, but then change to a `COMPLETED` or `CANCELED` state.
// - An update to the `IMPORT` activity for an imported gift card when the balance is later adjusted by Square.
type GiftCardActivityUpdatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.activity.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardActivityUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityUpdatedEvent) GetMerchantID() *string {
	if g == nil {
		return nil
	}
	return g.MerchantID
}

func (g *GiftCardActivityUpdatedEvent) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardActivityUpdatedEvent) GetEventID() *string {
	if g == nil {
		return nil
	}
	return g.EventID
}

func (g *GiftCardActivityUpdatedEvent) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GiftCardActivityUpdatedEvent) GetData() *GiftCardActivityUpdatedEventData {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GiftCardActivityUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUpdatedEvent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.activity.updated` event.
type GiftCardActivityUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `gift_card_activity`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card activity.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card activity.
	Object *GiftCardActivityUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityUpdatedEventData) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardActivityUpdatedEventData) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GiftCardActivityUpdatedEventData) GetObject() *GiftCardActivityUpdatedEventObject {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GiftCardActivityUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUpdatedEventData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card activity associated with a
// `gift_card.activity.updated` event.
type GiftCardActivityUpdatedEventObject struct {
	// The updated gift card activity.
	GiftCardActivity *GiftCardActivity `json:"gift_card_activity,omitempty" url:"gift_card_activity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardActivityUpdatedEventObject) GetGiftCardActivity() *GiftCardActivity {
	if g == nil {
		return nil
	}
	return g.GiftCardActivity
}

func (g *GiftCardActivityUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardActivityUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardActivityUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardActivityUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardActivityUpdatedEventObject) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [gift card](entity:GiftCard) is created.
type GiftCardCreatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCreatedEvent) GetMerchantID() *string {
	if g == nil {
		return nil
	}
	return g.MerchantID
}

func (g *GiftCardCreatedEvent) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardCreatedEvent) GetEventID() *string {
	if g == nil {
		return nil
	}
	return g.EventID
}

func (g *GiftCardCreatedEvent) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GiftCardCreatedEvent) GetData() *GiftCardCreatedEventData {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GiftCardCreatedEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCreatedEvent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.created` event.
type GiftCardCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the new gift card.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new gift card.
	Object *GiftCardCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCreatedEventData) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardCreatedEventData) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GiftCardCreatedEventData) GetObject() *GiftCardCreatedEventObject {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GiftCardCreatedEventData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCreatedEventData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card associated with a `gift_card.created` event.
type GiftCardCreatedEventObject struct {
	// The new gift card.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCreatedEventObject) GetGiftCard() *GiftCard {
	if g == nil {
		return nil
	}
	return g.GiftCard
}

func (g *GiftCardCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCreatedEventObject) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [customer](entity:Customer) is linked to a [gift card](entity:GiftCard).
type GiftCardCustomerLinkedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.customer_linked`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardCustomerLinkedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCustomerLinkedEvent) GetMerchantID() *string {
	if g == nil {
		return nil
	}
	return g.MerchantID
}

func (g *GiftCardCustomerLinkedEvent) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardCustomerLinkedEvent) GetEventID() *string {
	if g == nil {
		return nil
	}
	return g.EventID
}

func (g *GiftCardCustomerLinkedEvent) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GiftCardCustomerLinkedEvent) GetData() *GiftCardCustomerLinkedEventData {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GiftCardCustomerLinkedEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerLinkedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerLinkedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerLinkedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerLinkedEvent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.customer_linked` event.
type GiftCardCustomerLinkedEventData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card and the ID of the linked customer.
	Object *GiftCardCustomerLinkedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCustomerLinkedEventData) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardCustomerLinkedEventData) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GiftCardCustomerLinkedEventData) GetObject() *GiftCardCustomerLinkedEventObject {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GiftCardCustomerLinkedEventData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerLinkedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerLinkedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerLinkedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerLinkedEventData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card and customer ID associated with a
// `gift_card.customer_linked` event.
type GiftCardCustomerLinkedEventObject struct {
	// The gift card with the updated `customer_ids` field.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`
	// The ID of the linked [customer](entity:Customer).
	LinkedCustomerID *string `json:"linked_customer_id,omitempty" url:"linked_customer_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCustomerLinkedEventObject) GetGiftCard() *GiftCard {
	if g == nil {
		return nil
	}
	return g.GiftCard
}

func (g *GiftCardCustomerLinkedEventObject) GetLinkedCustomerID() *string {
	if g == nil {
		return nil
	}
	return g.LinkedCustomerID
}

func (g *GiftCardCustomerLinkedEventObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerLinkedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerLinkedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerLinkedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerLinkedEventObject) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [customer](entity:Customer) is unlinked from a [gift card](entity:GiftCard).
type GiftCardCustomerUnlinkedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `gift_card.customer_unlinked`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardCustomerUnlinkedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCustomerUnlinkedEvent) GetMerchantID() *string {
	if g == nil {
		return nil
	}
	return g.MerchantID
}

func (g *GiftCardCustomerUnlinkedEvent) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardCustomerUnlinkedEvent) GetEventID() *string {
	if g == nil {
		return nil
	}
	return g.EventID
}

func (g *GiftCardCustomerUnlinkedEvent) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GiftCardCustomerUnlinkedEvent) GetData() *GiftCardCustomerUnlinkedEventData {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GiftCardCustomerUnlinkedEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerUnlinkedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerUnlinkedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerUnlinkedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerUnlinkedEvent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.customer_unlinked` event.
type GiftCardCustomerUnlinkedEventData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card and the ID of the unlinked customer.
	Object *GiftCardCustomerUnlinkedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCustomerUnlinkedEventData) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardCustomerUnlinkedEventData) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GiftCardCustomerUnlinkedEventData) GetObject() *GiftCardCustomerUnlinkedEventObject {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GiftCardCustomerUnlinkedEventData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerUnlinkedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerUnlinkedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerUnlinkedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerUnlinkedEventData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card and the customer ID associated with a
// `gift_card.customer_linked` event.
type GiftCardCustomerUnlinkedEventObject struct {
	// The gift card with the updated `customer_ids` field.
	// The field is removed if the gift card is not linked to any customers.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`
	// The ID of the unlinked [customer](entity:Customer).
	UnlinkedCustomerID *string `json:"unlinked_customer_id,omitempty" url:"unlinked_customer_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardCustomerUnlinkedEventObject) GetGiftCard() *GiftCard {
	if g == nil {
		return nil
	}
	return g.GiftCard
}

func (g *GiftCardCustomerUnlinkedEventObject) GetUnlinkedCustomerID() *string {
	if g == nil {
		return nil
	}
	return g.UnlinkedCustomerID
}

func (g *GiftCardCustomerUnlinkedEventObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardCustomerUnlinkedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardCustomerUnlinkedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardCustomerUnlinkedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardCustomerUnlinkedEventObject) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Published when a [gift card](entity:GiftCard) is updated. This includes
// changes to the state, balance, and customer association.
type GiftCardUpdatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. For this event, the value is `gift_card.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID of the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *GiftCardUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardUpdatedEvent) GetMerchantID() *string {
	if g == nil {
		return nil
	}
	return g.MerchantID
}

func (g *GiftCardUpdatedEvent) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardUpdatedEvent) GetEventID() *string {
	if g == nil {
		return nil
	}
	return g.EventID
}

func (g *GiftCardUpdatedEvent) GetCreatedAt() *string {
	if g == nil {
		return nil
	}
	return g.CreatedAt
}

func (g *GiftCardUpdatedEvent) GetData() *GiftCardUpdatedEventData {
	if g == nil {
		return nil
	}
	return g.Data
}

func (g *GiftCardUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardUpdatedEvent) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The data associated with a `gift_card.updated` event.
type GiftCardUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `gift_card`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the updated gift card.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the updated gift card.
	Object *GiftCardUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardUpdatedEventData) GetType() *string {
	if g == nil {
		return nil
	}
	return g.Type
}

func (g *GiftCardUpdatedEventData) GetID() *string {
	if g == nil {
		return nil
	}
	return g.ID
}

func (g *GiftCardUpdatedEventData) GetObject() *GiftCardUpdatedEventObject {
	if g == nil {
		return nil
	}
	return g.Object
}

func (g *GiftCardUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardUpdatedEventData) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// An object that contains the gift card associated with a `gift_card.updated` event.
type GiftCardUpdatedEventObject struct {
	// The gift card with the updated `balance_money`, `state`, or `customer_ids` field.
	// Some events can affect both `balance_money` and `state`.
	GiftCard *GiftCard `json:"gift_card,omitempty" url:"gift_card,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GiftCardUpdatedEventObject) GetGiftCard() *GiftCard {
	if g == nil {
		return nil
	}
	return g.GiftCard
}

func (g *GiftCardUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GiftCardUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler GiftCardUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GiftCardUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GiftCardUpdatedEventObject) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates whether Square should alert the merchant when the inventory quantity of a CatalogItemVariation is low.
type InventoryAlertType string

const (
	InventoryAlertTypeNone        InventoryAlertType = "NONE"
	InventoryAlertTypeLowQuantity InventoryAlertType = "LOW_QUANTITY"
)

func NewInventoryAlertTypeFromString(s string) (InventoryAlertType, error) {
	switch s {
	case "NONE":
		return InventoryAlertTypeNone, nil
	case "LOW_QUANTITY":
		return InventoryAlertTypeLowQuantity, nil
	}
	var t InventoryAlertType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryAlertType) Ptr() *InventoryAlertType {
	return &i
}

// Published when the quantity is updated for a
// [CatalogItemVariation](entity:CatalogItemVariation).
type InventoryCountUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InventoryCountUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InventoryCountUpdatedEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InventoryCountUpdatedEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InventoryCountUpdatedEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InventoryCountUpdatedEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InventoryCountUpdatedEvent) GetData() *InventoryCountUpdatedEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InventoryCountUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCountUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCountUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCountUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCountUpdatedEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InventoryCountUpdatedEventData struct {
	// Name of the affected object’s type. For this event, the value is `inventory_counts`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing fields and values relevant to the event. Is absent if affected object was deleted.
	Object *InventoryCountUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InventoryCountUpdatedEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InventoryCountUpdatedEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InventoryCountUpdatedEventData) GetObject() *InventoryCountUpdatedEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InventoryCountUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCountUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCountUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCountUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCountUpdatedEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InventoryCountUpdatedEventObject struct {
	// The inventory counts.
	InventoryCounts []*InventoryCount `json:"inventory_counts,omitempty" url:"inventory_counts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InventoryCountUpdatedEventObject) GetInventoryCounts() []*InventoryCount {
	if i == nil {
		return nil
	}
	return i.InventoryCounts
}

func (i *InventoryCountUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InventoryCountUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InventoryCountUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InventoryCountUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InventoryCountUpdatedEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when an [Invoice](entity:Invoice) is canceled.
type InvoiceCanceledEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.canceled"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceCanceledEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCanceledEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoiceCanceledEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceCanceledEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoiceCanceledEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoiceCanceledEvent) GetData() *InvoiceCanceledEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceCanceledEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCanceledEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCanceledEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCanceledEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCanceledEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCanceledEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the canceled invoice.
	Object *InvoiceCanceledEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCanceledEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceCanceledEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceCanceledEventData) GetObject() *InvoiceCanceledEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InvoiceCanceledEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCanceledEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCanceledEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCanceledEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCanceledEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCanceledEventObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCanceledEventObject) GetInvoice() *Invoice {
	if i == nil {
		return nil
	}
	return i.Invoice
}

func (i *InvoiceCanceledEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCanceledEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCanceledEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCanceledEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCanceledEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when an [Invoice](entity:Invoice) is created.
type InvoiceCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCreatedEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoiceCreatedEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceCreatedEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoiceCreatedEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoiceCreatedEvent) GetData() *InvoiceCreatedEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceCreatedEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreatedEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCreatedEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created invoice.
	Object *InvoiceCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCreatedEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceCreatedEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceCreatedEventData) GetObject() *InvoiceCreatedEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InvoiceCreatedEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreatedEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceCreatedEventObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceCreatedEventObject) GetInvoice() *Invoice {
	if i == nil {
		return nil
	}
	return i.Invoice
}

func (i *InvoiceCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceCreatedEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when a draft [Invoice](entity:Invoice) is deleted.
type InvoiceDeletedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceDeletedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceDeletedEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoiceDeletedEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceDeletedEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoiceDeletedEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoiceDeletedEvent) GetData() *InvoiceDeletedEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceDeletedEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceDeletedEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceDeletedEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Indicates that the invoice was deleted.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceDeletedEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceDeletedEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceDeletedEventData) GetDeleted() *bool {
	if i == nil {
		return nil
	}
	return i.Deleted
}

func (i *InvoiceDeletedEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceDeletedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceDeletedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceDeletedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceDeletedEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when a payment that is associated with an [invoice](entity:Invoice) is completed.
// For more information about invoice payments, see [Pay an invoice](https://developer.squareup.com/docs/invoices-api/pay-refund-invoices#pay-invoice).
type InvoicePaymentMadeEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.payment_made"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoicePaymentMadeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoicePaymentMadeEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoicePaymentMadeEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoicePaymentMadeEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoicePaymentMadeEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoicePaymentMadeEvent) GetData() *InvoicePaymentMadeEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoicePaymentMadeEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentMadeEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentMadeEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentMadeEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentMadeEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePaymentMadeEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the invoice that was paid.
	Object *InvoicePaymentMadeEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoicePaymentMadeEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoicePaymentMadeEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoicePaymentMadeEventData) GetObject() *InvoicePaymentMadeEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InvoicePaymentMadeEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentMadeEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentMadeEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentMadeEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentMadeEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePaymentMadeEventObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoicePaymentMadeEventObject) GetInvoice() *Invoice {
	if i == nil {
		return nil
	}
	return i.Invoice
}

func (i *InvoicePaymentMadeEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePaymentMadeEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePaymentMadeEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePaymentMadeEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePaymentMadeEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when an [Invoice](entity:Invoice) transitions from a draft to a non-draft status.
type InvoicePublishedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.published"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoicePublishedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoicePublishedEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoicePublishedEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoicePublishedEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoicePublishedEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoicePublishedEvent) GetData() *InvoicePublishedEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoicePublishedEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePublishedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePublishedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePublishedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePublishedEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePublishedEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the published invoice.
	Object *InvoicePublishedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoicePublishedEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoicePublishedEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoicePublishedEventData) GetObject() *InvoicePublishedEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InvoicePublishedEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePublishedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePublishedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePublishedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePublishedEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoicePublishedEventObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoicePublishedEventObject) GetInvoice() *Invoice {
	if i == nil {
		return nil
	}
	return i.Invoice
}

func (i *InvoicePublishedEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoicePublishedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoicePublishedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoicePublishedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoicePublishedEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when a refund is applied toward a payment of an [invoice](entity:Invoice).
// For more information about invoice refunds, see [Refund an invoice](https://developer.squareup.com/docs/invoices-api/pay-refund-invoices#refund-invoice).
type InvoiceRefundedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.refunded"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceRefundedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceRefundedEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoiceRefundedEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceRefundedEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoiceRefundedEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoiceRefundedEvent) GetData() *InvoiceRefundedEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceRefundedEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRefundedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRefundedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRefundedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRefundedEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceRefundedEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the refunded invoice.
	Object *InvoiceRefundedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceRefundedEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceRefundedEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceRefundedEventData) GetObject() *InvoiceRefundedEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InvoiceRefundedEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRefundedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRefundedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRefundedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRefundedEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceRefundedEventObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceRefundedEventObject) GetInvoice() *Invoice {
	if i == nil {
		return nil
	}
	return i.Invoice
}

func (i *InvoiceRefundedEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceRefundedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceRefundedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceRefundedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceRefundedEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when an automatic scheduled payment for an [Invoice](entity:Invoice) has failed.
type InvoiceScheduledChargeFailedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.scheduled_charge_failed"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceScheduledChargeFailedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceScheduledChargeFailedEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoiceScheduledChargeFailedEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceScheduledChargeFailedEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoiceScheduledChargeFailedEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoiceScheduledChargeFailedEvent) GetData() *InvoiceScheduledChargeFailedEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceScheduledChargeFailedEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceScheduledChargeFailedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceScheduledChargeFailedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceScheduledChargeFailedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceScheduledChargeFailedEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceScheduledChargeFailedEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the invoice that experienced the failed scheduled charge.
	Object *InvoiceScheduledChargeFailedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceScheduledChargeFailedEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceScheduledChargeFailedEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceScheduledChargeFailedEventData) GetObject() *InvoiceScheduledChargeFailedEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InvoiceScheduledChargeFailedEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceScheduledChargeFailedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceScheduledChargeFailedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceScheduledChargeFailedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceScheduledChargeFailedEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceScheduledChargeFailedEventObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceScheduledChargeFailedEventObject) GetInvoice() *Invoice {
	if i == nil {
		return nil
	}
	return i.Invoice
}

func (i *InvoiceScheduledChargeFailedEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceScheduledChargeFailedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceScheduledChargeFailedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceScheduledChargeFailedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceScheduledChargeFailedEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Published when an [Invoice](entity:Invoice) is updated.
type InvoiceUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"invoice.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *InvoiceUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceUpdatedEvent) GetMerchantID() *string {
	if i == nil {
		return nil
	}
	return i.MerchantID
}

func (i *InvoiceUpdatedEvent) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceUpdatedEvent) GetEventID() *string {
	if i == nil {
		return nil
	}
	return i.EventID
}

func (i *InvoiceUpdatedEvent) GetCreatedAt() *string {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *InvoiceUpdatedEvent) GetData() *InvoiceUpdatedEventData {
	if i == nil {
		return nil
	}
	return i.Data
}

func (i *InvoiceUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdatedEvent) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdatedEventData struct {
	// Name of the affected object’s type, `"invoice"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected invoice.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated invoice.
	Object *InvoiceUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceUpdatedEventData) GetType() *string {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InvoiceUpdatedEventData) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InvoiceUpdatedEventData) GetObject() *InvoiceUpdatedEventObject {
	if i == nil {
		return nil
	}
	return i.Object
}

func (i *InvoiceUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdatedEventData) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InvoiceUpdatedEventObject struct {
	// The related invoice.
	Invoice *Invoice `json:"invoice,omitempty" url:"invoice,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InvoiceUpdatedEventObject) GetInvoice() *Invoice {
	if i == nil {
		return nil
	}
	return i.Invoice
}

func (i *InvoiceUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InvoiceUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler InvoiceUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InvoiceUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InvoiceUpdatedEventObject) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Price and inventory alerting overrides for a `CatalogItemVariation` at a specific `Location`.
type ItemVariationLocationOverrides struct {
	// The ID of the `Location`. This can include locations that are deactivated.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The price of the `CatalogItemVariation` at the given `Location`, or blank for variable pricing.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// The pricing type (fixed or variable) for the `CatalogItemVariation` at the given `Location`.
	// See [CatalogPricingType](#type-catalogpricingtype) for possible values
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	// If `true`, inventory tracking is active for the `CatalogItemVariation` at this `Location`.
	TrackInventory *bool `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	// Indicates whether the `CatalogItemVariation` displays an alert when its inventory
	// quantity is less than or equal to its `inventory_alert_threshold`.
	// See [InventoryAlertType](#type-inventoryalerttype) for possible values
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Indicates whether the overridden item variation is sold out at the specified location.
	//
	// When inventory tracking is enabled on the item variation either globally or at the specified location,
	// the item variation is automatically marked as sold out when its inventory count reaches zero. The seller
	// can manually set the item variation as sold out even when the inventory count is greater than zero.
	// Attempts by an application to set this attribute are ignored. Regardless how the sold-out status is set,
	// applications should treat its inventory count as zero when this attribute value is `true`.
	SoldOut *bool `json:"sold_out,omitempty" url:"sold_out,omitempty"`
	// The seller-assigned timestamp, of the RFC 3339 format, to indicate when this sold-out variation
	// becomes available again at the specified location. Attempts by an application to set this attribute are ignored.
	// When the current time is later than this attribute value, the affected item variation is no longer sold out.
	SoldOutValidUntil *string `json:"sold_out_valid_until,omitempty" url:"sold_out_valid_until,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ItemVariationLocationOverrides) GetLocationID() *string {
	if i == nil {
		return nil
	}
	return i.LocationID
}

func (i *ItemVariationLocationOverrides) GetPriceMoney() *Money {
	if i == nil {
		return nil
	}
	return i.PriceMoney
}

func (i *ItemVariationLocationOverrides) GetPricingType() *CatalogPricingType {
	if i == nil {
		return nil
	}
	return i.PricingType
}

func (i *ItemVariationLocationOverrides) GetTrackInventory() *bool {
	if i == nil {
		return nil
	}
	return i.TrackInventory
}

func (i *ItemVariationLocationOverrides) GetInventoryAlertType() *InventoryAlertType {
	if i == nil {
		return nil
	}
	return i.InventoryAlertType
}

func (i *ItemVariationLocationOverrides) GetInventoryAlertThreshold() *int64 {
	if i == nil {
		return nil
	}
	return i.InventoryAlertThreshold
}

func (i *ItemVariationLocationOverrides) GetSoldOut() *bool {
	if i == nil {
		return nil
	}
	return i.SoldOut
}

func (i *ItemVariationLocationOverrides) GetSoldOutValidUntil() *string {
	if i == nil {
		return nil
	}
	return i.SoldOutValidUntil
}

func (i *ItemVariationLocationOverrides) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemVariationLocationOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemVariationLocationOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemVariationLocationOverrides(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemVariationLocationOverrides) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Represents a job assigned to a [team member](entity:TeamMember), including the compensation the team
// member earns for the job. Job assignments are listed in the team member's [wage setting](entity:WageSetting).
type JobAssignment struct {
	// The title of the job.
	JobTitle *string `json:"job_title,omitempty" url:"job_title,omitempty"`
	// The current pay type for the job assignment used to
	// calculate the pay amount in a pay period.
	// See [JobAssignmentPayType](#type-jobassignmentpaytype) for possible values
	PayType JobAssignmentPayType `json:"pay_type" url:"pay_type"`
	// The hourly pay rate of the job. For `SALARY` pay types, Square calculates the hourly rate based on
	// `annual_rate` and `weekly_hours`.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// The total pay amount for a 12-month period on the job. Set if the job `PayType` is `SALARY`.
	AnnualRate *Money `json:"annual_rate,omitempty" url:"annual_rate,omitempty"`
	// The planned hours per week for the job. Set if the job `PayType` is `SALARY`.
	WeeklyHours *int `json:"weekly_hours,omitempty" url:"weekly_hours,omitempty"`
	// The ID of the [job](entity:Job).
	JobID *string `json:"job_id,omitempty" url:"job_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobAssignment) GetJobTitle() *string {
	if j == nil {
		return nil
	}
	return j.JobTitle
}

func (j *JobAssignment) GetPayType() JobAssignmentPayType {
	if j == nil {
		return ""
	}
	return j.PayType
}

func (j *JobAssignment) GetHourlyRate() *Money {
	if j == nil {
		return nil
	}
	return j.HourlyRate
}

func (j *JobAssignment) GetAnnualRate() *Money {
	if j == nil {
		return nil
	}
	return j.AnnualRate
}

func (j *JobAssignment) GetWeeklyHours() *int {
	if j == nil {
		return nil
	}
	return j.WeeklyHours
}

func (j *JobAssignment) GetJobID() *string {
	if j == nil {
		return nil
	}
	return j.JobID
}

func (j *JobAssignment) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobAssignment) UnmarshalJSON(data []byte) error {
	type unmarshaler JobAssignment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobAssignment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobAssignment) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// Enumerates the possible pay types that a job can be assigned.
type JobAssignmentPayType string

const (
	JobAssignmentPayTypeNone   JobAssignmentPayType = "NONE"
	JobAssignmentPayTypeHourly JobAssignmentPayType = "HOURLY"
	JobAssignmentPayTypeSalary JobAssignmentPayType = "SALARY"
)

func NewJobAssignmentPayTypeFromString(s string) (JobAssignmentPayType, error) {
	switch s {
	case "NONE":
		return JobAssignmentPayTypeNone, nil
	case "HOURLY":
		return JobAssignmentPayTypeHourly, nil
	case "SALARY":
		return JobAssignmentPayTypeSalary, nil
	}
	var t JobAssignmentPayType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (j JobAssignmentPayType) Ptr() *JobAssignmentPayType {
	return &j
}

// Published when a Job is created.
type JobCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"job.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *JobCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobCreatedEvent) GetMerchantID() *string {
	if j == nil {
		return nil
	}
	return j.MerchantID
}

func (j *JobCreatedEvent) GetType() *string {
	if j == nil {
		return nil
	}
	return j.Type
}

func (j *JobCreatedEvent) GetEventID() *string {
	if j == nil {
		return nil
	}
	return j.EventID
}

func (j *JobCreatedEvent) GetCreatedAt() *string {
	if j == nil {
		return nil
	}
	return j.CreatedAt
}

func (j *JobCreatedEvent) GetData() *JobCreatedEventData {
	if j == nil {
		return nil
	}
	return j.Data
}

func (j *JobCreatedEvent) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler JobCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobCreatedEvent) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobCreatedEventData struct {
	// Name of the affected object’s type, `"job"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created job.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created job.
	Object *JobCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobCreatedEventData) GetType() *string {
	if j == nil {
		return nil
	}
	return j.Type
}

func (j *JobCreatedEventData) GetID() *string {
	if j == nil {
		return nil
	}
	return j.ID
}

func (j *JobCreatedEventData) GetObject() *JobCreatedEventObject {
	if j == nil {
		return nil
	}
	return j.Object
}

func (j *JobCreatedEventData) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler JobCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobCreatedEventData) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobCreatedEventObject struct {
	// The created job.
	Job *Job `json:"job,omitempty" url:"job,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobCreatedEventObject) GetJob() *Job {
	if j == nil {
		return nil
	}
	return j.Job
}

func (j *JobCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler JobCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobCreatedEventObject) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// Published when a Job is updated.
type JobUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"job.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *JobUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobUpdatedEvent) GetMerchantID() *string {
	if j == nil {
		return nil
	}
	return j.MerchantID
}

func (j *JobUpdatedEvent) GetType() *string {
	if j == nil {
		return nil
	}
	return j.Type
}

func (j *JobUpdatedEvent) GetEventID() *string {
	if j == nil {
		return nil
	}
	return j.EventID
}

func (j *JobUpdatedEvent) GetCreatedAt() *string {
	if j == nil {
		return nil
	}
	return j.CreatedAt
}

func (j *JobUpdatedEvent) GetData() *JobUpdatedEventData {
	if j == nil {
		return nil
	}
	return j.Data
}

func (j *JobUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler JobUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobUpdatedEvent) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobUpdatedEventData struct {
	// Name of the affected object’s type, `"job"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated job.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated job.
	Object *JobUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobUpdatedEventData) GetType() *string {
	if j == nil {
		return nil
	}
	return j.Type
}

func (j *JobUpdatedEventData) GetID() *string {
	if j == nil {
		return nil
	}
	return j.ID
}

func (j *JobUpdatedEventData) GetObject() *JobUpdatedEventObject {
	if j == nil {
		return nil
	}
	return j.Object
}

func (j *JobUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler JobUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobUpdatedEventData) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type JobUpdatedEventObject struct {
	// The updated job.
	Job *Job `json:"job,omitempty" url:"job,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (j *JobUpdatedEventObject) GetJob() *Job {
	if j == nil {
		return nil
	}
	return j.Job
}

func (j *JobUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return j.extraProperties
}

func (j *JobUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler JobUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *j)
	if err != nil {
		return err
	}
	j.extraProperties = extraProperties
	j.rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobUpdatedEventObject) String() string {
	if len(j.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(j.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

// Published when a [ScheduledShift](entity:ScheduledShift) is created.
type LaborScheduledShiftCreatedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event. For this event, the value is `labor.scheduled_shift.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborScheduledShiftCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborScheduledShiftCreatedEvent) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LaborScheduledShiftCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborScheduledShiftCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborScheduledShiftCreatedEvent) GetData() *LaborScheduledShiftCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborScheduledShiftCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborScheduledShiftCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `scheduled_shift`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `ScheduledShift`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the affected `ScheduledShift`.
	Object *LaborScheduledShiftCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborScheduledShiftCreatedEventData) GetObject() *LaborScheduledShiftCreatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LaborScheduledShiftCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborScheduledShiftCreatedEventObject struct {
	// The new `ScheduledShift`.
	ScheduledShift *ScheduledShift `json:"ScheduledShift,omitempty" url:"ScheduledShift,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftCreatedEventObject) GetScheduledShift() *ScheduledShift {
	if l == nil {
		return nil
	}
	return l.ScheduledShift
}

func (l *LaborScheduledShiftCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftCreatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [ScheduledShift](entity:ScheduledShift) is deleted.
type LaborScheduledShiftDeletedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event. For this event, the value is `labor.scheduled_shift.deleted`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborScheduledShiftDeletedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborScheduledShiftDeletedEvent) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LaborScheduledShiftDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborScheduledShiftDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborScheduledShiftDeletedEvent) GetData() *LaborScheduledShiftDeletedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborScheduledShiftDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborScheduledShiftDeletedEventData struct {
	// The type of object affected by the event. For this event, the value is `scheduled_shift`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `ScheduledShift`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Is true if the affected object was deleted. Otherwise absent.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftDeletedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftDeletedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborScheduledShiftDeletedEventData) GetDeleted() *bool {
	if l == nil {
		return nil
	}
	return l.Deleted
}

func (l *LaborScheduledShiftDeletedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftDeletedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftDeletedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftDeletedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftDeletedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [ScheduledShift](entity:ScheduledShift) is published.
type LaborScheduledShiftPublishedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event. For this event, the value is `labor.scheduled_shift.published`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborScheduledShiftPublishedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftPublishedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborScheduledShiftPublishedEvent) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LaborScheduledShiftPublishedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftPublishedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborScheduledShiftPublishedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborScheduledShiftPublishedEvent) GetData() *LaborScheduledShiftPublishedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborScheduledShiftPublishedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftPublishedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftPublishedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftPublishedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftPublishedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborScheduledShiftPublishedEventData struct {
	// The type of object affected by the event. For this event, the value is `scheduled_shift`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `ScheduledShift`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the affected `ScheduledShift`.
	Object *LaborScheduledShiftPublishedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftPublishedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftPublishedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborScheduledShiftPublishedEventData) GetObject() *LaborScheduledShiftPublishedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LaborScheduledShiftPublishedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftPublishedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftPublishedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftPublishedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftPublishedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborScheduledShiftPublishedEventObject struct {
	// The published `ScheduledShift`.
	ScheduledShift *ScheduledShift `json:"ScheduledShift,omitempty" url:"ScheduledShift,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftPublishedEventObject) GetScheduledShift() *ScheduledShift {
	if l == nil {
		return nil
	}
	return l.ScheduledShift
}

func (l *LaborScheduledShiftPublishedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftPublishedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftPublishedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftPublishedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftPublishedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [ScheduledShift](entity:ScheduledShift) is updated.
type LaborScheduledShiftUpdatedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event. For this event, the value is `labor.scheduled_shift.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborScheduledShiftUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborScheduledShiftUpdatedEvent) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LaborScheduledShiftUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborScheduledShiftUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborScheduledShiftUpdatedEvent) GetData() *LaborScheduledShiftUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborScheduledShiftUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborScheduledShiftUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `scheduled_shift`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `ScheduledShift`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the affected `ScheduledShift`.
	Object *LaborScheduledShiftUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborScheduledShiftUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborScheduledShiftUpdatedEventData) GetObject() *LaborScheduledShiftUpdatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LaborScheduledShiftUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborScheduledShiftUpdatedEventObject struct {
	// The updated `ScheduledShift`.
	ScheduledShift *ScheduledShift `json:"ScheduledShift,omitempty" url:"ScheduledShift,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborScheduledShiftUpdatedEventObject) GetScheduledShift() *ScheduledShift {
	if l == nil {
		return nil
	}
	return l.ScheduledShift
}

func (l *LaborScheduledShiftUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborScheduledShiftUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborScheduledShiftUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborScheduledShiftUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborScheduledShiftUpdatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a worker starts a [Shift](entity:Shift).
//
// Deprecated at Square API version 2025-05-21. Replaced by `labor.timecard.created`.
type LaborShiftCreatedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `labor.shift.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborShiftCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborShiftCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborShiftCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborShiftCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborShiftCreatedEvent) GetData() *LaborShiftCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborShiftCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `shift`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `Shift`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the affected `Shift`.
	Object *LaborShiftCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborShiftCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborShiftCreatedEventData) GetObject() *LaborShiftCreatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LaborShiftCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftCreatedEventObject struct {
	// The new `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftCreatedEventObject) GetShift() *Shift {
	if l == nil {
		return nil
	}
	return l.Shift
}

func (l *LaborShiftCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftCreatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Shift](entity:Shift) is deleted.
//
// Deprecated at Square API version 2025-05-21. Replaced by `labor.timecard.deleted`.
type LaborShiftDeletedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `labor.shift.deleted`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborShiftDeletedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborShiftDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborShiftDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborShiftDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborShiftDeletedEvent) GetData() *LaborShiftDeletedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborShiftDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftDeletedEventData struct {
	// The type of object affected by the event. For this event, the value is `shift`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `Shift`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Is true if the affected object was deleted. Otherwise absent.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftDeletedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborShiftDeletedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborShiftDeletedEventData) GetDeleted() *bool {
	if l == nil {
		return nil
	}
	return l.Deleted
}

func (l *LaborShiftDeletedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftDeletedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftDeletedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftDeletedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftDeletedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Shift](entity:Shift) is updated.
//
// Deprecated at Square API version 2025-05-21. Replaced by `labor.timecard.updated`.
type LaborShiftUpdatedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `labor.shift.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborShiftUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborShiftUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborShiftUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborShiftUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborShiftUpdatedEvent) GetData() *LaborShiftUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborShiftUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `shift`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected `Shift`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the affected `Shift`.
	Object *LaborShiftUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborShiftUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborShiftUpdatedEventData) GetObject() *LaborShiftUpdatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LaborShiftUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborShiftUpdatedEventObject struct {
	// The updated `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborShiftUpdatedEventObject) GetShift() *Shift {
	if l == nil {
		return nil
	}
	return l.Shift
}

func (l *LaborShiftUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborShiftUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborShiftUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborShiftUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborShiftUpdatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a worker starts a [Timecard](entity:Timecard).
type LaborTimecardCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `labor.timecard.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborTimecardCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborTimecardCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborTimecardCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborTimecardCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborTimecardCreatedEvent) GetData() *LaborTimecardCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborTimecardCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborTimecardCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `timecard`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `Timecard`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the affected `Timecard`.
	Object *LaborTimecardCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborTimecardCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborTimecardCreatedEventData) GetObject() *LaborTimecardCreatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LaborTimecardCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborTimecardCreatedEventObject struct {
	// The new `Timecard`.
	Timecard *Timecard `json:"timecard,omitempty" url:"timecard,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardCreatedEventObject) GetTimecard() *Timecard {
	if l == nil {
		return nil
	}
	return l.Timecard
}

func (l *LaborTimecardCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardCreatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Timecard](entity:Timecard) is deleted.
type LaborTimecardDeletedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `labor.timecard.deleted`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborTimecardDeletedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborTimecardDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborTimecardDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborTimecardDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborTimecardDeletedEvent) GetData() *LaborTimecardDeletedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborTimecardDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborTimecardDeletedEventData struct {
	// The type of object affected by the event. For this event, the value is `timecard`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `Timecard`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Is true if the affected object was deleted. Otherwise absent.
	Deleted *bool `json:"deleted,omitempty" url:"deleted,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardDeletedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborTimecardDeletedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborTimecardDeletedEventData) GetDeleted() *bool {
	if l == nil {
		return nil
	}
	return l.Deleted
}

func (l *LaborTimecardDeletedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardDeletedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardDeletedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardDeletedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardDeletedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Timecard](entity:Timecard) is updated.
type LaborTimecardUpdatedEvent struct {
	// The ID of the merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `labor.timecard.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LaborTimecardUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LaborTimecardUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborTimecardUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LaborTimecardUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LaborTimecardUpdatedEvent) GetData() *LaborTimecardUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LaborTimecardUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborTimecardUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `timecard`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected `Timecard`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the affected `Timecard`.
	Object *LaborTimecardUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LaborTimecardUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LaborTimecardUpdatedEventData) GetObject() *LaborTimecardUpdatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LaborTimecardUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LaborTimecardUpdatedEventObject struct {
	// The updated `Timecard`.
	Timecard *Timecard `json:"timecard,omitempty" url:"timecard,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LaborTimecardUpdatedEventObject) GetTimecard() *Timecard {
	if l == nil {
		return nil
	}
	return l.Timecard
}

func (l *LaborTimecardUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LaborTimecardUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LaborTimecardUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LaborTimecardUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LaborTimecardUpdatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListBookingCustomAttributeDefinitions](api-endpoint:BookingCustomAttributes-ListBookingCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListBookingCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBookingCustomAttributeDefinitionsResponse) GetCustomAttributeDefinitions() []*CustomAttributeDefinition {
	if l == nil {
		return nil
	}
	return l.CustomAttributeDefinitions
}

func (l *ListBookingCustomAttributeDefinitionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListBookingCustomAttributeDefinitionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListBookingCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBookingCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBookingCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBookingCustomAttributeDefinitionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBookingCustomAttributeDefinitionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListBookingCustomAttributes](api-endpoint:BookingCustomAttributes-ListBookingCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListBookingCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	//
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBookingCustomAttributesResponse) GetCustomAttributes() []*CustomAttribute {
	if l == nil {
		return nil
	}
	return l.CustomAttributes
}

func (l *ListBookingCustomAttributesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListBookingCustomAttributesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListBookingCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBookingCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBookingCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBookingCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBookingCustomAttributesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `BreakType` objects. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type ListBreakTypesResponse struct {
	// A page of `BreakType` results.
	BreakTypes []*BreakType `json:"break_types,omitempty" url:"break_types,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `BreakType` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBreakTypesResponse) GetBreakTypes() []*BreakType {
	if l == nil {
		return nil
	}
	return l.BreakTypes
}

func (l *ListBreakTypesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListBreakTypesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListBreakTypesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBreakTypesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBreakTypesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBreakTypesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBreakTypesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftEventsResponse struct {
	// Opaque cursor for fetching the next page. Cursor is not present in
	// the last page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// All of the events (payments, refunds, etc.) for a cash drawer during
	// the shift.
	CashDrawerShiftEvents []*CashDrawerShiftEvent `json:"cash_drawer_shift_events,omitempty" url:"cash_drawer_shift_events,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCashDrawerShiftEventsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListCashDrawerShiftEventsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListCashDrawerShiftEventsResponse) GetCashDrawerShiftEvents() []*CashDrawerShiftEvent {
	if l == nil {
		return nil
	}
	return l.CashDrawerShiftEvents
}

func (l *ListCashDrawerShiftEventsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftEventsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftEventsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftEventsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftEventsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListCashDrawerShiftsResponse struct {
	// Opaque cursor for fetching the next page of results. Cursor is not
	// present in the last page of results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A collection of CashDrawerShiftSummary objects for shifts that match
	// the query.
	CashDrawerShifts []*CashDrawerShiftSummary `json:"cash_drawer_shifts,omitempty" url:"cash_drawer_shifts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCashDrawerShiftsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListCashDrawerShiftsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListCashDrawerShiftsResponse) GetCashDrawerShifts() []*CashDrawerShiftSummary {
	if l == nil {
		return nil
	}
	return l.CashDrawerShifts
}

func (l *ListCashDrawerShiftsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCashDrawerShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCashDrawerShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCashDrawerShiftsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCashDrawerShiftsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListCustomerCustomAttributeDefinitions](api-endpoint:CustomerCustomAttributes-ListCustomerCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListCustomerCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) GetCustomAttributeDefinitions() []*CustomAttributeDefinition {
	if l == nil {
		return nil
	}
	return l.CustomAttributeDefinitions
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerCustomAttributeDefinitionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerCustomAttributeDefinitionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListCustomerCustomAttributes](api-endpoint:CustomerCustomAttributes-ListCustomerCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListCustomerCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	//
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCustomerCustomAttributesResponse) GetCustomAttributes() []*CustomAttribute {
	if l == nil {
		return nil
	}
	return l.CustomAttributes
}

func (l *ListCustomerCustomAttributesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListCustomerCustomAttributesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListCustomerCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerCustomAttributesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListCustomerGroups](api-endpoint:CustomerGroups-ListCustomerGroups) endpoint.
//
// Either `errors` or `groups` is present in a given response (never both).
type ListCustomerGroupsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A list of customer groups belonging to the current seller.
	Groups []*CustomerGroup `json:"groups,omitempty" url:"groups,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint. This value is present only if the request
	// succeeded and additional results are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCustomerGroupsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListCustomerGroupsResponse) GetGroups() []*CustomerGroup {
	if l == nil {
		return nil
	}
	return l.Groups
}

func (l *ListCustomerGroupsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListCustomerGroupsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerGroupsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerGroupsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerGroupsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerGroupsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body for requests to the `ListCustomerSegments` endpoint.
//
// Either `errors` or `segments` is present in a given response (never both).
type ListCustomerSegmentsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of customer segments belonging to the associated Square account.
	Segments []*CustomerSegment `json:"segments,omitempty" url:"segments,omitempty"`
	// A pagination cursor to be used in subsequent calls to `ListCustomerSegments`
	// to retrieve the next set of query results. The cursor is only present if the request succeeded and
	// additional results are available.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListCustomerSegmentsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListCustomerSegmentsResponse) GetSegments() []*CustomerSegment {
	if l == nil {
		return nil
	}
	return l.Segments
}

func (l *ListCustomerSegmentsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListCustomerSegmentsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListCustomerSegmentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListCustomerSegmentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListCustomerSegmentsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListCustomerSegmentsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListDeviceCodesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The queried DeviceCode.
	DeviceCodes []*DeviceCode `json:"device_codes,omitempty" url:"device_codes,omitempty"`
	// A pagination cursor to retrieve the next set of results for your
	// original query to the endpoint. This value is present only if the request
	// succeeded and additional results are available.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListDeviceCodesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListDeviceCodesResponse) GetDeviceCodes() []*DeviceCode {
	if l == nil {
		return nil
	}
	return l.DeviceCodes
}

func (l *ListDeviceCodesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListDeviceCodesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDeviceCodesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDeviceCodesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDeviceCodesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDeviceCodesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields in a `ListDisputeEvidence` response.
type ListDisputeEvidenceResponse struct {
	// The list of evidence previously uploaded to the specified dispute.
	Evidence []*DisputeEvidence `json:"evidence,omitempty" url:"evidence,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The pagination cursor to be used in a subsequent request.
	// If unset, this is the final response. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListDisputeEvidenceResponse) GetEvidence() []*DisputeEvidence {
	if l == nil {
		return nil
	}
	return l.Evidence
}

func (l *ListDisputeEvidenceResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListDisputeEvidenceResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListDisputeEvidenceResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListDisputeEvidenceResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListDisputeEvidenceResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListDisputeEvidenceResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListDisputeEvidenceResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `EmployeeWage` objects. The response contains
// a set of `EmployeeWage` objects.
type ListEmployeeWagesResponse struct {
	// A page of `EmployeeWage` results.
	EmployeeWages []*EmployeeWage `json:"employee_wages,omitempty" url:"employee_wages,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `EmployeeWage` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListEmployeeWagesResponse) GetEmployeeWages() []*EmployeeWage {
	if l == nil {
		return nil
	}
	return l.EmployeeWages
}

func (l *ListEmployeeWagesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListEmployeeWagesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListEmployeeWagesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListEmployeeWagesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmployeeWagesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmployeeWagesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmployeeWagesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A response that contains a list of `GiftCardActivity` objects. If the request resulted in errors,
// the response contains a set of `Error` objects.
type ListGiftCardActivitiesResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested gift card activities or an empty object if none are found.
	GiftCardActivities []*GiftCardActivity `json:"gift_card_activities,omitempty" url:"gift_card_activities,omitempty"`
	// When a response is truncated, it includes a cursor that you can use in a
	// subsequent request to retrieve the next set of activities. If a cursor is not present, this is
	// the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListGiftCardActivitiesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListGiftCardActivitiesResponse) GetGiftCardActivities() []*GiftCardActivity {
	if l == nil {
		return nil
	}
	return l.GiftCardActivities
}

func (l *ListGiftCardActivitiesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListGiftCardActivitiesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListGiftCardActivitiesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListGiftCardActivitiesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListGiftCardActivitiesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListGiftCardActivitiesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListLocationBookingProfilesResponse struct {
	// The list of a seller's location booking profiles.
	LocationBookingProfiles []*LocationBookingProfile `json:"location_booking_profiles,omitempty" url:"location_booking_profiles,omitempty"`
	// The pagination cursor to be used in the subsequent request to get the next page of the results. Stop retrieving the next page of the results when the cursor is not set.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListLocationBookingProfilesResponse) GetLocationBookingProfiles() []*LocationBookingProfile {
	if l == nil {
		return nil
	}
	return l.LocationBookingProfiles
}

func (l *ListLocationBookingProfilesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListLocationBookingProfilesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListLocationBookingProfilesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationBookingProfilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationBookingProfilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationBookingProfilesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationBookingProfilesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLocationCustomAttributeDefinitions](api-endpoint:LocationCustomAttributes-ListLocationCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListLocationCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListLocationCustomAttributeDefinitionsResponse) GetCustomAttributeDefinitions() []*CustomAttributeDefinition {
	if l == nil {
		return nil
	}
	return l.CustomAttributeDefinitions
}

func (l *ListLocationCustomAttributeDefinitionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListLocationCustomAttributeDefinitionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListLocationCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationCustomAttributeDefinitionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationCustomAttributeDefinitionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLocationCustomAttributes](api-endpoint:LocationCustomAttributes-ListLocationCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListLocationCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListLocationCustomAttributesResponse) GetCustomAttributes() []*CustomAttribute {
	if l == nil {
		return nil
	}
	return l.CustomAttributes
}

func (l *ListLocationCustomAttributesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListLocationCustomAttributesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListLocationCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationCustomAttributesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// A response that contains all loyalty programs.
type ListLoyaltyProgramsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// A list of `LoyaltyProgram` for the merchant.
	Programs []*LoyaltyProgram `json:"programs,omitempty" url:"programs,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListLoyaltyProgramsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListLoyaltyProgramsResponse) GetPrograms() []*LoyaltyProgram {
	if l == nil {
		return nil
	}
	return l.Programs
}

func (l *ListLoyaltyProgramsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyProgramsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyProgramsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyProgramsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyProgramsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListLoyaltyPromotions](api-endpoint:Loyalty-ListLoyaltyPromotions) response.
// One of `loyalty_promotions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `loyalty_promotions`.
type ListLoyaltyPromotionsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The retrieved loyalty promotions.
	LoyaltyPromotions []*LoyaltyPromotion `json:"loyalty_promotions,omitempty" url:"loyalty_promotions,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListLoyaltyPromotionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListLoyaltyPromotionsResponse) GetLoyaltyPromotions() []*LoyaltyPromotion {
	if l == nil {
		return nil
	}
	return l.LoyaltyPromotions
}

func (l *ListLoyaltyPromotionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListLoyaltyPromotionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLoyaltyPromotionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLoyaltyPromotionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLoyaltyPromotionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLoyaltyPromotionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListMerchantCustomAttributeDefinitions](api-endpoint:MerchantCustomAttributes-ListMerchantCustomAttributeDefinitions) response.
// Either `custom_attribute_definitions`, an empty object, or `errors` is present in the response.
// If additional results are available, the `cursor` field is also present along with `custom_attribute_definitions`.
type ListMerchantCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found,
	// Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions,omitempty" url:"custom_attribute_definitions,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of
	// results for your original request. This field is present only if the request succeeded and
	// additional results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) GetCustomAttributeDefinitions() []*CustomAttributeDefinition {
	if l == nil {
		return nil
	}
	return l.CustomAttributeDefinitions
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMerchantCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMerchantCustomAttributeDefinitionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMerchantCustomAttributeDefinitionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a [ListMerchantCustomAttributes](api-endpoint:MerchantCustomAttributes-ListMerchantCustomAttributes) response.
// Either `custom_attributes`, an empty object, or `errors` is present in the response. If additional
// results are available, the `cursor` field is also present along with `custom_attributes`.
type ListMerchantCustomAttributesResponse struct {
	// The retrieved custom attributes. If `with_definitions` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field of each custom attribute.
	// If no custom attributes are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to use in your next call to this endpoint to retrieve the next page of results
	// for your original request. This field is present only if the request succeeded and additional
	// results are available. For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListMerchantCustomAttributesResponse) GetCustomAttributes() []*CustomAttribute {
	if l == nil {
		return nil
	}
	return l.CustomAttributes
}

func (l *ListMerchantCustomAttributesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListMerchantCustomAttributesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListMerchantCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListMerchantCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListMerchantCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListMerchantCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListMerchantCustomAttributesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a response from listing order custom attribute definitions.
type ListOrderCustomAttributeDefinitionsResponse struct {
	// The retrieved custom attribute definitions. If no custom attribute definitions are found, Square returns an empty object (`{}`).
	CustomAttributeDefinitions []*CustomAttributeDefinition `json:"custom_attribute_definitions" url:"custom_attribute_definitions"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of results for your original request.
	// This field is present only if the request succeeded and additional results are available.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListOrderCustomAttributeDefinitionsResponse) GetCustomAttributeDefinitions() []*CustomAttributeDefinition {
	if l == nil {
		return nil
	}
	return l.CustomAttributeDefinitions
}

func (l *ListOrderCustomAttributeDefinitionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListOrderCustomAttributeDefinitionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListOrderCustomAttributeDefinitionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListOrderCustomAttributeDefinitionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListOrderCustomAttributeDefinitionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListOrderCustomAttributeDefinitionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListOrderCustomAttributeDefinitionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a response from listing order custom attributes.
type ListOrderCustomAttributesResponse struct {
	// The retrieved custom attributes. If no custom attribute are found, Square returns an empty object (`{}`).
	CustomAttributes []*CustomAttribute `json:"custom_attributes,omitempty" url:"custom_attributes,omitempty"`
	// The cursor to provide in your next call to this endpoint to retrieve the next page of results for your original request.
	// This field is present only if the request succeeded and additional results are available.
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListOrderCustomAttributesResponse) GetCustomAttributes() []*CustomAttribute {
	if l == nil {
		return nil
	}
	return l.CustomAttributes
}

func (l *ListOrderCustomAttributesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListOrderCustomAttributesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListOrderCustomAttributesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListOrderCustomAttributesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListOrderCustomAttributesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListOrderCustomAttributesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListOrderCustomAttributesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPaymentLinksResponse struct {
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of payment links.
	PaymentLinks []*PaymentLink `json:"payment_links,omitempty" url:"payment_links,omitempty"`
	//	When a response is truncated, it includes a cursor that you can use in a subsequent request
	//
	// to retrieve the next set of gift cards. If a cursor is not present, this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListPaymentLinksResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListPaymentLinksResponse) GetPaymentLinks() []*PaymentLink {
	if l == nil {
		return nil
	}
	return l.PaymentLinks
}

func (l *ListPaymentLinksResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListPaymentLinksResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentLinksResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentLinksResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentLinksResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentLinksResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListTeamMemberBookingProfilesResponse struct {
	// The list of team member booking profiles. The results are returned in the ascending order of the time
	// when the team member booking profiles were last updated. Multiple booking profiles updated at the same time
	// are further sorted in the ascending order of their IDs.
	TeamMemberBookingProfiles []*TeamMemberBookingProfile `json:"team_member_booking_profiles,omitempty" url:"team_member_booking_profiles,omitempty"`
	// The pagination cursor to be used in the subsequent request to get the next page of the results. Stop retrieving the next page of the results when the cursor is not set.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListTeamMemberBookingProfilesResponse) GetTeamMemberBookingProfiles() []*TeamMemberBookingProfile {
	if l == nil {
		return nil
	}
	return l.TeamMemberBookingProfiles
}

func (l *ListTeamMemberBookingProfilesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListTeamMemberBookingProfilesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListTeamMemberBookingProfilesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberBookingProfilesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberBookingProfilesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberBookingProfilesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberBookingProfilesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `TeamMemberWage` objects. The response contains
// a set of `TeamMemberWage` objects.
type ListTeamMemberWagesResponse struct {
	// A page of `TeamMemberWage` results.
	TeamMemberWages []*TeamMemberWage `json:"team_member_wages,omitempty" url:"team_member_wages,omitempty"`
	// The value supplied in the subsequent request to fetch the next page
	// of `TeamMemberWage` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListTeamMemberWagesResponse) GetTeamMemberWages() []*TeamMemberWage {
	if l == nil {
		return nil
	}
	return l.TeamMemberWages
}

func (l *ListTeamMemberWagesResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListTeamMemberWagesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListTeamMemberWagesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTeamMemberWagesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTeamMemberWagesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTeamMemberWagesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTeamMemberWagesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListTransactions](api-endpoint:Transactions-ListTransactions) endpoint.
//
// One of `errors` or `transactions` is present in a given response (never both).
type ListTransactionsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// An array of transactions that match your query.
	Transactions []*Transaction `json:"transactions,omitempty" url:"transactions,omitempty"`
	// A pagination cursor for retrieving the next set of results,
	// if any remain. Provide this value as the `cursor` parameter in a subsequent
	// request to this endpoint.
	//
	// See [Paginating results](https://developer.squareup.com/docs/working-with-apis/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListTransactionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListTransactionsResponse) GetTransactions() []*Transaction {
	if l == nil {
		return nil
	}
	return l.Transactions
}

func (l *ListTransactionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListTransactionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListTransactionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListTransactionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListTransactionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListTransactionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListWebhookEventTypes](api-endpoint:WebhookSubscriptions-ListWebhookEventTypes) endpoint.
//
// Note: if there are errors processing the request, the event types field will not be
// present.
type ListWebhookEventTypesResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of event types.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// Contains the metadata of a webhook event type. For more information, see [EventTypeMetadata](entity:EventTypeMetadata).
	Metadata []*EventTypeMetadata `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListWebhookEventTypesResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListWebhookEventTypesResponse) GetEventTypes() []string {
	if l == nil {
		return nil
	}
	return l.EventTypes
}

func (l *ListWebhookEventTypesResponse) GetMetadata() []*EventTypeMetadata {
	if l == nil {
		return nil
	}
	return l.Metadata
}

func (l *ListWebhookEventTypesResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookEventTypesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookEventTypesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookEventTypesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookEventTypesResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the fields that are included in the response body of
// a request to the [ListWebhookSubscriptions](api-endpoint:WebhookSubscriptions-ListWebhookSubscriptions) endpoint.
//
// Note: if there are errors processing the request, the subscriptions field will not be
// present.
type ListWebhookSubscriptionsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested list of [Subscription](entity:WebhookSubscription)s.
	Subscriptions []*WebhookSubscription `json:"subscriptions,omitempty" url:"subscriptions,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListWebhookSubscriptionsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListWebhookSubscriptionsResponse) GetSubscriptions() []*WebhookSubscription {
	if l == nil {
		return nil
	}
	return l.Subscriptions
}

func (l *ListWebhookSubscriptionsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListWebhookSubscriptionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWebhookSubscriptionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWebhookSubscriptionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWebhookSubscriptionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWebhookSubscriptionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to a request for a set of `WorkweekConfig` objects. The response contains
// the requested `WorkweekConfig` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type ListWorkweekConfigsResponse struct {
	// A page of `WorkweekConfig` results.
	WorkweekConfigs []*WorkweekConfig `json:"workweek_configs,omitempty" url:"workweek_configs,omitempty"`
	// The value supplied in the subsequent request to fetch the next page of
	// `WorkweekConfig` results.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListWorkweekConfigsResponse) GetWorkweekConfigs() []*WorkweekConfig {
	if l == nil {
		return nil
	}
	return l.WorkweekConfigs
}

func (l *ListWorkweekConfigsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListWorkweekConfigsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListWorkweekConfigsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListWorkweekConfigsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListWorkweekConfigsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListWorkweekConfigsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListWorkweekConfigsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The booking profile of a seller's location, including the location's ID and whether the location is enabled for online booking.
type LocationBookingProfile struct {
	// The ID of the [location](entity:Location).
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Url for the online booking site for this location.
	BookingSiteURL *string `json:"booking_site_url,omitempty" url:"booking_site_url,omitempty"`
	// Indicates whether the location is enabled for online booking.
	OnlineBookingEnabled *bool `json:"online_booking_enabled,omitempty" url:"online_booking_enabled,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationBookingProfile) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LocationBookingProfile) GetBookingSiteURL() *string {
	if l == nil {
		return nil
	}
	return l.BookingSiteURL
}

func (l *LocationBookingProfile) GetOnlineBookingEnabled() *bool {
	if l == nil {
		return nil
	}
	return l.OnlineBookingEnabled
}

func (l *LocationBookingProfile) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationBookingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationBookingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationBookingProfile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationBookingProfile) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Location](entity:Location) is created.
type LocationCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the [Location](entity:Location) associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"location.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LocationCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCreatedEvent) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LocationCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCreatedEvent) GetData() *LocationCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LocationCreatedEventData struct {
	// Name of the affected object’s type, `"location"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated [Location](entity:Location).
	ID *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LocationCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute definition](entity:CustomAttributeDefinition)
// is created by the subscribing application.
type LocationCustomAttributeDefinitionOwnedCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute_definition.owned.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeDefinitionOwnedCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeDefinitionOwnedCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeDefinitionOwnedCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is deleted. A custom attribute definition can only be deleted by
// the application that created it.
type LocationCustomAttributeDefinitionOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute_definition.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeDefinitionOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeDefinitionOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeDefinitionOwnedDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute definition](entity:CustomAttributeDefinition)
// created by the subscribing application is updated. A custom attribute definition can only be updated
// by the application that created it.
type LocationCustomAttributeDefinitionOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute_definition.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeDefinitionOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeDefinitionOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeDefinitionOwnedUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is created. A notification is sent when your application
// creates a custom attribute definition or another application creates a custom attribute definition whose
// `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type LocationCustomAttributeDefinitionVisibleCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute_definition.visible.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeDefinitionVisibleCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeDefinitionVisibleCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeDefinitionVisibleCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is deleted. A custom attribute definition can only
// be deleted by the application that created it. A notification is sent when your application deletes
// a custom attribute definition or when another application deletes a custom attribute definition whose
// `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type LocationCustomAttributeDefinitionVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute_definition.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeDefinitionVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeDefinitionVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeDefinitionVisibleDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is updated. A custom attribute definition can only be updated
// by the application that created it. A notification is sent when your application updates a custom attribute
// definition or when another application updates a custom attribute definition whose `visibility` is
// `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type LocationCustomAttributeDefinitionVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute_definition.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeDefinitionVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeDefinitionVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeDefinitionVisibleUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute](entity:CustomAttribute)
// owned by the subscribing application is deleted. Custom attributes are owned by the
// application that created the corresponding [custom attribute definition](entity:CustomAttributeDefinition).
// Custom attributes whose `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application.
type LocationCustomAttributeOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeOwnedDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeOwnedDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeOwnedDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeOwnedDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeOwnedDeletedEvent) GetData() *CustomAttributeEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeOwnedDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute](entity:CustomAttribute) owned by the
// subscribing application is created or updated. Custom attributes are owned by the application that created
// the corresponding [custom attribute definition](entity:CustomAttributeDefinition). Custom attributes whose
// `visibility` is `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application.
type LocationCustomAttributeOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) GetData() *CustomAttributeEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeOwnedUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute](entity:CustomAttribute) that is visible to the
// subscribing application is deleted. A notification is sent when:
// - Your application deletes a custom attribute owned by your application, regardless of the `visibility` setting.
// - Any application deletes a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY`
// or `VISIBILITY_READ_WRITE_VALUES`.
//
// Custom attributes set to `VISIBILITY_READ_WRITE_VALUES` can be deleted by any application, but those set to
// `VISIBILITY_READ_ONLY` or `VISIBILITY_HIDDEN` can only be deleted by the owner. Custom attributes are owned
// by the application that created the corresponding [custom attribute definition](entity:CustomAttributeDefinition).
type LocationCustomAttributeVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeVisibleDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeVisibleDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeVisibleDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeVisibleDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeVisibleDeletedEvent) GetData() *CustomAttributeEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeVisibleDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a location [custom attribute](entity:CustomAttribute) that is visible
// to the subscribing application is created or updated. A notification is sent when:
// - Your application creates or updates a custom attribute owned by your application, regardless of the `visibility` setting.
// - Any application creates or updates a custom attribute whose `visibility` is `VISIBILITY_READ_ONLY`
// or `VISIBILITY_READ_WRITE_VALUES`.
//
// Custom attributes set to `VISIBILITY_READ_WRITE_VALUES` can be created or updated by any application, but those set to
// `VISIBILITY_READ_ONLY` or `VISIBILITY_HIDDEN` can only be created or updated by the owner. Custom attributes are owned
// by the application that created the corresponding [custom attribute definition](entity:CustomAttributeDefinition).
type LocationCustomAttributeVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"location.custom_attribute.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) GetData() *CustomAttributeEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationCustomAttributeVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationCustomAttributeVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationCustomAttributeVisibleUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when online checkout location settings are updated
type LocationSettingsUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"online_checkout.location_settings.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LocationSettingsUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationSettingsUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationSettingsUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationSettingsUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationSettingsUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationSettingsUpdatedEvent) GetData() *LocationSettingsUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationSettingsUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationSettingsUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationSettingsUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationSettingsUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationSettingsUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LocationSettingsUpdatedEventData struct {
	// Name of the updated object’s type, `"online_checkout.location_settings"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated location settings.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated location settings.
	Object *LocationSettingsUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationSettingsUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationSettingsUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LocationSettingsUpdatedEventData) GetObject() *LocationSettingsUpdatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LocationSettingsUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationSettingsUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationSettingsUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationSettingsUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationSettingsUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LocationSettingsUpdatedEventObject struct {
	// The updated location settings.
	LocationSettings *CheckoutLocationSettings `json:"location_settings,omitempty" url:"location_settings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationSettingsUpdatedEventObject) GetLocationSettings() *CheckoutLocationSettings {
	if l == nil {
		return nil
	}
	return l.LocationSettings
}

func (l *LocationSettingsUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationSettingsUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationSettingsUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationSettingsUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationSettingsUpdatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [Location](entity:Location) is updated.
type LocationUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the [Location](entity:Location) associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"location.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *LocationUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LocationUpdatedEvent) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LocationUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LocationUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LocationUpdatedEvent) GetData() *LocationUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LocationUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LocationUpdatedEventData struct {
	// Name of the affected object’s type, `"location"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated [Location](entity:Location).
	ID *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LocationUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LocationUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LocationUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LocationUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LocationUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LocationUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LocationUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes a loyalty account in a [loyalty program](entity:LoyaltyProgram). For more information, see
// [Create and Retrieve Loyalty Accounts](https://developer.squareup.com/docs/loyalty-api/loyalty-accounts).
type LoyaltyAccount struct {
	// The Square-assigned ID of the loyalty account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram) to which the account belongs.
	ProgramID string `json:"program_id" url:"program_id"`
	// The available point balance in the loyalty account. If points are scheduled to expire, they are listed in the `expiring_point_deadlines` field.
	//
	// Your application should be able to handle loyalty accounts that have a negative point balance (`balance` is less than 0). This might occur if a seller makes a manual adjustment or as a result of a refund or exchange.
	Balance *int `json:"balance,omitempty" url:"balance,omitempty"`
	// The total points accrued during the lifetime of the account.
	LifetimePoints *int `json:"lifetime_points,omitempty" url:"lifetime_points,omitempty"`
	// The Square-assigned ID of the [customer](entity:Customer) that is associated with the account.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The timestamp when the buyer joined the loyalty program, in RFC 3339 format. This field is used to display the **Enrolled On** or **Member Since** date in first-party Square products.
	//
	// If this field is not set in a `CreateLoyaltyAccount` request, Square populates it after the buyer's first action on their account
	// (when `AccumulateLoyaltyPoints` or `CreateLoyaltyReward` is called). In first-party flows, Square populates the field when the buyer agrees to the terms of service on Square Point of Sale.
	//
	// If this field is set in a `CreateLoyaltyAccount` request, it is meant to be used when there is a loyalty migration from another system and into Square.
	// In that case, the timestamp can reflect when the buyer originally enrolled in the previous system. It may represent a current or past date, but cannot be set in the future.
	// Note: Setting this field in this scenario does not, by itself, impact the first-party enrollment flow on Square Point of Sale.
	EnrolledAt *string `json:"enrolled_at,omitempty" url:"enrolled_at,omitempty"`
	// The timestamp when the loyalty account was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the loyalty account was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The mapping that associates the loyalty account with a buyer. Currently,
	// a loyalty account can only be mapped to a buyer by phone number.
	//
	// To create a loyalty account, you must specify the `mapping` field, with the buyer's phone number
	// in the `phone_number` field.
	Mapping *LoyaltyAccountMapping `json:"mapping,omitempty" url:"mapping,omitempty"`
	// The schedule for when points expire in the loyalty account balance. This field is present only if the account has points that are scheduled to expire.
	//
	// The total number of points in this field equals the number of points in the `balance` field.
	ExpiringPointDeadlines []*LoyaltyAccountExpiringPointDeadline `json:"expiring_point_deadlines,omitempty" url:"expiring_point_deadlines,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccount) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyAccount) GetProgramID() string {
	if l == nil {
		return ""
	}
	return l.ProgramID
}

func (l *LoyaltyAccount) GetBalance() *int {
	if l == nil {
		return nil
	}
	return l.Balance
}

func (l *LoyaltyAccount) GetLifetimePoints() *int {
	if l == nil {
		return nil
	}
	return l.LifetimePoints
}

func (l *LoyaltyAccount) GetCustomerID() *string {
	if l == nil {
		return nil
	}
	return l.CustomerID
}

func (l *LoyaltyAccount) GetEnrolledAt() *string {
	if l == nil {
		return nil
	}
	return l.EnrolledAt
}

func (l *LoyaltyAccount) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyAccount) GetUpdatedAt() *string {
	if l == nil {
		return nil
	}
	return l.UpdatedAt
}

func (l *LoyaltyAccount) GetMapping() *LoyaltyAccountMapping {
	if l == nil {
		return nil
	}
	return l.Mapping
}

func (l *LoyaltyAccount) GetExpiringPointDeadlines() []*LoyaltyAccountExpiringPointDeadline {
	if l == nil {
		return nil
	}
	return l.ExpiringPointDeadlines
}

func (l *LoyaltyAccount) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccount) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty account](entity:LoyaltyAccount) is created.
type LoyaltyAccountCreatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.account.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyAccountCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyAccountCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyAccountCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyAccountCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyAccountCreatedEvent) GetData() *LoyaltyAccountCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyAccountCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.account.created` event.
type LoyaltyAccountCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_account`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new loyalty account.
	Object *LoyaltyAccountCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyAccountCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyAccountCreatedEventData) GetObject() *LoyaltyAccountCreatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyAccountCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoyaltyAccountCreatedEventObject struct {
	// The loyalty account that was created.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountCreatedEventObject) GetLoyaltyAccount() *LoyaltyAccount {
	if l == nil {
		return nil
	}
	return l.LoyaltyAccount
}

func (l *LoyaltyAccountCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountCreatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty account](entity:LoyaltyAccount) is deleted.
type LoyaltyAccountDeletedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.account.deleted`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyAccountDeletedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountDeletedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyAccountDeletedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyAccountDeletedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyAccountDeletedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyAccountDeletedEvent) GetData() *LoyaltyAccountDeletedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyAccountDeletedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountDeletedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.account.deleted` event.
type LoyaltyAccountDeletedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_account`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the loyalty account that was deleted.
	Object *LoyaltyAccountDeletedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountDeletedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyAccountDeletedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyAccountDeletedEventData) GetObject() *LoyaltyAccountDeletedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyAccountDeletedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountDeletedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountDeletedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountDeletedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountDeletedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoyaltyAccountDeletedEventObject struct {
	// The loyalty account that was deleted.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountDeletedEventObject) GetLoyaltyAccount() *LoyaltyAccount {
	if l == nil {
		return nil
	}
	return l.LoyaltyAccount
}

func (l *LoyaltyAccountDeletedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountDeletedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountDeletedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountDeletedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountDeletedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a set of points for a loyalty account that are scheduled to expire on a specific date.
type LoyaltyAccountExpiringPointDeadline struct {
	// The number of points scheduled to expire at the `expires_at` timestamp.
	Points int `json:"points" url:"points"`
	// The timestamp of when the points are scheduled to expire, in RFC 3339 format.
	ExpiresAt string `json:"expires_at" url:"expires_at"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountExpiringPointDeadline) GetPoints() int {
	if l == nil {
		return 0
	}
	return l.Points
}

func (l *LoyaltyAccountExpiringPointDeadline) GetExpiresAt() string {
	if l == nil {
		return ""
	}
	return l.ExpiresAt
}

func (l *LoyaltyAccountExpiringPointDeadline) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountExpiringPointDeadline) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountExpiringPointDeadline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountExpiringPointDeadline(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountExpiringPointDeadline) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the mapping that associates a loyalty account with a buyer.
//
// Currently, a loyalty account can only be mapped to a buyer by phone number. For more information, see
// [Loyalty Overview](https://developer.squareup.com/docs/loyalty/overview).
type LoyaltyAccountMapping struct {
	// The Square-assigned ID of the mapping.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The timestamp when the mapping was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The phone number of the buyer, in E.164 format. For example, "+14155551111".
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountMapping) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyAccountMapping) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyAccountMapping) GetPhoneNumber() *string {
	if l == nil {
		return nil
	}
	return l.PhoneNumber
}

func (l *LoyaltyAccountMapping) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountMapping(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountMapping) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The type of mapping.
type LoyaltyAccountMappingType = string

// Published when a [loyalty account](entity:LoyaltyAccount) is updated.
type LoyaltyAccountUpdatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.account.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyAccountUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyAccountUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyAccountUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyAccountUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyAccountUpdatedEvent) GetData() *LoyaltyAccountUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyAccountUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.account.updated` event.
type LoyaltyAccountUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_account`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty account.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the loyalty account that was updated.
	Object *LoyaltyAccountUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyAccountUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyAccountUpdatedEventData) GetObject() *LoyaltyAccountUpdatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyAccountUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoyaltyAccountUpdatedEventObject struct {
	// The loyalty account that was updated.
	LoyaltyAccount *LoyaltyAccount `json:"loyalty_account,omitempty" url:"loyalty_account,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyAccountUpdatedEventObject) GetLoyaltyAccount() *LoyaltyAccount {
	if l == nil {
		return nil
	}
	return l.LoyaltyAccount
}

func (l *LoyaltyAccountUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyAccountUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyAccountUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyAccountUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyAccountUpdatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides information about a loyalty event.
// For more information, see [Search for Balance-Changing Loyalty Events](https://developer.squareup.com/docs/loyalty-api/loyalty-events).
type LoyaltyEvent struct {
	// The Square-assigned ID of the loyalty event.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The type of the loyalty event.
	// See [LoyaltyEventType](#type-loyaltyeventtype) for possible values
	Type LoyaltyEventType `json:"type" url:"type"`
	// The timestamp when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
	AccumulatePoints *LoyaltyEventAccumulatePoints `json:"accumulate_points,omitempty" url:"accumulate_points,omitempty"`
	// Provides metadata when the event `type` is `CREATE_REWARD`.
	CreateReward *LoyaltyEventCreateReward `json:"create_reward,omitempty" url:"create_reward,omitempty"`
	// Provides metadata when the event `type` is `REDEEM_REWARD`.
	RedeemReward *LoyaltyEventRedeemReward `json:"redeem_reward,omitempty" url:"redeem_reward,omitempty"`
	// Provides metadata when the event `type` is `DELETE_REWARD`.
	DeleteReward *LoyaltyEventDeleteReward `json:"delete_reward,omitempty" url:"delete_reward,omitempty"`
	// Provides metadata when the event `type` is `ADJUST_POINTS`.
	AdjustPoints *LoyaltyEventAdjustPoints `json:"adjust_points,omitempty" url:"adjust_points,omitempty"`
	// The ID of the [loyalty account](entity:LoyaltyAccount) associated with the event.
	LoyaltyAccountID *string `json:"loyalty_account_id,omitempty" url:"loyalty_account_id,omitempty"`
	// The ID of the [location](entity:Location) where the event occurred.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Defines whether the event was generated by the Square Point of Sale.
	// See [LoyaltyEventSource](#type-loyaltyeventsource) for possible values
	Source LoyaltyEventSource `json:"source" url:"source"`
	// Provides metadata when the event `type` is `EXPIRE_POINTS`.
	ExpirePoints *LoyaltyEventExpirePoints `json:"expire_points,omitempty" url:"expire_points,omitempty"`
	// Provides metadata when the event `type` is `OTHER`.
	OtherEvent *LoyaltyEventOther `json:"other_event,omitempty" url:"other_event,omitempty"`
	// Provides metadata when the event `type` is `ACCUMULATE_PROMOTION_POINTS`.
	AccumulatePromotionPoints *LoyaltyEventAccumulatePromotionPoints `json:"accumulate_promotion_points,omitempty" url:"accumulate_promotion_points,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEvent) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyEvent) GetType() LoyaltyEventType {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *LoyaltyEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyEvent) GetAccumulatePoints() *LoyaltyEventAccumulatePoints {
	if l == nil {
		return nil
	}
	return l.AccumulatePoints
}

func (l *LoyaltyEvent) GetCreateReward() *LoyaltyEventCreateReward {
	if l == nil {
		return nil
	}
	return l.CreateReward
}

func (l *LoyaltyEvent) GetRedeemReward() *LoyaltyEventRedeemReward {
	if l == nil {
		return nil
	}
	return l.RedeemReward
}

func (l *LoyaltyEvent) GetDeleteReward() *LoyaltyEventDeleteReward {
	if l == nil {
		return nil
	}
	return l.DeleteReward
}

func (l *LoyaltyEvent) GetAdjustPoints() *LoyaltyEventAdjustPoints {
	if l == nil {
		return nil
	}
	return l.AdjustPoints
}

func (l *LoyaltyEvent) GetLoyaltyAccountID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyAccountID
}

func (l *LoyaltyEvent) GetLocationID() *string {
	if l == nil {
		return nil
	}
	return l.LocationID
}

func (l *LoyaltyEvent) GetSource() LoyaltyEventSource {
	if l == nil {
		return ""
	}
	return l.Source
}

func (l *LoyaltyEvent) GetExpirePoints() *LoyaltyEventExpirePoints {
	if l == nil {
		return nil
	}
	return l.ExpirePoints
}

func (l *LoyaltyEvent) GetOtherEvent() *LoyaltyEventOther {
	if l == nil {
		return nil
	}
	return l.OtherEvent
}

func (l *LoyaltyEvent) GetAccumulatePromotionPoints() *LoyaltyEventAccumulatePromotionPoints {
	if l == nil {
		return nil
	}
	return l.AccumulatePromotionPoints
}

func (l *LoyaltyEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ACCUMULATE_POINTS`.
type LoyaltyEventAccumulatePoints struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points accumulated by the event.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The ID of the [order](entity:Order) for which the buyer accumulated the points.
	// This field is returned only if the Orders API is used to process orders.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventAccumulatePoints) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventAccumulatePoints) GetPoints() *int {
	if l == nil {
		return nil
	}
	return l.Points
}

func (l *LoyaltyEventAccumulatePoints) GetOrderID() *string {
	if l == nil {
		return nil
	}
	return l.OrderID
}

func (l *LoyaltyEventAccumulatePoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAccumulatePoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAccumulatePoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAccumulatePoints(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAccumulatePoints) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ACCUMULATE_PROMOTION_POINTS`.
type LoyaltyEventAccumulatePromotionPoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The Square-assigned ID of the [loyalty promotion](entity:LoyaltyPromotion).
	LoyaltyPromotionID *string `json:"loyalty_promotion_id,omitempty" url:"loyalty_promotion_id,omitempty"`
	// The number of points earned by the event.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The ID of the [order](entity:Order) for which the buyer earned the promotion points.
	// Only applications that use the Orders API to process orders can trigger this event.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventAccumulatePromotionPoints) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventAccumulatePromotionPoints) GetLoyaltyPromotionID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyPromotionID
}

func (l *LoyaltyEventAccumulatePromotionPoints) GetPoints() *int {
	if l == nil {
		return nil
	}
	return l.Points
}

func (l *LoyaltyEventAccumulatePromotionPoints) GetOrderID() *string {
	if l == nil {
		return nil
	}
	return l.OrderID
}

func (l *LoyaltyEventAccumulatePromotionPoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAccumulatePromotionPoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAccumulatePromotionPoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAccumulatePromotionPoints(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAccumulatePromotionPoints) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `ADJUST_POINTS`.
type LoyaltyEventAdjustPoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points added or removed.
	Points int `json:"points" url:"points"`
	// The reason for the adjustment of points.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventAdjustPoints) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventAdjustPoints) GetPoints() int {
	if l == nil {
		return 0
	}
	return l.Points
}

func (l *LoyaltyEventAdjustPoints) GetReason() *string {
	if l == nil {
		return nil
	}
	return l.Reason
}

func (l *LoyaltyEventAdjustPoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventAdjustPoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventAdjustPoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventAdjustPoints(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventAdjustPoints) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `CREATE_REWARD`.
type LoyaltyEventCreateReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The Square-assigned ID of the created [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardID *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The loyalty points used to create the reward.
	Points *int `json:"points,omitempty" url:"points,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventCreateReward) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventCreateReward) GetRewardID() *string {
	if l == nil {
		return nil
	}
	return l.RewardID
}

func (l *LoyaltyEventCreateReward) GetPoints() *int {
	if l == nil {
		return nil
	}
	return l.Points
}

func (l *LoyaltyEventCreateReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreateReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreateReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreateReward(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreateReward) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty event](entity:LoyaltyEvent) is created.
type LoyaltyEventCreatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.event.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyEventCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyEventCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyEventCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyEventCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyEventCreatedEvent) GetData() *LoyaltyEventCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyEventCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.event.created` event.
type LoyaltyEventCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_event`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected loyalty event.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the new loyalty event.
	Object *LoyaltyEventCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyEventCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyEventCreatedEventData) GetObject() *LoyaltyEventCreatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyEventCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoyaltyEventCreatedEventObject struct {
	// The loyalty event that was created.
	LoyaltyEvent *LoyaltyEvent `json:"loyalty_event,omitempty" url:"loyalty_event,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventCreatedEventObject) GetLoyaltyEvent() *LoyaltyEvent {
	if l == nil {
		return nil
	}
	return l.LoyaltyEvent
}

func (l *LoyaltyEventCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventCreatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `DELETE_REWARD`.
type LoyaltyEventDeleteReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The ID of the deleted [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardID *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The number of points returned to the loyalty account.
	Points *int `json:"points,omitempty" url:"points,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventDeleteReward) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventDeleteReward) GetRewardID() *string {
	if l == nil {
		return nil
	}
	return l.RewardID
}

func (l *LoyaltyEventDeleteReward) GetPoints() *int {
	if l == nil {
		return nil
	}
	return l.Points
}

func (l *LoyaltyEventDeleteReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventDeleteReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventDeleteReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventDeleteReward(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventDeleteReward) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `EXPIRE_POINTS`.
type LoyaltyEventExpirePoints struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points expired.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventExpirePoints) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventExpirePoints) GetPoints() int {
	if l == nil {
		return 0
	}
	return l.Points
}

func (l *LoyaltyEventExpirePoints) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventExpirePoints) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventExpirePoints
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventExpirePoints(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventExpirePoints) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `OTHER`.
type LoyaltyEventOther struct {
	// The Square-assigned ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The number of points added or removed.
	Points int `json:"points" url:"points"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventOther) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventOther) GetPoints() int {
	if l == nil {
		return 0
	}
	return l.Points
}

func (l *LoyaltyEventOther) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventOther) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventOther
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventOther(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventOther) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Provides metadata when the event `type` is `REDEEM_REWARD`.
type LoyaltyEventRedeemReward struct {
	// The ID of the [loyalty program](entity:LoyaltyProgram).
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The ID of the redeemed [loyalty reward](entity:LoyaltyReward).
	// This field is returned only if the event source is `LOYALTY_API`.
	RewardID *string `json:"reward_id,omitempty" url:"reward_id,omitempty"`
	// The ID of the [order](entity:Order) that redeemed the reward.
	// This field is returned only if the Orders API is used to process orders.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyEventRedeemReward) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyEventRedeemReward) GetRewardID() *string {
	if l == nil {
		return nil
	}
	return l.RewardID
}

func (l *LoyaltyEventRedeemReward) GetOrderID() *string {
	if l == nil {
		return nil
	}
	return l.OrderID
}

func (l *LoyaltyEventRedeemReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyEventRedeemReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyEventRedeemReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyEventRedeemReward(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyEventRedeemReward) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines whether the event was generated by the Square Point of Sale.
type LoyaltyEventSource string

const (
	LoyaltyEventSourceSquare     LoyaltyEventSource = "SQUARE"
	LoyaltyEventSourceLoyaltyAPI LoyaltyEventSource = "LOYALTY_API"
)

func NewLoyaltyEventSourceFromString(s string) (LoyaltyEventSource, error) {
	switch s {
	case "SQUARE":
		return LoyaltyEventSourceSquare, nil
	case "LOYALTY_API":
		return LoyaltyEventSourceLoyaltyAPI, nil
	}
	var t LoyaltyEventSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyEventSource) Ptr() *LoyaltyEventSource {
	return &l
}

// The type of the loyalty event.
type LoyaltyEventType string

const (
	LoyaltyEventTypeAccumulatePoints          LoyaltyEventType = "ACCUMULATE_POINTS"
	LoyaltyEventTypeCreateReward              LoyaltyEventType = "CREATE_REWARD"
	LoyaltyEventTypeRedeemReward              LoyaltyEventType = "REDEEM_REWARD"
	LoyaltyEventTypeDeleteReward              LoyaltyEventType = "DELETE_REWARD"
	LoyaltyEventTypeAdjustPoints              LoyaltyEventType = "ADJUST_POINTS"
	LoyaltyEventTypeExpirePoints              LoyaltyEventType = "EXPIRE_POINTS"
	LoyaltyEventTypeOther                     LoyaltyEventType = "OTHER"
	LoyaltyEventTypeAccumulatePromotionPoints LoyaltyEventType = "ACCUMULATE_PROMOTION_POINTS"
)

func NewLoyaltyEventTypeFromString(s string) (LoyaltyEventType, error) {
	switch s {
	case "ACCUMULATE_POINTS":
		return LoyaltyEventTypeAccumulatePoints, nil
	case "CREATE_REWARD":
		return LoyaltyEventTypeCreateReward, nil
	case "REDEEM_REWARD":
		return LoyaltyEventTypeRedeemReward, nil
	case "DELETE_REWARD":
		return LoyaltyEventTypeDeleteReward, nil
	case "ADJUST_POINTS":
		return LoyaltyEventTypeAdjustPoints, nil
	case "EXPIRE_POINTS":
		return LoyaltyEventTypeExpirePoints, nil
	case "OTHER":
		return LoyaltyEventTypeOther, nil
	case "ACCUMULATE_PROMOTION_POINTS":
		return LoyaltyEventTypeAccumulatePromotionPoints, nil
	}
	var t LoyaltyEventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyEventType) Ptr() *LoyaltyEventType {
	return &l
}

// Represents a Square loyalty program. Loyalty programs define how buyers can earn points and redeem points for rewards.
// Square sellers can have only one loyalty program, which is created and managed from the Seller Dashboard.
// For more information, see [Loyalty Program Overview](https://developer.squareup.com/docs/loyalty/overview).
type LoyaltyProgram struct {
	// The Square-assigned ID of the loyalty program. Updates to
	// the loyalty program do not modify the identifier.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// Whether the program is currently active.
	// See [LoyaltyProgramStatus](#type-loyaltyprogramstatus) for possible values
	Status *LoyaltyProgramStatus `json:"status,omitempty" url:"status,omitempty"`
	// The list of rewards for buyers, sorted by ascending points.
	RewardTiers []*LoyaltyProgramRewardTier `json:"reward_tiers,omitempty" url:"reward_tiers,omitempty"`
	// If present, details for how points expire.
	ExpirationPolicy *LoyaltyProgramExpirationPolicy `json:"expiration_policy,omitempty" url:"expiration_policy,omitempty"`
	// A cosmetic name for the “points” currency.
	Terminology *LoyaltyProgramTerminology `json:"terminology,omitempty" url:"terminology,omitempty"`
	// The [locations](entity:Location) at which the program is active.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// The timestamp when the program was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the reward was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Defines how buyers can earn loyalty points from the base loyalty program.
	// To check for associated [loyalty promotions](entity:LoyaltyPromotion) that enable
	// buyers to earn extra points, call [ListLoyaltyPromotions](api-endpoint:Loyalty-ListLoyaltyPromotions).
	AccrualRules []*LoyaltyProgramAccrualRule `json:"accrual_rules,omitempty" url:"accrual_rules,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgram) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyProgram) GetStatus() *LoyaltyProgramStatus {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LoyaltyProgram) GetRewardTiers() []*LoyaltyProgramRewardTier {
	if l == nil {
		return nil
	}
	return l.RewardTiers
}

func (l *LoyaltyProgram) GetExpirationPolicy() *LoyaltyProgramExpirationPolicy {
	if l == nil {
		return nil
	}
	return l.ExpirationPolicy
}

func (l *LoyaltyProgram) GetTerminology() *LoyaltyProgramTerminology {
	if l == nil {
		return nil
	}
	return l.Terminology
}

func (l *LoyaltyProgram) GetLocationIDs() []string {
	if l == nil {
		return nil
	}
	return l.LocationIDs
}

func (l *LoyaltyProgram) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyProgram) GetUpdatedAt() *string {
	if l == nil {
		return nil
	}
	return l.UpdatedAt
}

func (l *LoyaltyProgram) GetAccrualRules() []*LoyaltyProgramAccrualRule {
	if l == nil {
		return nil
	}
	return l.AccrualRules
}

func (l *LoyaltyProgram) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgram) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgram
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgram(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgram) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents an accrual rule, which defines how buyers can earn points from the base [loyalty program](entity:LoyaltyProgram).
type LoyaltyProgramAccrualRule struct {
	// The type of the accrual rule that defines how buyers can earn points.
	// See [LoyaltyProgramAccrualRuleType](#type-loyaltyprogramaccrualruletype) for possible values
	AccrualType LoyaltyProgramAccrualRuleType `json:"accrual_type" url:"accrual_type"`
	// The number of points that
	// buyers earn based on the `accrual_type`.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// Additional data for rules with the `VISIT` accrual type.
	VisitData *LoyaltyProgramAccrualRuleVisitData `json:"visit_data,omitempty" url:"visit_data,omitempty"`
	// Additional data for rules with the `SPEND` accrual type.
	SpendData *LoyaltyProgramAccrualRuleSpendData `json:"spend_data,omitempty" url:"spend_data,omitempty"`
	// Additional data for rules with the `ITEM_VARIATION` accrual type.
	ItemVariationData *LoyaltyProgramAccrualRuleItemVariationData `json:"item_variation_data,omitempty" url:"item_variation_data,omitempty"`
	// Additional data for rules with the `CATEGORY` accrual type.
	CategoryData *LoyaltyProgramAccrualRuleCategoryData `json:"category_data,omitempty" url:"category_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramAccrualRule) GetAccrualType() LoyaltyProgramAccrualRuleType {
	if l == nil {
		return ""
	}
	return l.AccrualType
}

func (l *LoyaltyProgramAccrualRule) GetPoints() *int {
	if l == nil {
		return nil
	}
	return l.Points
}

func (l *LoyaltyProgramAccrualRule) GetVisitData() *LoyaltyProgramAccrualRuleVisitData {
	if l == nil {
		return nil
	}
	return l.VisitData
}

func (l *LoyaltyProgramAccrualRule) GetSpendData() *LoyaltyProgramAccrualRuleSpendData {
	if l == nil {
		return nil
	}
	return l.SpendData
}

func (l *LoyaltyProgramAccrualRule) GetItemVariationData() *LoyaltyProgramAccrualRuleItemVariationData {
	if l == nil {
		return nil
	}
	return l.ItemVariationData
}

func (l *LoyaltyProgramAccrualRule) GetCategoryData() *LoyaltyProgramAccrualRuleCategoryData {
	if l == nil {
		return nil
	}
	return l.CategoryData
}

func (l *LoyaltyProgramAccrualRule) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRule) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRule) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `CATEGORY` accrual type.
type LoyaltyProgramAccrualRuleCategoryData struct {
	// The ID of the `CATEGORY` [catalog object](entity:CatalogObject) that buyers can purchase to earn
	// points.
	CategoryID string `json:"category_id" url:"category_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleCategoryData) GetCategoryID() string {
	if l == nil {
		return ""
	}
	return l.CategoryID
}

func (l *LoyaltyProgramAccrualRuleCategoryData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleCategoryData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleCategoryData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleCategoryData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleCategoryData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `ITEM_VARIATION` accrual type.
type LoyaltyProgramAccrualRuleItemVariationData struct {
	// The ID of the `ITEM_VARIATION` [catalog object](entity:CatalogObject) that buyers can purchase to earn
	// points.
	ItemVariationID string `json:"item_variation_id" url:"item_variation_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) GetItemVariationID() string {
	if l == nil {
		return ""
	}
	return l.ItemVariationID
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleItemVariationData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleItemVariationData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleItemVariationData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents additional data for rules with the `SPEND` accrual type.
type LoyaltyProgramAccrualRuleSpendData struct {
	// The amount that buyers must spend to earn points.
	// For example, given an "Earn 1 point for every $10 spent" accrual rule, a buyer who spends $105 earns 10 points.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// The IDs of any `CATEGORY` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded categories.
	ExcludedCategoryIDs []string `json:"excluded_category_ids,omitempty" url:"excluded_category_ids,omitempty"`
	// The IDs of any `ITEM_VARIATION` catalog objects that are excluded from points accrual.
	//
	// You can use the [BatchRetrieveCatalogObjects](api-endpoint:Catalog-BatchRetrieveCatalogObjects)
	// endpoint to retrieve information about the excluded item variations.
	ExcludedItemVariationIDs []string `json:"excluded_item_variation_ids,omitempty" url:"excluded_item_variation_ids,omitempty"`
	// Indicates how taxes should be treated when calculating the purchase amount used for points accrual.
	// See [LoyaltyProgramAccrualRuleTaxMode](#type-loyaltyprogramaccrualruletaxmode) for possible values
	TaxMode LoyaltyProgramAccrualRuleTaxMode `json:"tax_mode" url:"tax_mode"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleSpendData) GetAmountMoney() *Money {
	if l == nil {
		return nil
	}
	return l.AmountMoney
}

func (l *LoyaltyProgramAccrualRuleSpendData) GetExcludedCategoryIDs() []string {
	if l == nil {
		return nil
	}
	return l.ExcludedCategoryIDs
}

func (l *LoyaltyProgramAccrualRuleSpendData) GetExcludedItemVariationIDs() []string {
	if l == nil {
		return nil
	}
	return l.ExcludedItemVariationIDs
}

func (l *LoyaltyProgramAccrualRuleSpendData) GetTaxMode() LoyaltyProgramAccrualRuleTaxMode {
	if l == nil {
		return ""
	}
	return l.TaxMode
}

func (l *LoyaltyProgramAccrualRuleSpendData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleSpendData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleSpendData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleSpendData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleSpendData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates how taxes should be treated when calculating the purchase amount used for loyalty points accrual.
// This setting applies only to `SPEND` accrual rules or `VISIT` accrual rules that have a minimum spend requirement.
type LoyaltyProgramAccrualRuleTaxMode string

const (
	LoyaltyProgramAccrualRuleTaxModeBeforeTax LoyaltyProgramAccrualRuleTaxMode = "BEFORE_TAX"
	LoyaltyProgramAccrualRuleTaxModeAfterTax  LoyaltyProgramAccrualRuleTaxMode = "AFTER_TAX"
)

func NewLoyaltyProgramAccrualRuleTaxModeFromString(s string) (LoyaltyProgramAccrualRuleTaxMode, error) {
	switch s {
	case "BEFORE_TAX":
		return LoyaltyProgramAccrualRuleTaxModeBeforeTax, nil
	case "AFTER_TAX":
		return LoyaltyProgramAccrualRuleTaxModeAfterTax, nil
	}
	var t LoyaltyProgramAccrualRuleTaxMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramAccrualRuleTaxMode) Ptr() *LoyaltyProgramAccrualRuleTaxMode {
	return &l
}

// The type of the accrual rule that defines how buyers can earn points.
type LoyaltyProgramAccrualRuleType string

const (
	LoyaltyProgramAccrualRuleTypeVisit         LoyaltyProgramAccrualRuleType = "VISIT"
	LoyaltyProgramAccrualRuleTypeSpend         LoyaltyProgramAccrualRuleType = "SPEND"
	LoyaltyProgramAccrualRuleTypeItemVariation LoyaltyProgramAccrualRuleType = "ITEM_VARIATION"
	LoyaltyProgramAccrualRuleTypeCategory      LoyaltyProgramAccrualRuleType = "CATEGORY"
)

func NewLoyaltyProgramAccrualRuleTypeFromString(s string) (LoyaltyProgramAccrualRuleType, error) {
	switch s {
	case "VISIT":
		return LoyaltyProgramAccrualRuleTypeVisit, nil
	case "SPEND":
		return LoyaltyProgramAccrualRuleTypeSpend, nil
	case "ITEM_VARIATION":
		return LoyaltyProgramAccrualRuleTypeItemVariation, nil
	case "CATEGORY":
		return LoyaltyProgramAccrualRuleTypeCategory, nil
	}
	var t LoyaltyProgramAccrualRuleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramAccrualRuleType) Ptr() *LoyaltyProgramAccrualRuleType {
	return &l
}

// Represents additional data for rules with the `VISIT` accrual type.
type LoyaltyProgramAccrualRuleVisitData struct {
	// The minimum purchase required during the visit to quality for points.
	MinimumAmountMoney *Money `json:"minimum_amount_money,omitempty" url:"minimum_amount_money,omitempty"`
	// Indicates how taxes should be treated when calculating the purchase amount to determine whether the visit qualifies for points.
	// This setting applies only if `minimum_amount_money` is specified.
	// See [LoyaltyProgramAccrualRuleTaxMode](#type-loyaltyprogramaccrualruletaxmode) for possible values
	TaxMode LoyaltyProgramAccrualRuleTaxMode `json:"tax_mode" url:"tax_mode"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramAccrualRuleVisitData) GetMinimumAmountMoney() *Money {
	if l == nil {
		return nil
	}
	return l.MinimumAmountMoney
}

func (l *LoyaltyProgramAccrualRuleVisitData) GetTaxMode() LoyaltyProgramAccrualRuleTaxMode {
	if l == nil {
		return ""
	}
	return l.TaxMode
}

func (l *LoyaltyProgramAccrualRuleVisitData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramAccrualRuleVisitData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramAccrualRuleVisitData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramAccrualRuleVisitData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramAccrualRuleVisitData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty program](entity:LoyaltyProgram) is created.
type LoyaltyProgramCreatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.program.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyProgramCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyProgramCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyProgramCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyProgramCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyProgramCreatedEvent) GetData() *LoyaltyProgramCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyProgramCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.program.created` event.
type LoyaltyProgramCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_program`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the created loyalty program.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the loyalty program that was created.
	Object *LoyaltyProgramCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyProgramCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyProgramCreatedEventData) GetObject() *LoyaltyProgramCreatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyProgramCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// An object that contains the loyalty program associated with a `loyalty.program.created` event.
type LoyaltyProgramCreatedEventObject struct {
	// The loyalty program that was created.
	LoyaltyProgram *LoyaltyProgram `json:"loyalty_program,omitempty" url:"loyalty_program,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramCreatedEventObject) GetLoyaltyProgram() *LoyaltyProgram {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgram
}

func (l *LoyaltyProgramCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramCreatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Describes when the loyalty program expires.
type LoyaltyProgramExpirationPolicy struct {
	// The number of months before points expire, in `P[n]M` RFC 3339 duration format. For example, a value of `P12M` represents a duration of 12 months.
	// Points are valid through the last day of the month in which they are scheduled to expire. For example, with a  `P12M` duration, points earned on July 6, 2020 expire on August 1, 2021.
	ExpirationDuration string `json:"expiration_duration" url:"expiration_duration"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramExpirationPolicy) GetExpirationDuration() string {
	if l == nil {
		return ""
	}
	return l.ExpirationDuration
}

func (l *LoyaltyProgramExpirationPolicy) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramExpirationPolicy) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramExpirationPolicy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramExpirationPolicy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramExpirationPolicy) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a reward tier in a loyalty program. A reward tier defines how buyers can redeem points for a reward, such as the number of points required and the value and scope of the discount. A loyalty program can offer multiple reward tiers.
type LoyaltyProgramRewardTier struct {
	// The Square-assigned ID of the reward tier.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The points exchanged for the reward tier.
	Points int `json:"points" url:"points"`
	// The name of the reward tier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The timestamp when the reward tier was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A reference to the specific version of a `PRICING_RULE` catalog object that contains information about the reward tier discount.
	//
	// Use `object_id` and `catalog_version` with the [RetrieveCatalogObject](api-endpoint:Catalog-RetrieveCatalogObject) endpoint
	// to get discount details. Make sure to set `include_related_objects` to true in the request to retrieve all catalog objects
	// that define the discount. For more information, see [Getting discount details for a reward tier](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards#get-discount-details).
	PricingRuleReference *CatalogObjectReference `json:"pricing_rule_reference" url:"pricing_rule_reference"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramRewardTier) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyProgramRewardTier) GetPoints() int {
	if l == nil {
		return 0
	}
	return l.Points
}

func (l *LoyaltyProgramRewardTier) GetName() *string {
	if l == nil {
		return nil
	}
	return l.Name
}

func (l *LoyaltyProgramRewardTier) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyProgramRewardTier) GetPricingRuleReference() *CatalogObjectReference {
	if l == nil {
		return nil
	}
	return l.PricingRuleReference
}

func (l *LoyaltyProgramRewardTier) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramRewardTier) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramRewardTier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramRewardTier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramRewardTier) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates whether the program is currently active.
type LoyaltyProgramStatus string

const (
	LoyaltyProgramStatusInactive LoyaltyProgramStatus = "INACTIVE"
	LoyaltyProgramStatusActive   LoyaltyProgramStatus = "ACTIVE"
)

func NewLoyaltyProgramStatusFromString(s string) (LoyaltyProgramStatus, error) {
	switch s {
	case "INACTIVE":
		return LoyaltyProgramStatusInactive, nil
	case "ACTIVE":
		return LoyaltyProgramStatusActive, nil
	}
	var t LoyaltyProgramStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyProgramStatus) Ptr() *LoyaltyProgramStatus {
	return &l
}

// Represents the naming used for loyalty points.
type LoyaltyProgramTerminology struct {
	// A singular unit for a point (for example, 1 point is called 1 star).
	One string `json:"one" url:"one"`
	// A plural unit for point (for example, 10 points is called 10 stars).
	Other string `json:"other" url:"other"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramTerminology) GetOne() string {
	if l == nil {
		return ""
	}
	return l.One
}

func (l *LoyaltyProgramTerminology) GetOther() string {
	if l == nil {
		return ""
	}
	return l.Other
}

func (l *LoyaltyProgramTerminology) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramTerminology) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramTerminology
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramTerminology(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramTerminology) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty program](entity:LoyaltyProgram) is updated.
type LoyaltyProgramUpdatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.program.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyProgramUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyProgramUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyProgramUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyProgramUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyProgramUpdatedEvent) GetData() *LoyaltyProgramUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyProgramUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.program.updated` event.
type LoyaltyProgramUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_program`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty program.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the loyalty program that was updated.
	Object *LoyaltyProgramUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyProgramUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyProgramUpdatedEventData) GetObject() *LoyaltyProgramUpdatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyProgramUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// An object that contains the loyalty program associated with a `loyalty.program.updated` event.
type LoyaltyProgramUpdatedEventObject struct {
	// The loyalty program that was updated.
	LoyaltyProgram *LoyaltyProgram `json:"loyalty_program,omitempty" url:"loyalty_program,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyProgramUpdatedEventObject) GetLoyaltyProgram() *LoyaltyProgram {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgram
}

func (l *LoyaltyProgramUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyProgramUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyProgramUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyProgramUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyProgramUpdatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a promotion for a [loyalty program](entity:LoyaltyProgram). Loyalty promotions enable buyers
// to earn extra points on top of those earned from the base program.
//
// A loyalty program can have a maximum of 10 loyalty promotions with an `ACTIVE` or `SCHEDULED` status.
type LoyaltyPromotion struct {
	// The Square-assigned ID of the promotion.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the promotion.
	Name string `json:"name" url:"name"`
	// The points incentive for the promotion. This field defines whether promotion points
	// are earned by multiplying base program points or by adding a specified number of points.
	Incentive *LoyaltyPromotionIncentive `json:"incentive" url:"incentive"`
	// The scheduling information that defines when purchases can qualify to earn points from an `ACTIVE` promotion.
	AvailableTime *LoyaltyPromotionAvailableTimeData `json:"available_time" url:"available_time"`
	// The number of times a buyer can earn promotion points during a specified interval.
	// If not specified, buyers can trigger the promotion an unlimited number of times.
	TriggerLimit *LoyaltyPromotionTriggerLimit `json:"trigger_limit,omitempty" url:"trigger_limit,omitempty"`
	// The current status of the promotion.
	// See [LoyaltyPromotionStatus](#type-loyaltypromotionstatus) for possible values
	Status *LoyaltyPromotionStatus `json:"status,omitempty" url:"status,omitempty"`
	// The timestamp of when the promotion was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the promotion was canceled, in RFC 3339 format.
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// The timestamp when the promotion was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the [loyalty program](entity:LoyaltyProgram) associated with the promotion.
	LoyaltyProgramID *string `json:"loyalty_program_id,omitempty" url:"loyalty_program_id,omitempty"`
	// The minimum purchase amount required to earn promotion points. If specified, this amount is positive.
	MinimumSpendAmountMoney *Money `json:"minimum_spend_amount_money,omitempty" url:"minimum_spend_amount_money,omitempty"`
	// The IDs of any qualifying `ITEM_VARIATION` [catalog objects](entity:CatalogObject). If specified,
	// the purchase must include at least one of these items to qualify for the promotion.
	//
	// This option is valid only if the base loyalty program uses a `VISIT` or `SPEND` accrual rule.
	// With `SPEND` accrual rules, make sure that qualifying promotional items are not excluded.
	//
	// You can specify `qualifying_item_variation_ids` or `qualifying_category_ids` for a given promotion, but not both.
	QualifyingItemVariationIDs []string `json:"qualifying_item_variation_ids,omitempty" url:"qualifying_item_variation_ids,omitempty"`
	// The IDs of any qualifying `CATEGORY` [catalog objects](entity:CatalogObject). If specified,
	// the purchase must include at least one item from one of these categories to qualify for the promotion.
	//
	// This option is valid only if the base loyalty program uses a `VISIT` or `SPEND` accrual rule.
	// With `SPEND` accrual rules, make sure that qualifying promotional items are not excluded.
	//
	// You can specify `qualifying_category_ids` or `qualifying_item_variation_ids` for a promotion, but not both.
	QualifyingCategoryIDs []string `json:"qualifying_category_ids,omitempty" url:"qualifying_category_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotion) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyPromotion) GetName() string {
	if l == nil {
		return ""
	}
	return l.Name
}

func (l *LoyaltyPromotion) GetIncentive() *LoyaltyPromotionIncentive {
	if l == nil {
		return nil
	}
	return l.Incentive
}

func (l *LoyaltyPromotion) GetAvailableTime() *LoyaltyPromotionAvailableTimeData {
	if l == nil {
		return nil
	}
	return l.AvailableTime
}

func (l *LoyaltyPromotion) GetTriggerLimit() *LoyaltyPromotionTriggerLimit {
	if l == nil {
		return nil
	}
	return l.TriggerLimit
}

func (l *LoyaltyPromotion) GetStatus() *LoyaltyPromotionStatus {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LoyaltyPromotion) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyPromotion) GetCanceledAt() *string {
	if l == nil {
		return nil
	}
	return l.CanceledAt
}

func (l *LoyaltyPromotion) GetUpdatedAt() *string {
	if l == nil {
		return nil
	}
	return l.UpdatedAt
}

func (l *LoyaltyPromotion) GetLoyaltyProgramID() *string {
	if l == nil {
		return nil
	}
	return l.LoyaltyProgramID
}

func (l *LoyaltyPromotion) GetMinimumSpendAmountMoney() *Money {
	if l == nil {
		return nil
	}
	return l.MinimumSpendAmountMoney
}

func (l *LoyaltyPromotion) GetQualifyingItemVariationIDs() []string {
	if l == nil {
		return nil
	}
	return l.QualifyingItemVariationIDs
}

func (l *LoyaltyPromotion) GetQualifyingCategoryIDs() []string {
	if l == nil {
		return nil
	}
	return l.QualifyingCategoryIDs
}

func (l *LoyaltyPromotion) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotion) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotion(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotion) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents scheduling information that determines when purchases can qualify to earn points
// from a [loyalty promotion](entity:LoyaltyPromotion).
type LoyaltyPromotionAvailableTimeData struct {
	// The date that the promotion starts, in `YYYY-MM-DD` format. Square populates this field
	// based on the provided `time_periods`.
	StartDate *string `json:"start_date,omitempty" url:"start_date,omitempty"`
	// The date that the promotion ends, in `YYYY-MM-DD` format. Square populates this field
	// based on the provided `time_periods`. If an end date is not specified, an `ACTIVE` promotion
	// remains available until it is canceled.
	EndDate *string `json:"end_date,omitempty" url:"end_date,omitempty"`
	// A list of [iCalendar (RFC 5545) events](https://tools.ietf.org/html/rfc5545#section-3.6.1)
	// (`VEVENT`). Each event represents an available time period per day or days of the week.
	// A day can have a maximum of one available time period.
	//
	// Only `DTSTART`, `DURATION`, and `RRULE` are supported. `DTSTART` and `DURATION` are required and
	// timestamps must be in local (unzoned) time format. Include `RRULE` to specify recurring promotions,
	// an end date (using the `UNTIL` keyword), or both. For more information, see
	// [Available time](https://developer.squareup.com/docs/loyalty-api/loyalty-promotions#available-time).
	//
	// Note that `BEGIN:VEVENT` and `END:VEVENT` are optional in a `CreateLoyaltyPromotion` request
	// but are always included in the response.
	TimePeriods []string `json:"time_periods" url:"time_periods"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionAvailableTimeData) GetStartDate() *string {
	if l == nil {
		return nil
	}
	return l.StartDate
}

func (l *LoyaltyPromotionAvailableTimeData) GetEndDate() *string {
	if l == nil {
		return nil
	}
	return l.EndDate
}

func (l *LoyaltyPromotionAvailableTimeData) GetTimePeriods() []string {
	if l == nil {
		return nil
	}
	return l.TimePeriods
}

func (l *LoyaltyPromotionAvailableTimeData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionAvailableTimeData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionAvailableTimeData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionAvailableTimeData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionAvailableTimeData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Published when a [loyalty promotion](entity:LoyaltyPromotion) is created.
type LoyaltyPromotionCreatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.promotion.created`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyPromotionCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionCreatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyPromotionCreatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyPromotionCreatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyPromotionCreatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyPromotionCreatedEvent) GetData() *LoyaltyPromotionCreatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyPromotionCreatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionCreatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.promotion.created` event.
type LoyaltyPromotionCreatedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_promotion`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty promotion.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the loyalty promotion that was created.
	Object *LoyaltyPromotionCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionCreatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyPromotionCreatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyPromotionCreatedEventData) GetObject() *LoyaltyPromotionCreatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyPromotionCreatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionCreatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// An object that contains the loyalty promotion associated with a `loyalty.promotion.created` event.
type LoyaltyPromotionCreatedEventObject struct {
	// The loyalty promotion that was created.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionCreatedEventObject) GetLoyaltyPromotion() *LoyaltyPromotion {
	if l == nil {
		return nil
	}
	return l.LoyaltyPromotion
}

func (l *LoyaltyPromotionCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionCreatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents how points for a [loyalty promotion](entity:LoyaltyPromotion) are calculated,
// either by multiplying the points earned from the base program or by adding a specified number
// of points to the points earned from the base program.
type LoyaltyPromotionIncentive struct {
	// The type of points incentive.
	// See [LoyaltyPromotionIncentiveType](#type-loyaltypromotionincentivetype) for possible values
	Type LoyaltyPromotionIncentiveType `json:"type" url:"type"`
	// Additional data for a `POINTS_MULTIPLIER` incentive type.
	PointsMultiplierData *LoyaltyPromotionIncentivePointsMultiplierData `json:"points_multiplier_data,omitempty" url:"points_multiplier_data,omitempty"`
	// Additional data for a `POINTS_ADDITION` incentive type.
	PointsAdditionData *LoyaltyPromotionIncentivePointsAdditionData `json:"points_addition_data,omitempty" url:"points_addition_data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionIncentive) GetType() LoyaltyPromotionIncentiveType {
	if l == nil {
		return ""
	}
	return l.Type
}

func (l *LoyaltyPromotionIncentive) GetPointsMultiplierData() *LoyaltyPromotionIncentivePointsMultiplierData {
	if l == nil {
		return nil
	}
	return l.PointsMultiplierData
}

func (l *LoyaltyPromotionIncentive) GetPointsAdditionData() *LoyaltyPromotionIncentivePointsAdditionData {
	if l == nil {
		return nil
	}
	return l.PointsAdditionData
}

func (l *LoyaltyPromotionIncentive) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentive) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentive
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentive(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentive) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the metadata for a `POINTS_ADDITION` type of [loyalty promotion incentive](entity:LoyaltyPromotionIncentive).
type LoyaltyPromotionIncentivePointsAdditionData struct {
	// The number of additional points to earn each time the promotion is triggered. For example,
	// suppose a purchase qualifies for 5 points from the base loyalty program. If the purchase also
	// qualifies for a `POINTS_ADDITION` promotion incentive with a `points_addition` of 3, the buyer
	// earns a total of 8 points (5 program points + 3 promotion points = 8 points).
	PointsAddition int `json:"points_addition" url:"points_addition"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) GetPointsAddition() int {
	if l == nil {
		return 0
	}
	return l.PointsAddition
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentivePointsAdditionData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentivePointsAdditionData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentivePointsAdditionData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents the metadata for a `POINTS_MULTIPLIER` type of [loyalty promotion incentive](entity:LoyaltyPromotionIncentive).
type LoyaltyPromotionIncentivePointsMultiplierData struct {
	// The multiplier used to calculate the number of points earned each time the promotion
	// is triggered. For example, suppose a purchase qualifies for 5 points from the base loyalty program.
	// If the purchase also qualifies for a `POINTS_MULTIPLIER` promotion incentive with a `points_multiplier`
	// of 3, the buyer earns a total of 15 points (5 program points x 3 promotion multiplier = 15 points).
	//
	// DEPRECATED at version 2023-08-16. Replaced by the `multiplier` field.
	//
	// One of the following is required when specifying a points multiplier:
	// - (Recommended) The `multiplier` field.
	// - This deprecated `points_multiplier` field. If provided in the request, Square also returns `multiplier`
	// with the equivalent value.
	PointsMultiplier *int `json:"points_multiplier,omitempty" url:"points_multiplier,omitempty"`
	// The multiplier used to calculate the number of points earned each time the promotion is triggered,
	// specified as a string representation of a decimal. Square supports multipliers up to 10x, with three
	// point precision for decimal multipliers. For example, suppose a purchase qualifies for 4 points from the
	// base loyalty program. If the purchase also qualifies for a `POINTS_MULTIPLIER` promotion incentive with a
	// `multiplier` of "1.5", the buyer earns a total of 6 points (4 program points x 1.5 promotion multiplier = 6 points).
	// Fractional points are dropped.
	//
	// One of the following is required when specifying a points multiplier:
	// - (Recommended) This `multiplier` field.
	// - The deprecated `points_multiplier` field. If provided in the request, Square also returns `multiplier`
	// with the equivalent value.
	Multiplier *string `json:"multiplier,omitempty" url:"multiplier,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) GetPointsMultiplier() *int {
	if l == nil {
		return nil
	}
	return l.PointsMultiplier
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) GetMultiplier() *string {
	if l == nil {
		return nil
	}
	return l.Multiplier
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionIncentivePointsMultiplierData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionIncentivePointsMultiplierData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionIncentivePointsMultiplierData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the type of points incentive for a [loyalty promotion](entity:LoyaltyPromotion),
// which is used to determine how buyers can earn points from the promotion.
type LoyaltyPromotionIncentiveType string

const (
	LoyaltyPromotionIncentiveTypePointsMultiplier LoyaltyPromotionIncentiveType = "POINTS_MULTIPLIER"
	LoyaltyPromotionIncentiveTypePointsAddition   LoyaltyPromotionIncentiveType = "POINTS_ADDITION"
)

func NewLoyaltyPromotionIncentiveTypeFromString(s string) (LoyaltyPromotionIncentiveType, error) {
	switch s {
	case "POINTS_MULTIPLIER":
		return LoyaltyPromotionIncentiveTypePointsMultiplier, nil
	case "POINTS_ADDITION":
		return LoyaltyPromotionIncentiveTypePointsAddition, nil
	}
	var t LoyaltyPromotionIncentiveType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionIncentiveType) Ptr() *LoyaltyPromotionIncentiveType {
	return &l
}

// Indicates the status of a [loyalty promotion](entity:LoyaltyPromotion).
type LoyaltyPromotionStatus string

const (
	LoyaltyPromotionStatusActive    LoyaltyPromotionStatus = "ACTIVE"
	LoyaltyPromotionStatusEnded     LoyaltyPromotionStatus = "ENDED"
	LoyaltyPromotionStatusCanceled  LoyaltyPromotionStatus = "CANCELED"
	LoyaltyPromotionStatusScheduled LoyaltyPromotionStatus = "SCHEDULED"
)

func NewLoyaltyPromotionStatusFromString(s string) (LoyaltyPromotionStatus, error) {
	switch s {
	case "ACTIVE":
		return LoyaltyPromotionStatusActive, nil
	case "ENDED":
		return LoyaltyPromotionStatusEnded, nil
	case "CANCELED":
		return LoyaltyPromotionStatusCanceled, nil
	case "SCHEDULED":
		return LoyaltyPromotionStatusScheduled, nil
	}
	var t LoyaltyPromotionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionStatus) Ptr() *LoyaltyPromotionStatus {
	return &l
}

// Represents the number of times a buyer can earn points during a [loyalty promotion](entity:LoyaltyPromotion).
// If this field is not set, buyers can trigger the promotion an unlimited number of times to earn points during
// the time that the promotion is available.
//
// A purchase that is disqualified from earning points because of this limit might qualify for another active promotion.
type LoyaltyPromotionTriggerLimit struct {
	// The maximum number of times a buyer can trigger the promotion during the specified `interval`.
	Times int `json:"times" url:"times"`
	// The time period the limit applies to.
	// See [LoyaltyPromotionTriggerLimitInterval](#type-loyaltypromotiontriggerlimitinterval) for possible values
	Interval *LoyaltyPromotionTriggerLimitInterval `json:"interval,omitempty" url:"interval,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionTriggerLimit) GetTimes() int {
	if l == nil {
		return 0
	}
	return l.Times
}

func (l *LoyaltyPromotionTriggerLimit) GetInterval() *LoyaltyPromotionTriggerLimitInterval {
	if l == nil {
		return nil
	}
	return l.Interval
}

func (l *LoyaltyPromotionTriggerLimit) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionTriggerLimit) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionTriggerLimit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionTriggerLimit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionTriggerLimit) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Indicates the time period that the [trigger limit](entity:LoyaltyPromotionTriggerLimit) applies to,
// which is used to determine the number of times a buyer can earn points for a [loyalty promotion](entity:LoyaltyPromotion).
type LoyaltyPromotionTriggerLimitInterval string

const (
	LoyaltyPromotionTriggerLimitIntervalAllTime LoyaltyPromotionTriggerLimitInterval = "ALL_TIME"
	LoyaltyPromotionTriggerLimitIntervalDay     LoyaltyPromotionTriggerLimitInterval = "DAY"
)

func NewLoyaltyPromotionTriggerLimitIntervalFromString(s string) (LoyaltyPromotionTriggerLimitInterval, error) {
	switch s {
	case "ALL_TIME":
		return LoyaltyPromotionTriggerLimitIntervalAllTime, nil
	case "DAY":
		return LoyaltyPromotionTriggerLimitIntervalDay, nil
	}
	var t LoyaltyPromotionTriggerLimitInterval
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyPromotionTriggerLimitInterval) Ptr() *LoyaltyPromotionTriggerLimitInterval {
	return &l
}

// Published when a [loyalty promotion](entity:LoyaltyPromotion) is updated. This event is
// invoked only when a loyalty promotion is canceled.
type LoyaltyPromotionUpdatedEvent struct {
	// The ID of the Square seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event. For this event, the value is `loyalty.promotion.updated`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The unique ID for the event, which is used for
	// [idempotency support](https://developer.squareup.com/docs/webhooks/step4manage#webhooks-best-practices).
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *LoyaltyPromotionUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionUpdatedEvent) GetMerchantID() *string {
	if l == nil {
		return nil
	}
	return l.MerchantID
}

func (l *LoyaltyPromotionUpdatedEvent) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyPromotionUpdatedEvent) GetEventID() *string {
	if l == nil {
		return nil
	}
	return l.EventID
}

func (l *LoyaltyPromotionUpdatedEvent) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyPromotionUpdatedEvent) GetData() *LoyaltyPromotionUpdatedEventData {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *LoyaltyPromotionUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionUpdatedEvent) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The data associated with a `loyalty.promotion.updated` event.
type LoyaltyPromotionUpdatedEventData struct {
	// The type of object affected by the event. For this event, the value is `loyalty_promotion`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the affected loyalty promotion.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object that contains the loyalty promotion that was updated.
	Object *LoyaltyPromotionUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionUpdatedEventData) GetType() *string {
	if l == nil {
		return nil
	}
	return l.Type
}

func (l *LoyaltyPromotionUpdatedEventData) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyPromotionUpdatedEventData) GetObject() *LoyaltyPromotionUpdatedEventObject {
	if l == nil {
		return nil
	}
	return l.Object
}

func (l *LoyaltyPromotionUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionUpdatedEventData) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// An object that contains the loyalty promotion associated with a `loyalty.promotion.updated` event.
type LoyaltyPromotionUpdatedEventObject struct {
	// The loyalty promotion that was updated.
	LoyaltyPromotion *LoyaltyPromotion `json:"loyalty_promotion,omitempty" url:"loyalty_promotion,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyPromotionUpdatedEventObject) GetLoyaltyPromotion() *LoyaltyPromotion {
	if l == nil {
		return nil
	}
	return l.LoyaltyPromotion
}

func (l *LoyaltyPromotionUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyPromotionUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyPromotionUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyPromotionUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyPromotionUpdatedEventObject) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a contract to redeem loyalty points for a [reward tier](entity:LoyaltyProgramRewardTier) discount. Loyalty rewards can be in an ISSUED, REDEEMED, or DELETED state.
// For more information, see [Manage loyalty rewards](https://developer.squareup.com/docs/loyalty-api/loyalty-rewards).
type LoyaltyReward struct {
	// The Square-assigned ID of the loyalty reward.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The status of a loyalty reward.
	// See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
	Status *LoyaltyRewardStatus `json:"status,omitempty" url:"status,omitempty"`
	// The Square-assigned ID of the [loyalty account](entity:LoyaltyAccount) to which the reward belongs.
	LoyaltyAccountID string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The Square-assigned ID of the [reward tier](entity:LoyaltyProgramRewardTier) used to create the reward.
	RewardTierID string `json:"reward_tier_id" url:"reward_tier_id"`
	// The number of loyalty points used for the reward.
	Points *int `json:"points,omitempty" url:"points,omitempty"`
	// The Square-assigned ID of the [order](entity:Order) to which the reward is attached.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The timestamp when the reward was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the reward was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp when the reward was redeemed, in RFC 3339 format.
	RedeemedAt *string `json:"redeemed_at,omitempty" url:"redeemed_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LoyaltyReward) GetID() *string {
	if l == nil {
		return nil
	}
	return l.ID
}

func (l *LoyaltyReward) GetStatus() *LoyaltyRewardStatus {
	if l == nil {
		return nil
	}
	return l.Status
}

func (l *LoyaltyReward) GetLoyaltyAccountID() string {
	if l == nil {
		return ""
	}
	return l.LoyaltyAccountID
}

func (l *LoyaltyReward) GetRewardTierID() string {
	if l == nil {
		return ""
	}
	return l.RewardTierID
}

func (l *LoyaltyReward) GetPoints() *int {
	if l == nil {
		return nil
	}
	return l.Points
}

func (l *LoyaltyReward) GetOrderID() *string {
	if l == nil {
		return nil
	}
	return l.OrderID
}

func (l *LoyaltyReward) GetCreatedAt() *string {
	if l == nil {
		return nil
	}
	return l.CreatedAt
}

func (l *LoyaltyReward) GetUpdatedAt() *string {
	if l == nil {
		return nil
	}
	return l.UpdatedAt
}

func (l *LoyaltyReward) GetRedeemedAt() *string {
	if l == nil {
		return nil
	}
	return l.RedeemedAt
}

func (l *LoyaltyReward) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoyaltyReward) UnmarshalJSON(data []byte) error {
	type unmarshaler LoyaltyReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoyaltyReward(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoyaltyReward) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The status of the loyalty reward.
type LoyaltyRewardStatus string

const (
	LoyaltyRewardStatusIssued   LoyaltyRewardStatus = "ISSUED"
	LoyaltyRewardStatusRedeemed LoyaltyRewardStatus = "REDEEMED"
	LoyaltyRewardStatusDeleted  LoyaltyRewardStatus = "DELETED"
)

func NewLoyaltyRewardStatusFromString(s string) (LoyaltyRewardStatus, error) {
	switch s {
	case "ISSUED":
		return LoyaltyRewardStatusIssued, nil
	case "REDEEMED":
		return LoyaltyRewardStatusRedeemed, nil
	case "DELETED":
		return LoyaltyRewardStatusDeleted, nil
	}
	var t LoyaltyRewardStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoyaltyRewardStatus) Ptr() *LoyaltyRewardStatus {
	return &l
}

// Represents a unit of measurement to use with a quantity, such as ounces
// or inches. Exactly one of the following fields are required: `custom_unit`,
// `area_unit`, `length_unit`, `volume_unit`, and `weight_unit`.
type MeasurementUnit struct {
	// A custom unit of measurement defined by the seller using the Point of Sale
	// app or ad-hoc as an order line item.
	CustomUnit *MeasurementUnitCustom `json:"custom_unit,omitempty" url:"custom_unit,omitempty"`
	// Represents a standard area unit.
	// See [MeasurementUnitArea](#type-measurementunitarea) for possible values
	AreaUnit *MeasurementUnitArea `json:"area_unit,omitempty" url:"area_unit,omitempty"`
	// Represents a standard length unit.
	// See [MeasurementUnitLength](#type-measurementunitlength) for possible values
	LengthUnit *MeasurementUnitLength `json:"length_unit,omitempty" url:"length_unit,omitempty"`
	// Represents a standard volume unit.
	// See [MeasurementUnitVolume](#type-measurementunitvolume) for possible values
	VolumeUnit *MeasurementUnitVolume `json:"volume_unit,omitempty" url:"volume_unit,omitempty"`
	// Represents a standard unit of weight or mass.
	// See [MeasurementUnitWeight](#type-measurementunitweight) for possible values
	WeightUnit *MeasurementUnitWeight `json:"weight_unit,omitempty" url:"weight_unit,omitempty"`
	// Reserved for API integrations that lack the ability to specify a real measurement unit
	// See [MeasurementUnitGeneric](#type-measurementunitgeneric) for possible values
	GenericUnit *MeasurementUnitGeneric `json:"generic_unit,omitempty" url:"generic_unit,omitempty"`
	// Represents a standard unit of time.
	// See [MeasurementUnitTime](#type-measurementunittime) for possible values
	TimeUnit *MeasurementUnitTime `json:"time_unit,omitempty" url:"time_unit,omitempty"`
	// Represents the type of the measurement unit.
	// See [MeasurementUnitUnitType](#type-measurementunitunittype) for possible values
	Type *MeasurementUnitUnitType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MeasurementUnit) GetCustomUnit() *MeasurementUnitCustom {
	if m == nil {
		return nil
	}
	return m.CustomUnit
}

func (m *MeasurementUnit) GetAreaUnit() *MeasurementUnitArea {
	if m == nil {
		return nil
	}
	return m.AreaUnit
}

func (m *MeasurementUnit) GetLengthUnit() *MeasurementUnitLength {
	if m == nil {
		return nil
	}
	return m.LengthUnit
}

func (m *MeasurementUnit) GetVolumeUnit() *MeasurementUnitVolume {
	if m == nil {
		return nil
	}
	return m.VolumeUnit
}

func (m *MeasurementUnit) GetWeightUnit() *MeasurementUnitWeight {
	if m == nil {
		return nil
	}
	return m.WeightUnit
}

func (m *MeasurementUnit) GetTimeUnit() *MeasurementUnitTime {
	if m == nil {
		return nil
	}
	return m.TimeUnit
}

func (m *MeasurementUnit) GetType() *MeasurementUnitUnitType {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MeasurementUnit) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnit) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Unit of area used to measure a quantity.
type MeasurementUnitArea string

const (
	MeasurementUnitAreaImperialAcre           MeasurementUnitArea = "IMPERIAL_ACRE"
	MeasurementUnitAreaImperialSquareInch     MeasurementUnitArea = "IMPERIAL_SQUARE_INCH"
	MeasurementUnitAreaImperialSquareFoot     MeasurementUnitArea = "IMPERIAL_SQUARE_FOOT"
	MeasurementUnitAreaImperialSquareYard     MeasurementUnitArea = "IMPERIAL_SQUARE_YARD"
	MeasurementUnitAreaImperialSquareMile     MeasurementUnitArea = "IMPERIAL_SQUARE_MILE"
	MeasurementUnitAreaMetricSquareCentimeter MeasurementUnitArea = "METRIC_SQUARE_CENTIMETER"
	MeasurementUnitAreaMetricSquareMeter      MeasurementUnitArea = "METRIC_SQUARE_METER"
	MeasurementUnitAreaMetricSquareKilometer  MeasurementUnitArea = "METRIC_SQUARE_KILOMETER"
)

func NewMeasurementUnitAreaFromString(s string) (MeasurementUnitArea, error) {
	switch s {
	case "IMPERIAL_ACRE":
		return MeasurementUnitAreaImperialAcre, nil
	case "IMPERIAL_SQUARE_INCH":
		return MeasurementUnitAreaImperialSquareInch, nil
	case "IMPERIAL_SQUARE_FOOT":
		return MeasurementUnitAreaImperialSquareFoot, nil
	case "IMPERIAL_SQUARE_YARD":
		return MeasurementUnitAreaImperialSquareYard, nil
	case "IMPERIAL_SQUARE_MILE":
		return MeasurementUnitAreaImperialSquareMile, nil
	case "METRIC_SQUARE_CENTIMETER":
		return MeasurementUnitAreaMetricSquareCentimeter, nil
	case "METRIC_SQUARE_METER":
		return MeasurementUnitAreaMetricSquareMeter, nil
	case "METRIC_SQUARE_KILOMETER":
		return MeasurementUnitAreaMetricSquareKilometer, nil
	}
	var t MeasurementUnitArea
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitArea) Ptr() *MeasurementUnitArea {
	return &m
}

// The information needed to define a custom unit, provided by the seller.
type MeasurementUnitCustom struct {
	// The name of the custom unit, for example "bushel".
	Name string `json:"name" url:"name"`
	// The abbreviation of the custom unit, such as "bsh" (bushel). This appears
	// in the cart for the Point of Sale app, and in reports.
	Abbreviation string `json:"abbreviation" url:"abbreviation"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MeasurementUnitCustom) GetName() string {
	if m == nil {
		return ""
	}
	return m.Name
}

func (m *MeasurementUnitCustom) GetAbbreviation() string {
	if m == nil {
		return ""
	}
	return m.Abbreviation
}

func (m *MeasurementUnitCustom) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnitCustom) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnitCustom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnitCustom(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnitCustom) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MeasurementUnitGeneric = string

// The unit of length used to measure a quantity.
type MeasurementUnitLength string

const (
	MeasurementUnitLengthImperialInch     MeasurementUnitLength = "IMPERIAL_INCH"
	MeasurementUnitLengthImperialFoot     MeasurementUnitLength = "IMPERIAL_FOOT"
	MeasurementUnitLengthImperialYard     MeasurementUnitLength = "IMPERIAL_YARD"
	MeasurementUnitLengthImperialMile     MeasurementUnitLength = "IMPERIAL_MILE"
	MeasurementUnitLengthMetricMillimeter MeasurementUnitLength = "METRIC_MILLIMETER"
	MeasurementUnitLengthMetricCentimeter MeasurementUnitLength = "METRIC_CENTIMETER"
	MeasurementUnitLengthMetricMeter      MeasurementUnitLength = "METRIC_METER"
	MeasurementUnitLengthMetricKilometer  MeasurementUnitLength = "METRIC_KILOMETER"
)

func NewMeasurementUnitLengthFromString(s string) (MeasurementUnitLength, error) {
	switch s {
	case "IMPERIAL_INCH":
		return MeasurementUnitLengthImperialInch, nil
	case "IMPERIAL_FOOT":
		return MeasurementUnitLengthImperialFoot, nil
	case "IMPERIAL_YARD":
		return MeasurementUnitLengthImperialYard, nil
	case "IMPERIAL_MILE":
		return MeasurementUnitLengthImperialMile, nil
	case "METRIC_MILLIMETER":
		return MeasurementUnitLengthMetricMillimeter, nil
	case "METRIC_CENTIMETER":
		return MeasurementUnitLengthMetricCentimeter, nil
	case "METRIC_METER":
		return MeasurementUnitLengthMetricMeter, nil
	case "METRIC_KILOMETER":
		return MeasurementUnitLengthMetricKilometer, nil
	}
	var t MeasurementUnitLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitLength) Ptr() *MeasurementUnitLength {
	return &m
}

// Unit of time used to measure a quantity (a duration).
type MeasurementUnitTime string

const (
	MeasurementUnitTimeGenericMillisecond MeasurementUnitTime = "GENERIC_MILLISECOND"
	MeasurementUnitTimeGenericSecond      MeasurementUnitTime = "GENERIC_SECOND"
	MeasurementUnitTimeGenericMinute      MeasurementUnitTime = "GENERIC_MINUTE"
	MeasurementUnitTimeGenericHour        MeasurementUnitTime = "GENERIC_HOUR"
	MeasurementUnitTimeGenericDay         MeasurementUnitTime = "GENERIC_DAY"
)

func NewMeasurementUnitTimeFromString(s string) (MeasurementUnitTime, error) {
	switch s {
	case "GENERIC_MILLISECOND":
		return MeasurementUnitTimeGenericMillisecond, nil
	case "GENERIC_SECOND":
		return MeasurementUnitTimeGenericSecond, nil
	case "GENERIC_MINUTE":
		return MeasurementUnitTimeGenericMinute, nil
	case "GENERIC_HOUR":
		return MeasurementUnitTimeGenericHour, nil
	case "GENERIC_DAY":
		return MeasurementUnitTimeGenericDay, nil
	}
	var t MeasurementUnitTime
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitTime) Ptr() *MeasurementUnitTime {
	return &m
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type MeasurementUnitUnitType string

const (
	MeasurementUnitUnitTypeTypeCustom  MeasurementUnitUnitType = "TYPE_CUSTOM"
	MeasurementUnitUnitTypeTypeArea    MeasurementUnitUnitType = "TYPE_AREA"
	MeasurementUnitUnitTypeTypeLength  MeasurementUnitUnitType = "TYPE_LENGTH"
	MeasurementUnitUnitTypeTypeVolume  MeasurementUnitUnitType = "TYPE_VOLUME"
	MeasurementUnitUnitTypeTypeWeight  MeasurementUnitUnitType = "TYPE_WEIGHT"
	MeasurementUnitUnitTypeTypeGeneric MeasurementUnitUnitType = "TYPE_GENERIC"
)

func NewMeasurementUnitUnitTypeFromString(s string) (MeasurementUnitUnitType, error) {
	switch s {
	case "TYPE_CUSTOM":
		return MeasurementUnitUnitTypeTypeCustom, nil
	case "TYPE_AREA":
		return MeasurementUnitUnitTypeTypeArea, nil
	case "TYPE_LENGTH":
		return MeasurementUnitUnitTypeTypeLength, nil
	case "TYPE_VOLUME":
		return MeasurementUnitUnitTypeTypeVolume, nil
	case "TYPE_WEIGHT":
		return MeasurementUnitUnitTypeTypeWeight, nil
	case "TYPE_GENERIC":
		return MeasurementUnitUnitTypeTypeGeneric, nil
	}
	var t MeasurementUnitUnitType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitUnitType) Ptr() *MeasurementUnitUnitType {
	return &m
}

// The unit of volume used to measure a quantity.
type MeasurementUnitVolume string

const (
	MeasurementUnitVolumeGenericFluidOunce MeasurementUnitVolume = "GENERIC_FLUID_OUNCE"
	MeasurementUnitVolumeGenericShot       MeasurementUnitVolume = "GENERIC_SHOT"
	MeasurementUnitVolumeGenericCup        MeasurementUnitVolume = "GENERIC_CUP"
	MeasurementUnitVolumeGenericPint       MeasurementUnitVolume = "GENERIC_PINT"
	MeasurementUnitVolumeGenericQuart      MeasurementUnitVolume = "GENERIC_QUART"
	MeasurementUnitVolumeGenericGallon     MeasurementUnitVolume = "GENERIC_GALLON"
	MeasurementUnitVolumeImperialCubicInch MeasurementUnitVolume = "IMPERIAL_CUBIC_INCH"
	MeasurementUnitVolumeImperialCubicFoot MeasurementUnitVolume = "IMPERIAL_CUBIC_FOOT"
	MeasurementUnitVolumeImperialCubicYard MeasurementUnitVolume = "IMPERIAL_CUBIC_YARD"
	MeasurementUnitVolumeMetricMilliliter  MeasurementUnitVolume = "METRIC_MILLILITER"
	MeasurementUnitVolumeMetricLiter       MeasurementUnitVolume = "METRIC_LITER"
)

func NewMeasurementUnitVolumeFromString(s string) (MeasurementUnitVolume, error) {
	switch s {
	case "GENERIC_FLUID_OUNCE":
		return MeasurementUnitVolumeGenericFluidOunce, nil
	case "GENERIC_SHOT":
		return MeasurementUnitVolumeGenericShot, nil
	case "GENERIC_CUP":
		return MeasurementUnitVolumeGenericCup, nil
	case "GENERIC_PINT":
		return MeasurementUnitVolumeGenericPint, nil
	case "GENERIC_QUART":
		return MeasurementUnitVolumeGenericQuart, nil
	case "GENERIC_GALLON":
		return MeasurementUnitVolumeGenericGallon, nil
	case "IMPERIAL_CUBIC_INCH":
		return MeasurementUnitVolumeImperialCubicInch, nil
	case "IMPERIAL_CUBIC_FOOT":
		return MeasurementUnitVolumeImperialCubicFoot, nil
	case "IMPERIAL_CUBIC_YARD":
		return MeasurementUnitVolumeImperialCubicYard, nil
	case "METRIC_MILLILITER":
		return MeasurementUnitVolumeMetricMilliliter, nil
	case "METRIC_LITER":
		return MeasurementUnitVolumeMetricLiter, nil
	}
	var t MeasurementUnitVolume
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitVolume) Ptr() *MeasurementUnitVolume {
	return &m
}

// Unit of weight used to measure a quantity.
type MeasurementUnitWeight string

const (
	MeasurementUnitWeightImperialWeightOunce MeasurementUnitWeight = "IMPERIAL_WEIGHT_OUNCE"
	MeasurementUnitWeightImperialPound       MeasurementUnitWeight = "IMPERIAL_POUND"
	MeasurementUnitWeightImperialStone       MeasurementUnitWeight = "IMPERIAL_STONE"
	MeasurementUnitWeightMetricMilligram     MeasurementUnitWeight = "METRIC_MILLIGRAM"
	MeasurementUnitWeightMetricGram          MeasurementUnitWeight = "METRIC_GRAM"
	MeasurementUnitWeightMetricKilogram      MeasurementUnitWeight = "METRIC_KILOGRAM"
)

func NewMeasurementUnitWeightFromString(s string) (MeasurementUnitWeight, error) {
	switch s {
	case "IMPERIAL_WEIGHT_OUNCE":
		return MeasurementUnitWeightImperialWeightOunce, nil
	case "IMPERIAL_POUND":
		return MeasurementUnitWeightImperialPound, nil
	case "IMPERIAL_STONE":
		return MeasurementUnitWeightImperialStone, nil
	case "METRIC_MILLIGRAM":
		return MeasurementUnitWeightMetricMilligram, nil
	case "METRIC_GRAM":
		return MeasurementUnitWeightMetricGram, nil
	case "METRIC_KILOGRAM":
		return MeasurementUnitWeightMetricKilogram, nil
	}
	var t MeasurementUnitWeight
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitWeight) Ptr() *MeasurementUnitWeight {
	return &m
}

// Published when a merchant [custom attribute definition](entity:CustomAttributeDefinition)
// is created by the subscribing application. Subscribe to this event to be notified
// when your application creates a merchant custom attribute definition.
type MerchantCustomAttributeDefinitionOwnedCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute_definition.owned.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeDefinitionOwnedCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeDefinitionOwnedCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeDefinitionOwnedCreatedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute definition](entity:CustomAttributeDefinition)
// is deleted by the subscribing application. Subscribe to this event to be notified
// when your application deletes a merchant custom attribute definition.
type MerchantCustomAttributeDefinitionOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute_definition.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeDefinitionOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeDefinitionOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeDefinitionOwnedDeletedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute definition](entity:CustomAttributeDefinition)
// is updated by the subscribing application. Subscribe to this event to be notified
// when your application updates a merchant custom attribute definition.
type MerchantCustomAttributeDefinitionOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute_definition.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeDefinitionOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeDefinitionOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeDefinitionOwnedUpdatedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is created. A notification is sent when your application
// creates a custom attribute definition or another application creates a custom attribute definition whose
// `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type MerchantCustomAttributeDefinitionVisibleCreatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute_definition.visible.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeDefinitionVisibleCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeDefinitionVisibleCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeDefinitionVisibleCreatedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is deleted. A notification is sent when your application
// deletes a custom attribute definition or another application deletes a custom attribute definition whose
// `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type MerchantCustomAttributeDefinitionVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute_definition.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeDefinitionVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeDefinitionVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeDefinitionVisibleDeletedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute definition](entity:CustomAttributeDefinition)
// that is visible to the subscribing application is updated. A notification is sent when your application
// updates a custom attribute definition or another application updates a custom attribute definition whose
// `visibility` is `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES`.
type MerchantCustomAttributeDefinitionVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute_definition.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeDefinitionVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeDefinitionVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeDefinitionVisibleUpdatedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute](entity:CustomAttribute)
// associated with a [custom attribute definition](entity:CustomAttributeDefinition) that is
// owned by the subscribing application is deleted. Subscribe to this event to be notified
// when your application deletes a merchant custom attribute.
type MerchantCustomAttributeOwnedDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) GetData() *CustomAttributeEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeOwnedDeletedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute](entity:CustomAttribute)
// associated with a [custom attribute definition](entity:CustomAttributeDefinition) that is
// owned by the subscribing application is updated. Subscribe to this event to be notified
// when your application updates a merchant custom attribute.
type MerchantCustomAttributeOwnedUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) GetData() *CustomAttributeEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeOwnedUpdatedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute](entity:CustomAttribute) with
// the `visibility` field set to `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES` is deleted.
// An application that subscribes to this event is notified when a merchant custom attribute is deleted
// by any application for which the subscribing application has read access to the merchant custom attribute.
type MerchantCustomAttributeVisibleDeletedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) GetData() *CustomAttributeEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeVisibleDeletedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant [custom attribute](entity:CustomAttribute) with
// the `visibility` field set to `VISIBILITY_READ_ONLY` or `VISIBILITY_READ_WRITE_VALUES` is updated.
// An application that subscribes to this event is notified when a merchant custom attribute is updated
// by any application for which the subscribing application has read access to the merchant custom attribute.
type MerchantCustomAttributeVisibleUpdatedEvent struct {
	// The ID of the seller associated with the event that triggered the event notification.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"merchant.custom_attribute.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event notification.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp that indicates when the event notification was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event that triggered the event notification.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) GetData() *CustomAttributeEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantCustomAttributeVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantCustomAttributeVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantCustomAttributeVisibleUpdatedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when online checkout merchant settings are updated
type MerchantSettingsUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"online_checkout.merchant_settings.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *MerchantSettingsUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantSettingsUpdatedEvent) GetMerchantID() *string {
	if m == nil {
		return nil
	}
	return m.MerchantID
}

func (m *MerchantSettingsUpdatedEvent) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantSettingsUpdatedEvent) GetEventID() *string {
	if m == nil {
		return nil
	}
	return m.EventID
}

func (m *MerchantSettingsUpdatedEvent) GetCreatedAt() *string {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *MerchantSettingsUpdatedEvent) GetData() *MerchantSettingsUpdatedEventData {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *MerchantSettingsUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantSettingsUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantSettingsUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantSettingsUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantSettingsUpdatedEvent) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MerchantSettingsUpdatedEventData struct {
	// Name of the updated object’s type, `"online_checkout.merchant_settings"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated merchant settings.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated merchant settings.
	Object *MerchantSettingsUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantSettingsUpdatedEventData) GetType() *string {
	if m == nil {
		return nil
	}
	return m.Type
}

func (m *MerchantSettingsUpdatedEventData) GetID() *string {
	if m == nil {
		return nil
	}
	return m.ID
}

func (m *MerchantSettingsUpdatedEventData) GetObject() *MerchantSettingsUpdatedEventObject {
	if m == nil {
		return nil
	}
	return m.Object
}

func (m *MerchantSettingsUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantSettingsUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantSettingsUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantSettingsUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantSettingsUpdatedEventData) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MerchantSettingsUpdatedEventObject struct {
	// The updated merchant settings.
	MerchantSettings *CheckoutMerchantSettings `json:"merchant_settings,omitempty" url:"merchant_settings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MerchantSettingsUpdatedEventObject) GetMerchantSettings() *CheckoutMerchantSettings {
	if m == nil {
		return nil
	}
	return m.MerchantSettings
}

func (m *MerchantSettingsUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MerchantSettingsUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler MerchantSettingsUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MerchantSettingsUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MerchantSettingsUpdatedEventObject) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Location-specific overrides for specified properties of a `CatalogModifier` object.
type ModifierLocationOverrides struct {
	// The ID of the `Location` object representing the location. This can include a deactivated location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The overridden price at the specified location. If this is unspecified, the modifier price is not overridden.
	// The modifier becomes free of charge at the specified location, when this `price_money` field is set to 0.
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Indicates whether the modifier is sold out at the specified location or not. As an example, for cheese (modifier) burger (item), when the modifier is sold out, it is the cheese, but not the burger, that is sold out.
	// The seller can manually set this sold out status. Attempts by an application to set this attribute are ignored.
	SoldOut *bool `json:"sold_out,omitempty" url:"sold_out,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModifierLocationOverrides) GetLocationID() *string {
	if m == nil {
		return nil
	}
	return m.LocationID
}

func (m *ModifierLocationOverrides) GetPriceMoney() *Money {
	if m == nil {
		return nil
	}
	return m.PriceMoney
}

func (m *ModifierLocationOverrides) GetSoldOut() *bool {
	if m == nil {
		return nil
	}
	return m.SoldOut
}

func (m *ModifierLocationOverrides) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModifierLocationOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler ModifierLocationOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModifierLocationOverrides(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModifierLocationOverrides) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Represents an amount of money. `Money` fields can be signed or unsigned.
// Fields that do not explicitly define whether they are signed or unsigned are
// considered unsigned and can only hold positive amounts. For signed fields, the
// sign of the value indicates the purpose of the money transfer. See
// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts)
// for more information.
type Money struct {
	// The amount of money, in the smallest denomination of the currency
	// indicated by `currency`. For example, when `currency` is `USD`, `amount` is
	// in cents. Monetary amounts can be positive or negative. See the specific
	// field description to determine the meaning of the sign in a particular case.
	Amount *int64 `json:"amount,omitempty" url:"amount,omitempty"`
	// The type of currency, in __ISO 4217 format__. For example, the currency
	// code for US dollars is `USD`.
	//
	// See [Currency](entity:Currency) for possible values.
	// See [Currency](#type-currency) for possible values
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *Money) GetAmount() *int64 {
	if m == nil {
		return nil
	}
	return m.Amount
}

func (m *Money) GetCurrency() *Currency {
	if m == nil {
		return nil
	}
	return m.Currency
}

func (m *Money) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Money) UnmarshalJSON(data []byte) error {
	type unmarshaler Money
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Money(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *Money) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Published when a merchant/application revokes all access tokens and refresh tokens granted to an application.
type OauthAuthorizationRevokedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"oauth.authorization.revoked"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OauthAuthorizationRevokedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OauthAuthorizationRevokedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OauthAuthorizationRevokedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OauthAuthorizationRevokedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OauthAuthorizationRevokedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OauthAuthorizationRevokedEvent) GetData() *OauthAuthorizationRevokedEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OauthAuthorizationRevokedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OauthAuthorizationRevokedEventData struct {
	// Name of the affected object’s type, `"revocation"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// Not applicable, revocation is not an object
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about revocation event.
	Object *OauthAuthorizationRevokedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OauthAuthorizationRevokedEventData) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OauthAuthorizationRevokedEventData) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OauthAuthorizationRevokedEventData) GetObject() *OauthAuthorizationRevokedEventObject {
	if o == nil {
		return nil
	}
	return o.Object
}

func (o *OauthAuthorizationRevokedEventData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedEventData) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OauthAuthorizationRevokedEventObject struct {
	// The revocation event.
	Revocation *OauthAuthorizationRevokedEventRevocationObject `json:"revocation,omitempty" url:"revocation,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OauthAuthorizationRevokedEventObject) GetRevocation() *OauthAuthorizationRevokedEventRevocationObject {
	if o == nil {
		return nil
	}
	return o.Revocation
}

func (o *OauthAuthorizationRevokedEventObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedEventObject) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OauthAuthorizationRevokedEventRevocationObject struct {
	// Timestamp of when the revocation event occurred, in RFC 3339 format.
	RevokedAt *string `json:"revoked_at,omitempty" url:"revoked_at,omitempty"`
	// Type of client that performed the revocation, either APPLICATION, MERCHANT, or SQUARE.
	// See [OauthAuthorizationRevokedEventRevokerType](#type-oauthauthorizationrevokedeventrevokertype) for possible values
	RevokerType *OauthAuthorizationRevokedEventRevokerType `json:"revoker_type,omitempty" url:"revoker_type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OauthAuthorizationRevokedEventRevocationObject) GetRevokedAt() *string {
	if o == nil {
		return nil
	}
	return o.RevokedAt
}

func (o *OauthAuthorizationRevokedEventRevocationObject) GetRevokerType() *OauthAuthorizationRevokedEventRevokerType {
	if o == nil {
		return nil
	}
	return o.RevokerType
}

func (o *OauthAuthorizationRevokedEventRevocationObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OauthAuthorizationRevokedEventRevocationObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OauthAuthorizationRevokedEventRevocationObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OauthAuthorizationRevokedEventRevocationObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OauthAuthorizationRevokedEventRevocationObject) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Defines the possible types for the revoking client.
type OauthAuthorizationRevokedEventRevokerType string

const (
	OauthAuthorizationRevokedEventRevokerTypeApplication OauthAuthorizationRevokedEventRevokerType = "APPLICATION"
	OauthAuthorizationRevokedEventRevokerTypeMerchant    OauthAuthorizationRevokedEventRevokerType = "MERCHANT"
	OauthAuthorizationRevokedEventRevokerTypeSquare      OauthAuthorizationRevokedEventRevokerType = "SQUARE"
)

func NewOauthAuthorizationRevokedEventRevokerTypeFromString(s string) (OauthAuthorizationRevokedEventRevokerType, error) {
	switch s {
	case "APPLICATION":
		return OauthAuthorizationRevokedEventRevokerTypeApplication, nil
	case "MERCHANT":
		return OauthAuthorizationRevokedEventRevokerTypeMerchant, nil
	case "SQUARE":
		return OauthAuthorizationRevokedEventRevokerTypeSquare, nil
	}
	var t OauthAuthorizationRevokedEventRevokerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OauthAuthorizationRevokedEventRevokerType) Ptr() *OauthAuthorizationRevokedEventRevokerType {
	return &o
}

// Contains all information related to a single order to process with Square,
// including line items that specify the products to purchase. `Order` objects also
// include information about any associated tenders, refunds, and returns.
//
// All Connect V2 Transactions have all been converted to Orders including all associated
// itemization data.
type Order struct {
	// The order's unique ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID string `json:"location_id" url:"location_id"`
	// A client-specified ID to associate an entity in another system
	// with this order.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The origination details of the order.
	Source *OrderSource `json:"source,omitempty" url:"source,omitempty"`
	// The ID of the [customer](entity:Customer) associated with the order.
	//
	// You should specify a `customer_id` on the order (or the payment) to ensure that transactions
	// are reliably linked to customers. Omitting this field might result in the creation of new
	// [instant profiles](https://developer.squareup.com/docs/customers-api/what-it-does#instant-profiles).
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The line items included in the order.
	LineItems []*OrderLineItem `json:"line_items,omitempty" url:"line_items,omitempty"`
	// The list of all taxes associated with the order.
	//
	// Taxes can be scoped to either `ORDER` or `LINE_ITEM`. For taxes with `LINE_ITEM` scope, an
	// `OrderLineItemAppliedTax` must be added to each line item that the tax applies to. For taxes
	// with `ORDER` scope, the server generates an `OrderLineItemAppliedTax` for every line item.
	//
	// On reads, each tax in the list includes the total amount of that tax applied to the order.
	//
	// __IMPORTANT__: If `LINE_ITEM` scope is set on any taxes in this field, using the deprecated
	// `line_items.taxes` field results in an error. Use `line_items.applied_taxes`
	// instead.
	Taxes []*OrderLineItemTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// The list of all discounts associated with the order.
	//
	// Discounts can be scoped to either `ORDER` or `LINE_ITEM`. For discounts scoped to `LINE_ITEM`,
	// an `OrderLineItemAppliedDiscount` must be added to each line item that the discount applies to.
	// For discounts with `ORDER` scope, the server generates an `OrderLineItemAppliedDiscount`
	// for every line item.
	//
	// __IMPORTANT__: If `LINE_ITEM` scope is set on any discounts in this field, using the deprecated
	// `line_items.discounts` field results in an error. Use `line_items.applied_discounts`
	// instead.
	Discounts []*OrderLineItemDiscount `json:"discounts,omitempty" url:"discounts,omitempty"`
	// A list of service charges applied to the order.
	ServiceCharges []*OrderServiceCharge `json:"service_charges,omitempty" url:"service_charges,omitempty"`
	// Details about order fulfillment.
	//
	// Orders can only be created with at most one fulfillment. However, orders returned
	// by the API might contain multiple fulfillments.
	Fulfillments []*Fulfillment `json:"fulfillments,omitempty" url:"fulfillments,omitempty"`
	// A collection of items from sale orders being returned in this one. Normally part of an
	// itemized return or exchange. There is exactly one `Return` object per sale `Order` being
	// referenced.
	Returns []*OrderReturn `json:"returns,omitempty" url:"returns,omitempty"`
	// The rollup of the returned money amounts.
	ReturnAmounts *OrderMoneyAmounts `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`
	// The net money amounts (sale money - return money).
	NetAmounts *OrderMoneyAmounts `json:"net_amounts,omitempty" url:"net_amounts,omitempty"`
	// A positive rounding adjustment to the total of the order. This adjustment is commonly
	// used to apply cash rounding when the minimum unit of account is smaller than the lowest physical
	// denomination of the currency.
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// The tenders that were used to pay for the order.
	Tenders []*Tender `json:"tenders,omitempty" url:"tenders,omitempty"`
	// The refunds that are part of this order.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see  [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The timestamp for when the order was created, at server side, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, at server side, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp for when the order reached a terminal [state](entity:OrderState), in RFC 3339 format (for example "2016-09-04T23:59:33.123Z").
	ClosedAt *string `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	// The current state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The total amount of money to collect for the order.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the order.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to collect for the order.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of tip money to collect for the order.
	TotalTipMoney *Money `json:"total_tip_money,omitempty" url:"total_tip_money,omitempty"`
	// The total amount of money collected in service charges for the order.
	//
	// Note: `total_service_charge_money` is the sum of `applied_money` fields for each individual
	// service charge. Therefore, `total_service_charge_money` only includes inclusive tax amounts,
	// not additive tax amounts.
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`
	// A short-term identifier for the order (such as a customer first name,
	// table number, or auto-generated order number that resets daily).
	TicketName *string `json:"ticket_name,omitempty" url:"ticket_name,omitempty"`
	// Pricing options for an order. The options affect how the order's price is calculated.
	// They can be used, for example, to apply automatic price adjustments that are based on
	// preconfigured [pricing rules](entity:CatalogPricingRule).
	PricingOptions *OrderPricingOptions `json:"pricing_options,omitempty" url:"pricing_options,omitempty"`
	// A set-like list of Rewards that have been added to the Order.
	Rewards []*OrderReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	// The net amount of money due on the order.
	NetAmountDueMoney *Money `json:"net_amount_due_money,omitempty" url:"net_amount_due_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Order) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Order) GetLocationID() string {
	if o == nil {
		return ""
	}
	return o.LocationID
}

func (o *Order) GetReferenceID() *string {
	if o == nil {
		return nil
	}
	return o.ReferenceID
}

func (o *Order) GetSource() *OrderSource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *Order) GetCustomerID() *string {
	if o == nil {
		return nil
	}
	return o.CustomerID
}

func (o *Order) GetLineItems() []*OrderLineItem {
	if o == nil {
		return nil
	}
	return o.LineItems
}

func (o *Order) GetTaxes() []*OrderLineItemTax {
	if o == nil {
		return nil
	}
	return o.Taxes
}

func (o *Order) GetDiscounts() []*OrderLineItemDiscount {
	if o == nil {
		return nil
	}
	return o.Discounts
}

func (o *Order) GetServiceCharges() []*OrderServiceCharge {
	if o == nil {
		return nil
	}
	return o.ServiceCharges
}

func (o *Order) GetFulfillments() []*Fulfillment {
	if o == nil {
		return nil
	}
	return o.Fulfillments
}

func (o *Order) GetReturns() []*OrderReturn {
	if o == nil {
		return nil
	}
	return o.Returns
}

func (o *Order) GetReturnAmounts() *OrderMoneyAmounts {
	if o == nil {
		return nil
	}
	return o.ReturnAmounts
}

func (o *Order) GetNetAmounts() *OrderMoneyAmounts {
	if o == nil {
		return nil
	}
	return o.NetAmounts
}

func (o *Order) GetRoundingAdjustment() *OrderRoundingAdjustment {
	if o == nil {
		return nil
	}
	return o.RoundingAdjustment
}

func (o *Order) GetTenders() []*Tender {
	if o == nil {
		return nil
	}
	return o.Tenders
}

func (o *Order) GetRefunds() []*Refund {
	if o == nil {
		return nil
	}
	return o.Refunds
}

func (o *Order) GetMetadata() map[string]*string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Order) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Order) GetUpdatedAt() *string {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *Order) GetClosedAt() *string {
	if o == nil {
		return nil
	}
	return o.ClosedAt
}

func (o *Order) GetState() *OrderState {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *Order) GetVersion() *int {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *Order) GetTotalMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalMoney
}

func (o *Order) GetTotalTaxMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalTaxMoney
}

func (o *Order) GetTotalDiscountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalDiscountMoney
}

func (o *Order) GetTotalTipMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalTipMoney
}

func (o *Order) GetTotalServiceChargeMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalServiceChargeMoney
}

func (o *Order) GetTicketName() *string {
	if o == nil {
		return nil
	}
	return o.TicketName
}

func (o *Order) GetPricingOptions() *OrderPricingOptions {
	if o == nil {
		return nil
	}
	return o.PricingOptions
}

func (o *Order) GetRewards() []*OrderReward {
	if o == nil {
		return nil
	}
	return o.Rewards
}

func (o *Order) GetNetAmountDueMoney() *Money {
	if o == nil {
		return nil
	}
	return o.NetAmountDueMoney
}

func (o *Order) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Order) UnmarshalJSON(data []byte) error {
	type unmarshaler Order
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Order(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Order) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreated struct {
	// The order's unique ID.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCreated) GetOrderID() *string {
	if o == nil {
		return nil
	}
	return o.OrderID
}

func (o *OrderCreated) GetVersion() *int {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *OrderCreated) GetLocationID() *string {
	if o == nil {
		return nil
	}
	return o.LocationID
}

func (o *OrderCreated) GetState() *OrderState {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *OrderCreated) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCreated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreated(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreated) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an [Order](entity:Order) is created. This event is
// triggered only by the [CreateOrder](api-endpoint:Orders-CreateOrder) endpoint call.
//
// Creating an order in the Point of Sale app will **not** publish this event.
type OrderCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"order.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OrderCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCreatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCreatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCreatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCreatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCreatedEvent) GetData() *OrderCreatedEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCreatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreatedEventData struct {
	// Name of the affected object’s type, `"order_created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected order.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about the created Order.
	Object *OrderCreatedObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCreatedEventData) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCreatedEventData) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OrderCreatedEventData) GetObject() *OrderCreatedObject {
	if o == nil {
		return nil
	}
	return o.Object
}

func (o *OrderCreatedEventData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreatedEventData) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderCreatedObject struct {
	// Information about the created order.
	OrderCreated *OrderCreated `json:"order_created,omitempty" url:"order_created,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCreatedObject) GetOrderCreated() *OrderCreated {
	if o == nil {
		return nil
	}
	return o.OrderCreated
}

func (o *OrderCreatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCreatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCreatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCreatedObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCreatedObject) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute definition](entity:CustomAttributeDefinition) that is owned by the subscribing app is created.
type OrderCustomAttributeDefinitionOwnedCreatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute_definition.owned.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeDefinitionOwnedCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeDefinitionOwnedCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeDefinitionOwnedCreatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute definition](entity:CustomAttributeDefinition) that is owned by the subscribing app is deleted.
type OrderCustomAttributeDefinitionOwnedDeletedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute_definition.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeDefinitionOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeDefinitionOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeDefinitionOwnedDeletedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute definition](entity:CustomAttributeDefinition) that is owned by the subscribing app is updated.
type OrderCustomAttributeDefinitionOwnedUpdatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute_definition.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeDefinitionOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeDefinitionOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeDefinitionOwnedUpdatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute definition](entity:CustomAttributeDefinition) that is visible to the subscribing app is created.
type OrderCustomAttributeDefinitionVisibleCreatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute_definition.visible.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeDefinitionVisibleCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeDefinitionVisibleCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeDefinitionVisibleCreatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute definition](entity:CustomAttributeDefinition) that is visible to the subscribing app is deleted.
type OrderCustomAttributeDefinitionVisibleDeletedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute_definition.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) GetData() *CustomAttributeDefinitionEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeDefinitionVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeDefinitionVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeDefinitionVisibleDeletedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute definition](entity:CustomAttributeDefinition) that is visible to the subscribing app is updated.
type OrderCustomAttributeDefinitionVisibleUpdatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute_definition.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeDefinitionEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) GetData() *CustomAttributeDefinitionEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeDefinitionVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeDefinitionVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeDefinitionVisibleUpdatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute](entity:CustomAttribute) associated with a [custom attribute definition](entity:CustomAttributeDefinition) that is owned by the subscribing app is deleted.
type OrderCustomAttributeOwnedDeletedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute.owned.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeOwnedDeletedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeOwnedDeletedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeOwnedDeletedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeOwnedDeletedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeOwnedDeletedEvent) GetData() *CustomAttributeEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeOwnedDeletedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeOwnedDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeOwnedDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeOwnedDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeOwnedDeletedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute](entity:CustomAttribute) associated with a [custom attribute definition](entity:CustomAttributeDefinition) that is owned by the subscribing app is updated.
type OrderCustomAttributeOwnedUpdatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute.owned.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) GetData() *CustomAttributeEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeOwnedUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeOwnedUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeOwnedUpdatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute](entity:CustomAttribute) that is visible to the subscribing app is deleted.
type OrderCustomAttributeVisibleDeletedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute.visible.deleted"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeVisibleDeletedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeVisibleDeletedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeVisibleDeletedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeVisibleDeletedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeVisibleDeletedEvent) GetData() *CustomAttributeEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeVisibleDeletedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeVisibleDeletedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeVisibleDeletedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeVisibleDeletedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeVisibleDeletedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an order [custom attribute](entity:CustomAttribute) that is visible to the subscribing app is updated.
type OrderCustomAttributeVisibleUpdatedEvent struct {
	// The ID of the target seller associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of this event. The value is `"order.custom_attribute.visible.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with the event.
	Data *CustomAttributeEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) GetData() *CustomAttributeEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderCustomAttributeVisibleUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderCustomAttributeVisibleUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderCustomAttributeVisibleUpdatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The schedule type of the delivery fulfillment.
type OrderFulfillmentDeliveryDetailsScheduleType string

const (
	OrderFulfillmentDeliveryDetailsScheduleTypeScheduled OrderFulfillmentDeliveryDetailsScheduleType = "SCHEDULED"
	OrderFulfillmentDeliveryDetailsScheduleTypeAsap      OrderFulfillmentDeliveryDetailsScheduleType = "ASAP"
)

func NewOrderFulfillmentDeliveryDetailsScheduleTypeFromString(s string) (OrderFulfillmentDeliveryDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return OrderFulfillmentDeliveryDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return OrderFulfillmentDeliveryDetailsScheduleTypeAsap, nil
	}
	var t OrderFulfillmentDeliveryDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentDeliveryDetailsScheduleType) Ptr() *OrderFulfillmentDeliveryDetailsScheduleType {
	return &o
}

// The `line_item_application` describes what order line items this fulfillment applies
// to. It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
type OrderFulfillmentFulfillmentLineItemApplication string

const (
	OrderFulfillmentFulfillmentLineItemApplicationAll       OrderFulfillmentFulfillmentLineItemApplication = "ALL"
	OrderFulfillmentFulfillmentLineItemApplicationEntryList OrderFulfillmentFulfillmentLineItemApplication = "ENTRY_LIST"
)

func NewOrderFulfillmentFulfillmentLineItemApplicationFromString(s string) (OrderFulfillmentFulfillmentLineItemApplication, error) {
	switch s {
	case "ALL":
		return OrderFulfillmentFulfillmentLineItemApplicationAll, nil
	case "ENTRY_LIST":
		return OrderFulfillmentFulfillmentLineItemApplicationEntryList, nil
	}
	var t OrderFulfillmentFulfillmentLineItemApplication
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentFulfillmentLineItemApplication) Ptr() *OrderFulfillmentFulfillmentLineItemApplication {
	return &o
}

// The schedule type of the pickup fulfillment.
type OrderFulfillmentPickupDetailsScheduleType string

const (
	OrderFulfillmentPickupDetailsScheduleTypeScheduled OrderFulfillmentPickupDetailsScheduleType = "SCHEDULED"
	OrderFulfillmentPickupDetailsScheduleTypeAsap      OrderFulfillmentPickupDetailsScheduleType = "ASAP"
)

func NewOrderFulfillmentPickupDetailsScheduleTypeFromString(s string) (OrderFulfillmentPickupDetailsScheduleType, error) {
	switch s {
	case "SCHEDULED":
		return OrderFulfillmentPickupDetailsScheduleTypeScheduled, nil
	case "ASAP":
		return OrderFulfillmentPickupDetailsScheduleTypeAsap, nil
	}
	var t OrderFulfillmentPickupDetailsScheduleType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentPickupDetailsScheduleType) Ptr() *OrderFulfillmentPickupDetailsScheduleType {
	return &o
}

// The current state of this fulfillment.
type OrderFulfillmentState string

const (
	OrderFulfillmentStateProposed  OrderFulfillmentState = "PROPOSED"
	OrderFulfillmentStateReserved  OrderFulfillmentState = "RESERVED"
	OrderFulfillmentStatePrepared  OrderFulfillmentState = "PREPARED"
	OrderFulfillmentStateCompleted OrderFulfillmentState = "COMPLETED"
	OrderFulfillmentStateCanceled  OrderFulfillmentState = "CANCELED"
	OrderFulfillmentStateFailed    OrderFulfillmentState = "FAILED"
)

func NewOrderFulfillmentStateFromString(s string) (OrderFulfillmentState, error) {
	switch s {
	case "PROPOSED":
		return OrderFulfillmentStateProposed, nil
	case "RESERVED":
		return OrderFulfillmentStateReserved, nil
	case "PREPARED":
		return OrderFulfillmentStatePrepared, nil
	case "COMPLETED":
		return OrderFulfillmentStateCompleted, nil
	case "CANCELED":
		return OrderFulfillmentStateCanceled, nil
	case "FAILED":
		return OrderFulfillmentStateFailed, nil
	}
	var t OrderFulfillmentState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentState) Ptr() *OrderFulfillmentState {
	return &o
}

// The type of fulfillment.
type OrderFulfillmentType string

const (
	OrderFulfillmentTypePickup   OrderFulfillmentType = "PICKUP"
	OrderFulfillmentTypeShipment OrderFulfillmentType = "SHIPMENT"
	OrderFulfillmentTypeDelivery OrderFulfillmentType = "DELIVERY"
)

func NewOrderFulfillmentTypeFromString(s string) (OrderFulfillmentType, error) {
	switch s {
	case "PICKUP":
		return OrderFulfillmentTypePickup, nil
	case "SHIPMENT":
		return OrderFulfillmentTypeShipment, nil
	case "DELIVERY":
		return OrderFulfillmentTypeDelivery, nil
	}
	var t OrderFulfillmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentType) Ptr() *OrderFulfillmentType {
	return &o
}

type OrderFulfillmentUpdated struct {
	// The order's unique ID.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The fulfillments that were updated with this version change.
	FulfillmentUpdate []*OrderFulfillmentUpdatedUpdate `json:"fulfillment_update,omitempty" url:"fulfillment_update,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderFulfillmentUpdated) GetOrderID() *string {
	if o == nil {
		return nil
	}
	return o.OrderID
}

func (o *OrderFulfillmentUpdated) GetVersion() *int {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *OrderFulfillmentUpdated) GetLocationID() *string {
	if o == nil {
		return nil
	}
	return o.LocationID
}

func (o *OrderFulfillmentUpdated) GetState() *OrderState {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *OrderFulfillmentUpdated) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderFulfillmentUpdated) GetUpdatedAt() *string {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *OrderFulfillmentUpdated) GetFulfillmentUpdate() []*OrderFulfillmentUpdatedUpdate {
	if o == nil {
		return nil
	}
	return o.FulfillmentUpdate
}

func (o *OrderFulfillmentUpdated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdated(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdated) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an [OrderFulfillment](entity:OrderFulfillment)
// is created or updated. This event is triggered only by the
// [UpdateOrder](api-endpoint:Orders-UpdateOrder) endpoint call.
type OrderFulfillmentUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"order.fulfillment.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OrderFulfillmentUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderFulfillmentUpdatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderFulfillmentUpdatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderFulfillmentUpdatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderFulfillmentUpdatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderFulfillmentUpdatedEvent) GetData() *OrderFulfillmentUpdatedEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderFulfillmentUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderFulfillmentUpdatedEventData struct {
	// Name of the affected object’s type, `"order_fulfillment_updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected order.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about the updated Order.
	Object *OrderFulfillmentUpdatedObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderFulfillmentUpdatedEventData) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderFulfillmentUpdatedEventData) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OrderFulfillmentUpdatedEventData) GetObject() *OrderFulfillmentUpdatedObject {
	if o == nil {
		return nil
	}
	return o.Object
}

func (o *OrderFulfillmentUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedEventData) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderFulfillmentUpdatedObject struct {
	// Information about the updated order fulfillment.
	OrderFulfillmentUpdated *OrderFulfillmentUpdated `json:"order_fulfillment_updated,omitempty" url:"order_fulfillment_updated,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderFulfillmentUpdatedObject) GetOrderFulfillmentUpdated() *OrderFulfillmentUpdated {
	if o == nil {
		return nil
	}
	return o.OrderFulfillmentUpdated
}

func (o *OrderFulfillmentUpdatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedObject) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Information about fulfillment updates.
type OrderFulfillmentUpdatedUpdate struct {
	// A unique ID that identifies the fulfillment only within this order.
	FulfillmentUID *string `json:"fulfillment_uid,omitempty" url:"fulfillment_uid,omitempty"`
	// The state of the fulfillment before the change.
	// The state is not populated if the fulfillment is created with this new `Order` version.
	OldState *FulfillmentState `json:"old_state,omitempty" url:"old_state,omitempty"`
	// The state of the fulfillment after the change. The state might be equal to `old_state` if a non-state
	// field was changed on the fulfillment (such as the tracking number).
	NewState *FulfillmentState `json:"new_state,omitempty" url:"new_state,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderFulfillmentUpdatedUpdate) GetFulfillmentUID() *string {
	if o == nil {
		return nil
	}
	return o.FulfillmentUID
}

func (o *OrderFulfillmentUpdatedUpdate) GetOldState() *FulfillmentState {
	if o == nil {
		return nil
	}
	return o.OldState
}

func (o *OrderFulfillmentUpdatedUpdate) GetNewState() *FulfillmentState {
	if o == nil {
		return nil
	}
	return o.NewState
}

func (o *OrderFulfillmentUpdatedUpdate) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentUpdatedUpdate) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentUpdatedUpdate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentUpdatedUpdate(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentUpdatedUpdate) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a line item in an order. Each line item describes a different
// product to purchase, with its own quantity and price details.
type OrderLineItem struct {
	// A unique ID that identifies the line item only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The count, or measurement, of a line item being purchased:
	//
	// If `quantity` is a whole number, and `quantity_unit` is not specified, then `quantity` denotes an item count.  For example: `3` apples.
	//
	// If `quantity` is a whole or decimal number, and `quantity_unit` is also specified, then `quantity` denotes a measurement.  For example: `2.25` pounds of broccoli.
	//
	// For more information, see [Specify item quantity and measurement unit](https://developer.squareup.com/docs/orders-api/create-orders#specify-item-quantity-and-measurement-unit).
	//
	// Line items with a quantity of `0` are automatically removed
	// when paying for or otherwise completing the order.
	Quantity string `json:"quantity" url:"quantity"`
	// The measurement unit and decimal precision that this line item's quantity is measured in.
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// An optional note associated with the line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this line item.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this line item.
	VariationName *string `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	// The type of line item: an itemized sale, a non-itemized sale (custom amount), or the
	// activation or reloading of a gift card.
	// See [OrderLineItemItemType](#type-orderlineitemitemtype) for possible values
	ItemType *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// Application-defined data attached to this line item. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	Modifiers []*OrderLineItemModifier `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The list of references to taxes applied to this line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a
	// top-level `OrderLineItemTax` applied to the line item. On reads, the
	// amount applied is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every line
	// item for all `ORDER` scoped taxes added to the order. `OrderLineItemAppliedTax`
	// records for `LINE_ITEM` scoped taxes must be added in requests for the tax
	// to apply to any line items.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to discounts applied to this line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderLineItemDiscounts` applied to the line item. On reads, the amount
	// applied is populated.
	//
	// An `OrderLineItemAppliedDiscount` is automatically created on every line item for all
	// `ORDER` scoped discounts that are added to the order. `OrderLineItemAppliedDiscount` records
	// for `LINE_ITEM` scoped discounts must be added in requests for the discount to apply to any
	// line items.
	//
	// To change the amount of a discount, modify the referenced top-level discount.
	AppliedDiscounts []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	// The list of references to service charges applied to this line item. Each
	// `OrderLineItemAppliedServiceCharge` has a `service_charge_id` that references the `uid` of a
	// top-level `OrderServiceCharge` applied to the line item. On reads, the amount applied is
	// populated.
	//
	// To change the amount of a service charge, modify the referenced top-level service charge.
	AppliedServiceCharges []*OrderLineItemAppliedServiceCharge `json:"applied_service_charges,omitempty" url:"applied_service_charges,omitempty"`
	// The base price for a single unit of the line item.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of all item variations sold in this line item.
	// The price is calculated as `base_price_money` multiplied by `quantity`.
	// It does not include modifiers.
	VariationTotalPriceMoney *Money `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	// The amount of money made in gross sales for this line item.
	// The amount is calculated as the sum of the variation's total price and each modifier's total price.
	// For inclusive tax items in the US, Canada, and Japan, tax is deducted from `gross_sales_money`. For Europe and
	// Australia, inclusive tax remains as part of the gross sale calculation.
	GrossSalesMoney *Money `json:"gross_sales_money,omitempty" url:"gross_sales_money,omitempty"`
	// The total amount of tax money to collect for the line item.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to collect for the line item.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of money to collect for this line item.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// Describes pricing adjustments that are blocked from automatic
	// application to a line item. For more information, see
	// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
	PricingBlocklists *OrderLineItemPricingBlocklists `json:"pricing_blocklists,omitempty" url:"pricing_blocklists,omitempty"`
	// The total amount of apportioned service charge money to collect for the line item.
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItem) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItem) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderLineItem) GetQuantity() string {
	if o == nil {
		return ""
	}
	return o.Quantity
}

func (o *OrderLineItem) GetQuantityUnit() *OrderQuantityUnit {
	if o == nil {
		return nil
	}
	return o.QuantityUnit
}

func (o *OrderLineItem) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *OrderLineItem) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderLineItem) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderLineItem) GetVariationName() *string {
	if o == nil {
		return nil
	}
	return o.VariationName
}

func (o *OrderLineItem) GetItemType() *OrderLineItemItemType {
	if o == nil {
		return nil
	}
	return o.ItemType
}

func (o *OrderLineItem) GetMetadata() map[string]*string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *OrderLineItem) GetModifiers() []*OrderLineItemModifier {
	if o == nil {
		return nil
	}
	return o.Modifiers
}

func (o *OrderLineItem) GetAppliedTaxes() []*OrderLineItemAppliedTax {
	if o == nil {
		return nil
	}
	return o.AppliedTaxes
}

func (o *OrderLineItem) GetAppliedDiscounts() []*OrderLineItemAppliedDiscount {
	if o == nil {
		return nil
	}
	return o.AppliedDiscounts
}

func (o *OrderLineItem) GetAppliedServiceCharges() []*OrderLineItemAppliedServiceCharge {
	if o == nil {
		return nil
	}
	return o.AppliedServiceCharges
}

func (o *OrderLineItem) GetBasePriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.BasePriceMoney
}

func (o *OrderLineItem) GetVariationTotalPriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.VariationTotalPriceMoney
}

func (o *OrderLineItem) GetGrossSalesMoney() *Money {
	if o == nil {
		return nil
	}
	return o.GrossSalesMoney
}

func (o *OrderLineItem) GetTotalTaxMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalTaxMoney
}

func (o *OrderLineItem) GetTotalDiscountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalDiscountMoney
}

func (o *OrderLineItem) GetTotalMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalMoney
}

func (o *OrderLineItem) GetPricingBlocklists() *OrderLineItemPricingBlocklists {
	if o == nil {
		return nil
	}
	return o.PricingBlocklists
}

func (o *OrderLineItem) GetTotalServiceChargeMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalServiceChargeMoney
}

func (o *OrderLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItem) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a discount to a line item in an order.
//
// Order scoped discounts have automatically applied discounts present for each line item.
// Line-item scoped discounts must have applied discounts added manually for any applicable line
// items. The corresponding applied money is automatically computed based on participating
// line items.
type OrderLineItemAppliedDiscount struct {
	// A unique ID that identifies the applied discount only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that the applied discount represents. It must
	// reference a discount present in the `order.discounts` field.
	//
	// This field is immutable. To change which discounts apply to a line item,
	// you must delete the discount and re-add it as a new `OrderLineItemAppliedDiscount`.
	DiscountUID string `json:"discount_uid" url:"discount_uid"`
	// The amount of money applied by the discount to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemAppliedDiscount) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemAppliedDiscount) GetDiscountUID() string {
	if o == nil {
		return ""
	}
	return o.DiscountUID
}

func (o *OrderLineItemAppliedDiscount) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderLineItemAppliedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedDiscount) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderLineItemAppliedServiceCharge struct {
	// A unique ID that identifies the applied service charge only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the service charge that the applied service charge represents. It must
	// reference a service charge present in the `order.service_charges` field.
	//
	// This field is immutable. To change which service charges apply to a line item,
	// delete and add a new `OrderLineItemAppliedServiceCharge`.
	ServiceChargeUID string `json:"service_charge_uid" url:"service_charge_uid"`
	// The amount of money applied by the service charge to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemAppliedServiceCharge) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemAppliedServiceCharge) GetServiceChargeUID() string {
	if o == nil {
		return ""
	}
	return o.ServiceChargeUID
}

func (o *OrderLineItemAppliedServiceCharge) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderLineItemAppliedServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedServiceCharge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedServiceCharge) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a tax to a line item in an order.
//
// Order-scoped taxes automatically include the applied taxes in each line item.
// Line item taxes must be referenced from any applicable line items.
// The corresponding applied money is automatically computed, based on the
// set of participating line items.
type OrderLineItemAppliedTax struct {
	// A unique ID that identifies the applied tax only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax for which this applied tax represents. It must reference
	// a tax present in the `order.taxes` field.
	//
	// This field is immutable. To change which taxes apply to a line item, delete and add a new
	// `OrderLineItemAppliedTax`.
	TaxUID string `json:"tax_uid" url:"tax_uid"`
	// The amount of money applied by the tax to the line item.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemAppliedTax) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemAppliedTax) GetTaxUID() string {
	if o == nil {
		return ""
	}
	return o.TaxUID
}

func (o *OrderLineItemAppliedTax) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderLineItemAppliedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedTax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedTax) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount that applies to one or more line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the
// amount contributed by the item to the order subtotal.
type OrderLineItemDiscount struct {
	// A unique ID that identifies the discount only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The type of the discount.
	//
	// Discounts that do not reference a catalog object ID must have a type of
	// `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	// See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the discount, as a string representation of a decimal number.
	// A value of `7.25` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The total declared monetary amount of the discount.
	//
	// `amount_money` is not set for percentage-based discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of discount actually applied to the line item.
	//
	// The amount represents the amount of money applied as a line-item scoped discount.
	// When an amount-based discount is scoped to the entire order, the value
	// of `applied_money` is different than `amount_money` because the total
	// amount of the discount is distributed across all line items.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Application-defined data attached to this discount. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// Indicates the level at which the discount applies. For `ORDER` scoped discounts,
	// Square generates references in `applied_discounts` on all order line items that do
	// not have them. For `LINE_ITEM` scoped discounts, the discount only applies to line items
	// with a discount reference in their `applied_discounts` field.
	//
	// This field is immutable. To change the scope of a discount, you must delete
	// the discount and re-add it as a new discount.
	// See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
	Scope *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`
	// The reward IDs corresponding to this discount. The application and
	// specification of discounts that have `reward_ids` are completely controlled by the backing
	// criteria corresponding to the reward tiers of the rewards that are added to the order
	// through the Loyalty API. To manually unapply discounts that are the result of added rewards,
	// the rewards must be removed from the order through the Loyalty API.
	RewardIDs []string `json:"reward_ids,omitempty" url:"reward_ids,omitempty"`
	// The object ID of a [pricing rule](entity:CatalogPricingRule) to be applied
	// automatically to this discount. The specification and application of the discounts, to
	// which a `pricing_rule_id` is assigned, are completely controlled by the corresponding
	// pricing rule.
	PricingRuleID *string `json:"pricing_rule_id,omitempty" url:"pricing_rule_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemDiscount) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemDiscount) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderLineItemDiscount) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderLineItemDiscount) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderLineItemDiscount) GetType() *OrderLineItemDiscountType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderLineItemDiscount) GetPercentage() *string {
	if o == nil {
		return nil
	}
	return o.Percentage
}

func (o *OrderLineItemDiscount) GetAmountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AmountMoney
}

func (o *OrderLineItemDiscount) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderLineItemDiscount) GetMetadata() map[string]*string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *OrderLineItemDiscount) GetScope() *OrderLineItemDiscountScope {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OrderLineItemDiscount) GetRewardIDs() []string {
	if o == nil {
		return nil
	}
	return o.RewardIDs
}

func (o *OrderLineItemDiscount) GetPricingRuleID() *string {
	if o == nil {
		return nil
	}
	return o.PricingRuleID
}

func (o *OrderLineItemDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemDiscount) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level discount.
type OrderLineItemDiscountScope string

const (
	OrderLineItemDiscountScopeOtherDiscountScope OrderLineItemDiscountScope = "OTHER_DISCOUNT_SCOPE"
	OrderLineItemDiscountScopeLineItem           OrderLineItemDiscountScope = "LINE_ITEM"
	OrderLineItemDiscountScopeOrder              OrderLineItemDiscountScope = "ORDER"
)

func NewOrderLineItemDiscountScopeFromString(s string) (OrderLineItemDiscountScope, error) {
	switch s {
	case "OTHER_DISCOUNT_SCOPE":
		return OrderLineItemDiscountScopeOtherDiscountScope, nil
	case "LINE_ITEM":
		return OrderLineItemDiscountScopeLineItem, nil
	case "ORDER":
		return OrderLineItemDiscountScopeOrder, nil
	}
	var t OrderLineItemDiscountScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountScope) Ptr() *OrderLineItemDiscountScope {
	return &o
}

// Indicates how the discount is applied to the associated line item or order.
type OrderLineItemDiscountType string

const (
	OrderLineItemDiscountTypeUnknownDiscount    OrderLineItemDiscountType = "UNKNOWN_DISCOUNT"
	OrderLineItemDiscountTypeFixedPercentage    OrderLineItemDiscountType = "FIXED_PERCENTAGE"
	OrderLineItemDiscountTypeFixedAmount        OrderLineItemDiscountType = "FIXED_AMOUNT"
	OrderLineItemDiscountTypeVariablePercentage OrderLineItemDiscountType = "VARIABLE_PERCENTAGE"
	OrderLineItemDiscountTypeVariableAmount     OrderLineItemDiscountType = "VARIABLE_AMOUNT"
)

func NewOrderLineItemDiscountTypeFromString(s string) (OrderLineItemDiscountType, error) {
	switch s {
	case "UNKNOWN_DISCOUNT":
		return OrderLineItemDiscountTypeUnknownDiscount, nil
	case "FIXED_PERCENTAGE":
		return OrderLineItemDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return OrderLineItemDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return OrderLineItemDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return OrderLineItemDiscountTypeVariableAmount, nil
	}
	var t OrderLineItemDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountType) Ptr() *OrderLineItemDiscountType {
	return &o
}

// Represents the line item type.
type OrderLineItemItemType string

const (
	OrderLineItemItemTypeItem         OrderLineItemItemType = "ITEM"
	OrderLineItemItemTypeCustomAmount OrderLineItemItemType = "CUSTOM_AMOUNT"
	OrderLineItemItemTypeGiftCard     OrderLineItemItemType = "GIFT_CARD"
)

func NewOrderLineItemItemTypeFromString(s string) (OrderLineItemItemType, error) {
	switch s {
	case "ITEM":
		return OrderLineItemItemTypeItem, nil
	case "CUSTOM_AMOUNT":
		return OrderLineItemItemTypeCustomAmount, nil
	case "GIFT_CARD":
		return OrderLineItemItemTypeGiftCard, nil
	}
	var t OrderLineItemItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemItemType) Ptr() *OrderLineItemItemType {
	return &o
}

// A [CatalogModifier](entity:CatalogModifier).
type OrderLineItemModifier struct {
	// A unique ID that identifies the modifier only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity of the line item modifier. The modifier quantity can be 0 or more.
	// For example, suppose a restaurant offers a cheeseburger on the menu. When a buyer orders
	// this item, the restaurant records the purchase by creating an `Order` object with a line item
	// for a burger. The line item includes a line item modifier: the name is cheese and the quantity
	// is 1. The buyer has the option to order extra cheese (or no cheese). If the buyer chooses
	// the extra cheese option, the modifier quantity increases to 2. If the buyer does not want
	// any cheese, the modifier quantity is set to 0.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	// The base price for the modifier.
	//
	// `base_price_money` is required for ad hoc modifiers.
	// If both `catalog_object_id` and `base_price_money` are set, `base_price_money` will
	// override the predefined [CatalogModifier](entity:CatalogModifier) price.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of the item modifier for its line item.
	// This is the modifier's `base_price_money` multiplied by the line item's quantity.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see  [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemModifier) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemModifier) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderLineItemModifier) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderLineItemModifier) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderLineItemModifier) GetQuantity() *string {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OrderLineItemModifier) GetBasePriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.BasePriceMoney
}

func (o *OrderLineItemModifier) GetTotalPriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalPriceMoney
}

func (o *OrderLineItemModifier) GetMetadata() map[string]*string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *OrderLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemModifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemModifier) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Describes pricing adjustments that are blocked from automatic
// application to a line item. For more information, see
// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
type OrderLineItemPricingBlocklists struct {
	// A list of discounts blocked from applying to the line item.
	// Discounts can be blocked by the `discount_uid` (for ad hoc discounts) or
	// the `discount_catalog_object_id` (for catalog discounts).
	BlockedDiscounts []*OrderLineItemPricingBlocklistsBlockedDiscount `json:"blocked_discounts,omitempty" url:"blocked_discounts,omitempty"`
	// A list of taxes blocked from applying to the line item.
	// Taxes can be blocked by the `tax_uid` (for ad hoc taxes) or
	// the `tax_catalog_object_id` (for catalog taxes).
	BlockedTaxes []*OrderLineItemPricingBlocklistsBlockedTax `json:"blocked_taxes,omitempty" url:"blocked_taxes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemPricingBlocklists) GetBlockedDiscounts() []*OrderLineItemPricingBlocklistsBlockedDiscount {
	if o == nil {
		return nil
	}
	return o.BlockedDiscounts
}

func (o *OrderLineItemPricingBlocklists) GetBlockedTaxes() []*OrderLineItemPricingBlocklistsBlockedTax {
	if o == nil {
		return nil
	}
	return o.BlockedTaxes
}

func (o *OrderLineItemPricingBlocklists) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklists) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklists
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklists(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklists) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A discount to block from applying to a line item. The discount must be
// identified by either `discount_uid` or `discount_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedDiscount struct {
	// A unique ID of the `BlockedDiscount` within the order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that should be blocked. Use this field to block
	// ad hoc discounts. For catalog discounts, use the `discount_catalog_object_id` field.
	DiscountUID *string `json:"discount_uid,omitempty" url:"discount_uid,omitempty"`
	// The `catalog_object_id` of the discount that should be blocked.
	// Use this field to block catalog discounts. For ad hoc discounts, use the
	// `discount_uid` field.
	DiscountCatalogObjectID *string `json:"discount_catalog_object_id,omitempty" url:"discount_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetDiscountUID() *string {
	if o == nil {
		return nil
	}
	return o.DiscountUID
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetDiscountCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.DiscountCatalogObjectID
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A tax to block from applying to a line item. The tax must be
// identified by either `tax_uid` or `tax_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedTax struct {
	// A unique ID of the `BlockedTax` within the order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax that should be blocked. Use this field to block
	// ad hoc taxes. For catalog, taxes use the `tax_catalog_object_id` field.
	TaxUID *string `json:"tax_uid,omitempty" url:"tax_uid,omitempty"`
	// The `catalog_object_id` of the tax that should be blocked.
	// Use this field to block catalog taxes. For ad hoc taxes, use the
	// `tax_uid` field.
	TaxCatalogObjectID *string `json:"tax_catalog_object_id,omitempty" url:"tax_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetTaxUID() *string {
	if o == nil {
		return nil
	}
	return o.TaxUID
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetTaxCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.TaxCatalogObjectID
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedTax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax that applies to one or more line item in the order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the amount the item
// contributes to the order subtotal.
type OrderLineItemTax struct {
	// A unique ID that identifies the tax only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates the calculation method used to apply the tax.
	// See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal
	// number. For example, a value of `"7.25"` corresponds to a percentage of
	// 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// Application-defined data attached to this tax. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The amount of money applied to the order by the tax.
	//
	// - For percentage-based taxes, `applied_money` is the money
	// calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the tax applies. For `ORDER` scoped taxes,
	// Square generates references in `applied_taxes` on all order line items that do
	// not have them. For `LINE_ITEM` scoped taxes, the tax only applies to line items
	// with references in their `applied_taxes` field.
	//
	// This field is immutable. To change the scope, you must delete the tax and
	// re-add it as a new tax.
	// See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
	Scope *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`
	// Determines whether the tax was automatically applied to the order based on
	// the catalog configuration. For an example, see
	// [Automatically Apply Taxes to an Order](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts/auto-apply-taxes).
	AutoApplied *bool `json:"auto_applied,omitempty" url:"auto_applied,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderLineItemTax) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderLineItemTax) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderLineItemTax) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderLineItemTax) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderLineItemTax) GetType() *OrderLineItemTaxType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderLineItemTax) GetPercentage() *string {
	if o == nil {
		return nil
	}
	return o.Percentage
}

func (o *OrderLineItemTax) GetMetadata() map[string]*string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *OrderLineItemTax) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderLineItemTax) GetScope() *OrderLineItemTaxScope {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OrderLineItemTax) GetAutoApplied() *bool {
	if o == nil {
		return nil
	}
	return o.AutoApplied
}

func (o *OrderLineItemTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemTax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemTax) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level tax.
type OrderLineItemTaxScope string

const (
	OrderLineItemTaxScopeOtherTaxScope OrderLineItemTaxScope = "OTHER_TAX_SCOPE"
	OrderLineItemTaxScopeLineItem      OrderLineItemTaxScope = "LINE_ITEM"
	OrderLineItemTaxScopeOrder         OrderLineItemTaxScope = "ORDER"
)

func NewOrderLineItemTaxScopeFromString(s string) (OrderLineItemTaxScope, error) {
	switch s {
	case "OTHER_TAX_SCOPE":
		return OrderLineItemTaxScopeOtherTaxScope, nil
	case "LINE_ITEM":
		return OrderLineItemTaxScopeLineItem, nil
	case "ORDER":
		return OrderLineItemTaxScopeOrder, nil
	}
	var t OrderLineItemTaxScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxScope) Ptr() *OrderLineItemTaxScope {
	return &o
}

// Indicates how the tax is applied to the associated line item or order.
type OrderLineItemTaxType string

const (
	OrderLineItemTaxTypeUnknownTax OrderLineItemTaxType = "UNKNOWN_TAX"
	OrderLineItemTaxTypeAdditive   OrderLineItemTaxType = "ADDITIVE"
	OrderLineItemTaxTypeInclusive  OrderLineItemTaxType = "INCLUSIVE"
)

func NewOrderLineItemTaxTypeFromString(s string) (OrderLineItemTaxType, error) {
	switch s {
	case "UNKNOWN_TAX":
		return OrderLineItemTaxTypeUnknownTax, nil
	case "ADDITIVE":
		return OrderLineItemTaxTypeAdditive, nil
	case "INCLUSIVE":
		return OrderLineItemTaxTypeInclusive, nil
	}
	var t OrderLineItemTaxType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxType) Ptr() *OrderLineItemTaxType {
	return &o
}

// A collection of various money amounts.
type OrderMoneyAmounts struct {
	// The total money.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The money associated with taxes.
	TaxMoney *Money `json:"tax_money,omitempty" url:"tax_money,omitempty"`
	// The money associated with discounts.
	DiscountMoney *Money `json:"discount_money,omitempty" url:"discount_money,omitempty"`
	// The money associated with tips.
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The money associated with service charges.
	ServiceChargeMoney *Money `json:"service_charge_money,omitempty" url:"service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderMoneyAmounts) GetTotalMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalMoney
}

func (o *OrderMoneyAmounts) GetTaxMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TaxMoney
}

func (o *OrderMoneyAmounts) GetDiscountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.DiscountMoney
}

func (o *OrderMoneyAmounts) GetTipMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TipMoney
}

func (o *OrderMoneyAmounts) GetServiceChargeMoney() *Money {
	if o == nil {
		return nil
	}
	return o.ServiceChargeMoney
}

func (o *OrderMoneyAmounts) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderMoneyAmounts) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderMoneyAmounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderMoneyAmounts(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderMoneyAmounts) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Pricing options for an order. The options affect how the order's price is calculated.
// They can be used, for example, to apply automatic price adjustments that are based on preconfigured
// [pricing rules](entity:CatalogPricingRule).
type OrderPricingOptions struct {
	// The option to determine whether pricing rule-based
	// discounts are automatically applied to an order.
	AutoApplyDiscounts *bool `json:"auto_apply_discounts,omitempty" url:"auto_apply_discounts,omitempty"`
	// The option to determine whether rule-based taxes are automatically
	// applied to an order when the criteria of the corresponding rules are met.
	AutoApplyTaxes *bool `json:"auto_apply_taxes,omitempty" url:"auto_apply_taxes,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderPricingOptions) GetAutoApplyDiscounts() *bool {
	if o == nil {
		return nil
	}
	return o.AutoApplyDiscounts
}

func (o *OrderPricingOptions) GetAutoApplyTaxes() *bool {
	if o == nil {
		return nil
	}
	return o.AutoApplyTaxes
}

func (o *OrderPricingOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderPricingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderPricingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderPricingOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderPricingOptions) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the measurement unit for a quantity and a precision that
// specifies the number of digits after the decimal point for decimal quantities.
type OrderQuantityUnit struct {
	// A [MeasurementUnit](entity:MeasurementUnit) that represents the
	// unit of measure for the quantity.
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// For non-integer quantities, represents the number of digits after the decimal point that are
	// recorded for this quantity.
	//
	// For example, a precision of 1 allows quantities such as `"1.0"` and `"1.1"`, but not `"1.01"`.
	//
	// Min: 0. Max: 5.
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`
	// The catalog object ID referencing the
	// [CatalogMeasurementUnit](entity:CatalogMeasurementUnit).
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this measurement unit references.
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderQuantityUnit) GetMeasurementUnit() *MeasurementUnit {
	if o == nil {
		return nil
	}
	return o.MeasurementUnit
}

func (o *OrderQuantityUnit) GetPrecision() *int {
	if o == nil {
		return nil
	}
	return o.Precision
}

func (o *OrderQuantityUnit) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderQuantityUnit) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderQuantityUnit) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderQuantityUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderQuantityUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderQuantityUnit(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderQuantityUnit) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The set of line items, service charges, taxes, discounts, tips, and other items being returned in an order.
type OrderReturn struct {
	// A unique ID that identifies the return only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An order that contains the original sale of these return line items. This is unset
	// for unlinked returns.
	SourceOrderID *string `json:"source_order_id,omitempty" url:"source_order_id,omitempty"`
	// A collection of line items that are being returned.
	ReturnLineItems []*OrderReturnLineItem `json:"return_line_items,omitempty" url:"return_line_items,omitempty"`
	// A collection of service charges that are being returned.
	ReturnServiceCharges []*OrderReturnServiceCharge `json:"return_service_charges,omitempty" url:"return_service_charges,omitempty"`
	// A collection of references to taxes being returned for an order, including the total
	// applied tax amount to be returned. The taxes must reference a top-level tax ID from the source
	// order.
	ReturnTaxes []*OrderReturnTax `json:"return_taxes,omitempty" url:"return_taxes,omitempty"`
	// A collection of references to discounts being returned for an order, including the total
	// applied discount amount to be returned. The discounts must reference a top-level discount ID
	// from the source order.
	ReturnDiscounts []*OrderReturnDiscount `json:"return_discounts,omitempty" url:"return_discounts,omitempty"`
	// A collection of references to tips being returned for an order.
	ReturnTips []*OrderReturnTip `json:"return_tips,omitempty" url:"return_tips,omitempty"`
	// A positive or negative rounding adjustment to the total value being returned. Adjustments are commonly
	// used to apply cash rounding when the minimum unit of the account is smaller than the lowest
	// physical denomination of the currency.
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// An aggregate monetary value being returned by this return entry.
	ReturnAmounts *OrderMoneyAmounts `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReturn) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderReturn) GetSourceOrderID() *string {
	if o == nil {
		return nil
	}
	return o.SourceOrderID
}

func (o *OrderReturn) GetReturnLineItems() []*OrderReturnLineItem {
	if o == nil {
		return nil
	}
	return o.ReturnLineItems
}

func (o *OrderReturn) GetReturnServiceCharges() []*OrderReturnServiceCharge {
	if o == nil {
		return nil
	}
	return o.ReturnServiceCharges
}

func (o *OrderReturn) GetReturnTaxes() []*OrderReturnTax {
	if o == nil {
		return nil
	}
	return o.ReturnTaxes
}

func (o *OrderReturn) GetReturnDiscounts() []*OrderReturnDiscount {
	if o == nil {
		return nil
	}
	return o.ReturnDiscounts
}

func (o *OrderReturn) GetReturnTips() []*OrderReturnTip {
	if o == nil {
		return nil
	}
	return o.ReturnTips
}

func (o *OrderReturn) GetRoundingAdjustment() *OrderRoundingAdjustment {
	if o == nil {
		return nil
	}
	return o.RoundingAdjustment
}

func (o *OrderReturn) GetReturnAmounts() *OrderMoneyAmounts {
	if o == nil {
		return nil
	}
	return o.ReturnAmounts
}

func (o *OrderReturn) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturn) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturn(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturn) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount being returned that applies to one or more return line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnDiscount struct {
	// A unique ID that identifies the returned discount only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The discount `uid` from the order that contains the original application of this discount.
	SourceDiscountUID *string `json:"source_discount_uid,omitempty" url:"source_discount_uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The type of the discount. If it is created by the API, it is `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	//
	// Discounts that do not reference a catalog object ID must have a type of
	// `FIXED_PERCENTAGE` or `FIXED_AMOUNT`.
	// See [OrderLineItemDiscountType](#type-orderlineitemdiscounttype) for possible values
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// A value of `"7.25"` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The total declared monetary amount of the discount.
	//
	// `amount_money` is not set for percentage-based discounts.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of discount actually applied to this line item. When an amount-based
	// discount is at the order level, this value is different from `amount_money` because the discount
	// is distributed across the line items.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the `OrderReturnDiscount` applies. For `ORDER` scoped
	// discounts, the server generates references in `applied_discounts` on all
	// `OrderReturnLineItem`s. For `LINE_ITEM` scoped discounts, the discount is only applied to
	// `OrderReturnLineItem`s with references in their `applied_discounts` field.
	// See [OrderLineItemDiscountScope](#type-orderlineitemdiscountscope) for possible values
	Scope *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReturnDiscount) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderReturnDiscount) GetSourceDiscountUID() *string {
	if o == nil {
		return nil
	}
	return o.SourceDiscountUID
}

func (o *OrderReturnDiscount) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderReturnDiscount) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderReturnDiscount) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderReturnDiscount) GetType() *OrderLineItemDiscountType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderReturnDiscount) GetPercentage() *string {
	if o == nil {
		return nil
	}
	return o.Percentage
}

func (o *OrderReturnDiscount) GetAmountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AmountMoney
}

func (o *OrderReturnDiscount) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderReturnDiscount) GetScope() *OrderLineItemDiscountScope {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OrderReturnDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnDiscount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnDiscount) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The line item being returned in an order.
type OrderReturnLineItem struct {
	// A unique ID for this return line-item entry.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the line item in the original sale order.
	SourceLineItemUID *string `json:"source_line_item_uid,omitempty" url:"source_line_item_uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity returned, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// The unit and precision that this return line item's quantity is measured in.
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the return line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this return line item.
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this return line item.
	VariationName *string `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	// The type of line item: an itemized return, a non-itemized return (custom amount),
	// or the return of an unactivated gift card sale.
	// See [OrderLineItemItemType](#type-orderlineitemitemtype) for possible values
	ItemType *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	ReturnModifiers []*OrderReturnLineItemModifier `json:"return_modifiers,omitempty" url:"return_modifiers,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the return line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderReturnTax` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to `OrderReturnDiscount` entities applied to the return line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderReturnDiscount` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedDiscounts []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	// The base price for a single unit of the line item.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of all item variations returned in this line item.
	// The price is calculated as `base_price_money` multiplied by `quantity` and
	// does not include modifiers.
	VariationTotalPriceMoney *Money `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	// The gross return amount of money calculated as (item base price + modifiers price) * quantity.
	GrossReturnMoney *Money `json:"gross_return_money,omitempty" url:"gross_return_money,omitempty"`
	// The total amount of tax money to return for the line item.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The total amount of discount money to return for the line item.
	TotalDiscountMoney *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	// The total amount of money to return for this line item.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The list of references to `OrderReturnServiceCharge` entities applied to the return
	// line item. Each `OrderLineItemAppliedServiceCharge` has a `service_charge_uid` that
	// references the `uid` of a top-level `OrderReturnServiceCharge` applied to the return line
	// item. On reads, the applied amount is populated.
	AppliedServiceCharges []*OrderLineItemAppliedServiceCharge `json:"applied_service_charges,omitempty" url:"applied_service_charges,omitempty"`
	// The total amount of apportioned service charge money to return for the line item.
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReturnLineItem) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderReturnLineItem) GetSourceLineItemUID() *string {
	if o == nil {
		return nil
	}
	return o.SourceLineItemUID
}

func (o *OrderReturnLineItem) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderReturnLineItem) GetQuantity() string {
	if o == nil {
		return ""
	}
	return o.Quantity
}

func (o *OrderReturnLineItem) GetQuantityUnit() *OrderQuantityUnit {
	if o == nil {
		return nil
	}
	return o.QuantityUnit
}

func (o *OrderReturnLineItem) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *OrderReturnLineItem) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderReturnLineItem) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderReturnLineItem) GetVariationName() *string {
	if o == nil {
		return nil
	}
	return o.VariationName
}

func (o *OrderReturnLineItem) GetItemType() *OrderLineItemItemType {
	if o == nil {
		return nil
	}
	return o.ItemType
}

func (o *OrderReturnLineItem) GetReturnModifiers() []*OrderReturnLineItemModifier {
	if o == nil {
		return nil
	}
	return o.ReturnModifiers
}

func (o *OrderReturnLineItem) GetAppliedTaxes() []*OrderLineItemAppliedTax {
	if o == nil {
		return nil
	}
	return o.AppliedTaxes
}

func (o *OrderReturnLineItem) GetAppliedDiscounts() []*OrderLineItemAppliedDiscount {
	if o == nil {
		return nil
	}
	return o.AppliedDiscounts
}

func (o *OrderReturnLineItem) GetBasePriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.BasePriceMoney
}

func (o *OrderReturnLineItem) GetVariationTotalPriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.VariationTotalPriceMoney
}

func (o *OrderReturnLineItem) GetGrossReturnMoney() *Money {
	if o == nil {
		return nil
	}
	return o.GrossReturnMoney
}

func (o *OrderReturnLineItem) GetTotalTaxMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalTaxMoney
}

func (o *OrderReturnLineItem) GetTotalDiscountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalDiscountMoney
}

func (o *OrderReturnLineItem) GetTotalMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalMoney
}

func (o *OrderReturnLineItem) GetAppliedServiceCharges() []*OrderLineItemAppliedServiceCharge {
	if o == nil {
		return nil
	}
	return o.AppliedServiceCharges
}

func (o *OrderReturnLineItem) GetTotalServiceChargeMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalServiceChargeMoney
}

func (o *OrderReturnLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItem) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A line item modifier being returned.
type OrderReturnLineItemModifier struct {
	// A unique ID that identifies the return modifier only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The modifier `uid` from the order's line item that contains the
	// original sale of this line item modifier.
	SourceModifierUID *string `json:"source_modifier_uid,omitempty" url:"source_modifier_uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The base price for the modifier.
	//
	// `base_price_money` is required for ad hoc modifiers.
	// If both `catalog_object_id` and `base_price_money` are set, `base_price_money` overrides the predefined [CatalogModifier](entity:CatalogModifier) price.
	BasePriceMoney *Money `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	// The total price of the item modifier for its line item.
	// This is the modifier's `base_price_money` multiplied by the line item's quantity.
	TotalPriceMoney *Money `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// The quantity of the line item modifier. The modifier quantity can be 0 or more.
	// For example, suppose a restaurant offers a cheeseburger on the menu. When a buyer orders
	// this item, the restaurant records the purchase by creating an `Order` object with a line item
	// for a burger. The line item includes a line item modifier: the name is cheese and the quantity
	// is 1. The buyer has the option to order extra cheese (or no cheese). If the buyer chooses
	// the extra cheese option, the modifier quantity increases to 2. If the buyer does not want
	// any cheese, the modifier quantity is set to 0.
	Quantity *string `json:"quantity,omitempty" url:"quantity,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReturnLineItemModifier) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderReturnLineItemModifier) GetSourceModifierUID() *string {
	if o == nil {
		return nil
	}
	return o.SourceModifierUID
}

func (o *OrderReturnLineItemModifier) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderReturnLineItemModifier) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderReturnLineItemModifier) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderReturnLineItemModifier) GetBasePriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.BasePriceMoney
}

func (o *OrderReturnLineItemModifier) GetTotalPriceMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalPriceMoney
}

func (o *OrderReturnLineItemModifier) GetQuantity() *string {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OrderReturnLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItemModifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItemModifier) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents the service charge applied to the original order.
type OrderReturnServiceCharge struct {
	// A unique ID that identifies the return service charge only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The service charge `uid` from the order containing the original
	// service charge. `source_service_charge_uid` is `null` for
	// unlinked returns.
	SourceServiceChargeUID *string `json:"source_service_charge_uid,omitempty" url:"source_service_charge_uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID of the associated [OrderServiceCharge](entity:OrderServiceCharge).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The percentage of the service charge, as a string representation of
	// a decimal number. For example, a value of `"7.25"` corresponds to a
	// percentage of 7.25%.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of a non-percentage-based service charge.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money applied to the order by the service charge, including
	// any inclusive tax amounts, as calculated by Square.
	//
	// - For fixed-amount service charges, `applied_money` is equal to `amount_money`.
	// - For percentage-based service charges, `applied_money` is the money calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The total amount of money to collect for the service charge.
	//
	// __NOTE__: If an inclusive tax is applied to the service charge, `total_money`
	// does not equal `applied_money` plus `total_tax_money` because the inclusive
	// tax amount is already included in both `applied_money` and `total_tax_money`.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the service charge.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The calculation phase after which to apply the service charge.
	// See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the surcharge can be taxed. Service charges
	// calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the
	// `OrderReturnServiceCharge`. Each `OrderLineItemAppliedTax` has a `tax_uid`
	// that references the `uid` of a top-level `OrderReturnTax` that is being
	// applied to the `OrderReturnServiceCharge`. On reads, the applied amount is
	// populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The treatment type of the service charge.
	// See [OrderServiceChargeTreatmentType](#type-orderservicechargetreatmenttype) for possible values
	TreatmentType *OrderServiceChargeTreatmentType `json:"treatment_type,omitempty" url:"treatment_type,omitempty"`
	// Indicates the level at which the apportioned service charge applies. For `ORDER`
	// scoped service charges, Square generates references in `applied_service_charges` on
	// all order line items that do not have them. For `LINE_ITEM` scoped service charges,
	// the service charge only applies to line items with a service charge reference in their
	// `applied_service_charges` field.
	//
	// This field is immutable. To change the scope of an apportioned service charge, you must delete
	// the apportioned service charge and re-add it as a new apportioned service charge.
	// See [OrderServiceChargeScope](#type-orderservicechargescope) for possible values
	Scope *OrderServiceChargeScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReturnServiceCharge) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderReturnServiceCharge) GetSourceServiceChargeUID() *string {
	if o == nil {
		return nil
	}
	return o.SourceServiceChargeUID
}

func (o *OrderReturnServiceCharge) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderReturnServiceCharge) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderReturnServiceCharge) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderReturnServiceCharge) GetPercentage() *string {
	if o == nil {
		return nil
	}
	return o.Percentage
}

func (o *OrderReturnServiceCharge) GetAmountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AmountMoney
}

func (o *OrderReturnServiceCharge) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderReturnServiceCharge) GetTotalMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalMoney
}

func (o *OrderReturnServiceCharge) GetTotalTaxMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalTaxMoney
}

func (o *OrderReturnServiceCharge) GetCalculationPhase() *OrderServiceChargeCalculationPhase {
	if o == nil {
		return nil
	}
	return o.CalculationPhase
}

func (o *OrderReturnServiceCharge) GetTaxable() *bool {
	if o == nil {
		return nil
	}
	return o.Taxable
}

func (o *OrderReturnServiceCharge) GetAppliedTaxes() []*OrderLineItemAppliedTax {
	if o == nil {
		return nil
	}
	return o.AppliedTaxes
}

func (o *OrderReturnServiceCharge) GetTreatmentType() *OrderServiceChargeTreatmentType {
	if o == nil {
		return nil
	}
	return o.TreatmentType
}

func (o *OrderReturnServiceCharge) GetScope() *OrderServiceChargeScope {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OrderReturnServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnServiceCharge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnServiceCharge) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax being returned that applies to one or more return line items in an order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnTax struct {
	// A unique ID that identifies the returned tax only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The tax `uid` from the order that contains the original tax charge.
	SourceTaxUID *string `json:"source_tax_uid,omitempty" url:"source_tax_uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates the calculation method used to apply the tax.
	// See [OrderLineItemTaxType](#type-orderlineitemtaxtype) for possible values
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// For example, a value of `"7.25"` corresponds to a percentage of 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of money applied by the tax in an order.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Indicates the level at which the `OrderReturnTax` applies. For `ORDER` scoped
	// taxes, Square generates references in `applied_taxes` on all
	// `OrderReturnLineItem`s. For `LINE_ITEM` scoped taxes, the tax is only applied to
	// `OrderReturnLineItem`s with references in their `applied_discounts` field.
	// See [OrderLineItemTaxScope](#type-orderlineitemtaxscope) for possible values
	Scope *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReturnTax) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderReturnTax) GetSourceTaxUID() *string {
	if o == nil {
		return nil
	}
	return o.SourceTaxUID
}

func (o *OrderReturnTax) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderReturnTax) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderReturnTax) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderReturnTax) GetType() *OrderLineItemTaxType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderReturnTax) GetPercentage() *string {
	if o == nil {
		return nil
	}
	return o.Percentage
}

func (o *OrderReturnTax) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderReturnTax) GetScope() *OrderLineItemTaxScope {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OrderReturnTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnTax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnTax) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A tip being returned.
type OrderReturnTip struct {
	// A unique ID that identifies the tip only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The amount of tip being returned
	// --
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The tender `uid` from the order that contains the original application of this tip.
	SourceTenderUID *string `json:"source_tender_uid,omitempty" url:"source_tender_uid,omitempty"`
	// The tender `id` from the order that contains the original application of this tip.
	SourceTenderID *string `json:"source_tender_id,omitempty" url:"source_tender_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReturnTip) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderReturnTip) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderReturnTip) GetSourceTenderUID() *string {
	if o == nil {
		return nil
	}
	return o.SourceTenderUID
}

func (o *OrderReturnTip) GetSourceTenderID() *string {
	if o == nil {
		return nil
	}
	return o.SourceTenderID
}

func (o *OrderReturnTip) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnTip) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnTip
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnTip(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnTip) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a reward that can be applied to an order if the necessary
// reward tier criteria are met. Rewards are created through the Loyalty API.
type OrderReward struct {
	// The identifier of the reward.
	ID string `json:"id" url:"id"`
	// The identifier of the reward tier corresponding to this reward.
	RewardTierID string `json:"reward_tier_id" url:"reward_tier_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderReward) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *OrderReward) GetRewardTierID() string {
	if o == nil {
		return ""
	}
	return o.RewardTierID
}

func (o *OrderReward) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReward) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReward(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReward) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A rounding adjustment of the money being returned. Commonly used to apply cash rounding
// when the minimum unit of the account is smaller than the lowest physical denomination of the currency.
type OrderRoundingAdjustment struct {
	// A unique ID that identifies the rounding adjustment only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the rounding adjustment from the original sale order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The actual rounding adjustment amount.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderRoundingAdjustment) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderRoundingAdjustment) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderRoundingAdjustment) GetAmountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AmountMoney
}

func (o *OrderRoundingAdjustment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderRoundingAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderRoundingAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderRoundingAdjustment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderRoundingAdjustment) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a service charge applied to an order.
type OrderServiceCharge struct {
	// A unique ID that identifies the service charge only within this order.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID referencing the service charge [CatalogObject](entity:CatalogObject).
	CatalogObjectID *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The service charge percentage as a string representation of a
	// decimal number. For example, `"7.25"` indicates a service charge of 7.25%.
	//
	// Exactly 1 of `percentage` or `amount_money` should be set.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// The amount of a non-percentage-based service charge.
	//
	// Exactly one of `percentage` or `amount_money` should be set.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The amount of money applied to the order by the service charge,
	// including any inclusive tax amounts, as calculated by Square.
	//
	// - For fixed-amount service charges, `applied_money` is equal to `amount_money`.
	// - For percentage-based service charges, `applied_money` is the money
	// calculated using the percentage.
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// The total amount of money to collect for the service charge.
	//
	// __Note__: If an inclusive tax is applied to the service charge,
	// `total_money` does not equal `applied_money` plus `total_tax_money`
	// because the inclusive tax amount is already included in both
	// `applied_money` and `total_tax_money`.
	TotalMoney *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	// The total amount of tax money to collect for the service charge.
	TotalTaxMoney *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	// The calculation phase at which to apply the service charge.
	// See [OrderServiceChargeCalculationPhase](#type-orderservicechargecalculationphase) for possible values
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the service charge can be taxed. If set to `true`,
	// order-level taxes automatically apply to the service charge. Note that
	// service charges calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to the taxes applied to this service charge. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderLineItemTax` that is being applied to this service charge. On reads, the amount applied
	// is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every taxable service charge
	// for all `ORDER` scoped taxes that are added to the order. `OrderLineItemAppliedTax` records
	// for `LINE_ITEM` scoped taxes must be added in requests for the tax to apply to any taxable
	// service charge. Taxable service charges have the `taxable` field set to `true` and calculated
	// in the `SUBTOTAL_PHASE`.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// Application-defined data attached to this service charge. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]*string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The type of the service charge.
	// See [OrderServiceChargeType](#type-orderservicechargetype) for possible values
	Type *OrderServiceChargeType `json:"type,omitempty" url:"type,omitempty"`
	// The treatment type of the service charge.
	// See [OrderServiceChargeTreatmentType](#type-orderservicechargetreatmenttype) for possible values
	TreatmentType *OrderServiceChargeTreatmentType `json:"treatment_type,omitempty" url:"treatment_type,omitempty"`
	// Indicates the level at which the apportioned service charge applies. For `ORDER`
	// scoped service charges, Square generates references in `applied_service_charges` on
	// all order line items that do not have them. For `LINE_ITEM` scoped service charges,
	// the service charge only applies to line items with a service charge reference in their
	// `applied_service_charges` field.
	//
	// This field is immutable. To change the scope of an apportioned service charge, you must delete
	// the apportioned service charge and re-add it as a new apportioned service charge.
	// See [OrderServiceChargeScope](#type-orderservicechargescope) for possible values
	Scope *OrderServiceChargeScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderServiceCharge) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *OrderServiceCharge) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderServiceCharge) GetCatalogObjectID() *string {
	if o == nil {
		return nil
	}
	return o.CatalogObjectID
}

func (o *OrderServiceCharge) GetCatalogVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.CatalogVersion
}

func (o *OrderServiceCharge) GetPercentage() *string {
	if o == nil {
		return nil
	}
	return o.Percentage
}

func (o *OrderServiceCharge) GetAmountMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AmountMoney
}

func (o *OrderServiceCharge) GetAppliedMoney() *Money {
	if o == nil {
		return nil
	}
	return o.AppliedMoney
}

func (o *OrderServiceCharge) GetTotalMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalMoney
}

func (o *OrderServiceCharge) GetTotalTaxMoney() *Money {
	if o == nil {
		return nil
	}
	return o.TotalTaxMoney
}

func (o *OrderServiceCharge) GetCalculationPhase() *OrderServiceChargeCalculationPhase {
	if o == nil {
		return nil
	}
	return o.CalculationPhase
}

func (o *OrderServiceCharge) GetTaxable() *bool {
	if o == nil {
		return nil
	}
	return o.Taxable
}

func (o *OrderServiceCharge) GetAppliedTaxes() []*OrderLineItemAppliedTax {
	if o == nil {
		return nil
	}
	return o.AppliedTaxes
}

func (o *OrderServiceCharge) GetMetadata() map[string]*string {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *OrderServiceCharge) GetType() *OrderServiceChargeType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderServiceCharge) GetTreatmentType() *OrderServiceChargeTreatmentType {
	if o == nil {
		return nil
	}
	return o.TreatmentType
}

func (o *OrderServiceCharge) GetScope() *OrderServiceChargeScope {
	if o == nil {
		return nil
	}
	return o.Scope
}

func (o *OrderServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderServiceCharge(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderServiceCharge) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a phase in the process of calculating order totals.
// Service charges are applied after the indicated phase.
//
// [Read more about how order totals are calculated.](https://developer.squareup.com/docs/orders-api/how-it-works#how-totals-are-calculated)
type OrderServiceChargeCalculationPhase string

const (
	OrderServiceChargeCalculationPhaseSubtotalPhase              OrderServiceChargeCalculationPhase = "SUBTOTAL_PHASE"
	OrderServiceChargeCalculationPhaseTotalPhase                 OrderServiceChargeCalculationPhase = "TOTAL_PHASE"
	OrderServiceChargeCalculationPhaseApportionedPercentagePhase OrderServiceChargeCalculationPhase = "APPORTIONED_PERCENTAGE_PHASE"
	OrderServiceChargeCalculationPhaseApportionedAmountPhase     OrderServiceChargeCalculationPhase = "APPORTIONED_AMOUNT_PHASE"
)

func NewOrderServiceChargeCalculationPhaseFromString(s string) (OrderServiceChargeCalculationPhase, error) {
	switch s {
	case "SUBTOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseSubtotalPhase, nil
	case "TOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseTotalPhase, nil
	case "APPORTIONED_PERCENTAGE_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedPercentagePhase, nil
	case "APPORTIONED_AMOUNT_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedAmountPhase, nil
	}
	var t OrderServiceChargeCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeCalculationPhase) Ptr() *OrderServiceChargeCalculationPhase {
	return &o
}

// Indicates whether this is a line-item or order-level apportioned
// service charge.
type OrderServiceChargeScope string

const (
	OrderServiceChargeScopeOtherServiceChargeScope OrderServiceChargeScope = "OTHER_SERVICE_CHARGE_SCOPE"
	OrderServiceChargeScopeLineItem                OrderServiceChargeScope = "LINE_ITEM"
	OrderServiceChargeScopeOrder                   OrderServiceChargeScope = "ORDER"
)

func NewOrderServiceChargeScopeFromString(s string) (OrderServiceChargeScope, error) {
	switch s {
	case "OTHER_SERVICE_CHARGE_SCOPE":
		return OrderServiceChargeScopeOtherServiceChargeScope, nil
	case "LINE_ITEM":
		return OrderServiceChargeScopeLineItem, nil
	case "ORDER":
		return OrderServiceChargeScopeOrder, nil
	}
	var t OrderServiceChargeScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeScope) Ptr() *OrderServiceChargeScope {
	return &o
}

// Indicates whether the service charge will be treated as a value-holding line item or
// apportioned toward a line item.
type OrderServiceChargeTreatmentType string

const (
	OrderServiceChargeTreatmentTypeLineItemTreatment    OrderServiceChargeTreatmentType = "LINE_ITEM_TREATMENT"
	OrderServiceChargeTreatmentTypeApportionedTreatment OrderServiceChargeTreatmentType = "APPORTIONED_TREATMENT"
)

func NewOrderServiceChargeTreatmentTypeFromString(s string) (OrderServiceChargeTreatmentType, error) {
	switch s {
	case "LINE_ITEM_TREATMENT":
		return OrderServiceChargeTreatmentTypeLineItemTreatment, nil
	case "APPORTIONED_TREATMENT":
		return OrderServiceChargeTreatmentTypeApportionedTreatment, nil
	}
	var t OrderServiceChargeTreatmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeTreatmentType) Ptr() *OrderServiceChargeTreatmentType {
	return &o
}

type OrderServiceChargeType string

const (
	OrderServiceChargeTypeAutoGratuity OrderServiceChargeType = "AUTO_GRATUITY"
	OrderServiceChargeTypeCustom       OrderServiceChargeType = "CUSTOM"
)

func NewOrderServiceChargeTypeFromString(s string) (OrderServiceChargeType, error) {
	switch s {
	case "AUTO_GRATUITY":
		return OrderServiceChargeTypeAutoGratuity, nil
	case "CUSTOM":
		return OrderServiceChargeTypeCustom, nil
	}
	var t OrderServiceChargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeType) Ptr() *OrderServiceChargeType {
	return &o
}

// Represents the origination details of an order.
type OrderSource struct {
	// The name used to identify the place (physical or digital) that an order originates.
	// If unset, the name defaults to the name of the application that created the order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderSource) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OrderSource) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderSource) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderSource(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderSource) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The state of the order.
type OrderState string

const (
	OrderStateOpen      OrderState = "OPEN"
	OrderStateCompleted OrderState = "COMPLETED"
	OrderStateCanceled  OrderState = "CANCELED"
	OrderStateDraft     OrderState = "DRAFT"
)

func NewOrderStateFromString(s string) (OrderState, error) {
	switch s {
	case "OPEN":
		return OrderStateOpen, nil
	case "COMPLETED":
		return OrderStateCompleted, nil
	case "CANCELED":
		return OrderStateCanceled, nil
	case "DRAFT":
		return OrderStateDraft, nil
	}
	var t OrderState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderState) Ptr() *OrderState {
	return &o
}

type OrderUpdated struct {
	// The order's unique ID.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The state of the order.
	// See [OrderState](#type-orderstate) for possible values
	State *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderUpdated) GetOrderID() *string {
	if o == nil {
		return nil
	}
	return o.OrderID
}

func (o *OrderUpdated) GetVersion() *int {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *OrderUpdated) GetLocationID() *string {
	if o == nil {
		return nil
	}
	return o.LocationID
}

func (o *OrderUpdated) GetState() *OrderState {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *OrderUpdated) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderUpdated) GetUpdatedAt() *string {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *OrderUpdated) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdated) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdated
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdated(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdated) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when an [Order](entity:Order) is updated. This
// event is triggered by the [UpdateOrder](api-endpoint:Orders-UpdateOrder)
// endpoint call, Order Manager, or the Square Dashboard.
type OrderUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"order.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *OrderUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderUpdatedEvent) GetMerchantID() *string {
	if o == nil {
		return nil
	}
	return o.MerchantID
}

func (o *OrderUpdatedEvent) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderUpdatedEvent) GetEventID() *string {
	if o == nil {
		return nil
	}
	return o.EventID
}

func (o *OrderUpdatedEvent) GetCreatedAt() *string {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *OrderUpdatedEvent) GetData() *OrderUpdatedEventData {
	if o == nil {
		return nil
	}
	return o.Data
}

func (o *OrderUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdatedEvent) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderUpdatedEventData struct {
	// Name of the affected object’s type, `"order_updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected order.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing information about the updated Order.
	Object *OrderUpdatedObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderUpdatedEventData) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderUpdatedEventData) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OrderUpdatedEventData) GetObject() *OrderUpdatedObject {
	if o == nil {
		return nil
	}
	return o.Object
}

func (o *OrderUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdatedEventData) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OrderUpdatedObject struct {
	// Information about the updated order.
	OrderUpdated *OrderUpdated `json:"order_updated,omitempty" url:"order_updated,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OrderUpdatedObject) GetOrderUpdated() *OrderUpdated {
	if o == nil {
		return nil
	}
	return o.OrderUpdated
}

func (o *OrderUpdatedObject) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderUpdatedObject) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderUpdatedObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderUpdatedObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderUpdatedObject) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Published when a [Payment](entity:Payment) is created.
type PaymentCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"payment.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PaymentCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentCreatedEvent) GetMerchantID() *string {
	if p == nil {
		return nil
	}
	return p.MerchantID
}

func (p *PaymentCreatedEvent) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PaymentCreatedEvent) GetEventID() *string {
	if p == nil {
		return nil
	}
	return p.EventID
}

func (p *PaymentCreatedEvent) GetCreatedAt() *string {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PaymentCreatedEvent) GetData() *PaymentCreatedEventData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentCreatedEvent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentCreatedEvent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentCreatedEventData struct {
	// Name of the affected object’s type, `"payment"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected payment.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created payment.
	Object *PaymentCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentCreatedEventData) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PaymentCreatedEventData) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PaymentCreatedEventData) GetObject() *PaymentCreatedEventObject {
	if p == nil {
		return nil
	}
	return p.Object
}

func (p *PaymentCreatedEventData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentCreatedEventData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentCreatedEventObject struct {
	// The created payment.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentCreatedEventObject) GetPayment() *Payment {
	if p == nil {
		return nil
	}
	return p.Payment
}

func (p *PaymentCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentCreatedEventObject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentLink struct {
	// The Square-assigned ID of the payment link.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The Square-assigned version number, which is incremented each time an update is committed to the payment link.
	Version int `json:"version" url:"version"`
	// The optional description of the `payment_link` object.
	// It is primarily for use by your application and is not used anywhere.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The ID of the order associated with the payment link.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The checkout options configured for the payment link.
	// For more information, see [Optional Checkout Configurations](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations).
	CheckoutOptions *CheckoutOptions `json:"checkout_options,omitempty" url:"checkout_options,omitempty"`
	// Describes buyer data to prepopulate
	// on the checkout page.
	PrePopulatedData *PrePopulatedData `json:"pre_populated_data,omitempty" url:"pre_populated_data,omitempty"`
	// The shortened URL of the payment link.
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// The long URL of the payment link.
	LongURL *string `json:"long_url,omitempty" url:"long_url,omitempty"`
	// The timestamp when the payment link was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the payment link was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// An optional note. After Square processes the payment, this note is added to the
	// resulting `Payment`.
	PaymentNote *string `json:"payment_note,omitempty" url:"payment_note,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLink) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PaymentLink) GetVersion() int {
	if p == nil {
		return 0
	}
	return p.Version
}

func (p *PaymentLink) GetDescription() *string {
	if p == nil {
		return nil
	}
	return p.Description
}

func (p *PaymentLink) GetOrderID() *string {
	if p == nil {
		return nil
	}
	return p.OrderID
}

func (p *PaymentLink) GetCheckoutOptions() *CheckoutOptions {
	if p == nil {
		return nil
	}
	return p.CheckoutOptions
}

func (p *PaymentLink) GetPrePopulatedData() *PrePopulatedData {
	if p == nil {
		return nil
	}
	return p.PrePopulatedData
}

func (p *PaymentLink) GetURL() *string {
	if p == nil {
		return nil
	}
	return p.URL
}

func (p *PaymentLink) GetLongURL() *string {
	if p == nil {
		return nil
	}
	return p.LongURL
}

func (p *PaymentLink) GetCreatedAt() *string {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PaymentLink) GetUpdatedAt() *string {
	if p == nil {
		return nil
	}
	return p.UpdatedAt
}

func (p *PaymentLink) GetPaymentNote() *string {
	if p == nil {
		return nil
	}
	return p.PaymentNote
}

func (p *PaymentLink) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLink) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLink
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLink(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLink) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentLinkRelatedResources struct {
	// The order associated with the payment link.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// The subscription plan associated with the payment link.
	SubscriptionPlans []*CatalogObject `json:"subscription_plans,omitempty" url:"subscription_plans,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentLinkRelatedResources) GetOrders() []*Order {
	if p == nil {
		return nil
	}
	return p.Orders
}

func (p *PaymentLinkRelatedResources) GetSubscriptionPlans() []*CatalogObject {
	if p == nil {
		return nil
	}
	return p.SubscriptionPlans
}

func (p *PaymentLinkRelatedResources) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentLinkRelatedResources) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentLinkRelatedResources
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentLinkRelatedResources(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentLinkRelatedResources) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentOptions struct {
	// Indicates whether the `Payment` objects created from this `TerminalCheckout` are
	// automatically `COMPLETED` or left in an `APPROVED` state for later modification.
	//
	// Default: true
	Autocomplete *bool `json:"autocomplete,omitempty" url:"autocomplete,omitempty"`
	// The duration of time after the payment's creation when Square automatically resolves the
	// payment. This automatic resolution applies only to payments that do not reach a terminal state
	// (`COMPLETED` or `CANCELED`) before the `delay_duration` time period.
	//
	// This parameter should be specified as a time duration, in RFC 3339 format, with a minimum value
	// of 1 minute and a maximum value of 36 hours. This feature is only supported for card payments,
	// and all payments will be considered card-present.
	//
	// This parameter can only be set for a delayed capture payment (`autocomplete=false`). For more
	// information, see [Delayed Capture](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/delayed-capture#time-threshold).
	//
	// Default: "PT36H" (36 hours) from the creation time
	DelayDuration *string `json:"delay_duration,omitempty" url:"delay_duration,omitempty"`
	// If set to `true` and charging a Square Gift Card, a payment might be returned with
	// `amount_money` equal to less than what was requested. For example, a request for $20 when charging
	// a Square Gift Card with a balance of $5 results in an APPROVED payment of $5. You might choose
	// to prompt the buyer for an additional payment to cover the remainder or cancel the Gift Card
	// payment.
	//
	// This parameter can only be set for a delayed capture payment (`autocomplete=false`).
	//
	// For more information, see [Take Partial Payments](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/partial-payments-with-gift-cards).
	//
	// Default: false
	AcceptPartialAuthorization *bool `json:"accept_partial_authorization,omitempty" url:"accept_partial_authorization,omitempty"`
	// The action to be applied to the `Payment` when the delay_duration has elapsed.
	// The action must be CANCEL or COMPLETE.
	//
	// The action cannot be set to COMPLETE if an `order_id` is present on the TerminalCheckout.
	//
	// This parameter can only be set for a delayed capture payment (`autocomplete=false`). For more
	// information, see [Delayed Capture](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/delayed-capture#time-threshold).
	//
	// Default: CANCEL
	// See [DelayAction](#type-delayaction) for possible values
	DelayAction *PaymentOptionsDelayAction `json:"delay_action,omitempty" url:"delay_action,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentOptions) GetAutocomplete() *bool {
	if p == nil {
		return nil
	}
	return p.Autocomplete
}

func (p *PaymentOptions) GetDelayDuration() *string {
	if p == nil {
		return nil
	}
	return p.DelayDuration
}

func (p *PaymentOptions) GetAcceptPartialAuthorization() *bool {
	if p == nil {
		return nil
	}
	return p.AcceptPartialAuthorization
}

func (p *PaymentOptions) GetDelayAction() *PaymentOptionsDelayAction {
	if p == nil {
		return nil
	}
	return p.DelayAction
}

func (p *PaymentOptions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentOptions) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Describes the action to be applied to a delayed capture payment when the delay_duration
// has elapsed.
type PaymentOptionsDelayAction string

const (
	PaymentOptionsDelayActionCancel   PaymentOptionsDelayAction = "CANCEL"
	PaymentOptionsDelayActionComplete PaymentOptionsDelayAction = "COMPLETE"
)

func NewPaymentOptionsDelayActionFromString(s string) (PaymentOptionsDelayAction, error) {
	switch s {
	case "CANCEL":
		return PaymentOptionsDelayActionCancel, nil
	case "COMPLETE":
		return PaymentOptionsDelayActionComplete, nil
	}
	var t PaymentOptionsDelayAction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PaymentOptionsDelayAction) Ptr() *PaymentOptionsDelayAction {
	return &p
}

// Published when a [Payment](entity:Payment) is updated.
// Typically the `payment.status`, or `card_details.status` fields are updated
// as a payment is canceled, authorized, or completed.
type PaymentUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"payment.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PaymentUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentUpdatedEvent) GetMerchantID() *string {
	if p == nil {
		return nil
	}
	return p.MerchantID
}

func (p *PaymentUpdatedEvent) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PaymentUpdatedEvent) GetEventID() *string {
	if p == nil {
		return nil
	}
	return p.EventID
}

func (p *PaymentUpdatedEvent) GetCreatedAt() *string {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PaymentUpdatedEvent) GetData() *PaymentUpdatedEventData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PaymentUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentUpdatedEvent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentUpdatedEventData struct {
	// Name of the affected object’s type, `"payment"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected payment.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated payment.
	Object *PaymentUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentUpdatedEventData) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PaymentUpdatedEventData) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PaymentUpdatedEventData) GetObject() *PaymentUpdatedEventObject {
	if p == nil {
		return nil
	}
	return p.Object
}

func (p *PaymentUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentUpdatedEventData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentUpdatedEventObject struct {
	// The updated payment.
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PaymentUpdatedEventObject) GetPayment() *Payment {
	if p == nil {
		return nil
	}
	return p.Payment
}

func (p *PaymentUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentUpdatedEventObject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Published when a [Payout](entity:Payout) has failed.
type PayoutFailedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event that this represents, `payout.failed`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The timestamp of when the event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PayoutFailedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutFailedEvent) GetMerchantID() *string {
	if p == nil {
		return nil
	}
	return p.MerchantID
}

func (p *PayoutFailedEvent) GetLocationID() *string {
	if p == nil {
		return nil
	}
	return p.LocationID
}

func (p *PayoutFailedEvent) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PayoutFailedEvent) GetEventID() *string {
	if p == nil {
		return nil
	}
	return p.EventID
}

func (p *PayoutFailedEvent) GetCreatedAt() *string {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PayoutFailedEvent) GetData() *PayoutFailedEventData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayoutFailedEvent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFailedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFailedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFailedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFailedEvent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutFailedEventData struct {
	// The name of the affected object's type, `payout`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the failed payout.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the failed payout.
	Object *PayoutFailedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutFailedEventData) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PayoutFailedEventData) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PayoutFailedEventData) GetObject() *PayoutFailedEventObject {
	if p == nil {
		return nil
	}
	return p.Object
}

func (p *PayoutFailedEventData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFailedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFailedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFailedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFailedEventData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutFailedEventObject struct {
	// The payout that failed.
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutFailedEventObject) GetPayout() *Payout {
	if p == nil {
		return nil
	}
	return p.Payout
}

func (p *PayoutFailedEventObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFailedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFailedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFailedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFailedEventObject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Published when a [Payout](entity:Payout) is complete.
type PayoutPaidEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"payout.paid"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PayoutPaidEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutPaidEvent) GetMerchantID() *string {
	if p == nil {
		return nil
	}
	return p.MerchantID
}

func (p *PayoutPaidEvent) GetLocationID() *string {
	if p == nil {
		return nil
	}
	return p.LocationID
}

func (p *PayoutPaidEvent) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PayoutPaidEvent) GetEventID() *string {
	if p == nil {
		return nil
	}
	return p.EventID
}

func (p *PayoutPaidEvent) GetCreatedAt() *string {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PayoutPaidEvent) GetData() *PayoutPaidEventData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayoutPaidEvent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutPaidEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutPaidEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutPaidEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutPaidEvent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutPaidEventData struct {
	// Name of the affected object’s type, `"payout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the completed payout.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the completed payout.
	Object *PayoutPaidEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutPaidEventData) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PayoutPaidEventData) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PayoutPaidEventData) GetObject() *PayoutPaidEventObject {
	if p == nil {
		return nil
	}
	return p.Object
}

func (p *PayoutPaidEventData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutPaidEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutPaidEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutPaidEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutPaidEventData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutPaidEventObject struct {
	// The payout that has completed.
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutPaidEventObject) GetPayout() *Payout {
	if p == nil {
		return nil
	}
	return p.Payout
}

func (p *PayoutPaidEventObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutPaidEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutPaidEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutPaidEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutPaidEventObject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Published when a [Payout](entity:Payout) is sent.
type PayoutSentEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of the target location associated with the event.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of event this represents, `"payout.sent"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was verified, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *PayoutSentEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutSentEvent) GetMerchantID() *string {
	if p == nil {
		return nil
	}
	return p.MerchantID
}

func (p *PayoutSentEvent) GetLocationID() *string {
	if p == nil {
		return nil
	}
	return p.LocationID
}

func (p *PayoutSentEvent) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PayoutSentEvent) GetEventID() *string {
	if p == nil {
		return nil
	}
	return p.EventID
}

func (p *PayoutSentEvent) GetCreatedAt() *string {
	if p == nil {
		return nil
	}
	return p.CreatedAt
}

func (p *PayoutSentEvent) GetData() *PayoutSentEventData {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PayoutSentEvent) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutSentEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutSentEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutSentEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutSentEvent) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutSentEventData struct {
	// Name of the affected object’s type, `"payout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the sent payout.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the sent payout.
	Object *PayoutSentEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutSentEventData) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *PayoutSentEventData) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *PayoutSentEventData) GetObject() *PayoutSentEventObject {
	if p == nil {
		return nil
	}
	return p.Object
}

func (p *PayoutSentEventData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutSentEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutSentEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutSentEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutSentEventData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PayoutSentEventObject struct {
	// The payout that was sent.
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PayoutSentEventObject) GetPayout() *Payout {
	if p == nil {
		return nil
	}
	return p.Payout
}

func (p *PayoutSentEventObject) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutSentEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutSentEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutSentEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutSentEventObject) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Describes buyer data to prepopulate in the payment form.
// For more information,
// see [Optional Checkout Configurations](https://developer.squareup.com/docs/checkout-api/optional-checkout-configurations).
type PrePopulatedData struct {
	// The buyer email to prepopulate in the payment form.
	BuyerEmail *string `json:"buyer_email,omitempty" url:"buyer_email,omitempty"`
	// The buyer phone number to prepopulate in the payment form.
	BuyerPhoneNumber *string `json:"buyer_phone_number,omitempty" url:"buyer_phone_number,omitempty"`
	// The buyer address to prepopulate in the payment form.
	BuyerAddress *Address `json:"buyer_address,omitempty" url:"buyer_address,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PrePopulatedData) GetBuyerEmail() *string {
	if p == nil {
		return nil
	}
	return p.BuyerEmail
}

func (p *PrePopulatedData) GetBuyerPhoneNumber() *string {
	if p == nil {
		return nil
	}
	return p.BuyerPhoneNumber
}

func (p *PrePopulatedData) GetBuyerAddress() *Address {
	if p == nil {
		return nil
	}
	return p.BuyerAddress
}

func (p *PrePopulatedData) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrePopulatedData) UnmarshalJSON(data []byte) error {
	type unmarshaler PrePopulatedData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrePopulatedData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PrePopulatedData) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the Square processing fee.
type ProcessingFee struct {
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of fee assessed or adjusted. The fee type can be `INITIAL` or `ADJUSTMENT`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The fee amount, which might be negative, that is assessed or adjusted by Square.
	//
	// Positive values represent funds being assessed, while negative values represent
	// funds being returned.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *ProcessingFee) GetEffectiveAt() *string {
	if p == nil {
		return nil
	}
	return p.EffectiveAt
}

func (p *ProcessingFee) GetType() *string {
	if p == nil {
		return nil
	}
	return p.Type
}

func (p *ProcessingFee) GetAmountMoney() *Money {
	if p == nil {
		return nil
	}
	return p.AmountMoney
}

func (p *ProcessingFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingFee(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingFee) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the Square product used to generate a change.
type Product string

const (
	ProductSquarePos         Product = "SQUARE_POS"
	ProductExternalAPI       Product = "EXTERNAL_API"
	ProductBilling           Product = "BILLING"
	ProductAppointments      Product = "APPOINTMENTS"
	ProductInvoices          Product = "INVOICES"
	ProductOnlineStore       Product = "ONLINE_STORE"
	ProductPayroll           Product = "PAYROLL"
	ProductDashboard         Product = "DASHBOARD"
	ProductItemLibraryImport Product = "ITEM_LIBRARY_IMPORT"
	ProductOther             Product = "OTHER"
)

func NewProductFromString(s string) (Product, error) {
	switch s {
	case "SQUARE_POS":
		return ProductSquarePos, nil
	case "EXTERNAL_API":
		return ProductExternalAPI, nil
	case "BILLING":
		return ProductBilling, nil
	case "APPOINTMENTS":
		return ProductAppointments, nil
	case "INVOICES":
		return ProductInvoices, nil
	case "ONLINE_STORE":
		return ProductOnlineStore, nil
	case "PAYROLL":
		return ProductPayroll, nil
	case "DASHBOARD":
		return ProductDashboard, nil
	case "ITEM_LIBRARY_IMPORT":
		return ProductItemLibraryImport, nil
	case "OTHER":
		return ProductOther, nil
	}
	var t Product
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Product) Ptr() *Product {
	return &p
}

type ProductType = string

// Fields to describe the action that displays QR-Codes.
type QrCodeOptions struct {
	// The title text to display in the QR code flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display in the QR code flow on the Terminal.
	Body string `json:"body" url:"body"`
	// The text representation of the data to show in the QR code
	// as UTF8-encoded data.
	BarcodeContents string `json:"barcode_contents" url:"barcode_contents"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QrCodeOptions) GetTitle() string {
	if q == nil {
		return ""
	}
	return q.Title
}

func (q *QrCodeOptions) GetBody() string {
	if q == nil {
		return ""
	}
	return q.Body
}

func (q *QrCodeOptions) GetBarcodeContents() string {
	if q == nil {
		return ""
	}
	return q.BarcodeContents
}

func (q *QrCodeOptions) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QrCodeOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler QrCodeOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QrCodeOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QrCodeOptions) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Describes an ad hoc item and price to generate a quick pay checkout link.
// For more information,
// see [Quick Pay Checkout](https://developer.squareup.com/docs/checkout-api/quick-pay-checkout).
type QuickPay struct {
	// The ad hoc item name. In the resulting `Order`, this name appears as the line item name.
	Name string `json:"name" url:"name"`
	// The price of the item.
	PriceMoney *Money `json:"price_money" url:"price_money"`
	// The ID of the business location the checkout is associated with.
	LocationID string `json:"location_id" url:"location_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (q *QuickPay) GetName() string {
	if q == nil {
		return ""
	}
	return q.Name
}

func (q *QuickPay) GetPriceMoney() *Money {
	if q == nil {
		return nil
	}
	return q.PriceMoney
}

func (q *QuickPay) GetLocationID() string {
	if q == nil {
		return ""
	}
	return q.LocationID
}

func (q *QuickPay) GetExtraProperties() map[string]interface{} {
	return q.extraProperties
}

func (q *QuickPay) UnmarshalJSON(data []byte) error {
	type unmarshaler QuickPay
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*q = QuickPay(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *q)
	if err != nil {
		return err
	}
	q.extraProperties = extraProperties
	q.rawJSON = json.RawMessage(data)
	return nil
}

func (q *QuickPay) String() string {
	if len(q.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(q.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(q); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", q)
}

// Describes receipt action fields.
type ReceiptOptions struct {
	// The reference to the Square payment ID for the receipt.
	PaymentID string `json:"payment_id" url:"payment_id"`
	// Instructs the device to print the receipt without displaying the receipt selection screen.
	// Requires `printer_enabled` set to true.
	// Defaults to false.
	PrintOnly *bool `json:"print_only,omitempty" url:"print_only,omitempty"`
	// Identify the receipt as a reprint rather than an original receipt.
	// Defaults to false.
	IsDuplicate *bool `json:"is_duplicate,omitempty" url:"is_duplicate,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ReceiptOptions) GetPaymentID() string {
	if r == nil {
		return ""
	}
	return r.PaymentID
}

func (r *ReceiptOptions) GetPrintOnly() *bool {
	if r == nil {
		return nil
	}
	return r.PrintOnly
}

func (r *ReceiptOptions) GetIsDuplicate() *bool {
	if r == nil {
		return nil
	}
	return r.IsDuplicate
}

func (r *ReceiptOptions) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReceiptOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ReceiptOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReceiptOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReceiptOptions) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A response that includes the `LoyaltyEvent` published for redeeming the reward.
type RedeemLoyaltyRewardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The `LoyaltyEvent` for redeeming the reward.
	Event *LoyaltyEvent `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RedeemLoyaltyRewardResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RedeemLoyaltyRewardResponse) GetEvent() *LoyaltyEvent {
	if r == nil {
		return nil
	}
	return r.Event
}

func (r *RedeemLoyaltyRewardResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RedeemLoyaltyRewardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RedeemLoyaltyRewardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RedeemLoyaltyRewardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RedeemLoyaltyRewardResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a refund processed for a Square transaction.
type Refund struct {
	// The refund's unique ID.
	ID string `json:"id" url:"id"`
	// The ID of the refund's associated location.
	LocationID string `json:"location_id" url:"location_id"`
	// The ID of the transaction that the refunded tender is part of.
	TransactionID *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The ID of the refunded tender.
	TenderID *string `json:"tender_id,omitempty" url:"tender_id,omitempty"`
	// The timestamp for when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The reason for the refund being issued.
	Reason string `json:"reason" url:"reason"`
	// The amount of money refunded to the buyer.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// The current status of the refund (`PENDING`, `APPROVED`, `REJECTED`,
	// or `FAILED`).
	// See [RefundStatus](#type-refundstatus) for possible values
	Status RefundStatus `json:"status" url:"status"`
	// The amount of Square processing fee money refunded to the *merchant*.
	ProcessingFeeMoney *Money `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this refund.
	// For example, fees assessed on a refund of a purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Refund) GetID() string {
	if r == nil {
		return ""
	}
	return r.ID
}

func (r *Refund) GetLocationID() string {
	if r == nil {
		return ""
	}
	return r.LocationID
}

func (r *Refund) GetTransactionID() *string {
	if r == nil {
		return nil
	}
	return r.TransactionID
}

func (r *Refund) GetTenderID() *string {
	if r == nil {
		return nil
	}
	return r.TenderID
}

func (r *Refund) GetCreatedAt() *string {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *Refund) GetReason() string {
	if r == nil {
		return ""
	}
	return r.Reason
}

func (r *Refund) GetAmountMoney() *Money {
	if r == nil {
		return nil
	}
	return r.AmountMoney
}

func (r *Refund) GetStatus() RefundStatus {
	if r == nil {
		return ""
	}
	return r.Status
}

func (r *Refund) GetProcessingFeeMoney() *Money {
	if r == nil {
		return nil
	}
	return r.ProcessingFeeMoney
}

func (r *Refund) GetAdditionalRecipients() []*AdditionalRecipient {
	if r == nil {
		return nil
	}
	return r.AdditionalRecipients
}

func (r *Refund) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Refund) UnmarshalJSON(data []byte) error {
	type unmarshaler Refund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Refund(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Refund) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Published when a [Refund](entity:PaymentRefund) is created.
type RefundCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"refund.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *RefundCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundCreatedEvent) GetMerchantID() *string {
	if r == nil {
		return nil
	}
	return r.MerchantID
}

func (r *RefundCreatedEvent) GetType() *string {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *RefundCreatedEvent) GetEventID() *string {
	if r == nil {
		return nil
	}
	return r.EventID
}

func (r *RefundCreatedEvent) GetCreatedAt() *string {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *RefundCreatedEvent) GetData() *RefundCreatedEventData {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RefundCreatedEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundCreatedEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundCreatedEventData struct {
	// Name of the affected object’s type, `"refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected refund.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created refund.
	Object *RefundCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundCreatedEventData) GetType() *string {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *RefundCreatedEventData) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RefundCreatedEventData) GetObject() *RefundCreatedEventObject {
	if r == nil {
		return nil
	}
	return r.Object
}

func (r *RefundCreatedEventData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundCreatedEventData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundCreatedEventObject struct {
	// The created refund.
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundCreatedEventObject) GetRefund() *PaymentRefund {
	if r == nil {
		return nil
	}
	return r.Refund
}

func (r *RefundCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundCreatedEventObject) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates a refund's current status.
type RefundStatus string

const (
	RefundStatusPending  RefundStatus = "PENDING"
	RefundStatusApproved RefundStatus = "APPROVED"
	RefundStatusRejected RefundStatus = "REJECTED"
	RefundStatusFailed   RefundStatus = "FAILED"
)

func NewRefundStatusFromString(s string) (RefundStatus, error) {
	switch s {
	case "PENDING":
		return RefundStatusPending, nil
	case "APPROVED":
		return RefundStatusApproved, nil
	case "REJECTED":
		return RefundStatusRejected, nil
	case "FAILED":
		return RefundStatusFailed, nil
	}
	var t RefundStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefundStatus) Ptr() *RefundStatus {
	return &r
}

// Published when a [Refund](entity:PaymentRefund) is updated.
// Typically the `refund.status` changes when a refund is completed.
type RefundUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"refund.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *RefundUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundUpdatedEvent) GetMerchantID() *string {
	if r == nil {
		return nil
	}
	return r.MerchantID
}

func (r *RefundUpdatedEvent) GetType() *string {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *RefundUpdatedEvent) GetEventID() *string {
	if r == nil {
		return nil
	}
	return r.EventID
}

func (r *RefundUpdatedEvent) GetCreatedAt() *string {
	if r == nil {
		return nil
	}
	return r.CreatedAt
}

func (r *RefundUpdatedEvent) GetData() *RefundUpdatedEventData {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RefundUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundUpdatedEvent) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundUpdatedEventData struct {
	// Name of the affected object’s type, `"refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected refund.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated refund.
	Object *RefundUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundUpdatedEventData) GetType() *string {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *RefundUpdatedEventData) GetID() *string {
	if r == nil {
		return nil
	}
	return r.ID
}

func (r *RefundUpdatedEventData) GetObject() *RefundUpdatedEventObject {
	if r == nil {
		return nil
	}
	return r.Object
}

func (r *RefundUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundUpdatedEventData) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RefundUpdatedEventObject struct {
	// The updated refund.
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RefundUpdatedEventObject) GetRefund() *PaymentRefund {
	if r == nil {
		return nil
	}
	return r.Refund
}

func (r *RefundUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundUpdatedEventObject) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the fields that are included in the response body of
// a request to the [RemoveGroupFromCustomer](api-endpoint:Customers-RemoveGroupFromCustomer)
// endpoint.
type RemoveGroupFromCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RemoveGroupFromCustomerResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RemoveGroupFromCustomerResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RemoveGroupFromCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RemoveGroupFromCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RemoveGroupFromCustomerResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RemoveGroupFromCustomerResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveBookingCustomAttributeDefinition](api-endpoint:BookingCustomAttributes-RetrieveBookingCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveBookingCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if r == nil {
		return nil
	}
	return r.CustomAttributeDefinition
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveBookingCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveBookingCustomAttributeDefinitionResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveBookingCustomAttribute](api-endpoint:BookingCustomAttributes-RetrieveBookingCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveBookingCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveBookingCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if r == nil {
		return nil
	}
	return r.CustomAttribute
}

func (r *RetrieveBookingCustomAttributeResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveBookingCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveBookingCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveBookingCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveBookingCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveBookingCustomAttributeResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveLocationCustomAttributeDefinition](api-endpoint:LocationCustomAttributes-RetrieveLocationCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveLocationCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if r == nil {
		return nil
	}
	return r.CustomAttributeDefinition
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationCustomAttributeDefinitionResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveLocationCustomAttribute](api-endpoint:LocationCustomAttributes-RetrieveLocationCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveLocationCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveLocationCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if r == nil {
		return nil
	}
	return r.CustomAttribute
}

func (r *RetrieveLocationCustomAttributeResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveLocationCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveLocationCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveLocationCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveLocationCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveLocationCustomAttributeResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveMerchantCustomAttributeDefinition](api-endpoint:MerchantCustomAttributes-RetrieveMerchantCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveMerchantCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if r == nil {
		return nil
	}
	return r.CustomAttributeDefinition
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantCustomAttributeDefinitionResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a [RetrieveMerchantCustomAttribute](api-endpoint:MerchantCustomAttributes-RetrieveMerchantCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type RetrieveMerchantCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request,
	// the custom attribute definition is returned in the `definition` field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveMerchantCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if r == nil {
		return nil
	}
	return r.CustomAttribute
}

func (r *RetrieveMerchantCustomAttributeResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveMerchantCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantCustomAttributeResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a response from getting an order custom attribute definition.
type RetrieveOrderCustomAttributeDefinitionResponse struct {
	// The retrieved custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if r == nil {
		return nil
	}
	return r.CustomAttributeDefinition
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveOrderCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveOrderCustomAttributeDefinitionResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a response from getting an order custom attribute.
type RetrieveOrderCustomAttributeResponse struct {
	// The retrieved custom attribute. If `with_definition` was set to `true` in the request, the custom attribute definition is returned in the `definition field.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveOrderCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if r == nil {
		return nil
	}
	return r.CustomAttribute
}

func (r *RetrieveOrderCustomAttributeResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveOrderCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveOrderCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveOrderCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveOrderCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveOrderCustomAttributeResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Describes save-card action fields.
type SaveCardOptions struct {
	// The square-assigned ID of the customer linked to the saved card.
	CustomerID string `json:"customer_id" url:"customer_id"`
	// The id of the created card-on-file.
	CardID *string `json:"card_id,omitempty" url:"card_id,omitempty"`
	// An optional user-defined reference ID that can be used to associate
	// this `Card` to another entity in an external system. For example, a customer
	// ID generated by a third-party system.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SaveCardOptions) GetCustomerID() string {
	if s == nil {
		return ""
	}
	return s.CustomerID
}

func (s *SaveCardOptions) GetCardID() *string {
	if s == nil {
		return nil
	}
	return s.CardID
}

func (s *SaveCardOptions) GetReferenceID() *string {
	if s == nil {
		return nil
	}
	return s.ReferenceID
}

func (s *SaveCardOptions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SaveCardOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler SaveCardOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SaveCardOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SaveCardOptions) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The search criteria for the loyalty accounts.
type SearchLoyaltyAccountsRequestLoyaltyAccountQuery struct {
	// The set of mappings to use in the loyalty account search.
	//
	// This cannot be combined with `customer_ids`.
	//
	// Max: 30 mappings
	Mappings []*LoyaltyAccountMapping `json:"mappings,omitempty" url:"mappings,omitempty"`
	// The set of customer IDs to use in the loyalty account search.
	//
	// This cannot be combined with `mappings`.
	//
	// Max: 30 customer IDs
	CustomerIDs []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) GetMappings() []*LoyaltyAccountMapping {
	if s == nil {
		return nil
	}
	return s.Mappings
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) GetCustomerIDs() []string {
	if s == nil {
		return nil
	}
	return s.CustomerIDs
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyAccountsRequestLoyaltyAccountQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyAccountsRequestLoyaltyAccountQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyAccountsRequestLoyaltyAccountQuery) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A response that includes loyalty accounts that satisfy the search criteria.
type SearchLoyaltyAccountsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty accounts that met the search criteria,
	// in order of creation date.
	LoyaltyAccounts []*LoyaltyAccount `json:"loyalty_accounts,omitempty" url:"loyalty_accounts,omitempty"`
	// The pagination cursor to use in a subsequent
	// request. If empty, this is the final response.
	// For more information,
	// see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchLoyaltyAccountsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchLoyaltyAccountsResponse) GetLoyaltyAccounts() []*LoyaltyAccount {
	if s == nil {
		return nil
	}
	return s.LoyaltyAccounts
}

func (s *SearchLoyaltyAccountsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchLoyaltyAccountsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyAccountsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyAccountsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyAccountsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyAccountsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The set of search requirements.
type SearchLoyaltyRewardsRequestLoyaltyRewardQuery struct {
	// The ID of the [loyalty account](entity:LoyaltyAccount) to which the loyalty reward belongs.
	LoyaltyAccountID string `json:"loyalty_account_id" url:"loyalty_account_id"`
	// The status of the loyalty reward.
	// See [LoyaltyRewardStatus](#type-loyaltyrewardstatus) for possible values
	Status *LoyaltyRewardStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) GetLoyaltyAccountID() string {
	if s == nil {
		return ""
	}
	return s.LoyaltyAccountID
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) GetStatus() *LoyaltyRewardStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyRewardsRequestLoyaltyRewardQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyRewardsRequestLoyaltyRewardQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyRewardsRequestLoyaltyRewardQuery) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A response that includes the loyalty rewards satisfying the search criteria.
type SearchLoyaltyRewardsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The loyalty rewards that satisfy the search criteria.
	// These are returned in descending order by `updated_at`.
	Rewards []*LoyaltyReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	// The pagination cursor to be used in a subsequent
	// request. If empty, this is the final response.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchLoyaltyRewardsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchLoyaltyRewardsResponse) GetRewards() []*LoyaltyReward {
	if s == nil {
		return nil
	}
	return s.Rewards
}

func (s *SearchLoyaltyRewardsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchLoyaltyRewardsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchLoyaltyRewardsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchLoyaltyRewardsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchLoyaltyRewardsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchLoyaltyRewardsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The response to a request for `Shift` objects. The response contains
// the requested `Shift` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type SearchShiftsResponse struct {
	// Shifts.
	Shifts []*Shift `json:"shifts,omitempty" url:"shifts,omitempty"`
	// An opaque cursor for fetching the next page.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchShiftsResponse) GetShifts() []*Shift {
	if s == nil {
		return nil
	}
	return s.Shifts
}

func (s *SearchShiftsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchShiftsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchShiftsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchShiftsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchShiftsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalActionsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalAction`s.
	Action []*TerminalAction `json:"action,omitempty" url:"action,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more
	// information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchTerminalActionsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchTerminalActionsResponse) GetAction() []*TerminalAction {
	if s == nil {
		return nil
	}
	return s.Action
}

func (s *SearchTerminalActionsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchTerminalActionsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalActionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalActionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalActionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalActionsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalCheckoutsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalCheckout` objects.
	Checkouts []*TerminalCheckout `json:"checkouts,omitempty" url:"checkouts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchTerminalCheckoutsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchTerminalCheckoutsResponse) GetCheckouts() []*TerminalCheckout {
	if s == nil {
		return nil
	}
	return s.Checkouts
}

func (s *SearchTerminalCheckoutsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchTerminalCheckoutsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalCheckoutsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalCheckoutsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalCheckoutsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalCheckoutsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SearchTerminalRefundsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested search result of `TerminalRefund` objects.
	Refunds []*TerminalRefund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchTerminalRefundsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchTerminalRefundsResponse) GetRefunds() []*TerminalRefund {
	if s == nil {
		return nil
	}
	return s.Refunds
}

func (s *SearchTerminalRefundsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchTerminalRefundsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTerminalRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTerminalRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTerminalRefundsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTerminalRefundsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SelectOption struct {
	// The reference id for the option.
	ReferenceID string `json:"reference_id" url:"reference_id"`
	// The title text that displays in the select option button.
	Title string `json:"title" url:"title"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SelectOption) GetReferenceID() string {
	if s == nil {
		return ""
	}
	return s.ReferenceID
}

func (s *SelectOption) GetTitle() string {
	if s == nil {
		return ""
	}
	return s.Title
}

func (s *SelectOption) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SelectOption) UnmarshalJSON(data []byte) error {
	type unmarshaler SelectOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SelectOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SelectOption) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SelectOptions struct {
	// The title text to display in the select flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display in the select flow on the Terminal.
	Body string `json:"body" url:"body"`
	// Represents the buttons/options that should be displayed in the select flow on the Terminal.
	Options []*SelectOption `json:"options" url:"options"`
	// The buyer’s selected option.
	SelectedOption *SelectOption `json:"selected_option,omitempty" url:"selected_option,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SelectOptions) GetTitle() string {
	if s == nil {
		return ""
	}
	return s.Title
}

func (s *SelectOptions) GetBody() string {
	if s == nil {
		return ""
	}
	return s.Body
}

func (s *SelectOptions) GetOptions() []*SelectOption {
	if s == nil {
		return nil
	}
	return s.Options
}

func (s *SelectOptions) GetSelectedOption() *SelectOption {
	if s == nil {
		return nil
	}
	return s.SelectedOption
}

func (s *SelectOptions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SelectOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler SelectOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SelectOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SelectOptions) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A record of the hourly rate, start, and end times for a single work shift
// for an employee. This might include a record of the start and end times for breaks
// taken during the shift.
//
// Deprecated at Square API version 2025-05-21. Replaced by [Timecard](entity:Timecard).
// See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type Shift struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the employee this shift belongs to. DEPRECATED at version 2020-08-26. Use `team_member_id` instead.
	EmployeeID *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// The ID of the location this shift occurred at. The location should be based on
	// where the employee clocked in.
	LocationID string `json:"location_id" url:"location_id"`
	// The read-only convenience value that is calculated from the location based
	// on the `location_id`. Format: the IANA timezone database identifier for the
	// location timezone.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// RFC 3339; shifted to the location timezone + offset. Precision up to the
	// minute is respected; seconds are truncated.
	StartAt string `json:"start_at" url:"start_at"`
	// RFC 3339; shifted to the timezone + offset. Precision up to the minute is
	// respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// Job and pay related information. If the wage is not set on create, it defaults to a wage
	// of zero. If the title is not set on create, it defaults to the name of the role the employee
	// is assigned to, if any.
	Wage *ShiftWage `json:"wage,omitempty" url:"wage,omitempty"`
	// A list of all the paid or unpaid breaks that were taken during this shift.
	Breaks []*Break `json:"breaks,omitempty" url:"breaks,omitempty"`
	// Describes the working state of the current `Shift`.
	// See [ShiftStatus](#type-shiftstatus) for possible values
	Status *ShiftStatus `json:"status,omitempty" url:"status,omitempty"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write; potentially overwriting data from another
	// write.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the team member this shift belongs to. Replaced `employee_id` at version "2020-08-26".
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The tips declared by the team member for the shift.
	DeclaredCashTipMoney *Money `json:"declared_cash_tip_money,omitempty" url:"declared_cash_tip_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Shift) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Shift) GetEmployeeID() *string {
	if s == nil {
		return nil
	}
	return s.EmployeeID
}

func (s *Shift) GetLocationID() string {
	if s == nil {
		return ""
	}
	return s.LocationID
}

func (s *Shift) GetTimezone() *string {
	if s == nil {
		return nil
	}
	return s.Timezone
}

func (s *Shift) GetStartAt() string {
	if s == nil {
		return ""
	}
	return s.StartAt
}

func (s *Shift) GetEndAt() *string {
	if s == nil {
		return nil
	}
	return s.EndAt
}

func (s *Shift) GetWage() *ShiftWage {
	if s == nil {
		return nil
	}
	return s.Wage
}

func (s *Shift) GetBreaks() []*Break {
	if s == nil {
		return nil
	}
	return s.Breaks
}

func (s *Shift) GetStatus() *ShiftStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *Shift) GetVersion() *int {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *Shift) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *Shift) GetUpdatedAt() *string {
	if s == nil {
		return nil
	}
	return s.UpdatedAt
}

func (s *Shift) GetTeamMemberID() *string {
	if s == nil {
		return nil
	}
	return s.TeamMemberID
}

func (s *Shift) GetDeclaredCashTipMoney() *Money {
	if s == nil {
		return nil
	}
	return s.DeclaredCashTipMoney
}

func (s *Shift) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Shift) UnmarshalJSON(data []byte) error {
	type unmarshaler Shift
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Shift(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Shift) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines a filter used in a search for `Shift` records. `AND` logic is
// used by Square's servers to apply each filter property specified.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftFilter struct {
	// Fetch shifts for the specified location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Fetch shifts for the specified employees. DEPRECATED at version 2020-08-26. Use `team_member_ids` instead.
	EmployeeIDs []string `json:"employee_ids,omitempty" url:"employee_ids,omitempty"`
	// Fetch a `Shift` instance by `Shift.status`.
	// See [ShiftFilterStatus](#type-shiftfilterstatus) for possible values
	Status *ShiftFilterStatus `json:"status,omitempty" url:"status,omitempty"`
	// Fetch `Shift` instances that start in the time range - Inclusive.
	Start *TimeRange `json:"start,omitempty" url:"start,omitempty"`
	// Fetch the `Shift` instances that end in the time range - Inclusive.
	End *TimeRange `json:"end,omitempty" url:"end,omitempty"`
	// Fetch the `Shift` instances based on the workday date range.
	Workday *ShiftWorkday `json:"workday,omitempty" url:"workday,omitempty"`
	// Fetch shifts for the specified team members. Replaced `employee_ids` at version "2020-08-26".
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ShiftFilter) GetLocationIDs() []string {
	if s == nil {
		return nil
	}
	return s.LocationIDs
}

func (s *ShiftFilter) GetEmployeeIDs() []string {
	if s == nil {
		return nil
	}
	return s.EmployeeIDs
}

func (s *ShiftFilter) GetStatus() *ShiftFilterStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *ShiftFilter) GetStart() *TimeRange {
	if s == nil {
		return nil
	}
	return s.Start
}

func (s *ShiftFilter) GetEnd() *TimeRange {
	if s == nil {
		return nil
	}
	return s.End
}

func (s *ShiftFilter) GetWorkday() *ShiftWorkday {
	if s == nil {
		return nil
	}
	return s.Workday
}

func (s *ShiftFilter) GetTeamMemberIDs() []string {
	if s == nil {
		return nil
	}
	return s.TeamMemberIDs
}

func (s *ShiftFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftFilter) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies the `status` of `Shift` records to be returned.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftFilterStatus string

const (
	ShiftFilterStatusOpen   ShiftFilterStatus = "OPEN"
	ShiftFilterStatusClosed ShiftFilterStatus = "CLOSED"
)

func NewShiftFilterStatusFromString(s string) (ShiftFilterStatus, error) {
	switch s {
	case "OPEN":
		return ShiftFilterStatusOpen, nil
	case "CLOSED":
		return ShiftFilterStatusClosed, nil
	}
	var t ShiftFilterStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftFilterStatus) Ptr() *ShiftFilterStatus {
	return &s
}

// The parameters of a `Shift` search query, which includes filter and sort options.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftQuery struct {
	// Query filter options.
	Filter *ShiftFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Sort order details.
	Sort *ShiftSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ShiftQuery) GetFilter() *ShiftFilter {
	if s == nil {
		return nil
	}
	return s.Filter
}

func (s *ShiftQuery) GetSort() *ShiftSort {
	if s == nil {
		return nil
	}
	return s.Sort
}

func (s *ShiftQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftQuery) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sets the sort order of search results.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftSort struct {
	// The field to sort on.
	// See [ShiftSortField](#type-shiftsortfield) for possible values
	Field *ShiftSortField `json:"field,omitempty" url:"field,omitempty"`
	// The order in which results are returned. Defaults to DESC.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ShiftSort) GetField() *ShiftSortField {
	if s == nil {
		return nil
	}
	return s.Field
}

func (s *ShiftSort) GetOrder() *SortOrder {
	if s == nil {
		return nil
	}
	return s.Order
}

func (s *ShiftSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftSort) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftSort(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftSort) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Enumerates the `Shift` fields to sort on.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftSortField string

const (
	ShiftSortFieldStartAt   ShiftSortField = "START_AT"
	ShiftSortFieldEndAt     ShiftSortField = "END_AT"
	ShiftSortFieldCreatedAt ShiftSortField = "CREATED_AT"
	ShiftSortFieldUpdatedAt ShiftSortField = "UPDATED_AT"
)

func NewShiftSortFieldFromString(s string) (ShiftSortField, error) {
	switch s {
	case "START_AT":
		return ShiftSortFieldStartAt, nil
	case "END_AT":
		return ShiftSortFieldEndAt, nil
	case "CREATED_AT":
		return ShiftSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return ShiftSortFieldUpdatedAt, nil
	}
	var t ShiftSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftSortField) Ptr() *ShiftSortField {
	return &s
}

// Enumerates the possible status of a `Shift`.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftStatus string

const (
	ShiftStatusOpen   ShiftStatus = "OPEN"
	ShiftStatusClosed ShiftStatus = "CLOSED"
)

func NewShiftStatusFromString(s string) (ShiftStatus, error) {
	switch s {
	case "OPEN":
		return ShiftStatusOpen, nil
	case "CLOSED":
		return ShiftStatusClosed, nil
	}
	var t ShiftStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftStatus) Ptr() *ShiftStatus {
	return &s
}

// The hourly wage rate used to compensate an employee for this shift.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftWage struct {
	// The name of the job performed during this shift.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// The id of the job performed during this shift. Square
	// labor-reporting UIs might group shifts together by id.
	JobID *string `json:"job_id,omitempty" url:"job_id,omitempty"`
	// Whether team members are eligible for tips when working this job.
	TipEligible *bool `json:"tip_eligible,omitempty" url:"tip_eligible,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ShiftWage) GetTitle() *string {
	if s == nil {
		return nil
	}
	return s.Title
}

func (s *ShiftWage) GetHourlyRate() *Money {
	if s == nil {
		return nil
	}
	return s.HourlyRate
}

func (s *ShiftWage) GetJobID() *string {
	if s == nil {
		return nil
	}
	return s.JobID
}

func (s *ShiftWage) GetTipEligible() *bool {
	if s == nil {
		return nil
	}
	return s.TipEligible
}

func (s *ShiftWage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftWage) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftWage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftWage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A `Shift` search query filter parameter that sets a range of days that
// a `Shift` must start or end in before passing the filter condition.
//
// Deprecated at Square API version 2025-05-21. See the [migration notes](https://developer.squareup.com/docs/labor-api/what-it-does#migration-notes).
type ShiftWorkday struct {
	// Dates for fetching the shifts.
	DateRange *DateRange `json:"date_range,omitempty" url:"date_range,omitempty"`
	// The strategy on which the dates are applied.
	// See [ShiftWorkdayMatcher](#type-shiftworkdaymatcher) for possible values
	MatchShiftsBy *ShiftWorkdayMatcher `json:"match_shifts_by,omitempty" url:"match_shifts_by,omitempty"`
	// Location-specific timezones convert workdays to datetime filters.
	// Every location included in the query must have a timezone or this field
	// must be provided as a fallback. Format: the IANA timezone database
	// identifier for the relevant timezone.
	DefaultTimezone *string `json:"default_timezone,omitempty" url:"default_timezone,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ShiftWorkday) GetDateRange() *DateRange {
	if s == nil {
		return nil
	}
	return s.DateRange
}

func (s *ShiftWorkday) GetMatchShiftsBy() *ShiftWorkdayMatcher {
	if s == nil {
		return nil
	}
	return s.MatchShiftsBy
}

func (s *ShiftWorkday) GetDefaultTimezone() *string {
	if s == nil {
		return nil
	}
	return s.DefaultTimezone
}

func (s *ShiftWorkday) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShiftWorkday) UnmarshalJSON(data []byte) error {
	type unmarshaler ShiftWorkday
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShiftWorkday(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShiftWorkday) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the logic used to apply a workday filter.
type ShiftWorkdayMatcher string

const (
	ShiftWorkdayMatcherStartAt      ShiftWorkdayMatcher = "START_AT"
	ShiftWorkdayMatcherEndAt        ShiftWorkdayMatcher = "END_AT"
	ShiftWorkdayMatcherIntersection ShiftWorkdayMatcher = "INTERSECTION"
)

func NewShiftWorkdayMatcherFromString(s string) (ShiftWorkdayMatcher, error) {
	switch s {
	case "START_AT":
		return ShiftWorkdayMatcherStartAt, nil
	case "END_AT":
		return ShiftWorkdayMatcherEndAt, nil
	case "INTERSECTION":
		return ShiftWorkdayMatcherIntersection, nil
	}
	var t ShiftWorkdayMatcher
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShiftWorkdayMatcher) Ptr() *ShiftWorkdayMatcher {
	return &s
}

type ShippingFee struct {
	// The name for the shipping fee.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The amount and currency for the shipping fee.
	Charge *Money `json:"charge" url:"charge"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ShippingFee) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *ShippingFee) GetCharge() *Money {
	if s == nil {
		return nil
	}
	return s.Charge
}

func (s *ShippingFee) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ShippingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ShippingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ShippingFee(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ShippingFee) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SignatureImage struct {
	// The mime/type of the image data.
	// Use `image/png;base64` for png.
	ImageType *string `json:"image_type,omitempty" url:"image_type,omitempty"`
	// The base64 representation of the image.
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignatureImage) GetImageType() *string {
	if s == nil {
		return nil
	}
	return s.ImageType
}

func (s *SignatureImage) GetData() *string {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SignatureImage) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureImage) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureImage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureImage) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SignatureOptions struct {
	// The title text to display in the signature capture flow on the Terminal.
	Title string `json:"title" url:"title"`
	// The body text to display in the signature capture flow on the Terminal.
	Body string `json:"body" url:"body"`
	// An image representation of the collected signature.
	Signature []*SignatureImage `json:"signature,omitempty" url:"signature,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SignatureOptions) GetTitle() string {
	if s == nil {
		return ""
	}
	return s.Title
}

func (s *SignatureOptions) GetBody() string {
	if s == nil {
		return ""
	}
	return s.Body
}

func (s *SignatureOptions) GetSignature() []*SignatureImage {
	if s == nil {
		return nil
	}
	return s.Signature
}

func (s *SignatureOptions) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SignatureOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler SignatureOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SignatureOptions(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SignatureOptions) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The order (e.g., chronological or alphabetical) in which results from a request are returned.
type SortOrder string

const (
	SortOrderDesc SortOrder = "DESC"
	SortOrderAsc  SortOrder = "ASC"
)

func NewSortOrderFromString(s string) (SortOrder, error) {
	switch s {
	case "DESC":
		return SortOrderDesc, nil
	case "ASC":
		return SortOrderAsc, nil
	}
	var t SortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortOrder) Ptr() *SortOrder {
	return &s
}

// Represents information about the application used to generate a change.
type SourceApplication struct {
	// __Read only__ The [product](entity:Product) type of the application.
	// See [Product](#type-product) for possible values
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// __Read only__ The Square-assigned ID of the application. This field is used only if the
	// [product](entity:Product) type is `EXTERNAL_API`.
	ApplicationID *string `json:"application_id,omitempty" url:"application_id,omitempty"`
	// __Read only__ The display name of the application
	// (for example, `"Custom Application"` or `"Square POS 4.74 for Android"`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceApplication) GetProduct() *Product {
	if s == nil {
		return nil
	}
	return s.Product
}

func (s *SourceApplication) GetApplicationID() *string {
	if s == nil {
		return nil
	}
	return s.ApplicationID
}

func (s *SourceApplication) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SourceApplication) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceApplication) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceApplication
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceApplication(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceApplication) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Determines the billing cadence of a [Subscription](entity:Subscription)
type SubscriptionCadence string

const (
	SubscriptionCadenceDaily           SubscriptionCadence = "DAILY"
	SubscriptionCadenceWeekly          SubscriptionCadence = "WEEKLY"
	SubscriptionCadenceEveryTwoWeeks   SubscriptionCadence = "EVERY_TWO_WEEKS"
	SubscriptionCadenceThirtyDays      SubscriptionCadence = "THIRTY_DAYS"
	SubscriptionCadenceSixtyDays       SubscriptionCadence = "SIXTY_DAYS"
	SubscriptionCadenceNinetyDays      SubscriptionCadence = "NINETY_DAYS"
	SubscriptionCadenceMonthly         SubscriptionCadence = "MONTHLY"
	SubscriptionCadenceEveryTwoMonths  SubscriptionCadence = "EVERY_TWO_MONTHS"
	SubscriptionCadenceQuarterly       SubscriptionCadence = "QUARTERLY"
	SubscriptionCadenceEveryFourMonths SubscriptionCadence = "EVERY_FOUR_MONTHS"
	SubscriptionCadenceEverySixMonths  SubscriptionCadence = "EVERY_SIX_MONTHS"
	SubscriptionCadenceAnnual          SubscriptionCadence = "ANNUAL"
	SubscriptionCadenceEveryTwoYears   SubscriptionCadence = "EVERY_TWO_YEARS"
)

func NewSubscriptionCadenceFromString(s string) (SubscriptionCadence, error) {
	switch s {
	case "DAILY":
		return SubscriptionCadenceDaily, nil
	case "WEEKLY":
		return SubscriptionCadenceWeekly, nil
	case "EVERY_TWO_WEEKS":
		return SubscriptionCadenceEveryTwoWeeks, nil
	case "THIRTY_DAYS":
		return SubscriptionCadenceThirtyDays, nil
	case "SIXTY_DAYS":
		return SubscriptionCadenceSixtyDays, nil
	case "NINETY_DAYS":
		return SubscriptionCadenceNinetyDays, nil
	case "MONTHLY":
		return SubscriptionCadenceMonthly, nil
	case "EVERY_TWO_MONTHS":
		return SubscriptionCadenceEveryTwoMonths, nil
	case "QUARTERLY":
		return SubscriptionCadenceQuarterly, nil
	case "EVERY_FOUR_MONTHS":
		return SubscriptionCadenceEveryFourMonths, nil
	case "EVERY_SIX_MONTHS":
		return SubscriptionCadenceEverySixMonths, nil
	case "ANNUAL":
		return SubscriptionCadenceAnnual, nil
	case "EVERY_TWO_YEARS":
		return SubscriptionCadenceEveryTwoYears, nil
	}
	var t SubscriptionCadence
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionCadence) Ptr() *SubscriptionCadence {
	return &s
}

// Published when a [Subscription](entity:Subscription) is created.
type SubscriptionCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"subscription.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *SubscriptionCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionCreatedEvent) GetMerchantID() *string {
	if s == nil {
		return nil
	}
	return s.MerchantID
}

func (s *SubscriptionCreatedEvent) GetType() *string {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SubscriptionCreatedEvent) GetEventID() *string {
	if s == nil {
		return nil
	}
	return s.EventID
}

func (s *SubscriptionCreatedEvent) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *SubscriptionCreatedEvent) GetData() *SubscriptionCreatedEventData {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SubscriptionCreatedEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionCreatedEvent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionCreatedEventData struct {
	// Name of the affected object’s type, `"subscription"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created subscription.
	Object *SubscriptionCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionCreatedEventData) GetType() *string {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SubscriptionCreatedEventData) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *SubscriptionCreatedEventData) GetObject() *SubscriptionCreatedEventObject {
	if s == nil {
		return nil
	}
	return s.Object
}

func (s *SubscriptionCreatedEventData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionCreatedEventData) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionCreatedEventObject struct {
	// The created subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionCreatedEventObject) GetSubscription() *Subscription {
	if s == nil {
		return nil
	}
	return s.Subscription
}

func (s *SubscriptionCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionCreatedEventObject) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Describes a phase in a subscription plan variation. For more information, see [Subscription Plans and Variations](https://developer.squareup.com/docs/subscriptions-api/plans-and-variations).
type SubscriptionPhase struct {
	// The Square-assigned ID of the subscription phase. This field cannot be changed after a `SubscriptionPhase` is created.
	UID *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The billing cadence of the phase. For example, weekly or monthly. This field cannot be changed after a `SubscriptionPhase` is created.
	// See [SubscriptionCadence](#type-subscriptioncadence) for possible values
	Cadence SubscriptionCadence `json:"cadence" url:"cadence"`
	// The number of `cadence`s the phase lasts. If not set, the phase never ends. Only the last phase can be indefinite. This field cannot be changed after a `SubscriptionPhase` is created.
	Periods *int `json:"periods,omitempty" url:"periods,omitempty"`
	// The amount to bill for each `cadence`. Failure to specify this field results in a `MISSING_REQUIRED_PARAMETER` error at runtime.
	RecurringPriceMoney *Money `json:"recurring_price_money,omitempty" url:"recurring_price_money,omitempty"`
	// The position this phase appears in the sequence of phases defined for the plan, indexed from 0. This field cannot be changed after a `SubscriptionPhase` is created.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// The subscription pricing.
	Pricing *SubscriptionPricing `json:"pricing,omitempty" url:"pricing,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionPhase) GetUID() *string {
	if s == nil {
		return nil
	}
	return s.UID
}

func (s *SubscriptionPhase) GetCadence() SubscriptionCadence {
	if s == nil {
		return ""
	}
	return s.Cadence
}

func (s *SubscriptionPhase) GetPeriods() *int {
	if s == nil {
		return nil
	}
	return s.Periods
}

func (s *SubscriptionPhase) GetRecurringPriceMoney() *Money {
	if s == nil {
		return nil
	}
	return s.RecurringPriceMoney
}

func (s *SubscriptionPhase) GetOrdinal() *int64 {
	if s == nil {
		return nil
	}
	return s.Ordinal
}

func (s *SubscriptionPhase) GetPricing() *SubscriptionPricing {
	if s == nil {
		return nil
	}
	return s.Pricing
}

func (s *SubscriptionPhase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPhase) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPhase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPhase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPhase) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Describes the pricing for the subscription.
type SubscriptionPricing struct {
	// RELATIVE or STATIC
	// See [SubscriptionPricingType](#type-subscriptionpricingtype) for possible values
	Type *SubscriptionPricingType `json:"type,omitempty" url:"type,omitempty"`
	// The ids of the discount catalog objects
	DiscountIDs []string `json:"discount_ids,omitempty" url:"discount_ids,omitempty"`
	// The price of the subscription, if STATIC
	PriceMoney *Money `json:"price_money,omitempty" url:"price_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionPricing) GetType() *SubscriptionPricingType {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SubscriptionPricing) GetDiscountIDs() []string {
	if s == nil {
		return nil
	}
	return s.DiscountIDs
}

func (s *SubscriptionPricing) GetPriceMoney() *Money {
	if s == nil {
		return nil
	}
	return s.PriceMoney
}

func (s *SubscriptionPricing) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPricing) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPricing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPricing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPricing) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Determines the pricing of a [Subscription](entity:Subscription)
type SubscriptionPricingType string

const (
	SubscriptionPricingTypeStatic   SubscriptionPricingType = "STATIC"
	SubscriptionPricingTypeRelative SubscriptionPricingType = "RELATIVE"
)

func NewSubscriptionPricingTypeFromString(s string) (SubscriptionPricingType, error) {
	switch s {
	case "STATIC":
		return SubscriptionPricingTypeStatic, nil
	case "RELATIVE":
		return SubscriptionPricingTypeRelative, nil
	}
	var t SubscriptionPricingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionPricingType) Ptr() *SubscriptionPricingType {
	return &s
}

// Represents the details of a webhook subscription, including notification URL,
// event types, and signature key.
type SubscriptionTestResult struct {
	// A Square-generated unique ID for the subscription test result.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The status code returned by the subscription notification URL.
	StatusCode *int `json:"status_code,omitempty" url:"status_code,omitempty"`
	// An object containing the payload of the test event. For example, a `payment.created` event.
	Payload *string `json:"payload,omitempty" url:"payload,omitempty"`
	// The timestamp of when the subscription was created, in RFC 3339 format.
	// For example, "2016-09-04T23:59:33.123Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the subscription was updated, in RFC 3339 format. For example, "2016-09-04T23:59:33.123Z".
	// Because a subscription test result is unique, this field is the same as the `created_at` field.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionTestResult) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *SubscriptionTestResult) GetStatusCode() *int {
	if s == nil {
		return nil
	}
	return s.StatusCode
}

func (s *SubscriptionTestResult) GetPayload() *string {
	if s == nil {
		return nil
	}
	return s.Payload
}

func (s *SubscriptionTestResult) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *SubscriptionTestResult) GetUpdatedAt() *string {
	if s == nil {
		return nil
	}
	return s.UpdatedAt
}

func (s *SubscriptionTestResult) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionTestResult) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionTestResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionTestResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionTestResult) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Published when a [Subscription](entity:Subscription) is updated.
// Typically the `subscription.status` is updated as subscriptions become active
// or cancelled.
type SubscriptionUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"subscription.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *SubscriptionUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionUpdatedEvent) GetMerchantID() *string {
	if s == nil {
		return nil
	}
	return s.MerchantID
}

func (s *SubscriptionUpdatedEvent) GetType() *string {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SubscriptionUpdatedEvent) GetEventID() *string {
	if s == nil {
		return nil
	}
	return s.EventID
}

func (s *SubscriptionUpdatedEvent) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *SubscriptionUpdatedEvent) GetData() *SubscriptionUpdatedEventData {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SubscriptionUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionUpdatedEvent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionUpdatedEventData struct {
	// Name of the affected object’s type, `"subscription"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated subscription.
	Object *SubscriptionUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionUpdatedEventData) GetType() *string {
	if s == nil {
		return nil
	}
	return s.Type
}

func (s *SubscriptionUpdatedEventData) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *SubscriptionUpdatedEventData) GetObject() *SubscriptionUpdatedEventObject {
	if s == nil {
		return nil
	}
	return s.Object
}

func (s *SubscriptionUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionUpdatedEventData) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SubscriptionUpdatedEventObject struct {
	// The updated subscription.
	Subscription *Subscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubscriptionUpdatedEventObject) GetSubscription() *Subscription {
	if s == nil {
		return nil
	}
	return s.Subscription
}

func (s *SubscriptionUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionUpdatedEventObject) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// When to calculate the taxes due on a cart.
type TaxCalculationPhase string

const (
	TaxCalculationPhaseTaxSubtotalPhase TaxCalculationPhase = "TAX_SUBTOTAL_PHASE"
	TaxCalculationPhaseTaxTotalPhase    TaxCalculationPhase = "TAX_TOTAL_PHASE"
)

func NewTaxCalculationPhaseFromString(s string) (TaxCalculationPhase, error) {
	switch s {
	case "TAX_SUBTOTAL_PHASE":
		return TaxCalculationPhaseTaxSubtotalPhase, nil
	case "TAX_TOTAL_PHASE":
		return TaxCalculationPhaseTaxTotalPhase, nil
	}
	var t TaxCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxCalculationPhase) Ptr() *TaxCalculationPhase {
	return &t
}

// Whether to the tax amount should be additional to or included in the CatalogItem price.
type TaxInclusionType string

const (
	TaxInclusionTypeAdditive  TaxInclusionType = "ADDITIVE"
	TaxInclusionTypeInclusive TaxInclusionType = "INCLUSIVE"
)

func NewTaxInclusionTypeFromString(s string) (TaxInclusionType, error) {
	switch s {
	case "ADDITIVE":
		return TaxInclusionTypeAdditive, nil
	case "INCLUSIVE":
		return TaxInclusionTypeInclusive, nil
	}
	var t TaxInclusionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxInclusionType) Ptr() *TaxInclusionType {
	return &t
}

// The booking profile of a seller's team member, including the team member's ID, display name, description and whether the team member can be booked as a service provider.
type TeamMemberBookingProfile struct {
	// The ID of the [TeamMember](entity:TeamMember) object for the team member associated with the booking profile.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The description of the team member.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The display name of the team member.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// Indicates whether the team member can be booked through the Bookings API or the seller's online booking channel or site (`true`) or not (`false`).
	IsBookable *bool `json:"is_bookable,omitempty" url:"is_bookable,omitempty"`
	// The URL of the team member's image for the bookings profile.
	ProfileImageURL *string `json:"profile_image_url,omitempty" url:"profile_image_url,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberBookingProfile) GetTeamMemberID() *string {
	if t == nil {
		return nil
	}
	return t.TeamMemberID
}

func (t *TeamMemberBookingProfile) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TeamMemberBookingProfile) GetDisplayName() *string {
	if t == nil {
		return nil
	}
	return t.DisplayName
}

func (t *TeamMemberBookingProfile) GetIsBookable() *bool {
	if t == nil {
		return nil
	}
	return t.IsBookable
}

func (t *TeamMemberBookingProfile) GetProfileImageURL() *string {
	if t == nil {
		return nil
	}
	return t.ProfileImageURL
}

func (t *TeamMemberBookingProfile) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberBookingProfile) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberBookingProfile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberBookingProfile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberBookingProfile) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Team Member is created.
type TeamMemberCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"team_member.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TeamMemberCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberCreatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TeamMemberCreatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TeamMemberCreatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TeamMemberCreatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TeamMemberCreatedEvent) GetData() *TeamMemberCreatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TeamMemberCreatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberCreatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberCreatedEventData struct {
	// Name of the affected object’s type, `"team_member"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created team member.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created team member.
	Object *TeamMemberCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberCreatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TeamMemberCreatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TeamMemberCreatedEventData) GetObject() *TeamMemberCreatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TeamMemberCreatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberCreatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberCreatedEventObject struct {
	// The created team member.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberCreatedEventObject) GetTeamMember() *TeamMember {
	if t == nil {
		return nil
	}
	return t.TeamMember
}

func (t *TeamMemberCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberCreatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Enumerates the possible invitation statuses the team member can have within a business.
type TeamMemberInvitationStatus string

const (
	TeamMemberInvitationStatusUninvited TeamMemberInvitationStatus = "UNINVITED"
	TeamMemberInvitationStatusPending   TeamMemberInvitationStatus = "PENDING"
	TeamMemberInvitationStatusAccepted  TeamMemberInvitationStatus = "ACCEPTED"
)

func NewTeamMemberInvitationStatusFromString(s string) (TeamMemberInvitationStatus, error) {
	switch s {
	case "UNINVITED":
		return TeamMemberInvitationStatusUninvited, nil
	case "PENDING":
		return TeamMemberInvitationStatusPending, nil
	case "ACCEPTED":
		return TeamMemberInvitationStatusAccepted, nil
	}
	var t TeamMemberInvitationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TeamMemberInvitationStatus) Ptr() *TeamMemberInvitationStatus {
	return &t
}

// Published when a Team Member is updated.
type TeamMemberUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"team_member.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TeamMemberUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberUpdatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TeamMemberUpdatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TeamMemberUpdatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TeamMemberUpdatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TeamMemberUpdatedEvent) GetData() *TeamMemberUpdatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TeamMemberUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberUpdatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberUpdatedEventData struct {
	// Name of the affected object’s type, `"team_member"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the affected team member.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated team member.
	Object *TeamMemberUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberUpdatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TeamMemberUpdatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TeamMemberUpdatedEventData) GetObject() *TeamMemberUpdatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TeamMemberUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberUpdatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberUpdatedEventObject struct {
	// The updated team member.
	TeamMember *TeamMember `json:"team_member,omitempty" url:"team_member,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberUpdatedEventObject) GetTeamMember() *TeamMember {
	if t == nil {
		return nil
	}
	return t.TeamMember
}

func (t *TeamMemberUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberUpdatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Job and wage information for a [team member](entity:TeamMember).
// This convenience object provides details needed to specify the `wage`
// field for a [timecard](entity:Timecard).
type TeamMemberWage struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The `TeamMember` that this wage is assigned to.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The job title that this wage relates to.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// An identifier for the [job](entity:Job) that this wage relates to.
	JobID *string `json:"job_id,omitempty" url:"job_id,omitempty"`
	// Whether team members are eligible for tips when working this job.
	TipEligible *bool `json:"tip_eligible,omitempty" url:"tip_eligible,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberWage) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TeamMemberWage) GetTeamMemberID() *string {
	if t == nil {
		return nil
	}
	return t.TeamMemberID
}

func (t *TeamMemberWage) GetTitle() *string {
	if t == nil {
		return nil
	}
	return t.Title
}

func (t *TeamMemberWage) GetHourlyRate() *Money {
	if t == nil {
		return nil
	}
	return t.HourlyRate
}

func (t *TeamMemberWage) GetJobID() *string {
	if t == nil {
		return nil
	}
	return t.JobID
}

func (t *TeamMemberWage) GetTipEligible() *bool {
	if t == nil {
		return nil
	}
	return t.TipEligible
}

func (t *TeamMemberWage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWage) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWage) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Wage Setting is updated.
type TeamMemberWageSettingUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"team_member.wage_setting.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// Timestamp of when the event was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TeamMemberWageSettingUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberWageSettingUpdatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TeamMemberWageSettingUpdatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TeamMemberWageSettingUpdatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TeamMemberWageSettingUpdatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TeamMemberWageSettingUpdatedEvent) GetData() *TeamMemberWageSettingUpdatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TeamMemberWageSettingUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWageSettingUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWageSettingUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWageSettingUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWageSettingUpdatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberWageSettingUpdatedEventData struct {
	// Name of the affected object’s type, `"wage_setting"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated team member wage setting.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated team member wage setting.
	Object *TeamMemberWageSettingUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberWageSettingUpdatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TeamMemberWageSettingUpdatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TeamMemberWageSettingUpdatedEventData) GetObject() *TeamMemberWageSettingUpdatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TeamMemberWageSettingUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWageSettingUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWageSettingUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWageSettingUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWageSettingUpdatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TeamMemberWageSettingUpdatedEventObject struct {
	// The updated team member wage setting.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TeamMemberWageSettingUpdatedEventObject) GetWageSetting() *WageSetting {
	if t == nil {
		return nil
	}
	return t.WageSetting
}

func (t *TeamMemberWageSettingUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TeamMemberWageSettingUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TeamMemberWageSettingUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TeamMemberWageSettingUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TeamMemberWageSettingUpdatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a tender (i.e., a method of payment) used in a Square transaction.
type Tender struct {
	// The tender's unique ID. It is the associated payment ID.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the transaction's associated location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the tender's associated transaction.
	TransactionID *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The timestamp for when the tender was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// An optional note associated with the tender at the time of payment.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The total amount of the tender, including `tip_money`. If the tender has a `payment_id`,
	// the `total_money` of the corresponding [Payment](entity:Payment) will be equal to the
	// `amount_money` of the tender.
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The tip's amount of the tender.
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	// The amount of any Square processing fees applied to the tender.
	//
	// This field is not immediately populated when a new transaction is created.
	// It is usually available after about ten seconds.
	ProcessingFeeMoney *Money `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// If the tender is associated with a customer or represents a customer's card on file,
	// this is the ID of the associated customer.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The type of tender, such as `CARD` or `CASH`.
	// See [TenderType](#type-tendertype) for possible values
	Type TenderType `json:"type" url:"type"`
	// The details of the card tender.
	//
	// This value is present only if the value of `type` is `CARD`.
	CardDetails *TenderCardDetails `json:"card_details,omitempty" url:"card_details,omitempty"`
	// The details of the cash tender.
	//
	// This value is present only if the value of `type` is `CASH`.
	CashDetails *TenderCashDetails `json:"cash_details,omitempty" url:"cash_details,omitempty"`
	// The details of the bank account tender.
	//
	// This value is present only if the value of `type` is `BANK_ACCOUNT`.
	BankAccountDetails *TenderBankAccountDetails `json:"bank_account_details,omitempty" url:"bank_account_details,omitempty"`
	// The details of a Buy Now Pay Later tender.
	//
	// This value is present only if the value of `type` is `BUY_NOW_PAY_LATER`.
	BuyNowPayLaterDetails *TenderBuyNowPayLaterDetails `json:"buy_now_pay_later_details,omitempty" url:"buy_now_pay_later_details,omitempty"`
	// The details of a Square Account tender.
	//
	// This value is present only if the value of `type` is `SQUARE_ACCOUNT`.
	SquareAccountDetails *TenderSquareAccountDetails `json:"square_account_details,omitempty" url:"square_account_details,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this tender.
	// For example, fees assessed on the purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`
	// The ID of the [Payment](entity:Payment) that corresponds to this tender.
	// This value is only present for payments created with the v2 Payments API.
	PaymentID *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Tender) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *Tender) GetLocationID() *string {
	if t == nil {
		return nil
	}
	return t.LocationID
}

func (t *Tender) GetTransactionID() *string {
	if t == nil {
		return nil
	}
	return t.TransactionID
}

func (t *Tender) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *Tender) GetNote() *string {
	if t == nil {
		return nil
	}
	return t.Note
}

func (t *Tender) GetAmountMoney() *Money {
	if t == nil {
		return nil
	}
	return t.AmountMoney
}

func (t *Tender) GetTipMoney() *Money {
	if t == nil {
		return nil
	}
	return t.TipMoney
}

func (t *Tender) GetProcessingFeeMoney() *Money {
	if t == nil {
		return nil
	}
	return t.ProcessingFeeMoney
}

func (t *Tender) GetCustomerID() *string {
	if t == nil {
		return nil
	}
	return t.CustomerID
}

func (t *Tender) GetType() TenderType {
	if t == nil {
		return ""
	}
	return t.Type
}

func (t *Tender) GetCardDetails() *TenderCardDetails {
	if t == nil {
		return nil
	}
	return t.CardDetails
}

func (t *Tender) GetCashDetails() *TenderCashDetails {
	if t == nil {
		return nil
	}
	return t.CashDetails
}

func (t *Tender) GetBankAccountDetails() *TenderBankAccountDetails {
	if t == nil {
		return nil
	}
	return t.BankAccountDetails
}

func (t *Tender) GetBuyNowPayLaterDetails() *TenderBuyNowPayLaterDetails {
	if t == nil {
		return nil
	}
	return t.BuyNowPayLaterDetails
}

func (t *Tender) GetSquareAccountDetails() *TenderSquareAccountDetails {
	if t == nil {
		return nil
	}
	return t.SquareAccountDetails
}

func (t *Tender) GetAdditionalRecipients() []*AdditionalRecipient {
	if t == nil {
		return nil
	}
	return t.AdditionalRecipients
}

func (t *Tender) GetPaymentID() *string {
	if t == nil {
		return nil
	}
	return t.PaymentID
}

func (t *Tender) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Tender) UnmarshalJSON(data []byte) error {
	type unmarshaler Tender
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tender(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tender) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents the details of a tender with `type` `BANK_ACCOUNT`.
//
// See [BankAccountPaymentDetails](entity:BankAccountPaymentDetails)
// for more exposed details of a bank account payment.
type TenderBankAccountDetails struct {
	// The bank account payment's current state.
	//
	// See [TenderBankAccountPaymentDetailsStatus](entity:TenderBankAccountDetailsStatus) for possible values.
	// See [TenderBankAccountDetailsStatus](#type-tenderbankaccountdetailsstatus) for possible values
	Status *TenderBankAccountDetailsStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TenderBankAccountDetails) GetStatus() *TenderBankAccountDetailsStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TenderBankAccountDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderBankAccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderBankAccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderBankAccountDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderBankAccountDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the bank account payment's current status.
type TenderBankAccountDetailsStatus string

const (
	TenderBankAccountDetailsStatusPending   TenderBankAccountDetailsStatus = "PENDING"
	TenderBankAccountDetailsStatusCompleted TenderBankAccountDetailsStatus = "COMPLETED"
	TenderBankAccountDetailsStatusFailed    TenderBankAccountDetailsStatus = "FAILED"
)

func NewTenderBankAccountDetailsStatusFromString(s string) (TenderBankAccountDetailsStatus, error) {
	switch s {
	case "PENDING":
		return TenderBankAccountDetailsStatusPending, nil
	case "COMPLETED":
		return TenderBankAccountDetailsStatusCompleted, nil
	case "FAILED":
		return TenderBankAccountDetailsStatusFailed, nil
	}
	var t TenderBankAccountDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderBankAccountDetailsStatus) Ptr() *TenderBankAccountDetailsStatus {
	return &t
}

// Represents the details of a tender with `type` `BUY_NOW_PAY_LATER`.
type TenderBuyNowPayLaterDetails struct {
	// The Buy Now Pay Later brand.
	// See [Brand](#type-brand) for possible values
	BuyNowPayLaterBrand *TenderBuyNowPayLaterDetailsBrand `json:"buy_now_pay_later_brand,omitempty" url:"buy_now_pay_later_brand,omitempty"`
	// The buy now pay later payment's current state (such as `AUTHORIZED` or
	// `CAPTURED`). See [TenderBuyNowPayLaterDetailsStatus](entity:TenderBuyNowPayLaterDetailsStatus)
	// for possible values.
	// See [Status](#type-status) for possible values
	Status *TenderBuyNowPayLaterDetailsStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TenderBuyNowPayLaterDetails) GetBuyNowPayLaterBrand() *TenderBuyNowPayLaterDetailsBrand {
	if t == nil {
		return nil
	}
	return t.BuyNowPayLaterBrand
}

func (t *TenderBuyNowPayLaterDetails) GetStatus() *TenderBuyNowPayLaterDetailsStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TenderBuyNowPayLaterDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderBuyNowPayLaterDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderBuyNowPayLaterDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderBuyNowPayLaterDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderBuyNowPayLaterDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TenderBuyNowPayLaterDetailsBrand string

const (
	TenderBuyNowPayLaterDetailsBrandOtherBrand TenderBuyNowPayLaterDetailsBrand = "OTHER_BRAND"
	TenderBuyNowPayLaterDetailsBrandAfterpay   TenderBuyNowPayLaterDetailsBrand = "AFTERPAY"
)

func NewTenderBuyNowPayLaterDetailsBrandFromString(s string) (TenderBuyNowPayLaterDetailsBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return TenderBuyNowPayLaterDetailsBrandOtherBrand, nil
	case "AFTERPAY":
		return TenderBuyNowPayLaterDetailsBrandAfterpay, nil
	}
	var t TenderBuyNowPayLaterDetailsBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderBuyNowPayLaterDetailsBrand) Ptr() *TenderBuyNowPayLaterDetailsBrand {
	return &t
}

type TenderBuyNowPayLaterDetailsStatus string

const (
	TenderBuyNowPayLaterDetailsStatusAuthorized TenderBuyNowPayLaterDetailsStatus = "AUTHORIZED"
	TenderBuyNowPayLaterDetailsStatusCaptured   TenderBuyNowPayLaterDetailsStatus = "CAPTURED"
	TenderBuyNowPayLaterDetailsStatusVoided     TenderBuyNowPayLaterDetailsStatus = "VOIDED"
	TenderBuyNowPayLaterDetailsStatusFailed     TenderBuyNowPayLaterDetailsStatus = "FAILED"
)

func NewTenderBuyNowPayLaterDetailsStatusFromString(s string) (TenderBuyNowPayLaterDetailsStatus, error) {
	switch s {
	case "AUTHORIZED":
		return TenderBuyNowPayLaterDetailsStatusAuthorized, nil
	case "CAPTURED":
		return TenderBuyNowPayLaterDetailsStatusCaptured, nil
	case "VOIDED":
		return TenderBuyNowPayLaterDetailsStatusVoided, nil
	case "FAILED":
		return TenderBuyNowPayLaterDetailsStatusFailed, nil
	}
	var t TenderBuyNowPayLaterDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderBuyNowPayLaterDetailsStatus) Ptr() *TenderBuyNowPayLaterDetailsStatus {
	return &t
}

// Represents additional details of a tender with `type` `CARD` or `SQUARE_GIFT_CARD`
type TenderCardDetails struct {
	// The credit card payment's current state (such as `AUTHORIZED` or
	// `CAPTURED`). See [TenderCardDetailsStatus](entity:TenderCardDetailsStatus)
	// for possible values.
	// See [TenderCardDetailsStatus](#type-tendercarddetailsstatus) for possible values
	Status *TenderCardDetailsStatus `json:"status,omitempty" url:"status,omitempty"`
	// The credit card's non-confidential details.
	Card *Card `json:"card,omitempty" url:"card,omitempty"`
	// The method used to enter the card's details for the transaction.
	// See [TenderCardDetailsEntryMethod](#type-tendercarddetailsentrymethod) for possible values
	EntryMethod *TenderCardDetailsEntryMethod `json:"entry_method,omitempty" url:"entry_method,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TenderCardDetails) GetStatus() *TenderCardDetailsStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TenderCardDetails) GetCard() *Card {
	if t == nil {
		return nil
	}
	return t.Card
}

func (t *TenderCardDetails) GetEntryMethod() *TenderCardDetailsEntryMethod {
	if t == nil {
		return nil
	}
	return t.EntryMethod
}

func (t *TenderCardDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderCardDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderCardDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderCardDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderCardDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the method used to enter the card's details.
type TenderCardDetailsEntryMethod string

const (
	TenderCardDetailsEntryMethodSwiped      TenderCardDetailsEntryMethod = "SWIPED"
	TenderCardDetailsEntryMethodKeyed       TenderCardDetailsEntryMethod = "KEYED"
	TenderCardDetailsEntryMethodEmv         TenderCardDetailsEntryMethod = "EMV"
	TenderCardDetailsEntryMethodOnFile      TenderCardDetailsEntryMethod = "ON_FILE"
	TenderCardDetailsEntryMethodContactless TenderCardDetailsEntryMethod = "CONTACTLESS"
)

func NewTenderCardDetailsEntryMethodFromString(s string) (TenderCardDetailsEntryMethod, error) {
	switch s {
	case "SWIPED":
		return TenderCardDetailsEntryMethodSwiped, nil
	case "KEYED":
		return TenderCardDetailsEntryMethodKeyed, nil
	case "EMV":
		return TenderCardDetailsEntryMethodEmv, nil
	case "ON_FILE":
		return TenderCardDetailsEntryMethodOnFile, nil
	case "CONTACTLESS":
		return TenderCardDetailsEntryMethodContactless, nil
	}
	var t TenderCardDetailsEntryMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderCardDetailsEntryMethod) Ptr() *TenderCardDetailsEntryMethod {
	return &t
}

// Indicates the card transaction's current status.
type TenderCardDetailsStatus string

const (
	TenderCardDetailsStatusAuthorized TenderCardDetailsStatus = "AUTHORIZED"
	TenderCardDetailsStatusCaptured   TenderCardDetailsStatus = "CAPTURED"
	TenderCardDetailsStatusVoided     TenderCardDetailsStatus = "VOIDED"
	TenderCardDetailsStatusFailed     TenderCardDetailsStatus = "FAILED"
)

func NewTenderCardDetailsStatusFromString(s string) (TenderCardDetailsStatus, error) {
	switch s {
	case "AUTHORIZED":
		return TenderCardDetailsStatusAuthorized, nil
	case "CAPTURED":
		return TenderCardDetailsStatusCaptured, nil
	case "VOIDED":
		return TenderCardDetailsStatusVoided, nil
	case "FAILED":
		return TenderCardDetailsStatusFailed, nil
	}
	var t TenderCardDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderCardDetailsStatus) Ptr() *TenderCardDetailsStatus {
	return &t
}

// Represents the details of a tender with `type` `CASH`.
type TenderCashDetails struct {
	// The total amount of cash provided by the buyer, before change is given.
	BuyerTenderedMoney *Money `json:"buyer_tendered_money,omitempty" url:"buyer_tendered_money,omitempty"`
	// The amount of change returned to the buyer.
	ChangeBackMoney *Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TenderCashDetails) GetBuyerTenderedMoney() *Money {
	if t == nil {
		return nil
	}
	return t.BuyerTenderedMoney
}

func (t *TenderCashDetails) GetChangeBackMoney() *Money {
	if t == nil {
		return nil
	}
	return t.ChangeBackMoney
}

func (t *TenderCashDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderCashDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderCashDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderCashDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderCashDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents the details of a tender with `type` `SQUARE_ACCOUNT`.
type TenderSquareAccountDetails struct {
	// The Square Account payment's current state (such as `AUTHORIZED` or
	// `CAPTURED`). See [TenderSquareAccountDetailsStatus](entity:TenderSquareAccountDetailsStatus)
	// for possible values.
	// See [Status](#type-status) for possible values
	Status *TenderSquareAccountDetailsStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TenderSquareAccountDetails) GetStatus() *TenderSquareAccountDetailsStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TenderSquareAccountDetails) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TenderSquareAccountDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler TenderSquareAccountDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TenderSquareAccountDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TenderSquareAccountDetails) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TenderSquareAccountDetailsStatus string

const (
	TenderSquareAccountDetailsStatusAuthorized TenderSquareAccountDetailsStatus = "AUTHORIZED"
	TenderSquareAccountDetailsStatusCaptured   TenderSquareAccountDetailsStatus = "CAPTURED"
	TenderSquareAccountDetailsStatusVoided     TenderSquareAccountDetailsStatus = "VOIDED"
	TenderSquareAccountDetailsStatusFailed     TenderSquareAccountDetailsStatus = "FAILED"
)

func NewTenderSquareAccountDetailsStatusFromString(s string) (TenderSquareAccountDetailsStatus, error) {
	switch s {
	case "AUTHORIZED":
		return TenderSquareAccountDetailsStatusAuthorized, nil
	case "CAPTURED":
		return TenderSquareAccountDetailsStatusCaptured, nil
	case "VOIDED":
		return TenderSquareAccountDetailsStatusVoided, nil
	case "FAILED":
		return TenderSquareAccountDetailsStatusFailed, nil
	}
	var t TenderSquareAccountDetailsStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderSquareAccountDetailsStatus) Ptr() *TenderSquareAccountDetailsStatus {
	return &t
}

// Indicates a tender's type.
type TenderType string

const (
	TenderTypeCard           TenderType = "CARD"
	TenderTypeCash           TenderType = "CASH"
	TenderTypeThirdPartyCard TenderType = "THIRD_PARTY_CARD"
	TenderTypeSquareGiftCard TenderType = "SQUARE_GIFT_CARD"
	TenderTypeNoSale         TenderType = "NO_SALE"
	TenderTypeBankAccount    TenderType = "BANK_ACCOUNT"
	TenderTypeWallet         TenderType = "WALLET"
	TenderTypeBuyNowPayLater TenderType = "BUY_NOW_PAY_LATER"
	TenderTypeSquareAccount  TenderType = "SQUARE_ACCOUNT"
	TenderTypeOther          TenderType = "OTHER"
)

func NewTenderTypeFromString(s string) (TenderType, error) {
	switch s {
	case "CARD":
		return TenderTypeCard, nil
	case "CASH":
		return TenderTypeCash, nil
	case "THIRD_PARTY_CARD":
		return TenderTypeThirdPartyCard, nil
	case "SQUARE_GIFT_CARD":
		return TenderTypeSquareGiftCard, nil
	case "NO_SALE":
		return TenderTypeNoSale, nil
	case "BANK_ACCOUNT":
		return TenderTypeBankAccount, nil
	case "WALLET":
		return TenderTypeWallet, nil
	case "BUY_NOW_PAY_LATER":
		return TenderTypeBuyNowPayLater, nil
	case "SQUARE_ACCOUNT":
		return TenderTypeSquareAccount, nil
	case "OTHER":
		return TenderTypeOther, nil
	}
	var t TenderType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TenderType) Ptr() *TenderType {
	return &t
}

// Represents an action processed by the Square Terminal.
type TerminalAction struct {
	// A unique ID for this `TerminalAction`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The unique Id of the device intended for this `TerminalAction`.
	// The Id can be retrieved from /v2/devices api.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The duration as an RFC 3339 duration, after which the action will be automatically canceled.
	// TerminalActions that are `PENDING` will be automatically `CANCELED` and have a cancellation reason
	// of `TIMED_OUT`
	//
	// Default: 5 minutes from creation
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalAction`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The reason why `TerminalAction` is canceled. Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The time when the `TerminalAction` was created as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalAction` was last updated as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the action.
	AppID *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location id the action is attached to, if a link can be made.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Represents the type of the action.
	// See [ActionType](#type-actiontype) for possible values
	Type *TerminalActionActionType `json:"type,omitempty" url:"type,omitempty"`
	// Describes configuration for the QR code action. Requires `QR_CODE` type.
	QrCodeOptions *QrCodeOptions `json:"qr_code_options,omitempty" url:"qr_code_options,omitempty"`
	// Describes configuration for the save-card action. Requires `SAVE_CARD` type.
	SaveCardOptions *SaveCardOptions `json:"save_card_options,omitempty" url:"save_card_options,omitempty"`
	// Describes configuration for the signature capture action. Requires `SIGNATURE` type.
	SignatureOptions *SignatureOptions `json:"signature_options,omitempty" url:"signature_options,omitempty"`
	// Describes configuration for the confirmation action. Requires `CONFIRMATION` type.
	ConfirmationOptions *ConfirmationOptions `json:"confirmation_options,omitempty" url:"confirmation_options,omitempty"`
	// Describes configuration for the receipt action. Requires `RECEIPT` type.
	ReceiptOptions *ReceiptOptions `json:"receipt_options,omitempty" url:"receipt_options,omitempty"`
	// Describes configuration for the data collection action. Requires `DATA_COLLECTION` type.
	DataCollectionOptions *DataCollectionOptions `json:"data_collection_options,omitempty" url:"data_collection_options,omitempty"`
	// Describes configuration for the select action. Requires `SELECT` type.
	SelectOptions *SelectOptions `json:"select_options,omitempty" url:"select_options,omitempty"`
	// Details about the Terminal that received the action request (such as battery level,
	// operating system version, and network connection settings).
	//
	// Only available for `PING` action type.
	DeviceMetadata *DeviceMetadata `json:"device_metadata,omitempty" url:"device_metadata,omitempty"`
	// Indicates the action will be linked to another action and requires a waiting dialog to be
	// displayed instead of returning to the idle screen on completion of the action.
	//
	// Only supported on SIGNATURE, CONFIRMATION, DATA_COLLECTION, and SELECT types.
	AwaitNextAction *bool `json:"await_next_action,omitempty" url:"await_next_action,omitempty"`
	// The timeout duration of the waiting dialog as an RFC 3339 duration, after which the
	// waiting dialog will no longer be displayed and the Terminal will return to the idle screen.
	//
	// Default: 5 minutes from when the waiting dialog is displayed
	//
	// Maximum: 5 minutes
	AwaitNextActionDuration *string `json:"await_next_action_duration,omitempty" url:"await_next_action_duration,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalAction) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalAction) GetDeviceID() *string {
	if t == nil {
		return nil
	}
	return t.DeviceID
}

func (t *TerminalAction) GetDeadlineDuration() *string {
	if t == nil {
		return nil
	}
	return t.DeadlineDuration
}

func (t *TerminalAction) GetStatus() *string {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TerminalAction) GetCancelReason() *ActionCancelReason {
	if t == nil {
		return nil
	}
	return t.CancelReason
}

func (t *TerminalAction) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalAction) GetUpdatedAt() *string {
	if t == nil {
		return nil
	}
	return t.UpdatedAt
}

func (t *TerminalAction) GetAppID() *string {
	if t == nil {
		return nil
	}
	return t.AppID
}

func (t *TerminalAction) GetLocationID() *string {
	if t == nil {
		return nil
	}
	return t.LocationID
}

func (t *TerminalAction) GetType() *TerminalActionActionType {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalAction) GetQrCodeOptions() *QrCodeOptions {
	if t == nil {
		return nil
	}
	return t.QrCodeOptions
}

func (t *TerminalAction) GetSaveCardOptions() *SaveCardOptions {
	if t == nil {
		return nil
	}
	return t.SaveCardOptions
}

func (t *TerminalAction) GetSignatureOptions() *SignatureOptions {
	if t == nil {
		return nil
	}
	return t.SignatureOptions
}

func (t *TerminalAction) GetConfirmationOptions() *ConfirmationOptions {
	if t == nil {
		return nil
	}
	return t.ConfirmationOptions
}

func (t *TerminalAction) GetReceiptOptions() *ReceiptOptions {
	if t == nil {
		return nil
	}
	return t.ReceiptOptions
}

func (t *TerminalAction) GetDataCollectionOptions() *DataCollectionOptions {
	if t == nil {
		return nil
	}
	return t.DataCollectionOptions
}

func (t *TerminalAction) GetSelectOptions() *SelectOptions {
	if t == nil {
		return nil
	}
	return t.SelectOptions
}

func (t *TerminalAction) GetDeviceMetadata() *DeviceMetadata {
	if t == nil {
		return nil
	}
	return t.DeviceMetadata
}

func (t *TerminalAction) GetAwaitNextAction() *bool {
	if t == nil {
		return nil
	}
	return t.AwaitNextAction
}

func (t *TerminalAction) GetAwaitNextActionDuration() *string {
	if t == nil {
		return nil
	}
	return t.AwaitNextActionDuration
}

func (t *TerminalAction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalAction) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalAction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalAction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type TerminalActionActionType string

const (
	TerminalActionActionTypeQrCode         TerminalActionActionType = "QR_CODE"
	TerminalActionActionTypePing           TerminalActionActionType = "PING"
	TerminalActionActionTypeSaveCard       TerminalActionActionType = "SAVE_CARD"
	TerminalActionActionTypeSignature      TerminalActionActionType = "SIGNATURE"
	TerminalActionActionTypeConfirmation   TerminalActionActionType = "CONFIRMATION"
	TerminalActionActionTypeReceipt        TerminalActionActionType = "RECEIPT"
	TerminalActionActionTypeDataCollection TerminalActionActionType = "DATA_COLLECTION"
	TerminalActionActionTypeSelect         TerminalActionActionType = "SELECT"
)

func NewTerminalActionActionTypeFromString(s string) (TerminalActionActionType, error) {
	switch s {
	case "QR_CODE":
		return TerminalActionActionTypeQrCode, nil
	case "PING":
		return TerminalActionActionTypePing, nil
	case "SAVE_CARD":
		return TerminalActionActionTypeSaveCard, nil
	case "SIGNATURE":
		return TerminalActionActionTypeSignature, nil
	case "CONFIRMATION":
		return TerminalActionActionTypeConfirmation, nil
	case "RECEIPT":
		return TerminalActionActionTypeReceipt, nil
	case "DATA_COLLECTION":
		return TerminalActionActionTypeDataCollection, nil
	case "SELECT":
		return TerminalActionActionTypeSelect, nil
	}
	var t TerminalActionActionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TerminalActionActionType) Ptr() *TerminalActionActionType {
	return &t
}

// Published when a TerminalAction is created.
type TerminalActionCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.action.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalActionCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionCreatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TerminalActionCreatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalActionCreatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TerminalActionCreatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalActionCreatedEvent) GetData() *TerminalActionCreatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TerminalActionCreatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionCreatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionCreatedEventData struct {
	// Name of the created object’s type, `"action"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created terminal action.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created terminal action.
	Object *TerminalActionCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionCreatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalActionCreatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalActionCreatedEventData) GetObject() *TerminalActionCreatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TerminalActionCreatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionCreatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionCreatedEventObject struct {
	// The created terminal action.
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionCreatedEventObject) GetAction() *TerminalAction {
	if t == nil {
		return nil
	}
	return t.Action
}

func (t *TerminalActionCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionCreatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQuery struct {
	// Options for filtering returned `TerminalAction`s
	Filter *TerminalActionQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Option for sorting returned `TerminalAction` objects.
	Sort *TerminalActionQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionQuery) GetFilter() *TerminalActionQueryFilter {
	if t == nil {
		return nil
	}
	return t.Filter
}

func (t *TerminalActionQuery) GetSort() *TerminalActionQuerySort {
	if t == nil {
		return nil
	}
	return t.Sort
}

func (t *TerminalActionQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQuery) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQueryFilter struct {
	// `TerminalAction`s associated with a specific device. If no device is specified then all
	// `TerminalAction`s for the merchant will be displayed.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// Time range for the beginning of the reporting period. Inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalAction`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filter results with the desired status of the `TerminalAction`
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Filter results with the requested ActionType.
	// See [TerminalActionActionType](#type-terminalactionactiontype) for possible values
	Type *TerminalActionActionType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionQueryFilter) GetDeviceID() *string {
	if t == nil {
		return nil
	}
	return t.DeviceID
}

func (t *TerminalActionQueryFilter) GetCreatedAt() *TimeRange {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalActionQueryFilter) GetStatus() *string {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TerminalActionQueryFilter) GetType() *TerminalActionActionType {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalActionQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQueryFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQueryFilter) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionQuerySort struct {
	// The order in which results are listed.
	// - `ASC` - Oldest to newest.
	// - `DESC` - Newest to oldest (default).
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionQuerySort) GetSortOrder() *SortOrder {
	if t == nil {
		return nil
	}
	return t.SortOrder
}

func (t *TerminalActionQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionQuerySort(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionQuerySort) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a TerminalAction is updated.
type TerminalActionUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.action.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalActionUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionUpdatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TerminalActionUpdatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalActionUpdatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TerminalActionUpdatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalActionUpdatedEvent) GetData() *TerminalActionUpdatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TerminalActionUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionUpdatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionUpdatedEventData struct {
	// Name of the updated object’s type, `"action"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated terminal action.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated terminal action.
	Object *TerminalActionUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionUpdatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalActionUpdatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalActionUpdatedEventData) GetObject() *TerminalActionUpdatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TerminalActionUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionUpdatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalActionUpdatedEventObject struct {
	// The updated terminal action.
	Action *TerminalAction `json:"action,omitempty" url:"action,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalActionUpdatedEventObject) GetAction() *TerminalAction {
	if t == nil {
		return nil
	}
	return t.Action
}

func (t *TerminalActionUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalActionUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalActionUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalActionUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalActionUpdatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a checkout processed by the Square Terminal.
type TerminalCheckout struct {
	// A unique ID for this `TerminalCheckout`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The amount of money (including the tax amount) that the Square Terminal device should try to collect.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// An optional user-defined reference ID that can be used to associate
	// this `TerminalCheckout` to another entity in an external system. For example, an order
	// ID generated by a third-party shopping cart. The ID is also associated with any payments
	// used to complete the checkout.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// An optional note to associate with the checkout, as well as with any payments used to complete the checkout.
	// Note: maximum 500 characters
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The reference to the Square order ID for the checkout request.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// Payment-specific options for the checkout request.
	PaymentOptions *PaymentOptions `json:"payment_options,omitempty" url:"payment_options,omitempty"`
	// Options to control the display and behavior of the Square Terminal device.
	DeviceOptions *DeviceCheckoutOptions `json:"device_options" url:"device_options"`
	// An RFC 3339 duration, after which the checkout is automatically canceled.
	// A `TerminalCheckout` that is `PENDING` is automatically `CANCELED` and has a cancellation reason
	// of `TIMED_OUT`.
	//
	// Default: 5 minutes from creation
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalCheckout`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The reason why `TerminalCheckout` is canceled. Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// A list of IDs for payments created by this `TerminalCheckout`.
	PaymentIDs []string `json:"payment_ids,omitempty" url:"payment_ids,omitempty"`
	// The time when the `TerminalCheckout` was created, as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalCheckout` was last updated, as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the checkout.
	AppID *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location of the device where the `TerminalCheckout` was directed.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of payment the terminal should attempt to capture from. Defaults to `CARD_PRESENT`.
	// See [CheckoutOptionsPaymentType](#type-checkoutoptionspaymenttype) for possible values
	PaymentType *CheckoutOptionsPaymentType `json:"payment_type,omitempty" url:"payment_type,omitempty"`
	// An optional ID of the team member associated with creating the checkout.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// An optional ID of the customer associated with the checkout.
	CustomerID *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The amount the developer is taking as a fee for facilitating the payment on behalf
	// of the seller.
	//
	// The amount cannot be more than 90% of the total amount of the payment.
	//
	// The amount must be specified in the smallest denomination of the applicable currency (for example, US dollar amounts are specified in cents). For more information, see [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts).
	//
	// The fee currency code must match the currency associated with the seller that is accepting the payment. The application must be from a developer account in the same country and using the same currency code as the seller.
	//
	// For more information about the application fee scenario, see [Take Payments and Collect Fees](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees).
	//
	// To set this field, PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS OAuth permission is required. For more information, see [Permissions](https://developer.squareup.com/docs/payments-api/take-payments-and-collect-fees#permissions).
	AppFeeMoney *Money `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// Optional additional payment information to include on the customer's card statement as
	// part of the statement description. This can be, for example, an invoice number, ticket number,
	// or short description that uniquely identifies the purchase.
	StatementDescriptionIdentifier *string `json:"statement_description_identifier,omitempty" url:"statement_description_identifier,omitempty"`
	// The amount designated as a tip, in addition to `amount_money`. This may only be set for a
	// checkout that has tipping disabled (`tip_settings.allow_tipping` is `false`).
	TipMoney *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckout) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalCheckout) GetAmountMoney() *Money {
	if t == nil {
		return nil
	}
	return t.AmountMoney
}

func (t *TerminalCheckout) GetReferenceID() *string {
	if t == nil {
		return nil
	}
	return t.ReferenceID
}

func (t *TerminalCheckout) GetNote() *string {
	if t == nil {
		return nil
	}
	return t.Note
}

func (t *TerminalCheckout) GetOrderID() *string {
	if t == nil {
		return nil
	}
	return t.OrderID
}

func (t *TerminalCheckout) GetPaymentOptions() *PaymentOptions {
	if t == nil {
		return nil
	}
	return t.PaymentOptions
}

func (t *TerminalCheckout) GetDeviceOptions() *DeviceCheckoutOptions {
	if t == nil {
		return nil
	}
	return t.DeviceOptions
}

func (t *TerminalCheckout) GetDeadlineDuration() *string {
	if t == nil {
		return nil
	}
	return t.DeadlineDuration
}

func (t *TerminalCheckout) GetStatus() *string {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TerminalCheckout) GetCancelReason() *ActionCancelReason {
	if t == nil {
		return nil
	}
	return t.CancelReason
}

func (t *TerminalCheckout) GetPaymentIDs() []string {
	if t == nil {
		return nil
	}
	return t.PaymentIDs
}

func (t *TerminalCheckout) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalCheckout) GetUpdatedAt() *string {
	if t == nil {
		return nil
	}
	return t.UpdatedAt
}

func (t *TerminalCheckout) GetAppID() *string {
	if t == nil {
		return nil
	}
	return t.AppID
}

func (t *TerminalCheckout) GetLocationID() *string {
	if t == nil {
		return nil
	}
	return t.LocationID
}

func (t *TerminalCheckout) GetPaymentType() *CheckoutOptionsPaymentType {
	if t == nil {
		return nil
	}
	return t.PaymentType
}

func (t *TerminalCheckout) GetTeamMemberID() *string {
	if t == nil {
		return nil
	}
	return t.TeamMemberID
}

func (t *TerminalCheckout) GetCustomerID() *string {
	if t == nil {
		return nil
	}
	return t.CustomerID
}

func (t *TerminalCheckout) GetAppFeeMoney() *Money {
	if t == nil {
		return nil
	}
	return t.AppFeeMoney
}

func (t *TerminalCheckout) GetStatementDescriptionIdentifier() *string {
	if t == nil {
		return nil
	}
	return t.StatementDescriptionIdentifier
}

func (t *TerminalCheckout) GetTipMoney() *Money {
	if t == nil {
		return nil
	}
	return t.TipMoney
}

func (t *TerminalCheckout) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckout) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckout(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckout) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a [TerminalCheckout](entity:TerminalCheckout) is created.
type TerminalCheckoutCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.checkout.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalCheckoutCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutCreatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TerminalCheckoutCreatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalCheckoutCreatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TerminalCheckoutCreatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalCheckoutCreatedEvent) GetData() *TerminalCheckoutCreatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TerminalCheckoutCreatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutCreatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutCreatedEventData struct {
	// Name of the created object’s type, `"checkout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created terminal checkout.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created terminal checkout
	Object *TerminalCheckoutCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutCreatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalCheckoutCreatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalCheckoutCreatedEventData) GetObject() *TerminalCheckoutCreatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TerminalCheckoutCreatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutCreatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutCreatedEventObject struct {
	// The created terminal checkout
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutCreatedEventObject) GetCheckout() *TerminalCheckout {
	if t == nil {
		return nil
	}
	return t.Checkout
}

func (t *TerminalCheckoutCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutCreatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQuery struct {
	// Options for filtering returned `TerminalCheckout` objects.
	Filter *TerminalCheckoutQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Option for sorting returned `TerminalCheckout` objects.
	Sort *TerminalCheckoutQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutQuery) GetFilter() *TerminalCheckoutQueryFilter {
	if t == nil {
		return nil
	}
	return t.Filter
}

func (t *TerminalCheckoutQuery) GetSort() *TerminalCheckoutQuerySort {
	if t == nil {
		return nil
	}
	return t.Sort
}

func (t *TerminalCheckoutQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQuery) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQueryFilter struct {
	// The `TerminalCheckout` objects associated with a specific device. If no device is specified, then all
	// `TerminalCheckout` objects for the merchant are displayed.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The time range for the beginning of the reporting period, which is inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalCheckout`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filtered results with the desired status of the `TerminalCheckout`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, `COMPLETED`
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutQueryFilter) GetDeviceID() *string {
	if t == nil {
		return nil
	}
	return t.DeviceID
}

func (t *TerminalCheckoutQueryFilter) GetCreatedAt() *TimeRange {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalCheckoutQueryFilter) GetStatus() *string {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TerminalCheckoutQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQueryFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQueryFilter) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutQuerySort struct {
	// The order in which results are listed.
	// Default: `DESC`
	// See [SortOrder](#type-sortorder) for possible values
	SortOrder *SortOrder `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutQuerySort) GetSortOrder() *SortOrder {
	if t == nil {
		return nil
	}
	return t.SortOrder
}

func (t *TerminalCheckoutQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutQuerySort(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutQuerySort) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a [TerminalCheckout](entity:TerminalCheckout) is updated.
type TerminalCheckoutUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.checkout.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalCheckoutUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutUpdatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TerminalCheckoutUpdatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalCheckoutUpdatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TerminalCheckoutUpdatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalCheckoutUpdatedEvent) GetData() *TerminalCheckoutUpdatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TerminalCheckoutUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutUpdatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutUpdatedEventData struct {
	// Name of the updated object’s type, `"checkout"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated terminal checkout.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated terminal checkout
	Object *TerminalCheckoutUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutUpdatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalCheckoutUpdatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalCheckoutUpdatedEventData) GetObject() *TerminalCheckoutUpdatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TerminalCheckoutUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutUpdatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalCheckoutUpdatedEventObject struct {
	// The updated terminal checkout
	Checkout *TerminalCheckout `json:"checkout,omitempty" url:"checkout,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalCheckoutUpdatedEventObject) GetCheckout() *TerminalCheckout {
	if t == nil {
		return nil
	}
	return t.Checkout
}

func (t *TerminalCheckoutUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalCheckoutUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalCheckoutUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalCheckoutUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalCheckoutUpdatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a payment refund processed by the Square Terminal. Only supports Interac (Canadian debit network) payment refunds.
type TerminalRefund struct {
	// A unique ID for this `TerminalRefund`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The reference to the payment refund created by completing this `TerminalRefund`.
	RefundID *string `json:"refund_id,omitempty" url:"refund_id,omitempty"`
	// The unique ID of the payment being refunded.
	PaymentID string `json:"payment_id" url:"payment_id"`
	// The reference to the Square order ID for the payment identified by the `payment_id`.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The amount of money, inclusive of `tax_money`, that the `TerminalRefund` should return.
	// This value is limited to the amount taken in the original payment minus any completed or
	// pending refunds.
	AmountMoney *Money `json:"amount_money" url:"amount_money"`
	// A description of the reason for the refund.
	Reason string `json:"reason" url:"reason"`
	// The unique ID of the device intended for this `TerminalRefund`.
	// The Id can be retrieved from /v2/devices api.
	DeviceID string `json:"device_id" url:"device_id"`
	// The RFC 3339 duration, after which the refund is automatically canceled.
	// A `TerminalRefund` that is `PENDING` is automatically `CANCELED` and has a cancellation reason
	// of `TIMED_OUT`.
	//
	// Default: 5 minutes from creation.
	//
	// Maximum: 5 minutes
	DeadlineDuration *string `json:"deadline_duration,omitempty" url:"deadline_duration,omitempty"`
	// The status of the `TerminalRefund`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, or `COMPLETED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// Present if the status is `CANCELED`.
	// See [ActionCancelReason](#type-actioncancelreason) for possible values
	CancelReason *ActionCancelReason `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The time when the `TerminalRefund` was created, as an RFC 3339 timestamp.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The time when the `TerminalRefund` was last updated, as an RFC 3339 timestamp.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the application that created the refund.
	AppID *string `json:"app_id,omitempty" url:"app_id,omitempty"`
	// The location of the device where the `TerminalRefund` was directed.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefund) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalRefund) GetRefundID() *string {
	if t == nil {
		return nil
	}
	return t.RefundID
}

func (t *TerminalRefund) GetPaymentID() string {
	if t == nil {
		return ""
	}
	return t.PaymentID
}

func (t *TerminalRefund) GetOrderID() *string {
	if t == nil {
		return nil
	}
	return t.OrderID
}

func (t *TerminalRefund) GetAmountMoney() *Money {
	if t == nil {
		return nil
	}
	return t.AmountMoney
}

func (t *TerminalRefund) GetReason() string {
	if t == nil {
		return ""
	}
	return t.Reason
}

func (t *TerminalRefund) GetDeviceID() string {
	if t == nil {
		return ""
	}
	return t.DeviceID
}

func (t *TerminalRefund) GetDeadlineDuration() *string {
	if t == nil {
		return nil
	}
	return t.DeadlineDuration
}

func (t *TerminalRefund) GetStatus() *string {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TerminalRefund) GetCancelReason() *ActionCancelReason {
	if t == nil {
		return nil
	}
	return t.CancelReason
}

func (t *TerminalRefund) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalRefund) GetUpdatedAt() *string {
	if t == nil {
		return nil
	}
	return t.UpdatedAt
}

func (t *TerminalRefund) GetAppID() *string {
	if t == nil {
		return nil
	}
	return t.AppID
}

func (t *TerminalRefund) GetLocationID() *string {
	if t == nil {
		return nil
	}
	return t.LocationID
}

func (t *TerminalRefund) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefund(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefund) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Terminal API refund is created.
type TerminalRefundCreatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.refund.created"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalRefundCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundCreatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TerminalRefundCreatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalRefundCreatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TerminalRefundCreatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalRefundCreatedEvent) GetData() *TerminalRefundCreatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TerminalRefundCreatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundCreatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundCreatedEventData struct {
	// Name of the created object’s type, `"refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the created terminal refund.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created terminal refund.
	Object *TerminalRefundCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundCreatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalRefundCreatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalRefundCreatedEventData) GetObject() *TerminalRefundCreatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TerminalRefundCreatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundCreatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundCreatedEventObject struct {
	// The created terminal refund.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundCreatedEventObject) GetRefund() *TerminalRefund {
	if t == nil {
		return nil
	}
	return t.Refund
}

func (t *TerminalRefundCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundCreatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQuery struct {
	// The filter for the Terminal refund query.
	Filter *TerminalRefundQueryFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// The sort order for the Terminal refund query.
	Sort *TerminalRefundQuerySort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundQuery) GetFilter() *TerminalRefundQueryFilter {
	if t == nil {
		return nil
	}
	return t.Filter
}

func (t *TerminalRefundQuery) GetSort() *TerminalRefundQuerySort {
	if t == nil {
		return nil
	}
	return t.Sort
}

func (t *TerminalRefundQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQuery) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQueryFilter struct {
	// `TerminalRefund` objects associated with a specific device. If no device is specified, then all
	// `TerminalRefund` objects for the signed-in account are displayed.
	DeviceID *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The timestamp for the beginning of the reporting period, in RFC 3339 format. Inclusive.
	// Default value: The current time minus one day.
	// Note that `TerminalRefund`s are available for 30 days after creation.
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Filtered results with the desired status of the `TerminalRefund`.
	// Options: `PENDING`, `IN_PROGRESS`, `CANCEL_REQUESTED`, `CANCELED`, or `COMPLETED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundQueryFilter) GetDeviceID() *string {
	if t == nil {
		return nil
	}
	return t.DeviceID
}

func (t *TerminalRefundQueryFilter) GetCreatedAt() *TimeRange {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalRefundQueryFilter) GetStatus() *string {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TerminalRefundQueryFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQueryFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQueryFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQueryFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQueryFilter) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundQuerySort struct {
	// The order in which results are listed.
	// - `ASC` - Oldest to newest.
	// - `DESC` - Newest to oldest (default).
	SortOrder *string `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundQuerySort) GetSortOrder() *string {
	if t == nil {
		return nil
	}
	return t.SortOrder
}

func (t *TerminalRefundQuerySort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundQuerySort) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundQuerySort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundQuerySort(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundQuerySort) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Published when a Terminal API refund is updated.
type TerminalRefundUpdatedEvent struct {
	// The ID of the target merchant associated with the event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The type of event this represents, `"terminal.refund.updated"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for the event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// RFC 3339 timestamp of when the event was created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Data associated with the event.
	Data *TerminalRefundUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundUpdatedEvent) GetMerchantID() *string {
	if t == nil {
		return nil
	}
	return t.MerchantID
}

func (t *TerminalRefundUpdatedEvent) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalRefundUpdatedEvent) GetEventID() *string {
	if t == nil {
		return nil
	}
	return t.EventID
}

func (t *TerminalRefundUpdatedEvent) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *TerminalRefundUpdatedEvent) GetData() *TerminalRefundUpdatedEventData {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TerminalRefundUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundUpdatedEvent) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundUpdatedEventData struct {
	// Name of the updated object’s type, `"refund"`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// ID of the updated terminal refund.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the updated terminal refund.
	Object *TerminalRefundUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundUpdatedEventData) GetType() *string {
	if t == nil {
		return nil
	}
	return t.Type
}

func (t *TerminalRefundUpdatedEventData) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *TerminalRefundUpdatedEventData) GetObject() *TerminalRefundUpdatedEventObject {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *TerminalRefundUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundUpdatedEventData) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TerminalRefundUpdatedEventObject struct {
	// The updated terminal refund.
	Refund *TerminalRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TerminalRefundUpdatedEventObject) GetRefund() *TerminalRefund {
	if t == nil {
		return nil
	}
	return t.Refund
}

func (t *TerminalRefundUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TerminalRefundUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TerminalRefundUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TerminalRefundUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TerminalRefundUpdatedEventObject) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines the fields that are included in the response body of
// a request to the [TestWebhookSubscription](api-endpoint:WebhookSubscriptions-TestWebhookSubscription) endpoint.
//
// Note: If there are errors processing the request, the [SubscriptionTestResult](entity:SubscriptionTestResult) field is not
// present.
type TestWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The [SubscriptionTestResult](entity:SubscriptionTestResult).
	SubscriptionTestResult *SubscriptionTestResult `json:"subscription_test_result,omitempty" url:"subscription_test_result,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TestWebhookSubscriptionResponse) GetErrors() []*Error {
	if t == nil {
		return nil
	}
	return t.Errors
}

func (t *TestWebhookSubscriptionResponse) GetSubscriptionTestResult() *SubscriptionTestResult {
	if t == nil {
		return nil
	}
	return t.SubscriptionTestResult
}

func (t *TestWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TestWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TestWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TestWebhookSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TestWebhookSubscriptionResponse) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a generic time range. The start and end values are
// represented in RFC 3339 format. Time ranges are customized to be
// inclusive or exclusive based on the needs of a particular endpoint.
// Refer to the relevant endpoint-specific documentation to determine
// how time ranges are handled.
type TimeRange struct {
	// A datetime value in RFC 3339 format indicating when the time range
	// starts.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// A datetime value in RFC 3339 format indicating when the time range
	// ends.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimeRange) GetStartAt() *string {
	if t == nil {
		return nil
	}
	return t.StartAt
}

func (t *TimeRange) GetEndAt() *string {
	if t == nil {
		return nil
	}
	return t.EndAt
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TipSettings struct {
	// Indicates whether tipping is enabled for this checkout. Defaults to false.
	AllowTipping *bool `json:"allow_tipping,omitempty" url:"allow_tipping,omitempty"`
	// Indicates whether tip options should be presented on the screen before presenting
	// the signature screen during card payment. Defaults to false.
	SeparateTipScreen *bool `json:"separate_tip_screen,omitempty" url:"separate_tip_screen,omitempty"`
	// Indicates whether custom tip amounts are allowed during the checkout flow. Defaults to false.
	CustomTipField *bool `json:"custom_tip_field,omitempty" url:"custom_tip_field,omitempty"`
	// A list of tip percentages that should be presented during the checkout flow, specified as
	// up to 3 non-negative integers from 0 to 100 (inclusive). Defaults to 15, 20, and 25.
	TipPercentages []int `json:"tip_percentages,omitempty" url:"tip_percentages,omitempty"`
	// Enables the "Smart Tip Amounts" behavior.
	// Exact tipping options depend on the region in which the Square seller is active.
	//
	// For payments under 10.00, in the Australia, Canada, Ireland, United Kingdom, and United States, tipping options are presented as no tip, .50, 1.00 or 2.00.
	//
	// For payment amounts of 10.00 or greater, tipping options are presented as the following percentages: 0%, 5%, 10%, 15%.
	//
	// If set to true, the `tip_percentages` settings is ignored.
	// Defaults to false.
	//
	// To learn more about smart tipping, see [Accept Tips with the Square App](https://squareup.com/help/us/en/article/5069-accept-tips-with-the-square-app).
	SmartTipping *bool `json:"smart_tipping,omitempty" url:"smart_tipping,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TipSettings) GetAllowTipping() *bool {
	if t == nil {
		return nil
	}
	return t.AllowTipping
}

func (t *TipSettings) GetSeparateTipScreen() *bool {
	if t == nil {
		return nil
	}
	return t.SeparateTipScreen
}

func (t *TipSettings) GetCustomTipField() *bool {
	if t == nil {
		return nil
	}
	return t.CustomTipField
}

func (t *TipSettings) GetTipPercentages() []int {
	if t == nil {
		return nil
	}
	return t.TipPercentages
}

func (t *TipSettings) GetSmartTipping() *bool {
	if t == nil {
		return nil
	}
	return t.SmartTipping
}

func (t *TipSettings) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TipSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler TipSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TipSettings(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TipSettings) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Represents a transaction processed with Square, either with the
// Connect API or with Square Point of Sale.
//
// The `tenders` field of this object lists all methods of payment used to pay in
// the transaction.
type Transaction struct {
	// The transaction's unique ID, issued by Square payments servers.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the transaction's associated location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The timestamp for when the transaction was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The tenders used to pay in the transaction.
	Tenders []*Tender `json:"tenders,omitempty" url:"tenders,omitempty"`
	// Refunds that have been applied to any tender in the transaction.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// If the transaction was created with the [Charge](api-endpoint:Transactions-Charge)
	// endpoint, this value is the same as the value provided for the `reference_id`
	// parameter in the request to that endpoint. Otherwise, it is not set.
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The Square product that processed the transaction.
	// See [TransactionProduct](#type-transactionproduct) for possible values
	Product *TransactionProduct `json:"product,omitempty" url:"product,omitempty"`
	// If the transaction was created in the Square Point of Sale app, this value
	// is the ID generated for the transaction by Square Point of Sale.
	//
	// This ID has no relationship to the transaction's canonical `id`, which is
	// generated by Square's backend servers. This value is generated for bookkeeping
	// purposes, in case the transaction cannot immediately be completed (for example,
	// if the transaction is processed in offline mode).
	//
	// It is not currently possible with the Connect API to perform a transaction
	// lookup by this value.
	ClientID *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The shipping address provided in the request, if any.
	ShippingAddress *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// The order_id is an identifier for the order associated with this transaction, if any.
	OrderID *string `json:"order_id,omitempty" url:"order_id,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Transaction) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *Transaction) GetLocationID() *string {
	if t == nil {
		return nil
	}
	return t.LocationID
}

func (t *Transaction) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *Transaction) GetTenders() []*Tender {
	if t == nil {
		return nil
	}
	return t.Tenders
}

func (t *Transaction) GetRefunds() []*Refund {
	if t == nil {
		return nil
	}
	return t.Refunds
}

func (t *Transaction) GetReferenceID() *string {
	if t == nil {
		return nil
	}
	return t.ReferenceID
}

func (t *Transaction) GetProduct() *TransactionProduct {
	if t == nil {
		return nil
	}
	return t.Product
}

func (t *Transaction) GetClientID() *string {
	if t == nil {
		return nil
	}
	return t.ClientID
}

func (t *Transaction) GetShippingAddress() *Address {
	if t == nil {
		return nil
	}
	return t.ShippingAddress
}

func (t *Transaction) GetOrderID() *string {
	if t == nil {
		return nil
	}
	return t.OrderID
}

func (t *Transaction) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Transaction) UnmarshalJSON(data []byte) error {
	type unmarshaler Transaction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Transaction(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Transaction) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Indicates the Square product used to process a transaction.
type TransactionProduct string

const (
	TransactionProductRegister     TransactionProduct = "REGISTER"
	TransactionProductExternalAPI  TransactionProduct = "EXTERNAL_API"
	TransactionProductBilling      TransactionProduct = "BILLING"
	TransactionProductAppointments TransactionProduct = "APPOINTMENTS"
	TransactionProductInvoices     TransactionProduct = "INVOICES"
	TransactionProductOnlineStore  TransactionProduct = "ONLINE_STORE"
	TransactionProductPayroll      TransactionProduct = "PAYROLL"
	TransactionProductOther        TransactionProduct = "OTHER"
)

func NewTransactionProductFromString(s string) (TransactionProduct, error) {
	switch s {
	case "REGISTER":
		return TransactionProductRegister, nil
	case "EXTERNAL_API":
		return TransactionProductExternalAPI, nil
	case "BILLING":
		return TransactionProductBilling, nil
	case "APPOINTMENTS":
		return TransactionProductAppointments, nil
	case "INVOICES":
		return TransactionProductInvoices, nil
	case "ONLINE_STORE":
		return TransactionProductOnlineStore, nil
	case "PAYROLL":
		return TransactionProductPayroll, nil
	case "OTHER":
		return TransactionProductOther, nil
	}
	var t TransactionProduct
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionProduct) Ptr() *TransactionProduct {
	return &t
}

// The transaction type used in the disputed payment.
type TransactionType string

const (
	TransactionTypeDebit  TransactionType = "DEBIT"
	TransactionTypeCredit TransactionType = "CREDIT"
)

func NewTransactionTypeFromString(s string) (TransactionType, error) {
	switch s {
	case "DEBIT":
		return TransactionTypeDebit, nil
	case "CREDIT":
		return TransactionTypeCredit, nil
	}
	var t TransactionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransactionType) Ptr() *TransactionType {
	return &t
}

// Represents an [UpdateBookingCustomAttributeDefinition](api-endpoint:BookingCustomAttributes-UpdateBookingCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateBookingCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if u == nil {
		return nil
	}
	return u.CustomAttributeDefinition
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBookingCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBookingCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBookingCustomAttributeDefinitionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// A response to a request to update a `BreakType`. The response contains
// the requested `BreakType` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateBreakTypeResponse struct {
	// The response object.
	BreakType *BreakType `json:"break_type,omitempty" url:"break_type,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateBreakTypeResponse) GetBreakType() *BreakType {
	if u == nil {
		return nil
	}
	return u.BreakType
}

func (u *UpdateBreakTypeResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateBreakTypeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateBreakTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBreakTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBreakTypeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBreakTypeResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCatalogImageRequest struct {
	// A unique string that identifies this UpdateCatalogImage request.
	// Keys can be any valid string but must be unique for every UpdateCatalogImage request.
	//
	// See [Idempotency keys](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) for more information.
	IdempotencyKey string `json:"idempotency_key" url:"idempotency_key"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCatalogImageRequest) GetIdempotencyKey() string {
	if u == nil {
		return ""
	}
	return u.IdempotencyKey
}

func (u *UpdateCatalogImageRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCatalogImageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCatalogImageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCatalogImageRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCatalogImageRequest) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdateCatalogImageResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The newly updated `CatalogImage` including a Square-generated
	// URL for the encapsulated image file.
	Image *CatalogObject `json:"image,omitempty" url:"image,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCatalogImageResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateCatalogImageResponse) GetImage() *CatalogObject {
	if u == nil {
		return nil
	}
	return u.Image
}

func (u *UpdateCatalogImageResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCatalogImageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCatalogImageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCatalogImageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCatalogImageResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpdateCustomerCustomAttributeDefinition](api-endpoint:CustomerCustomAttributes-UpdateCustomerCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateCustomerCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if u == nil {
		return nil
	}
	return u.CustomAttributeDefinition
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomerCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomerCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomerCustomAttributeDefinitionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateCustomerGroup](api-endpoint:CustomerGroups-UpdateCustomerGroup) endpoint.
//
// Either `errors` or `group` is present in a given response (never both).
type UpdateCustomerGroupResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully updated customer group.
	Group *CustomerGroup `json:"group,omitempty" url:"group,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateCustomerGroupResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateCustomerGroupResponse) GetGroup() *CustomerGroup {
	if u == nil {
		return nil
	}
	return u.Group
}

func (u *UpdateCustomerGroupResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomerGroupResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomerGroupResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomerGroupResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomerGroupResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpdateLocationCustomAttributeDefinition](api-endpoint:LocationCustomAttributes-UpdateLocationCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateLocationCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if u == nil {
		return nil
	}
	return u.CustomAttributeDefinition
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateLocationCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateLocationCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateLocationCustomAttributeDefinitionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpdateMerchantCustomAttributeDefinition](api-endpoint:MerchantCustomAttributes-UpdateMerchantCustomAttributeDefinition) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpdateMerchantCustomAttributeDefinitionResponse struct {
	// The updated custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if u == nil {
		return nil
	}
	return u.CustomAttributeDefinition
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMerchantCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMerchantCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMerchantCustomAttributeDefinitionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from updating an order custom attribute definition.
type UpdateOrderCustomAttributeDefinitionResponse struct {
	// The updated order custom attribute definition.
	CustomAttributeDefinition *CustomAttributeDefinition `json:"custom_attribute_definition,omitempty" url:"custom_attribute_definition,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) GetCustomAttributeDefinition() *CustomAttributeDefinition {
	if u == nil {
		return nil
	}
	return u.CustomAttributeDefinition
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrderCustomAttributeDefinitionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrderCustomAttributeDefinitionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrderCustomAttributeDefinitionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpdatePaymentLinkResponse struct {
	// Any errors that occurred when updating the payment link.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated payment link.
	PaymentLink *PaymentLink `json:"payment_link,omitempty" url:"payment_link,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdatePaymentLinkResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdatePaymentLinkResponse) GetPaymentLink() *PaymentLink {
	if u == nil {
		return nil
	}
	return u.PaymentLink
}

func (u *UpdatePaymentLinkResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePaymentLinkResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePaymentLinkResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePaymentLinkResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePaymentLinkResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response to a request to update a `Shift`. The response contains
// the updated `Shift` object and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateShiftResponse struct {
	// The updated `Shift`.
	Shift *Shift `json:"shift,omitempty" url:"shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateShiftResponse) GetShift() *Shift {
	if u == nil {
		return nil
	}
	return u.Shift
}

func (u *UpdateShiftResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateShiftResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateShiftResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from an update request containing the updated `WageSetting` object
// or error messages.
type UpdateWageSettingResponse struct {
	// The successfully updated `WageSetting` object.
	WageSetting *WageSetting `json:"wage_setting,omitempty" url:"wage_setting,omitempty"`
	// The errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateWageSettingResponse) GetWageSetting() *WageSetting {
	if u == nil {
		return nil
	}
	return u.WageSetting
}

func (u *UpdateWageSettingResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateWageSettingResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWageSettingResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWageSettingResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWageSettingResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWageSettingResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateWebhookSubscription](api-endpoint:WebhookSubscriptions-UpdateWebhookSubscription) endpoint.
//
// Note: If there are errors processing the request, the [Subscription](entity:WebhookSubscription) is not
// present.
type UpdateWebhookSubscriptionResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The updated [Subscription](entity:WebhookSubscription).
	Subscription *WebhookSubscription `json:"subscription,omitempty" url:"subscription,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateWebhookSubscriptionResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateWebhookSubscriptionResponse) GetSubscription() *WebhookSubscription {
	if u == nil {
		return nil
	}
	return u.Subscription
}

func (u *UpdateWebhookSubscriptionResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWebhookSubscriptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWebhookSubscriptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWebhookSubscriptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWebhookSubscriptionResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateWebhookSubscriptionSignatureKey](api-endpoint:WebhookSubscriptions-UpdateWebhookSubscriptionSignatureKey) endpoint.
//
// Note: If there are errors processing the request, the [Subscription](entity:WebhookSubscription) is not
// present.
type UpdateWebhookSubscriptionSignatureKeyResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The new Square-generated signature key used to validate the origin of the webhook event.
	SignatureKey *string `json:"signature_key,omitempty" url:"signature_key,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) GetSignatureKey() *string {
	if u == nil {
		return nil
	}
	return u.SignatureKey
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWebhookSubscriptionSignatureKeyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWebhookSubscriptionSignatureKeyResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWebhookSubscriptionSignatureKeyResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response to a request to update a `WorkweekConfig` object. The response contains
// the updated `WorkweekConfig` object and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateWorkweekConfigResponse struct {
	// The response object.
	WorkweekConfig *WorkweekConfig `json:"workweek_config,omitempty" url:"workweek_config,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateWorkweekConfigResponse) GetWorkweekConfig() *WorkweekConfig {
	if u == nil {
		return nil
	}
	return u.WorkweekConfig
}

func (u *UpdateWorkweekConfigResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateWorkweekConfigResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateWorkweekConfigResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateWorkweekConfigResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateWorkweekConfigResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateWorkweekConfigResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertBookingCustomAttribute](api-endpoint:BookingCustomAttributes-UpsertBookingCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertBookingCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertBookingCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if u == nil {
		return nil
	}
	return u.CustomAttribute
}

func (u *UpsertBookingCustomAttributeResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpsertBookingCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertBookingCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertBookingCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertBookingCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertBookingCustomAttributeResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UpsertCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The successfully created or updated CatalogObject.
	CatalogObject *CatalogObject `json:"catalog_object,omitempty" url:"catalog_object,omitempty"`
	// The mapping between client and server IDs for this upsert.
	IDMappings []*CatalogIDMapping `json:"id_mappings,omitempty" url:"id_mappings,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertCatalogObjectResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpsertCatalogObjectResponse) GetCatalogObject() *CatalogObject {
	if u == nil {
		return nil
	}
	return u.CatalogObject
}

func (u *UpsertCatalogObjectResponse) GetIDMappings() []*CatalogIDMapping {
	if u == nil {
		return nil
	}
	return u.IDMappings
}

func (u *UpsertCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertCatalogObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertCatalogObjectResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertCustomerCustomAttribute](api-endpoint:CustomerCustomAttributes-UpsertCustomerCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertCustomerCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertCustomerCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if u == nil {
		return nil
	}
	return u.CustomAttribute
}

func (u *UpsertCustomerCustomAttributeResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpsertCustomerCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertCustomerCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertCustomerCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertCustomerCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertCustomerCustomAttributeResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertLocationCustomAttribute](api-endpoint:LocationCustomAttributes-UpsertLocationCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertLocationCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertLocationCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if u == nil {
		return nil
	}
	return u.CustomAttribute
}

func (u *UpsertLocationCustomAttributeResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpsertLocationCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertLocationCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertLocationCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertLocationCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertLocationCustomAttributeResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents an [UpsertMerchantCustomAttribute](api-endpoint:MerchantCustomAttributes-UpsertMerchantCustomAttribute) response.
// Either `custom_attribute_definition` or `errors` is present in the response.
type UpsertMerchantCustomAttributeResponse struct {
	// The new or updated custom attribute.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertMerchantCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if u == nil {
		return nil
	}
	return u.CustomAttribute
}

func (u *UpsertMerchantCustomAttributeResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpsertMerchantCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertMerchantCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertMerchantCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertMerchantCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertMerchantCustomAttributeResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Represents a response from upserting order custom attribute definitions.
type UpsertOrderCustomAttributeResponse struct {
	// The order custom attribute that was created or modified.
	CustomAttribute *CustomAttribute `json:"custom_attribute,omitempty" url:"custom_attribute,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpsertOrderCustomAttributeResponse) GetCustomAttribute() *CustomAttribute {
	if u == nil {
		return nil
	}
	return u.CustomAttribute
}

func (u *UpsertOrderCustomAttributeResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpsertOrderCustomAttributeResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpsertOrderCustomAttributeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpsertOrderCustomAttributeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpsertOrderCustomAttributeResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpsertOrderCustomAttributeResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type V1GetPaymentRequest = interface{}

type V1GetSettlementRequest = interface{}

// Published when a [Vendor](entity:Vendor) is created.
type VendorCreatedEvent struct {
	// The ID of a seller associated with this event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of a location associated with the event, if the event is associated with the location of the seller.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of this event. The value is `"vendor.created".`
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for this event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The RFC 3339-formatted time when the underlying event data object is created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with this event.
	Data *VendorCreatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreatedEvent) GetMerchantID() *string {
	if v == nil {
		return nil
	}
	return v.MerchantID
}

func (v *VendorCreatedEvent) GetLocationID() *string {
	if v == nil {
		return nil
	}
	return v.LocationID
}

func (v *VendorCreatedEvent) GetType() *string {
	if v == nil {
		return nil
	}
	return v.Type
}

func (v *VendorCreatedEvent) GetEventID() *string {
	if v == nil {
		return nil
	}
	return v.EventID
}

func (v *VendorCreatedEvent) GetCreatedAt() *string {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *VendorCreatedEvent) GetData() *VendorCreatedEventData {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *VendorCreatedEvent) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreatedEvent) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Defines the `vendor.created` event data structure.
type VendorCreatedEventData struct {
	// The type of the event data object. The value is `vendor`
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing the created vendor.
	Object *VendorCreatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreatedEventData) GetType() *string {
	if v == nil {
		return nil
	}
	return v.Type
}

func (v *VendorCreatedEventData) GetID() *string {
	if v == nil {
		return nil
	}
	return v.ID
}

func (v *VendorCreatedEventData) GetObject() *VendorCreatedEventObject {
	if v == nil {
		return nil
	}
	return v.Object
}

func (v *VendorCreatedEventData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreatedEventData) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorCreatedEventObject struct {
	// The operation on the vendor that caused the event to be published. The value is `CREATED`.
	// See [Operation](#type-operation) for possible values
	Operation *VendorCreatedEventObjectOperation `json:"operation,omitempty" url:"operation,omitempty"`
	// The created vendor as the result of the specified operation.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorCreatedEventObject) GetVendor() *Vendor {
	if v == nil {
		return nil
	}
	return v.Vendor
}

func (v *VendorCreatedEventObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorCreatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorCreatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorCreatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorCreatedEventObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The operation that can be performed against a vendor to cause the event to be published.
type VendorCreatedEventObjectOperation = string

// Published when a [Vendor](entity:Vendor) is updated.
type VendorUpdatedEvent struct {
	// The ID of a seller associated with this event.
	MerchantID *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// The ID of a seller location associated with this event, if the event is associated with the location.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The type of this event. The value is `"vendor.updated".`
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// A unique ID for this webhoook event.
	EventID *string `json:"event_id,omitempty" url:"event_id,omitempty"`
	// The RFC 3339-formatted time when the underlying event data object is created.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The data associated with this event.
	Data *VendorUpdatedEventData `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorUpdatedEvent) GetMerchantID() *string {
	if v == nil {
		return nil
	}
	return v.MerchantID
}

func (v *VendorUpdatedEvent) GetLocationID() *string {
	if v == nil {
		return nil
	}
	return v.LocationID
}

func (v *VendorUpdatedEvent) GetType() *string {
	if v == nil {
		return nil
	}
	return v.Type
}

func (v *VendorUpdatedEvent) GetEventID() *string {
	if v == nil {
		return nil
	}
	return v.EventID
}

func (v *VendorUpdatedEvent) GetCreatedAt() *string {
	if v == nil {
		return nil
	}
	return v.CreatedAt
}

func (v *VendorUpdatedEvent) GetData() *VendorUpdatedEventData {
	if v == nil {
		return nil
	}
	return v.Data
}

func (v *VendorUpdatedEvent) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorUpdatedEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorUpdatedEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorUpdatedEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorUpdatedEvent) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Defines the `vendor.updated` event data structure.
type VendorUpdatedEventData struct {
	// The type of the event data object. The value is `vendor`.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// The ID of the event data object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// An object containing updated vendor.
	Object *VendorUpdatedEventObject `json:"object,omitempty" url:"object,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorUpdatedEventData) GetType() *string {
	if v == nil {
		return nil
	}
	return v.Type
}

func (v *VendorUpdatedEventData) GetID() *string {
	if v == nil {
		return nil
	}
	return v.ID
}

func (v *VendorUpdatedEventData) GetObject() *VendorUpdatedEventObject {
	if v == nil {
		return nil
	}
	return v.Object
}

func (v *VendorUpdatedEventData) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorUpdatedEventData) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorUpdatedEventData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorUpdatedEventData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorUpdatedEventData) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VendorUpdatedEventObject struct {
	// The operation on the vendor that caused the event to be published. The value is `UPDATED`.
	// See [Operation](#type-operation) for possible values
	Operation *VendorUpdatedEventObjectOperation `json:"operation,omitempty" url:"operation,omitempty"`
	// The updated vendor as the result of the specified operation.
	Vendor *Vendor `json:"vendor,omitempty" url:"vendor,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VendorUpdatedEventObject) GetVendor() *Vendor {
	if v == nil {
		return nil
	}
	return v.Vendor
}

func (v *VendorUpdatedEventObject) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VendorUpdatedEventObject) UnmarshalJSON(data []byte) error {
	type unmarshaler VendorUpdatedEventObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VendorUpdatedEventObject(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VendorUpdatedEventObject) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// The operation that can be performed against a vendor to cause the event to be published.
type VendorUpdatedEventObjectOperation = string

// Enumeration of visibility-filter values used to set the ability to view custom attributes or custom attribute definitions.
type VisibilityFilter string

const (
	VisibilityFilterAll       VisibilityFilter = "ALL"
	VisibilityFilterRead      VisibilityFilter = "READ"
	VisibilityFilterReadWrite VisibilityFilter = "READ_WRITE"
)

func NewVisibilityFilterFromString(s string) (VisibilityFilter, error) {
	switch s {
	case "ALL":
		return VisibilityFilterAll, nil
	case "READ":
		return VisibilityFilterRead, nil
	case "READ_WRITE":
		return VisibilityFilterReadWrite, nil
	}
	var t VisibilityFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VisibilityFilter) Ptr() *VisibilityFilter {
	return &v
}

// Defines the fields that are included in the response body of
// a request to the [VoidTransaction](api-endpoint:Transactions-VoidTransaction) endpoint.
type VoidTransactionResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoidTransactionResponse) GetErrors() []*Error {
	if v == nil {
		return nil
	}
	return v.Errors
}

func (v *VoidTransactionResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoidTransactionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoidTransactionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoidTransactionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoidTransactionResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

// Represents information about the overtime exemption status, job assignments, and compensation
// for a [team member](entity:TeamMember).
type WageSetting struct {
	// The ID of the team member associated with the wage setting.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// **Required** The ordered list of jobs that the team member is assigned to.
	// The first job assignment is considered the team member's primary job.
	JobAssignments []*JobAssignment `json:"job_assignments,omitempty" url:"job_assignments,omitempty"`
	// Whether the team member is exempt from the overtime rules of the seller's country.
	IsOvertimeExempt *bool `json:"is_overtime_exempt,omitempty" url:"is_overtime_exempt,omitempty"`
	// **Read only** Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write, potentially overwriting data from another write. For more information,
	// see [optimistic concurrency](https://developer.squareup.com/docs/working-with-apis/optimistic-concurrency).
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp when the wage setting was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the wage setting was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WageSetting) GetTeamMemberID() *string {
	if w == nil {
		return nil
	}
	return w.TeamMemberID
}

func (w *WageSetting) GetJobAssignments() []*JobAssignment {
	if w == nil {
		return nil
	}
	return w.JobAssignments
}

func (w *WageSetting) GetIsOvertimeExempt() *bool {
	if w == nil {
		return nil
	}
	return w.IsOvertimeExempt
}

func (w *WageSetting) GetVersion() *int {
	if w == nil {
		return nil
	}
	return w.Version
}

func (w *WageSetting) GetCreatedAt() *string {
	if w == nil {
		return nil
	}
	return w.CreatedAt
}

func (w *WageSetting) GetUpdatedAt() *string {
	if w == nil {
		return nil
	}
	return w.UpdatedAt
}

func (w *WageSetting) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WageSetting) UnmarshalJSON(data []byte) error {
	type unmarshaler WageSetting
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WageSetting(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WageSetting) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Represents the details of a webhook subscription, including notification URL,
// event types, and signature key.
type WebhookSubscription struct {
	// A Square-generated unique ID for the subscription.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of this subscription.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Indicates whether the subscription is enabled (`true`) or not (`false`).
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`
	// The event types associated with this subscription.
	EventTypes []string `json:"event_types,omitempty" url:"event_types,omitempty"`
	// The URL to which webhooks are sent.
	NotificationURL *string `json:"notification_url,omitempty" url:"notification_url,omitempty"`
	// The API version of the subscription.
	// This field is optional for `CreateWebhookSubscription`.
	// The value defaults to the API version used by the application.
	APIVersion *string `json:"api_version,omitempty" url:"api_version,omitempty"`
	// The Square-generated signature key used to validate the origin of the webhook event.
	SignatureKey *string `json:"signature_key,omitempty" url:"signature_key,omitempty"`
	// The timestamp of when the subscription was created, in RFC 3339 format. For example, "2016-09-04T23:59:33.123Z".
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the subscription was last updated, in RFC 3339 format.
	// For example, "2016-09-04T23:59:33.123Z".
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookSubscription) GetID() *string {
	if w == nil {
		return nil
	}
	return w.ID
}

func (w *WebhookSubscription) GetName() *string {
	if w == nil {
		return nil
	}
	return w.Name
}

func (w *WebhookSubscription) GetEnabled() *bool {
	if w == nil {
		return nil
	}
	return w.Enabled
}

func (w *WebhookSubscription) GetEventTypes() []string {
	if w == nil {
		return nil
	}
	return w.EventTypes
}

func (w *WebhookSubscription) GetNotificationURL() *string {
	if w == nil {
		return nil
	}
	return w.NotificationURL
}

func (w *WebhookSubscription) GetAPIVersion() *string {
	if w == nil {
		return nil
	}
	return w.APIVersion
}

func (w *WebhookSubscription) GetSignatureKey() *string {
	if w == nil {
		return nil
	}
	return w.SignatureKey
}

func (w *WebhookSubscription) GetCreatedAt() *string {
	if w == nil {
		return nil
	}
	return w.CreatedAt
}

func (w *WebhookSubscription) GetUpdatedAt() *string {
	if w == nil {
		return nil
	}
	return w.UpdatedAt
}

func (w *WebhookSubscription) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookSubscription) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookSubscription
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookSubscription(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookSubscription) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// The days of the week.
type Weekday string

const (
	WeekdayMon Weekday = "MON"
	WeekdayTue Weekday = "TUE"
	WeekdayWed Weekday = "WED"
	WeekdayThu Weekday = "THU"
	WeekdayFri Weekday = "FRI"
	WeekdaySat Weekday = "SAT"
	WeekdaySun Weekday = "SUN"
)

func NewWeekdayFromString(s string) (Weekday, error) {
	switch s {
	case "MON":
		return WeekdayMon, nil
	case "TUE":
		return WeekdayTue, nil
	case "WED":
		return WeekdayWed, nil
	case "THU":
		return WeekdayThu, nil
	case "FRI":
		return WeekdayFri, nil
	case "SAT":
		return WeekdaySat, nil
	case "SUN":
		return WeekdaySun, nil
	}
	var t Weekday
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w Weekday) Ptr() *Weekday {
	return &w
}

// Sets the day of the week and hour of the day that a business starts a
// workweek. This is used to calculate overtime pay.
type WorkweekConfig struct {
	// The UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The day of the week on which a business week starts for
	// compensation purposes.
	// See [Weekday](#type-weekday) for possible values
	StartOfWeek Weekday `json:"start_of_week" url:"start_of_week"`
	// The local time at which a business week starts. Represented as a
	// string in `HH:MM` format (`HH:MM:SS` is also accepted, but seconds are
	// truncated).
	StartOfDayLocalTime string `json:"start_of_day_local_time" url:"start_of_day_local_time"`
	// Used for resolving concurrency issues. The request fails if the version
	// provided does not match the server version at the time of the request. If not provided,
	// Square executes a blind write; potentially overwriting data from another
	// write.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// A read-only timestamp in RFC 3339 format; presented in UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WorkweekConfig) GetID() *string {
	if w == nil {
		return nil
	}
	return w.ID
}

func (w *WorkweekConfig) GetStartOfWeek() Weekday {
	if w == nil {
		return ""
	}
	return w.StartOfWeek
}

func (w *WorkweekConfig) GetStartOfDayLocalTime() string {
	if w == nil {
		return ""
	}
	return w.StartOfDayLocalTime
}

func (w *WorkweekConfig) GetVersion() *int {
	if w == nil {
		return nil
	}
	return w.Version
}

func (w *WorkweekConfig) GetCreatedAt() *string {
	if w == nil {
		return nil
	}
	return w.CreatedAt
}

func (w *WorkweekConfig) GetUpdatedAt() *string {
	if w == nil {
		return nil
	}
	return w.UpdatedAt
}

func (w *WorkweekConfig) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WorkweekConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler WorkweekConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WorkweekConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WorkweekConfig) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}
