// This file was auto-generated by Fern from our API Definition.

package square

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/square/square-go-sdk/v2/internal"
)

type BulkPublishScheduledShiftsRequest struct {
	// A map of 1 to 100 key-value pairs that represent individual publish requests.
	//
	// - Each key is the ID of a scheduled shift you want to publish.
	// - Each value is a `BulkPublishScheduledShiftsData` object that contains the
	// `version` field or is an empty object.
	ScheduledShifts map[string]*BulkPublishScheduledShiftsData `json:"scheduled_shifts,omitempty" url:"-"`
	// Indicates whether Square should send email notifications to team members and
	// which team members should receive the notifications. This setting applies to all shifts
	// specified in the bulk operation. The default value is `AFFECTED`.
	// See [ScheduledShiftNotificationAudience](#type-scheduledshiftnotificationaudience) for possible values
	ScheduledShiftNotificationAudience *ScheduledShiftNotificationAudience `json:"scheduled_shift_notification_audience,omitempty" url:"-"`
}

type CreateScheduledShiftRequest struct {
	// A unique identifier for the `CreateScheduledShift` request, used to ensure the
	// [idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency)
	// of the operation.
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"-"`
	// The scheduled shift with `draft_shift_details`.
	// If needed, call [ListLocations](api-endpoint:Locations-ListLocations) to get location IDs,
	// [ListJobs](api-endpoint:Team-ListJobs) to get job IDs, and [SearchTeamMembers](api-endpoint:Team-SearchTeamMembers)
	// to get team member IDs and current job assignments.
	//
	// The `start_at` and `end_at` timestamps must be provided in the time zone + offset of the
	// shift location specified in `location_id`. Example for Pacific Standard Time: 2024-10-31T12:30:00-08:00
	ScheduledShift *ScheduledShift `json:"scheduled_shift,omitempty" url:"-"`
}

type CreateTimecardRequest struct {
	// A unique string value to ensure the idempotency of the operation.
	IdempotencyKey *string `json:"idempotency_key,omitempty" url:"-"`
	// The `Timecard` to be created.
	Timecard *Timecard `json:"timecard,omitempty" url:"-"`
}

type DeleteTimecardRequest struct {
	// The UUID for the `Timecard` being deleted.
	ID string `json:"-" url:"-"`
}

type PublishScheduledShiftRequest struct {
	// The ID of the scheduled shift to publish.
	ID string `json:"-" url:"-"`
	// A unique identifier for the `PublishScheduledShift` request, used to ensure the
	// [idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency)
	// of the operation.
	IdempotencyKey string `json:"idempotency_key" url:"-"`
	// The current version of the scheduled shift, used to enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control. If the provided version doesn't match the server version, the request fails.
	// If omitted, Square executes a blind write, potentially overwriting data from another publish request.
	Version *int `json:"version,omitempty" url:"-"`
	// Indicates whether Square should send an email notification to team members and
	// which team members should receive the notification. The default value is `AFFECTED`.
	// See [ScheduledShiftNotificationAudience](#type-scheduledshiftnotificationaudience) for possible values
	ScheduledShiftNotificationAudience *ScheduledShiftNotificationAudience `json:"scheduled_shift_notification_audience,omitempty" url:"-"`
}

type RetrieveScheduledShiftRequest struct {
	// The ID of the scheduled shift to retrieve.
	ID string `json:"-" url:"-"`
}

type RetrieveTimecardRequest struct {
	// The UUID for the `Timecard` being retrieved.
	ID string `json:"-" url:"-"`
}

type SearchScheduledShiftsRequest struct {
	// Query conditions used to filter and sort the results.
	Query *ScheduledShiftQuery `json:"query,omitempty" url:"-"`
	// The maximum number of results to return in a single response page. The default value is 50.
	Limit *int `json:"limit,omitempty" url:"-"`
	// The pagination cursor returned by the previous call to this endpoint. Provide
	// this cursor to retrieve the next page of results for your original request. For more
	// information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).
	Cursor *string `json:"cursor,omitempty" url:"-"`
}

type SearchTimecardsRequest struct {
	// Query filters.
	Query *TimecardQuery `json:"query,omitempty" url:"-"`
	// The number of resources in a page (200 by default).
	Limit *int `json:"limit,omitempty" url:"-"`
	// An opaque cursor for fetching the next page.
	Cursor *string `json:"cursor,omitempty" url:"-"`
}

type UpdateScheduledShiftRequest struct {
	// The ID of the scheduled shift to update.
	ID string `json:"-" url:"-"`
	// The scheduled shift with any updates in the `draft_shift_details` field.
	// If needed, call [ListLocations](api-endpoint:Locations-ListLocations) to get location IDs,
	// [ListJobs](api-endpoint:Team-ListJobs) to get job IDs, and [SearchTeamMembers](api-endpoint:Team-SearchTeamMembers)
	// to get team member IDs and current job assignments. Updates made to `published_shift_details`
	// are ignored.
	//
	// If provided, the `start_at` and `end_at` timestamps must be in the time zone + offset of the
	// shift location specified in `location_id`. Example for Pacific Standard Time: 2024-10-31T12:30:00-08:00
	//
	// To enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control for the request, provide the current version of the shift in the `version` field.
	// If the provided version doesn't match the server version, the request fails. If `version` is
	// omitted, Square executes a blind write, potentially overwriting data from another publish request.
	ScheduledShift *ScheduledShift `json:"scheduled_shift,omitempty" url:"-"`
}

type UpdateTimecardRequest struct {
	// The ID of the object being updated.
	ID string `json:"-" url:"-"`
	// The updated `Timecard` object.
	Timecard *Timecard `json:"timecard,omitempty" url:"-"`
}

// Represents options for an individual publish request in a
// [BulkPublishScheduledShifts](api-endpoint:Labor-BulkPublishScheduledShifts)
// operation, provided as the value in a key-value pair.
type BulkPublishScheduledShiftsData struct {
	// The current version of the scheduled shift, used to enable [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control. If the provided version doesn't match the server version, the request fails.
	// If omitted, Square executes a blind write, potentially overwriting data from another publish request.
	Version *int `json:"version,omitempty" url:"version,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkPublishScheduledShiftsData) GetVersion() *int {
	if b == nil {
		return nil
	}
	return b.Version
}

func (b *BulkPublishScheduledShiftsData) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkPublishScheduledShiftsData) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkPublishScheduledShiftsData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkPublishScheduledShiftsData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkPublishScheduledShiftsData) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [BulkPublishScheduledShifts](api-endpoint:Labor-BulkPublishScheduledShifts) response.
// Either `scheduled_shifts` or `errors` is present in the response.
type BulkPublishScheduledShiftsResponse struct {
	// A map of key-value pairs that represent responses for individual publish requests.
	// The order of responses might differ from the order in which the requests were provided.
	//
	// - Each key is the scheduled shift ID that was specified for a publish request.
	// - Each value is the corresponding response. If the request succeeds, the value is the
	// published scheduled shift. If the request fails, the value is an `errors` array containing
	// any errors that occurred while processing the request.
	Responses map[string]*PublishScheduledShiftResponse `json:"responses,omitempty" url:"responses,omitempty"`
	// Any top-level errors that prevented the bulk operation from succeeding.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BulkPublishScheduledShiftsResponse) GetResponses() map[string]*PublishScheduledShiftResponse {
	if b == nil {
		return nil
	}
	return b.Responses
}

func (b *BulkPublishScheduledShiftsResponse) GetErrors() []*Error {
	if b == nil {
		return nil
	}
	return b.Errors
}

func (b *BulkPublishScheduledShiftsResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BulkPublishScheduledShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkPublishScheduledShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkPublishScheduledShiftsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkPublishScheduledShiftsResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a [CreateScheduledShift](api-endpoint:Labor-CreateScheduledShift) response.
// Either `scheduled_shift` or `errors` is present in the response.
type CreateScheduledShiftResponse struct {
	// The new scheduled shift. To make the shift public, call
	// [PublishScheduledShift](api-endpoint:Labor-PublishScheduledShift) or
	// [BulkPublishScheduledShifts](api-endpoint:Labor-BulkPublishScheduledShifts).
	ScheduledShift *ScheduledShift `json:"scheduled_shift,omitempty" url:"scheduled_shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateScheduledShiftResponse) GetScheduledShift() *ScheduledShift {
	if c == nil {
		return nil
	}
	return c.ScheduledShift
}

func (c *CreateScheduledShiftResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateScheduledShiftResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateScheduledShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateScheduledShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateScheduledShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateScheduledShiftResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response to a request to create a `Timecard`. The response contains
// the created `Timecard` object and might contain a set of `Error` objects if
// the request resulted in errors.
type CreateTimecardResponse struct {
	// The `Timecard` that was created on the request.
	Timecard *Timecard `json:"timecard,omitempty" url:"timecard,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateTimecardResponse) GetTimecard() *Timecard {
	if c == nil {
		return nil
	}
	return c.Timecard
}

func (c *CreateTimecardResponse) GetErrors() []*Error {
	if c == nil {
		return nil
	}
	return c.Errors
}

func (c *CreateTimecardResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateTimecardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateTimecardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateTimecardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateTimecardResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The response to a request to delete a `Timecard`. The response might contain a set of
// `Error` objects if the request resulted in errors.
type DeleteTimecardResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeleteTimecardResponse) GetErrors() []*Error {
	if d == nil {
		return nil
	}
	return d.Errors
}

func (d *DeleteTimecardResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteTimecardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteTimecardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteTimecardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteTimecardResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents a [PublishScheduledShift](api-endpoint:Labor-PublishScheduledShift) response.
// Either `scheduled_shift` or `errors` is present in the response.
type PublishScheduledShiftResponse struct {
	// The published scheduled shift.
	ScheduledShift *ScheduledShift `json:"scheduled_shift,omitempty" url:"scheduled_shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PublishScheduledShiftResponse) GetScheduledShift() *ScheduledShift {
	if p == nil {
		return nil
	}
	return p.ScheduledShift
}

func (p *PublishScheduledShiftResponse) GetErrors() []*Error {
	if p == nil {
		return nil
	}
	return p.Errors
}

func (p *PublishScheduledShiftResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PublishScheduledShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PublishScheduledShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PublishScheduledShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PublishScheduledShiftResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a [RetrieveScheduledShift](api-endpoint:Labor-RetrieveScheduledShift) response.
// Either `scheduled_shift` or `errors` is present in the response.
type RetrieveScheduledShiftResponse struct {
	// The requested scheduled shift.
	ScheduledShift *ScheduledShift `json:"scheduled_shift,omitempty" url:"scheduled_shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveScheduledShiftResponse) GetScheduledShift() *ScheduledShift {
	if r == nil {
		return nil
	}
	return r.ScheduledShift
}

func (r *RetrieveScheduledShiftResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveScheduledShiftResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveScheduledShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveScheduledShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveScheduledShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveScheduledShiftResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A response to a request to get a `Timecard`. The response contains
// the requested `Timecard` object and might contain a set of `Error` objects if
// the request resulted in errors.
type RetrieveTimecardResponse struct {
	// The requested `Timecard`.
	Timecard *Timecard `json:"timecard,omitempty" url:"timecard,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RetrieveTimecardResponse) GetTimecard() *Timecard {
	if r == nil {
		return nil
	}
	return r.Timecard
}

func (r *RetrieveTimecardResponse) GetErrors() []*Error {
	if r == nil {
		return nil
	}
	return r.Errors
}

func (r *RetrieveTimecardResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveTimecardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveTimecardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveTimecardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveTimecardResponse) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents a specific time slot in a work schedule. This object is used to manage the
// lifecycle of a scheduled shift from the draft to published state. A scheduled shift contains
// the latest draft shift details and current published shift details.
type ScheduledShift struct {
	// **Read only** The Square-issued ID of the scheduled shift.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The latest draft shift details for the scheduled shift. Draft shift details are used to
	// stage and manage shifts before publishing. This field is always present.
	DraftShiftDetails *ScheduledShiftDetails `json:"draft_shift_details,omitempty" url:"draft_shift_details,omitempty"`
	// The current published (public) shift details for the scheduled shift. This field is
	// present only if the shift was published.
	PublishedShiftDetails *ScheduledShiftDetails `json:"published_shift_details,omitempty" url:"published_shift_details,omitempty"`
	// **Read only** The current version of the scheduled shift, which is incremented with each update.
	// This field is used for [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control to ensure that requests don't overwrite data from another request.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp of when the scheduled shift was created, in RFC 3339 format presented as UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the scheduled shift was last updated, in RFC 3339 format presented as UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduledShift) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *ScheduledShift) GetDraftShiftDetails() *ScheduledShiftDetails {
	if s == nil {
		return nil
	}
	return s.DraftShiftDetails
}

func (s *ScheduledShift) GetPublishedShiftDetails() *ScheduledShiftDetails {
	if s == nil {
		return nil
	}
	return s.PublishedShiftDetails
}

func (s *ScheduledShift) GetVersion() *int {
	if s == nil {
		return nil
	}
	return s.Version
}

func (s *ScheduledShift) GetCreatedAt() *string {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *ScheduledShift) GetUpdatedAt() *string {
	if s == nil {
		return nil
	}
	return s.UpdatedAt
}

func (s *ScheduledShift) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduledShift) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduledShift
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduledShift(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduledShift) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Represents shift details for draft and published versions of a [scheduled shift](entity:ScheduledShift),
// such as job ID, team member assignment, and start and end times.
type ScheduledShiftDetails struct {
	// The ID of the [team member](entity:TeamMember) scheduled for the shift.
	TeamMemberID *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// The ID of the [location](entity:Location) the shift is scheduled for.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the [job](entity:Job) the shift is scheduled for.
	JobID *string `json:"job_id,omitempty" url:"job_id,omitempty"`
	// The start time of the shift, in RFC 3339 format in the time zone &plus;
	// offset of the shift location specified in `location_id`. Precision up to the minute
	// is respected; seconds are truncated.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// The end time for the shift, in RFC 3339 format in the time zone &plus;
	// offset of the shift location specified in `location_id`. Precision up to the minute
	// is respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// Optional notes for the shift.
	Notes *string `json:"notes,omitempty" url:"notes,omitempty"`
	// Indicates whether the draft shift version is deleted. If set to `true` when the shift
	// is published, the entire scheduled shift (including the published shift) is deleted and
	// cannot be accessed using any endpoint.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// The time zone of the shift location, calculated based on the `location_id`. This field
	// is provided for convenience.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduledShiftDetails) GetTeamMemberID() *string {
	if s == nil {
		return nil
	}
	return s.TeamMemberID
}

func (s *ScheduledShiftDetails) GetLocationID() *string {
	if s == nil {
		return nil
	}
	return s.LocationID
}

func (s *ScheduledShiftDetails) GetJobID() *string {
	if s == nil {
		return nil
	}
	return s.JobID
}

func (s *ScheduledShiftDetails) GetStartAt() *string {
	if s == nil {
		return nil
	}
	return s.StartAt
}

func (s *ScheduledShiftDetails) GetEndAt() *string {
	if s == nil {
		return nil
	}
	return s.EndAt
}

func (s *ScheduledShiftDetails) GetNotes() *string {
	if s == nil {
		return nil
	}
	return s.Notes
}

func (s *ScheduledShiftDetails) GetIsDeleted() *bool {
	if s == nil {
		return nil
	}
	return s.IsDeleted
}

func (s *ScheduledShiftDetails) GetTimezone() *string {
	if s == nil {
		return nil
	}
	return s.Timezone
}

func (s *ScheduledShiftDetails) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduledShiftDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduledShiftDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduledShiftDetails(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduledShiftDetails) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines filter criteria for a [SearchScheduledShifts](api-endpoint:Labor-SearchScheduledShifts)
// request. Multiple filters in a query are combined as an `AND` operation.
type ScheduledShiftFilter struct {
	// Return shifts for the specified locations. When omitted, shifts for all
	// locations are returned. If needed, call [ListLocations](api-endpoint:Locations-ListLocations)
	// to get location IDs.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Return shifts whose `start_at` time is within the specified
	// time range (inclusive).
	Start *TimeRange `json:"start,omitempty" url:"start,omitempty"`
	// Return shifts whose `end_at` time is within the specified
	// time range (inclusive).
	End *TimeRange `json:"end,omitempty" url:"end,omitempty"`
	// Return shifts based on a workday date range.
	Workday *ScheduledShiftWorkday `json:"workday,omitempty" url:"workday,omitempty"`
	// Return shifts assigned to specified team members. If needed, call
	// [SearchTeamMembers](api-endpoint:Team-SearchTeamMembers) to get team member IDs.
	//
	// To return only the shifts assigned to the specified team members, include the
	// `assignment_status` filter in the query. Otherwise, all unassigned shifts are
	// returned along with shifts assigned to the specified team members.
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`
	// Return shifts based on whether a team member is assigned. A shift is
	// assigned if the `team_member_id` field is populated in the `draft_shift_details`
	// or `published_shift details` field of the shift.
	//
	// To return only draft or published shifts, include the `scheduled_shift_statuses`
	// filter in the query.
	// See [ScheduledShiftFilterAssignmentStatus](#type-scheduledshiftfilterassignmentstatus) for possible values
	AssignmentStatus *ScheduledShiftFilterAssignmentStatus `json:"assignment_status,omitempty" url:"assignment_status,omitempty"`
	// Return shifts based on the draft or published status of the shift.
	// A shift is published if the `published_shift_details` field is present.
	//
	// Note that shifts with `draft_shift_details.is_deleted` set to `true` are ignored
	// with the `DRAFT` filter.
	// See [ScheduledShiftFilterScheduledShiftStatus](#type-scheduledshiftfilterscheduledshiftstatus) for possible values
	ScheduledShiftStatuses []ScheduledShiftFilterScheduledShiftStatus `json:"scheduled_shift_statuses,omitempty" url:"scheduled_shift_statuses,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduledShiftFilter) GetLocationIDs() []string {
	if s == nil {
		return nil
	}
	return s.LocationIDs
}

func (s *ScheduledShiftFilter) GetStart() *TimeRange {
	if s == nil {
		return nil
	}
	return s.Start
}

func (s *ScheduledShiftFilter) GetEnd() *TimeRange {
	if s == nil {
		return nil
	}
	return s.End
}

func (s *ScheduledShiftFilter) GetWorkday() *ScheduledShiftWorkday {
	if s == nil {
		return nil
	}
	return s.Workday
}

func (s *ScheduledShiftFilter) GetTeamMemberIDs() []string {
	if s == nil {
		return nil
	}
	return s.TeamMemberIDs
}

func (s *ScheduledShiftFilter) GetAssignmentStatus() *ScheduledShiftFilterAssignmentStatus {
	if s == nil {
		return nil
	}
	return s.AssignmentStatus
}

func (s *ScheduledShiftFilter) GetScheduledShiftStatuses() []ScheduledShiftFilterScheduledShiftStatus {
	if s == nil {
		return nil
	}
	return s.ScheduledShiftStatuses
}

func (s *ScheduledShiftFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduledShiftFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduledShiftFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduledShiftFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduledShiftFilter) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines valid values for the `assignment_status` filter in a
// [SearchScheduledShifts](api-endpoint:Labor-SearchScheduledShifts) request.
// Assignment status is based on the `draft_shift_details.team_member_id` and
// `published_shift_details.team_member_id` fields of the scheduled shift.
type ScheduledShiftFilterAssignmentStatus string

const (
	ScheduledShiftFilterAssignmentStatusAssigned   ScheduledShiftFilterAssignmentStatus = "ASSIGNED"
	ScheduledShiftFilterAssignmentStatusUnassigned ScheduledShiftFilterAssignmentStatus = "UNASSIGNED"
)

func NewScheduledShiftFilterAssignmentStatusFromString(s string) (ScheduledShiftFilterAssignmentStatus, error) {
	switch s {
	case "ASSIGNED":
		return ScheduledShiftFilterAssignmentStatusAssigned, nil
	case "UNASSIGNED":
		return ScheduledShiftFilterAssignmentStatusUnassigned, nil
	}
	var t ScheduledShiftFilterAssignmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduledShiftFilterAssignmentStatus) Ptr() *ScheduledShiftFilterAssignmentStatus {
	return &s
}

// Defines valid values for the `scheduled_shift_statuses` filter in a
// [SearchScheduledShifts](api-endpoint:Labor-SearchScheduledShifts) request.
type ScheduledShiftFilterScheduledShiftStatus string

const (
	ScheduledShiftFilterScheduledShiftStatusDraft     ScheduledShiftFilterScheduledShiftStatus = "DRAFT"
	ScheduledShiftFilterScheduledShiftStatusPublished ScheduledShiftFilterScheduledShiftStatus = "PUBLISHED"
)

func NewScheduledShiftFilterScheduledShiftStatusFromString(s string) (ScheduledShiftFilterScheduledShiftStatus, error) {
	switch s {
	case "DRAFT":
		return ScheduledShiftFilterScheduledShiftStatusDraft, nil
	case "PUBLISHED":
		return ScheduledShiftFilterScheduledShiftStatusPublished, nil
	}
	var t ScheduledShiftFilterScheduledShiftStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduledShiftFilterScheduledShiftStatus) Ptr() *ScheduledShiftFilterScheduledShiftStatus {
	return &s
}

// Indicates whether Square sends an email notification to team members
// when a scheduled shift is published and which team members receive the notification.
type ScheduledShiftNotificationAudience string

const (
	ScheduledShiftNotificationAudienceAll      ScheduledShiftNotificationAudience = "ALL"
	ScheduledShiftNotificationAudienceAffected ScheduledShiftNotificationAudience = "AFFECTED"
	ScheduledShiftNotificationAudienceNone     ScheduledShiftNotificationAudience = "NONE"
)

func NewScheduledShiftNotificationAudienceFromString(s string) (ScheduledShiftNotificationAudience, error) {
	switch s {
	case "ALL":
		return ScheduledShiftNotificationAudienceAll, nil
	case "AFFECTED":
		return ScheduledShiftNotificationAudienceAffected, nil
	case "NONE":
		return ScheduledShiftNotificationAudienceNone, nil
	}
	var t ScheduledShiftNotificationAudience
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduledShiftNotificationAudience) Ptr() *ScheduledShiftNotificationAudience {
	return &s
}

// Represents filter and sort criteria for the `query` field in a
// [SearchScheduledShifts](api-endpoint:Labor-SearchScheduledShifts) request.
type ScheduledShiftQuery struct {
	// Filtering options for the query.
	Filter *ScheduledShiftFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Sorting options for the query.
	Sort *ScheduledShiftSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduledShiftQuery) GetFilter() *ScheduledShiftFilter {
	if s == nil {
		return nil
	}
	return s.Filter
}

func (s *ScheduledShiftQuery) GetSort() *ScheduledShiftSort {
	if s == nil {
		return nil
	}
	return s.Sort
}

func (s *ScheduledShiftQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduledShiftQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduledShiftQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduledShiftQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduledShiftQuery) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines sort criteria for a [SearchScheduledShifts](api-endpoint:Labor-SearchScheduledShifts)
// request.
type ScheduledShiftSort struct {
	// The field to sort on. The default value is `START_AT`.
	// See [ScheduledShiftSortField](#type-scheduledshiftsortfield) for possible values
	Field *ScheduledShiftSortField `json:"field,omitempty" url:"field,omitempty"`
	// The order in which results are returned. The default value is `ASC`.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduledShiftSort) GetField() *ScheduledShiftSortField {
	if s == nil {
		return nil
	}
	return s.Field
}

func (s *ScheduledShiftSort) GetOrder() *SortOrder {
	if s == nil {
		return nil
	}
	return s.Order
}

func (s *ScheduledShiftSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduledShiftSort) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduledShiftSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduledShiftSort(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduledShiftSort) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines valid values for the `field` sort setting in a
// [SearchScheduledShifts](api-endpoint:Labor-SearchScheduledShifts) request.
type ScheduledShiftSortField string

const (
	ScheduledShiftSortFieldStartAt   ScheduledShiftSortField = "START_AT"
	ScheduledShiftSortFieldEndAt     ScheduledShiftSortField = "END_AT"
	ScheduledShiftSortFieldCreatedAt ScheduledShiftSortField = "CREATED_AT"
	ScheduledShiftSortFieldUpdatedAt ScheduledShiftSortField = "UPDATED_AT"
)

func NewScheduledShiftSortFieldFromString(s string) (ScheduledShiftSortField, error) {
	switch s {
	case "START_AT":
		return ScheduledShiftSortFieldStartAt, nil
	case "END_AT":
		return ScheduledShiftSortFieldEndAt, nil
	case "CREATED_AT":
		return ScheduledShiftSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return ScheduledShiftSortFieldUpdatedAt, nil
	}
	var t ScheduledShiftSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduledShiftSortField) Ptr() *ScheduledShiftSortField {
	return &s
}

// A `ScheduledShift` search query filter parameter that sets a range of days that
// a `Shift` must start or end in before passing the filter condition.
type ScheduledShiftWorkday struct {
	// Dates for fetching the scheduled shifts.
	DateRange *DateRange `json:"date_range,omitempty" url:"date_range,omitempty"`
	// The strategy on which the dates are applied.
	// See [ScheduledShiftWorkdayMatcher](#type-scheduledshiftworkdaymatcher) for possible values
	MatchScheduledShiftsBy *ScheduledShiftWorkdayMatcher `json:"match_scheduled_shifts_by,omitempty" url:"match_scheduled_shifts_by,omitempty"`
	// Location-specific timezones convert workdays to datetime filters.
	// Every location included in the query must have a timezone or this field
	// must be provided as a fallback. Format: the IANA timezone database
	// identifier for the relevant timezone.
	DefaultTimezone *string `json:"default_timezone,omitempty" url:"default_timezone,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduledShiftWorkday) GetDateRange() *DateRange {
	if s == nil {
		return nil
	}
	return s.DateRange
}

func (s *ScheduledShiftWorkday) GetMatchScheduledShiftsBy() *ScheduledShiftWorkdayMatcher {
	if s == nil {
		return nil
	}
	return s.MatchScheduledShiftsBy
}

func (s *ScheduledShiftWorkday) GetDefaultTimezone() *string {
	if s == nil {
		return nil
	}
	return s.DefaultTimezone
}

func (s *ScheduledShiftWorkday) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduledShiftWorkday) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduledShiftWorkday
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduledShiftWorkday(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduledShiftWorkday) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Defines the logic used to apply a workday filter.
type ScheduledShiftWorkdayMatcher string

const (
	ScheduledShiftWorkdayMatcherStartAt      ScheduledShiftWorkdayMatcher = "START_AT"
	ScheduledShiftWorkdayMatcherEndAt        ScheduledShiftWorkdayMatcher = "END_AT"
	ScheduledShiftWorkdayMatcherIntersection ScheduledShiftWorkdayMatcher = "INTERSECTION"
)

func NewScheduledShiftWorkdayMatcherFromString(s string) (ScheduledShiftWorkdayMatcher, error) {
	switch s {
	case "START_AT":
		return ScheduledShiftWorkdayMatcherStartAt, nil
	case "END_AT":
		return ScheduledShiftWorkdayMatcherEndAt, nil
	case "INTERSECTION":
		return ScheduledShiftWorkdayMatcherIntersection, nil
	}
	var t ScheduledShiftWorkdayMatcher
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduledShiftWorkdayMatcher) Ptr() *ScheduledShiftWorkdayMatcher {
	return &s
}

// Represents a [SearchScheduledShifts](api-endpoint:Labor-SearchScheduledShifts) response.
// Either `scheduled_shifts` or `errors` is present in the response.
type SearchScheduledShiftsResponse struct {
	// A paginated list of scheduled shifts that match the query conditions.
	ScheduledShifts []*ScheduledShift `json:"scheduled_shifts,omitempty" url:"scheduled_shifts,omitempty"`
	// The pagination cursor used to retrieve the next page of results. This field is present
	// only if additional results are available.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchScheduledShiftsResponse) GetScheduledShifts() []*ScheduledShift {
	if s == nil {
		return nil
	}
	return s.ScheduledShifts
}

func (s *SearchScheduledShiftsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchScheduledShiftsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchScheduledShiftsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchScheduledShiftsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchScheduledShiftsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchScheduledShiftsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchScheduledShiftsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The response to a request for `Timecard` objects. The response contains
// the requested `Timecard` objects and might contain a set of `Error` objects if
// the request resulted in errors.
type SearchTimecardsResponse struct {
	// Timecards.
	Timecards []*Timecard `json:"timecards,omitempty" url:"timecards,omitempty"`
	// An opaque cursor for fetching the next page.
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SearchTimecardsResponse) GetTimecards() []*Timecard {
	if s == nil {
		return nil
	}
	return s.Timecards
}

func (s *SearchTimecardsResponse) GetCursor() *string {
	if s == nil {
		return nil
	}
	return s.Cursor
}

func (s *SearchTimecardsResponse) GetErrors() []*Error {
	if s == nil {
		return nil
	}
	return s.Errors
}

func (s *SearchTimecardsResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchTimecardsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchTimecardsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchTimecardsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchTimecardsResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// A record of the hourly rate, start time, and end time of a single timecard (shift)
// for a team member. This might include a record of the start and end times of breaks
// taken during the shift.
type Timecard struct {
	// **Read only** The Square-issued UUID for this object.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the [location](entity:Location) for this timecard. The location should be based on
	// where the team member clocked in.
	LocationID string `json:"location_id" url:"location_id"`
	// **Read only** The time zone calculated from the location based on the `location_id`,
	// provided as a convenience value. Format: the IANA time zone database identifier for the
	// location time zone.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// The start time of the timecard, in RFC 3339 format and shifted to the location
	// timezone + offset. Precision up to the minute is respected; seconds are truncated.
	StartAt string `json:"start_at" url:"start_at"`
	// The end time of the timecard, in RFC 3339 format and shifted to the location
	// timezone + offset. Precision up to the minute is respected; seconds are truncated.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`
	// Job and pay related information. If the wage is not set on create, it defaults to a wage
	// of zero. If the title is not set on create, it defaults to the name of the role the team member
	// is assigned to, if any.
	Wage *TimecardWage `json:"wage,omitempty" url:"wage,omitempty"`
	// A list of all the paid or unpaid breaks that were taken during this timecard.
	Breaks []*Break `json:"breaks,omitempty" url:"breaks,omitempty"`
	// Describes the working state of the timecard.
	// See [TimecardStatus](#type-timecardstatus) for possible values
	Status *TimecardStatus `json:"status,omitempty" url:"status,omitempty"`
	// **Read only** The current version of the timecard, which is incremented with each update.
	// This field is used for [optimistic concurrency](https://developer.squareup.com/docs/build-basics/common-api-patterns/optimistic-concurrency)
	// control to ensure that requests don't overwrite data from another request.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The timestamp of when the timecard was created, in RFC 3339 format presented as UTC.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the timecard was last updated, in RFC 3339 format presented as UTC.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The ID of the [team member](entity:TeamMember) this timecard belongs to.
	TeamMemberID string `json:"team_member_id" url:"team_member_id"`
	// The cash tips declared by the team member for this timecard.
	DeclaredCashTipMoney *Money `json:"declared_cash_tip_money,omitempty" url:"declared_cash_tip_money,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Timecard) GetID() *string {
	if t == nil {
		return nil
	}
	return t.ID
}

func (t *Timecard) GetLocationID() string {
	if t == nil {
		return ""
	}
	return t.LocationID
}

func (t *Timecard) GetTimezone() *string {
	if t == nil {
		return nil
	}
	return t.Timezone
}

func (t *Timecard) GetStartAt() string {
	if t == nil {
		return ""
	}
	return t.StartAt
}

func (t *Timecard) GetEndAt() *string {
	if t == nil {
		return nil
	}
	return t.EndAt
}

func (t *Timecard) GetWage() *TimecardWage {
	if t == nil {
		return nil
	}
	return t.Wage
}

func (t *Timecard) GetBreaks() []*Break {
	if t == nil {
		return nil
	}
	return t.Breaks
}

func (t *Timecard) GetStatus() *TimecardStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *Timecard) GetVersion() *int {
	if t == nil {
		return nil
	}
	return t.Version
}

func (t *Timecard) GetCreatedAt() *string {
	if t == nil {
		return nil
	}
	return t.CreatedAt
}

func (t *Timecard) GetUpdatedAt() *string {
	if t == nil {
		return nil
	}
	return t.UpdatedAt
}

func (t *Timecard) GetTeamMemberID() string {
	if t == nil {
		return ""
	}
	return t.TeamMemberID
}

func (t *Timecard) GetDeclaredCashTipMoney() *Money {
	if t == nil {
		return nil
	}
	return t.DeclaredCashTipMoney
}

func (t *Timecard) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Timecard) UnmarshalJSON(data []byte) error {
	type unmarshaler Timecard
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Timecard(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Timecard) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines a filter used in a search for `Timecard` records. `AND` logic is
// used by Square's servers to apply each filter property specified.
type TimecardFilter struct {
	// Fetch timecards for the specified location.
	LocationIDs []string `json:"location_ids,omitempty" url:"location_ids,omitempty"`
	// Fetch a `Timecard` instance by `Timecard.status`.
	// See [TimecardFilterStatus](#type-timecardfilterstatus) for possible values
	Status *TimecardFilterStatus `json:"status,omitempty" url:"status,omitempty"`
	// Fetch `Timecard` instances that start in the time range - Inclusive.
	Start *TimeRange `json:"start,omitempty" url:"start,omitempty"`
	// Fetch the `Timecard` instances that end in the time range - Inclusive.
	End *TimeRange `json:"end,omitempty" url:"end,omitempty"`
	// Fetch the `Timecard` instances based on the workday date range.
	Workday *TimecardWorkday `json:"workday,omitempty" url:"workday,omitempty"`
	// Fetch timecards for the specified team members.
	TeamMemberIDs []string `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimecardFilter) GetLocationIDs() []string {
	if t == nil {
		return nil
	}
	return t.LocationIDs
}

func (t *TimecardFilter) GetStatus() *TimecardFilterStatus {
	if t == nil {
		return nil
	}
	return t.Status
}

func (t *TimecardFilter) GetStart() *TimeRange {
	if t == nil {
		return nil
	}
	return t.Start
}

func (t *TimecardFilter) GetEnd() *TimeRange {
	if t == nil {
		return nil
	}
	return t.End
}

func (t *TimecardFilter) GetWorkday() *TimecardWorkday {
	if t == nil {
		return nil
	}
	return t.Workday
}

func (t *TimecardFilter) GetTeamMemberIDs() []string {
	if t == nil {
		return nil
	}
	return t.TeamMemberIDs
}

func (t *TimecardFilter) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimecardFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler TimecardFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimecardFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimecardFilter) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Specifies the `status` of `Timecard` records to be returned.
type TimecardFilterStatus string

const (
	TimecardFilterStatusOpen   TimecardFilterStatus = "OPEN"
	TimecardFilterStatusClosed TimecardFilterStatus = "CLOSED"
)

func NewTimecardFilterStatusFromString(s string) (TimecardFilterStatus, error) {
	switch s {
	case "OPEN":
		return TimecardFilterStatusOpen, nil
	case "CLOSED":
		return TimecardFilterStatusClosed, nil
	}
	var t TimecardFilterStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimecardFilterStatus) Ptr() *TimecardFilterStatus {
	return &t
}

// The parameters of a `Timecard` search query, which includes filter and sort options.
type TimecardQuery struct {
	// Query filter options.
	Filter *TimecardFilter `json:"filter,omitempty" url:"filter,omitempty"`
	// Sort order details.
	Sort *TimecardSort `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimecardQuery) GetFilter() *TimecardFilter {
	if t == nil {
		return nil
	}
	return t.Filter
}

func (t *TimecardQuery) GetSort() *TimecardSort {
	if t == nil {
		return nil
	}
	return t.Sort
}

func (t *TimecardQuery) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimecardQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler TimecardQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimecardQuery(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimecardQuery) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Sets the sort order of search results.
type TimecardSort struct {
	// The field to sort on.
	// See [TimecardSortField](#type-timecardsortfield) for possible values
	Field *TimecardSortField `json:"field,omitempty" url:"field,omitempty"`
	// The order in which results are returned. Defaults to DESC.
	// See [SortOrder](#type-sortorder) for possible values
	Order *SortOrder `json:"order,omitempty" url:"order,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimecardSort) GetField() *TimecardSortField {
	if t == nil {
		return nil
	}
	return t.Field
}

func (t *TimecardSort) GetOrder() *SortOrder {
	if t == nil {
		return nil
	}
	return t.Order
}

func (t *TimecardSort) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimecardSort) UnmarshalJSON(data []byte) error {
	type unmarshaler TimecardSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimecardSort(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimecardSort) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Enumerates the `Timecard` fields to sort on.
type TimecardSortField string

const (
	TimecardSortFieldStartAt   TimecardSortField = "START_AT"
	TimecardSortFieldEndAt     TimecardSortField = "END_AT"
	TimecardSortFieldCreatedAt TimecardSortField = "CREATED_AT"
	TimecardSortFieldUpdatedAt TimecardSortField = "UPDATED_AT"
)

func NewTimecardSortFieldFromString(s string) (TimecardSortField, error) {
	switch s {
	case "START_AT":
		return TimecardSortFieldStartAt, nil
	case "END_AT":
		return TimecardSortFieldEndAt, nil
	case "CREATED_AT":
		return TimecardSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return TimecardSortFieldUpdatedAt, nil
	}
	var t TimecardSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimecardSortField) Ptr() *TimecardSortField {
	return &t
}

// **Read only** Enumerates the possible status of a [timecard](entity:Timecard).
type TimecardStatus string

const (
	TimecardStatusOpen   TimecardStatus = "OPEN"
	TimecardStatusClosed TimecardStatus = "CLOSED"
)

func NewTimecardStatusFromString(s string) (TimecardStatus, error) {
	switch s {
	case "OPEN":
		return TimecardStatusOpen, nil
	case "CLOSED":
		return TimecardStatusClosed, nil
	}
	var t TimecardStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimecardStatus) Ptr() *TimecardStatus {
	return &t
}

// The hourly wage rate used to compensate a team member for a [timecard](entity:Timecard).
type TimecardWage struct {
	// The name of the job performed during this timecard.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Can be a custom-set hourly wage or the calculated effective hourly
	// wage based on the annual wage and hours worked per week.
	HourlyRate *Money `json:"hourly_rate,omitempty" url:"hourly_rate,omitempty"`
	// The ID of the [job](entity:Job) performed for this timecard. Square
	// labor-reporting UIs might group timecards together by ID.
	JobID *string `json:"job_id,omitempty" url:"job_id,omitempty"`
	// Whether team members are eligible for tips when working this job.
	TipEligible *bool `json:"tip_eligible,omitempty" url:"tip_eligible,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimecardWage) GetTitle() *string {
	if t == nil {
		return nil
	}
	return t.Title
}

func (t *TimecardWage) GetHourlyRate() *Money {
	if t == nil {
		return nil
	}
	return t.HourlyRate
}

func (t *TimecardWage) GetJobID() *string {
	if t == nil {
		return nil
	}
	return t.JobID
}

func (t *TimecardWage) GetTipEligible() *bool {
	if t == nil {
		return nil
	}
	return t.TipEligible
}

func (t *TimecardWage) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimecardWage) UnmarshalJSON(data []byte) error {
	type unmarshaler TimecardWage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimecardWage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimecardWage) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// A `Timecard` search query filter parameter that sets a range of days that
// a `Timecard` must start or end in before passing the filter condition.
type TimecardWorkday struct {
	// Dates for fetching the timecards.
	DateRange *DateRange `json:"date_range,omitempty" url:"date_range,omitempty"`
	// The strategy on which the dates are applied.
	// See [TimecardWorkdayMatcher](#type-timecardworkdaymatcher) for possible values
	MatchTimecardsBy *TimecardWorkdayMatcher `json:"match_timecards_by,omitempty" url:"match_timecards_by,omitempty"`
	// Location-specific timezones convert workdays to datetime filters.
	// Every location included in the query must have a timezone or this field
	// must be provided as a fallback. Format: the IANA timezone database
	// identifier for the relevant timezone.
	DefaultTimezone *string `json:"default_timezone,omitempty" url:"default_timezone,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimecardWorkday) GetDateRange() *DateRange {
	if t == nil {
		return nil
	}
	return t.DateRange
}

func (t *TimecardWorkday) GetMatchTimecardsBy() *TimecardWorkdayMatcher {
	if t == nil {
		return nil
	}
	return t.MatchTimecardsBy
}

func (t *TimecardWorkday) GetDefaultTimezone() *string {
	if t == nil {
		return nil
	}
	return t.DefaultTimezone
}

func (t *TimecardWorkday) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimecardWorkday) UnmarshalJSON(data []byte) error {
	type unmarshaler TimecardWorkday
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimecardWorkday(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimecardWorkday) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines the logic used to apply a workday filter.
type TimecardWorkdayMatcher string

const (
	TimecardWorkdayMatcherStartAt      TimecardWorkdayMatcher = "START_AT"
	TimecardWorkdayMatcherEndAt        TimecardWorkdayMatcher = "END_AT"
	TimecardWorkdayMatcherIntersection TimecardWorkdayMatcher = "INTERSECTION"
)

func NewTimecardWorkdayMatcherFromString(s string) (TimecardWorkdayMatcher, error) {
	switch s {
	case "START_AT":
		return TimecardWorkdayMatcherStartAt, nil
	case "END_AT":
		return TimecardWorkdayMatcherEndAt, nil
	case "INTERSECTION":
		return TimecardWorkdayMatcherIntersection, nil
	}
	var t TimecardWorkdayMatcher
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimecardWorkdayMatcher) Ptr() *TimecardWorkdayMatcher {
	return &t
}

// Represents an [UpdateScheduledShift](api-endpoint:Labor-UpdateScheduledShift) response.
// Either `scheduled_shift` or `errors` is present in the response.
type UpdateScheduledShiftResponse struct {
	// The updated scheduled shift. To make the changes public, call
	// [PublishScheduledShift](api-endpoint:Labor-PublishScheduledShift) or
	// [BulkPublishScheduledShifts](api-endpoint:Labor-BulkPublishScheduledShifts).
	ScheduledShift *ScheduledShift `json:"scheduled_shift,omitempty" url:"scheduled_shift,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateScheduledShiftResponse) GetScheduledShift() *ScheduledShift {
	if u == nil {
		return nil
	}
	return u.ScheduledShift
}

func (u *UpdateScheduledShiftResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateScheduledShiftResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateScheduledShiftResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateScheduledShiftResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateScheduledShiftResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateScheduledShiftResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// The response to a request to update a `Timecard`. The response contains
// the updated `Timecard` object and might contain a set of `Error` objects if
// the request resulted in errors.
type UpdateTimecardResponse struct {
	// The updated `Timecard`.
	Timecard *Timecard `json:"timecard,omitempty" url:"timecard,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateTimecardResponse) GetTimecard() *Timecard {
	if u == nil {
		return nil
	}
	return u.Timecard
}

func (u *UpdateTimecardResponse) GetErrors() []*Error {
	if u == nil {
		return nil
	}
	return u.Errors
}

func (u *UpdateTimecardResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateTimecardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateTimecardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateTimecardResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateTimecardResponse) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
