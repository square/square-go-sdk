// Code generated by Fern. DO NOT EDIT.

package square

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/square/square-go-sdk/v2/internal"
	big "math/big"
)

var (
	getByV1IDBankAccountsRequestFieldV1BankAccountID = big.NewInt(1 << 0)
)

type GetByV1IDBankAccountsRequest struct {
	// Connect V1 ID of the desired `BankAccount`. For more information, see
	// [Retrieve a bank account by using an ID issued by V1 Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api#retrieve-a-bank-account-by-using-an-id-issued-by-v1-bank-accounts-api).
	V1BankAccountID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetByV1IDBankAccountsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetV1BankAccountID sets the V1BankAccountID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetByV1IDBankAccountsRequest) SetV1BankAccountID(v1BankAccountID string) {
	g.V1BankAccountID = v1BankAccountID
	g.require(getByV1IDBankAccountsRequestFieldV1BankAccountID)
}

var (
	getBankAccountsRequestFieldBankAccountID = big.NewInt(1 << 0)
)

type GetBankAccountsRequest struct {
	// Square-issued ID of the desired `BankAccount`.
	BankAccountID string `json:"-" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (g *GetBankAccountsRequest) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetBankAccountID sets the BankAccountID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetBankAccountsRequest) SetBankAccountID(bankAccountID string) {
	g.BankAccountID = bankAccountID
	g.require(getBankAccountsRequestFieldBankAccountID)
}

var (
	listBankAccountsRequestFieldCursor     = big.NewInt(1 << 0)
	listBankAccountsRequestFieldLimit      = big.NewInt(1 << 1)
	listBankAccountsRequestFieldLocationID = big.NewInt(1 << 2)
)

type ListBankAccountsRequest struct {
	// The pagination cursor returned by a previous call to this endpoint.
	// Use it in the next `ListBankAccounts` request to retrieve the next set
	// of results.
	//
	// See the [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination) guide for more information.
	Cursor *string `json:"-" url:"cursor,omitempty"`
	// Upper limit on the number of bank accounts to return in the response.
	// Currently, 1000 is the largest supported limit. You can specify a limit
	// of up to 1000 bank accounts. This is also the default limit.
	Limit *int `json:"-" url:"limit,omitempty"`
	// Location ID. You can specify this optional filter
	// to retrieve only the linked bank accounts belonging to a specific location.
	LocationID *string `json:"-" url:"location_id,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (l *ListBankAccountsRequest) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBankAccountsRequest) SetCursor(cursor *string) {
	l.Cursor = cursor
	l.require(listBankAccountsRequestFieldCursor)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBankAccountsRequest) SetLimit(limit *int) {
	l.Limit = limit
	l.require(listBankAccountsRequestFieldLimit)
}

// SetLocationID sets the LocationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBankAccountsRequest) SetLocationID(locationID *string) {
	l.LocationID = locationID
	l.require(listBankAccountsRequestFieldLocationID)
}

// Represents a bank account. For more information about
// linking a bank account to a Square account, see
// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
var (
	bankAccountFieldID                                = big.NewInt(1 << 0)
	bankAccountFieldAccountNumberSuffix               = big.NewInt(1 << 1)
	bankAccountFieldCountry                           = big.NewInt(1 << 2)
	bankAccountFieldCurrency                          = big.NewInt(1 << 3)
	bankAccountFieldAccountType                       = big.NewInt(1 << 4)
	bankAccountFieldHolderName                        = big.NewInt(1 << 5)
	bankAccountFieldPrimaryBankIdentificationNumber   = big.NewInt(1 << 6)
	bankAccountFieldSecondaryBankIdentificationNumber = big.NewInt(1 << 7)
	bankAccountFieldDebitMandateReferenceID           = big.NewInt(1 << 8)
	bankAccountFieldReferenceID                       = big.NewInt(1 << 9)
	bankAccountFieldLocationID                        = big.NewInt(1 << 10)
	bankAccountFieldStatus                            = big.NewInt(1 << 11)
	bankAccountFieldCreditable                        = big.NewInt(1 << 12)
	bankAccountFieldDebitable                         = big.NewInt(1 << 13)
	bankAccountFieldFingerprint                       = big.NewInt(1 << 14)
	bankAccountFieldVersion                           = big.NewInt(1 << 15)
	bankAccountFieldBankName                          = big.NewInt(1 << 16)
)

type BankAccount struct {
	// The unique, Square-issued identifier for the bank account.
	ID string `json:"id" url:"id"`
	// The last few digits of the account number.
	AccountNumberSuffix string `json:"account_number_suffix" url:"account_number_suffix"`
	// The ISO 3166 Alpha-2 country code where the bank account is based.
	// See [Country](#type-country) for possible values
	Country Country `json:"country" url:"country"`
	// The 3-character ISO 4217 currency code indicating the operating
	// currency of the bank account. For example, the currency code for US dollars
	// is `USD`.
	// See [Currency](#type-currency) for possible values
	Currency Currency `json:"currency" url:"currency"`
	// The financial purpose of the associated bank account.
	// See [BankAccountType](#type-bankaccounttype) for possible values
	AccountType BankAccountType `json:"account_type" url:"account_type"`
	// Name of the account holder. This name must match the name
	// on the targeted bank account record.
	HolderName string `json:"holder_name" url:"holder_name"`
	// Primary identifier for the bank. For more information, see
	// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
	PrimaryBankIdentificationNumber string `json:"primary_bank_identification_number" url:"primary_bank_identification_number"`
	// Secondary identifier for the bank. For more information, see
	// [Bank Accounts API](https://developer.squareup.com/docs/bank-accounts-api).
	SecondaryBankIdentificationNumber *string `json:"secondary_bank_identification_number,omitempty" url:"secondary_bank_identification_number,omitempty"`
	// Reference identifier that will be displayed to UK bank account owners
	// when collecting direct debit authorization. Only required for UK bank accounts.
	DebitMandateReferenceID *string `json:"debit_mandate_reference_id,omitempty" url:"debit_mandate_reference_id,omitempty"`
	// Client-provided identifier for linking the banking account to an entity
	// in a third-party system (for example, a bank account number or a user identifier).
	ReferenceID *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The location to which the bank account belongs.
	LocationID *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// Read-only. The current verification status of this BankAccount object.
	// See [BankAccountStatus](#type-bankaccountstatus) for possible values
	Status BankAccountStatus `json:"status" url:"status"`
	// Indicates whether it is possible for Square to send money to this bank account.
	Creditable bool `json:"creditable" url:"creditable"`
	// Indicates whether it is possible for Square to take money from this
	// bank account.
	Debitable bool `json:"debitable" url:"debitable"`
	// A Square-assigned, unique identifier for the bank account based on the
	// account information. The account fingerprint can be used to compare account
	// entries and determine if the they represent the same real-world bank account.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// The current version of the `BankAccount`.
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// Read only. Name of actual financial institution.
	// For example "Bank of America".
	BankName *string `json:"bank_name,omitempty" url:"bank_name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BankAccount) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BankAccount) GetAccountNumberSuffix() string {
	if b == nil {
		return ""
	}
	return b.AccountNumberSuffix
}

func (b *BankAccount) GetCountry() Country {
	if b == nil {
		return ""
	}
	return b.Country
}

func (b *BankAccount) GetCurrency() Currency {
	if b == nil {
		return ""
	}
	return b.Currency
}

func (b *BankAccount) GetAccountType() BankAccountType {
	if b == nil {
		return ""
	}
	return b.AccountType
}

func (b *BankAccount) GetHolderName() string {
	if b == nil {
		return ""
	}
	return b.HolderName
}

func (b *BankAccount) GetPrimaryBankIdentificationNumber() string {
	if b == nil {
		return ""
	}
	return b.PrimaryBankIdentificationNumber
}

func (b *BankAccount) GetSecondaryBankIdentificationNumber() *string {
	if b == nil {
		return nil
	}
	return b.SecondaryBankIdentificationNumber
}

func (b *BankAccount) GetDebitMandateReferenceID() *string {
	if b == nil {
		return nil
	}
	return b.DebitMandateReferenceID
}

func (b *BankAccount) GetReferenceID() *string {
	if b == nil {
		return nil
	}
	return b.ReferenceID
}

func (b *BankAccount) GetLocationID() *string {
	if b == nil {
		return nil
	}
	return b.LocationID
}

func (b *BankAccount) GetStatus() BankAccountStatus {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BankAccount) GetCreditable() bool {
	if b == nil {
		return false
	}
	return b.Creditable
}

func (b *BankAccount) GetDebitable() bool {
	if b == nil {
		return false
	}
	return b.Debitable
}

func (b *BankAccount) GetFingerprint() *string {
	if b == nil {
		return nil
	}
	return b.Fingerprint
}

func (b *BankAccount) GetVersion() *int {
	if b == nil {
		return nil
	}
	return b.Version
}

func (b *BankAccount) GetBankName() *string {
	if b == nil {
		return nil
	}
	return b.BankName
}

func (b *BankAccount) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccount) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetID(id string) {
	b.ID = id
	b.require(bankAccountFieldID)
}

// SetAccountNumberSuffix sets the AccountNumberSuffix field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetAccountNumberSuffix(accountNumberSuffix string) {
	b.AccountNumberSuffix = accountNumberSuffix
	b.require(bankAccountFieldAccountNumberSuffix)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetCountry(country Country) {
	b.Country = country
	b.require(bankAccountFieldCountry)
}

// SetCurrency sets the Currency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetCurrency(currency Currency) {
	b.Currency = currency
	b.require(bankAccountFieldCurrency)
}

// SetAccountType sets the AccountType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetAccountType(accountType BankAccountType) {
	b.AccountType = accountType
	b.require(bankAccountFieldAccountType)
}

// SetHolderName sets the HolderName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetHolderName(holderName string) {
	b.HolderName = holderName
	b.require(bankAccountFieldHolderName)
}

// SetPrimaryBankIdentificationNumber sets the PrimaryBankIdentificationNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetPrimaryBankIdentificationNumber(primaryBankIdentificationNumber string) {
	b.PrimaryBankIdentificationNumber = primaryBankIdentificationNumber
	b.require(bankAccountFieldPrimaryBankIdentificationNumber)
}

// SetSecondaryBankIdentificationNumber sets the SecondaryBankIdentificationNumber field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetSecondaryBankIdentificationNumber(secondaryBankIdentificationNumber *string) {
	b.SecondaryBankIdentificationNumber = secondaryBankIdentificationNumber
	b.require(bankAccountFieldSecondaryBankIdentificationNumber)
}

// SetDebitMandateReferenceID sets the DebitMandateReferenceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetDebitMandateReferenceID(debitMandateReferenceID *string) {
	b.DebitMandateReferenceID = debitMandateReferenceID
	b.require(bankAccountFieldDebitMandateReferenceID)
}

// SetReferenceID sets the ReferenceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetReferenceID(referenceID *string) {
	b.ReferenceID = referenceID
	b.require(bankAccountFieldReferenceID)
}

// SetLocationID sets the LocationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetLocationID(locationID *string) {
	b.LocationID = locationID
	b.require(bankAccountFieldLocationID)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetStatus(status BankAccountStatus) {
	b.Status = status
	b.require(bankAccountFieldStatus)
}

// SetCreditable sets the Creditable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetCreditable(creditable bool) {
	b.Creditable = creditable
	b.require(bankAccountFieldCreditable)
}

// SetDebitable sets the Debitable field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetDebitable(debitable bool) {
	b.Debitable = debitable
	b.require(bankAccountFieldDebitable)
}

// SetFingerprint sets the Fingerprint field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetFingerprint(fingerprint *string) {
	b.Fingerprint = fingerprint
	b.require(bankAccountFieldFingerprint)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetVersion(version *int) {
	b.Version = version
	b.require(bankAccountFieldVersion)
}

// SetBankName sets the BankName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BankAccount) SetBankName(bankName *string) {
	b.BankName = bankName
	b.require(bankAccountFieldBankName)
}

func (b *BankAccount) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccount) MarshalJSON() ([]byte, error) {
	type embed BankAccount
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BankAccount) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Indicates the current verification status of a `BankAccount` object.
type BankAccountStatus string

const (
	BankAccountStatusVerificationInProgress BankAccountStatus = "VERIFICATION_IN_PROGRESS"
	BankAccountStatusVerified               BankAccountStatus = "VERIFIED"
	BankAccountStatusDisabled               BankAccountStatus = "DISABLED"
)

func NewBankAccountStatusFromString(s string) (BankAccountStatus, error) {
	switch s {
	case "VERIFICATION_IN_PROGRESS":
		return BankAccountStatusVerificationInProgress, nil
	case "VERIFIED":
		return BankAccountStatusVerified, nil
	case "DISABLED":
		return BankAccountStatusDisabled, nil
	}
	var t BankAccountStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankAccountStatus) Ptr() *BankAccountStatus {
	return &b
}

// Indicates the financial purpose of the bank account.
type BankAccountType string

const (
	BankAccountTypeChecking         BankAccountType = "CHECKING"
	BankAccountTypeSavings          BankAccountType = "SAVINGS"
	BankAccountTypeInvestment       BankAccountType = "INVESTMENT"
	BankAccountTypeOther            BankAccountType = "OTHER"
	BankAccountTypeBusinessChecking BankAccountType = "BUSINESS_CHECKING"
)

func NewBankAccountTypeFromString(s string) (BankAccountType, error) {
	switch s {
	case "CHECKING":
		return BankAccountTypeChecking, nil
	case "SAVINGS":
		return BankAccountTypeSavings, nil
	case "INVESTMENT":
		return BankAccountTypeInvestment, nil
	case "OTHER":
		return BankAccountTypeOther, nil
	case "BUSINESS_CHECKING":
		return BankAccountTypeBusinessChecking, nil
	}
	var t BankAccountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BankAccountType) Ptr() *BankAccountType {
	return &b
}

// Response object returned by GetBankAccountByV1Id.
var (
	getBankAccountByV1IDResponseFieldErrors      = big.NewInt(1 << 0)
	getBankAccountByV1IDResponseFieldBankAccount = big.NewInt(1 << 1)
)

type GetBankAccountByV1IDResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `BankAccount` object.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetBankAccountByV1IDResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetBankAccountByV1IDResponse) GetBankAccount() *BankAccount {
	if g == nil {
		return nil
	}
	return g.BankAccount
}

func (g *GetBankAccountByV1IDResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountByV1IDResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetBankAccountByV1IDResponse) SetErrors(errors []*Error) {
	g.Errors = errors
	g.require(getBankAccountByV1IDResponseFieldErrors)
}

// SetBankAccount sets the BankAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetBankAccountByV1IDResponse) SetBankAccount(bankAccount *BankAccount) {
	g.BankAccount = bankAccount
	g.require(getBankAccountByV1IDResponseFieldBankAccount)
}

func (g *GetBankAccountByV1IDResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountByV1IDResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountByV1IDResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountByV1IDResponse) MarshalJSON() ([]byte, error) {
	type embed GetBankAccountByV1IDResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GetBankAccountByV1IDResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response object returned by `GetBankAccount`.
var (
	getBankAccountResponseFieldErrors      = big.NewInt(1 << 0)
	getBankAccountResponseFieldBankAccount = big.NewInt(1 << 1)
)

type GetBankAccountResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested `BankAccount` object.
	BankAccount *BankAccount `json:"bank_account,omitempty" url:"bank_account,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetBankAccountResponse) GetErrors() []*Error {
	if g == nil {
		return nil
	}
	return g.Errors
}

func (g *GetBankAccountResponse) GetBankAccount() *BankAccount {
	if g == nil {
		return nil
	}
	return g.BankAccount
}

func (g *GetBankAccountResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetBankAccountResponse) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetBankAccountResponse) SetErrors(errors []*Error) {
	g.Errors = errors
	g.require(getBankAccountResponseFieldErrors)
}

// SetBankAccount sets the BankAccount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GetBankAccountResponse) SetBankAccount(bankAccount *BankAccount) {
	g.BankAccount = bankAccount
	g.require(getBankAccountResponseFieldBankAccount)
}

func (g *GetBankAccountResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetBankAccountResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetBankAccountResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetBankAccountResponse) MarshalJSON() ([]byte, error) {
	type embed GetBankAccountResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GetBankAccountResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response object returned by ListBankAccounts.
var (
	listBankAccountsResponseFieldErrors       = big.NewInt(1 << 0)
	listBankAccountsResponseFieldBankAccounts = big.NewInt(1 << 1)
	listBankAccountsResponseFieldCursor       = big.NewInt(1 << 2)
)

type ListBankAccountsResponse struct {
	// Information on errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// List of BankAccounts associated with this account.
	BankAccounts []*BankAccount `json:"bank_accounts,omitempty" url:"bank_accounts,omitempty"`
	// When a response is truncated, it includes a cursor that you can
	// use in a subsequent request to fetch next set of bank accounts.
	// If empty, this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/working-with-apis/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListBankAccountsResponse) GetErrors() []*Error {
	if l == nil {
		return nil
	}
	return l.Errors
}

func (l *ListBankAccountsResponse) GetBankAccounts() []*BankAccount {
	if l == nil {
		return nil
	}
	return l.BankAccounts
}

func (l *ListBankAccountsResponse) GetCursor() *string {
	if l == nil {
		return nil
	}
	return l.Cursor
}

func (l *ListBankAccountsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListBankAccountsResponse) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetErrors sets the Errors field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBankAccountsResponse) SetErrors(errors []*Error) {
	l.Errors = errors
	l.require(listBankAccountsResponseFieldErrors)
}

// SetBankAccounts sets the BankAccounts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBankAccountsResponse) SetBankAccounts(bankAccounts []*BankAccount) {
	l.BankAccounts = bankAccounts
	l.require(listBankAccountsResponseFieldBankAccounts)
}

// SetCursor sets the Cursor field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *ListBankAccountsResponse) SetCursor(cursor *string) {
	l.Cursor = cursor
	l.require(listBankAccountsResponseFieldCursor)
}

func (l *ListBankAccountsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBankAccountsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBankAccountsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBankAccountsResponse) MarshalJSON() ([]byte, error) {
	type embed ListBankAccountsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *ListBankAccountsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}
